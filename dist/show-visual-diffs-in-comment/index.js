require('./sourcemap-register.js');/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 1156:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const core = __importStar(__nccwpck_require__(2186));
const filestack = __importStar(__nccwpck_require__(3222));
const globby_1 = __nccwpck_require__(4824);
const util_1 = __nccwpck_require__(1669);
const promises_1 = __nccwpck_require__(2004);
function run() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const filestackKey = core.getInput('filestack-key');
            const client = filestack.init(filestackKey);
            let paths = yield (0, globby_1.globby)('**/*diff.png');
            paths = paths.filter(path => !path.includes('retry'));
            const uploadPromises = paths.map((path) => __awaiter(this, void 0, void 0, function* () {
                const file = yield (0, promises_1.readFile)(path);
                const response = yield client.upload(file);
                core.debug(`upload response for ${path}: ${(0, util_1.inspect)(response)}`);
                let summaryPath = path.split('/').pop() || '';
                summaryPath = summaryPath === null || summaryPath === void 0 ? void 0 : summaryPath.replace('diff.png', '').split('-').join(' ');
                return `
<details>
  <summary>${summaryPath}</summary>
      ${path}
</details>

![${path}](${response.url})`;
            }));
            const mdLines = yield Promise.all(uploadPromises);
            const commentBody = [
                '### Ch-ch-ch-ch-changes',
                'Turn and face the strange\n',
                ...mdLines
            ].join('\n');
            core.setOutput('body', commentBody);
        }
        catch (error) {
            if (error instanceof Error)
                core.setFailed(error.message);
        }
    });
}
run();


/***/ }),

/***/ 7351:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__nccwpck_require__(2087));
const utils_1 = __nccwpck_require__(5278);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 2186:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __nccwpck_require__(7351);
const file_command_1 = __nccwpck_require__(717);
const utils_1 = __nccwpck_require__(5278);
const os = __importStar(__nccwpck_require__(2087));
const path = __importStar(__nccwpck_require__(5622));
const oidc_utils_1 = __nccwpck_require__(8041);
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        const delimiter = '_GitHubActionsFileCommandDelimeter_';
        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;
        file_command_1.issueCommand('ENV', commandValue);
    }
    else {
        command_1.issueCommand('set-env', { name }, convertedVal);
    }
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    return inputs;
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, value);
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function error(message, properties = {}) {
    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds a warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function warning(message, properties = {}) {
    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Adds a notice issue
 * @param message notice issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function notice(message, properties = {}) {
    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.notice = notice;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    command_1.issueCommand('save-state', { name }, value);
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
}
exports.getIDToken = getIDToken;
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 717:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issueCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__nccwpck_require__(5747));
const os = __importStar(__nccwpck_require__(2087));
const utils_1 = __nccwpck_require__(5278);
function issueCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueCommand = issueCommand;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 8041:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OidcClient = void 0;
const http_client_1 = __nccwpck_require__(9925);
const auth_1 = __nccwpck_require__(3702);
const core_1 = __nccwpck_require__(2186);
class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
        };
        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
    }
    static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
    }
    static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient
                .getJson(id_token_url)
                .catch(error => {
                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
                throw new Error('Response json body do not have ID Token field');
            }
            return id_token;
        });
    }
    static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // New ID Token is requested from action service
                let id_token_url = OidcClient.getIDTokenUrl();
                if (audience) {
                    const encodedAudience = encodeURIComponent(audience);
                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                }
                core_1.debug(`ID token url is ${id_token_url}`);
                const id_token = yield OidcClient.getCall(id_token_url);
                core_1.setSecret(id_token);
                return id_token;
            }
            catch (error) {
                throw new Error(`Error message: ${error.message}`);
            }
        });
    }
}
exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

/***/ }),

/***/ 5278:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandProperties = exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
/**
 *
 * @param annotationProperties
 * @returns The command properties to send with the actual annotation command
 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
 */
function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
        return {};
    }
    return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
    };
}
exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 3702:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class BasicCredentialHandler {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
    prepareRequest(options) {
        options.headers['Authorization'] =
            'Basic ' +
                Buffer.from(this.username + ':' + this.password).toString('base64');
    }
    // This handler cannot handle 401
    canHandleAuthentication(response) {
        return false;
    }
    handleAuthentication(httpClient, requestInfo, objs) {
        return null;
    }
}
exports.BasicCredentialHandler = BasicCredentialHandler;
class BearerCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        options.headers['Authorization'] = 'Bearer ' + this.token;
    }
    // This handler cannot handle 401
    canHandleAuthentication(response) {
        return false;
    }
    handleAuthentication(httpClient, requestInfo, objs) {
        return null;
    }
}
exports.BearerCredentialHandler = BearerCredentialHandler;
class PersonalAccessTokenCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        options.headers['Authorization'] =
            'Basic ' + Buffer.from('PAT:' + this.token).toString('base64');
    }
    // This handler cannot handle 401
    canHandleAuthentication(response) {
        return false;
    }
    handleAuthentication(httpClient, requestInfo, objs) {
        return null;
    }
}
exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;


/***/ }),

/***/ 9925:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const http = __nccwpck_require__(8605);
const https = __nccwpck_require__(7211);
const pm = __nccwpck_require__(6443);
let tunnel;
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return new Promise(async (resolve, reject) => {
            let output = Buffer.alloc(0);
            this.message.on('data', (chunk) => {
                output = Buffer.concat([output, chunk]);
            });
            this.message.on('end', () => {
                resolve(output.toString());
            });
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    let parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
    }
    get(requestUrl, additionalHeaders) {
        return this.request('GET', requestUrl, null, additionalHeaders || {});
    }
    del(requestUrl, additionalHeaders) {
        return this.request('DELETE', requestUrl, null, additionalHeaders || {});
    }
    post(requestUrl, data, additionalHeaders) {
        return this.request('POST', requestUrl, data, additionalHeaders || {});
    }
    patch(requestUrl, data, additionalHeaders) {
        return this.request('PATCH', requestUrl, data, additionalHeaders || {});
    }
    put(requestUrl, data, additionalHeaders) {
        return this.request('PUT', requestUrl, data, additionalHeaders || {});
    }
    head(requestUrl, additionalHeaders) {
        return this.request('HEAD', requestUrl, null, additionalHeaders || {});
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return this.request(verb, requestUrl, stream, additionalHeaders);
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    async getJson(requestUrl, additionalHeaders = {}) {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        let res = await this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    async postJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = await this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    async putJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = await this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    async patchJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = await this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    async request(verb, requestUrl, data, headers) {
        if (this._disposed) {
            throw new Error('Client has already been disposed.');
        }
        let parsedUrl = new URL(requestUrl);
        let info = this._prepareRequest(verb, parsedUrl, headers);
        // Only perform retries on reads since writes may not be idempotent.
        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1
            ? this._maxRetries + 1
            : 1;
        let numTries = 0;
        let response;
        while (numTries < maxTries) {
            response = await this.requestRaw(info, data);
            // Check if it's an authentication challenge
            if (response &&
                response.message &&
                response.message.statusCode === HttpCodes.Unauthorized) {
                let authenticationHandler;
                for (let i = 0; i < this.handlers.length; i++) {
                    if (this.handlers[i].canHandleAuthentication(response)) {
                        authenticationHandler = this.handlers[i];
                        break;
                    }
                }
                if (authenticationHandler) {
                    return authenticationHandler.handleAuthentication(this, info, data);
                }
                else {
                    // We have received an unauthorized response but have no handlers to handle it.
                    // Let the response return to the caller.
                    return response;
                }
            }
            let redirectsRemaining = this._maxRedirects;
            while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 &&
                this._allowRedirects &&
                redirectsRemaining > 0) {
                const redirectUrl = response.message.headers['location'];
                if (!redirectUrl) {
                    // if there's no location to redirect to, we won't
                    break;
                }
                let parsedRedirectUrl = new URL(redirectUrl);
                if (parsedUrl.protocol == 'https:' &&
                    parsedUrl.protocol != parsedRedirectUrl.protocol &&
                    !this._allowRedirectDowngrade) {
                    throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                }
                // we need to finish reading the response before reassigning response
                // which will leak the open socket.
                await response.readBody();
                // strip authorization header if redirected to a different hostname
                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                    for (let header in headers) {
                        // header names are case insensitive
                        if (header.toLowerCase() === 'authorization') {
                            delete headers[header];
                        }
                    }
                }
                // let's make the request with the new redirectUrl
                info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                response = await this.requestRaw(info, data);
                redirectsRemaining--;
            }
            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {
                // If not a retry code, return immediately instead of retrying
                return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
                await response.readBody();
                await this._performExponentialBackoff(numTries);
            }
        }
        return response;
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return new Promise((resolve, reject) => {
            let callbackForResult = function (err, res) {
                if (err) {
                    reject(err);
                }
                resolve(res);
            };
            this.requestRawWithCallback(info, data, callbackForResult);
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        let socket;
        if (typeof data === 'string') {
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        let handleResult = (err, res) => {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        };
        let req = info.httpModule.request(info.options, (msg) => {
            let res = new HttpClientResponse(msg);
            handleResult(null, res);
        });
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error('Request timeout: ' + info.options.path), null);
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err, null);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        let parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            this.handlers.forEach(handler => {
                handler.prepareRequest(info.options);
            });
        }
        return info;
    }
    _mergeHeaders(headers) {
        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        let proxyUrl = pm.getProxyUrl(parsedUrl);
        let useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (!!agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (!!this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (useProxy) {
            // If using proxy, need tunnel
            if (!tunnel) {
                tunnel = __nccwpck_require__(4294);
            }
            const agentOptions = {
                maxSockets: maxSockets,
                keepAlive: this._keepAlive,
                proxy: {
                    ...((proxyUrl.username || proxyUrl.password) && {
                        proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                    }),
                    host: proxyUrl.hostname,
                    port: proxyUrl.port
                }
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets: maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise(resolve => setTimeout(() => resolve(), ms));
    }
    static dateTimeDeserializer(key, value) {
        if (typeof value === 'string') {
            let a = new Date(value);
            if (!isNaN(a.valueOf())) {
                return a;
            }
        }
        return value;
    }
    async _processResponse(res, options) {
        return new Promise(async (resolve, reject) => {
            const statusCode = res.message.statusCode;
            const response = {
                statusCode: statusCode,
                result: null,
                headers: {}
            };
            // not found leads to null obj returned
            if (statusCode == HttpCodes.NotFound) {
                resolve(response);
            }
            let obj;
            let contents;
            // get the result from the body
            try {
                contents = await res.readBody();
                if (contents && contents.length > 0) {
                    if (options && options.deserializeDates) {
                        obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);
                    }
                    else {
                        obj = JSON.parse(contents);
                    }
                    response.result = obj;
                }
                response.headers = res.message.headers;
            }
            catch (err) {
                // Invalid resource (contents not json);  leaving result obj null
            }
            // note that 3xx redirects are handled by the http layer.
            if (statusCode > 299) {
                let msg;
                // if exception/error in body, attempt to get better error
                if (obj && obj.message) {
                    msg = obj.message;
                }
                else if (contents && contents.length > 0) {
                    // it may be the case that the exception is in the body message as string
                    msg = contents;
                }
                else {
                    msg = 'Failed request: (' + statusCode + ')';
                }
                let err = new HttpClientError(msg, statusCode);
                err.result = response.result;
                reject(err);
            }
            else {
                resolve(response);
            }
        });
    }
}
exports.HttpClient = HttpClient;


/***/ }),

/***/ 6443:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function getProxyUrl(reqUrl) {
    let usingSsl = reqUrl.protocol === 'https:';
    let proxyUrl;
    if (checkBypass(reqUrl)) {
        return proxyUrl;
    }
    let proxyVar;
    if (usingSsl) {
        proxyVar = process.env['https_proxy'] || process.env['HTTPS_PROXY'];
    }
    else {
        proxyVar = process.env['http_proxy'] || process.env['HTTP_PROXY'];
    }
    if (proxyVar) {
        proxyUrl = new URL(proxyVar);
    }
    return proxyUrl;
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    let noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    let upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (let upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperReqHosts.some(x => x === upperNoProxyItem)) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;


/***/ }),

/***/ 2995:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var MODULE_PREFIX = 'fs-loader-';
var globalHolder = {};
var initializeGlobalNamespace = function () {
    var holder;
    // if there is no window obj use nodejs global lib variable
    if (typeof window === 'undefined') {
        holder = globalHolder;
    }
    else {
        holder = window;
    }
    // @ts-ignore
    var namespace = holder.filestackInternals;
    if (!namespace) {
        namespace = {
            modules: {},
        };
        holder.filestackInternals = namespace;
    }
    if (!namespace.modules) {
        namespace.modules = {};
    }
    return namespace;
};
var filestackInternals = initializeGlobalNamespace();
var modules = filestackInternals && filestackInternals.modules;
/**
 * Remove listeners (browser compatible)
 *
 * @param node
 * @param func
 * @param name
 */
var removeListener = function (node, func, name) {
    if (node.detachEvent) {
        node.detachEvent('onreadystatechange', func);
    }
    else {
        node.removeEventListener(name, func, false);
    }
};
/**
 * Load multiple modules
 *
 * @param {*} modules
 */
exports.loadModules = function (modulesList) { return Promise.all(modulesList.map(function (_a) {
    var id = _a.id, url = _a.url;
    return exports.loadModule(id, url);
})).then(function (res) {
    var toReturn = {};
    res.forEach(function (mod, idx) {
        var el = modulesList[idx];
        toReturn[el.id] = mod;
    });
    return toReturn;
}); };
/**
 * Load single module from url with given id
 *
 * @param {*} id - module id
 * @param {*} url
 */
exports.loadModule = function (id, url) {
    if (typeof window === 'undefined') {
        return Promise.reject(new Error('Load module is working only on browser env'));
    }
    if (!id) {
        throw new Error('Module id is required');
    }
    id = MODULE_PREFIX + id;
    var moduleDefinition = modules[id];
    if (!moduleDefinition) {
        modules[id] = {};
        moduleDefinition = modules[id];
    }
    if (moduleDefinition.instance) {
        return Promise.resolve(moduleDefinition.instance);
    }
    if (moduleDefinition.promise) {
        return moduleDefinition.promise;
    }
    return moduleDefinition.promise = new Promise(function (resolve, reject) {
        var readyStateChange = function (evt) {
            if (evt.type === 'load' || (/^(complete|loaded)$/.test((evt.currentTarget || evt.srcElement).readyState))) {
                var node = evt.currentTarget || evt.srcElement;
                removeListener(node, readyStateChange, 'load');
                removeListener(node, reject, 'error');
                // slow dow checking if module is loaded to ensure that script that  register module is called
                setTimeout(function () { return resolve(modules[id] ? modules[id].instance : undefined); }, 10);
            }
        };
        var script = document.createElement('script');
        script.id = id;
        // @ts-ignore fix for IE
        if (script.attachEvent && !(script.attachEvent.toString && script.attachEvent.toString().indexOf('[native code') < 0)) {
            // @ts-ignore
            script.attachEvent('onreadystatechange', readyStateChange);
        }
        else {
            script.addEventListener('load', readyStateChange, false);
            script.addEventListener('onerror', reject, false);
        }
        script.setAttribute('crossorigin', 'anonymous');
        script.setAttribute('charset', 'utf-8');
        script.setAttribute('async', 'true');
        script.src = url;
        document.body.appendChild(script);
    });
};
/**
 * Register that module is ready
 *
 * @param {string} id
 * @param {any} instance
 * @param {any} metadata - additional module metadata like version
 */
exports.registerModule = function (id, instance, metadata) {
    // loader not working on nodejs envs
    if (typeof window === 'undefined') {
        return;
    }
    if (!id) {
        throw new Error('Module id is required');
    }
    if (!modules) {
        throw new Error('Loader is not initialized');
    }
    id = MODULE_PREFIX + id;
    if (modules[id]) {
        modules[id] = { instance: instance, metadata: metadata };
    }
};
/**
 * Load external css from given url
 *
 * @param {*} url
 */
exports.loadCss = function (url) {
    var alreadyAddedThisTag = document.querySelector("link[href=\"" + url + "\"]");
    if (alreadyAddedThisTag !== null) {
        return Promise.resolve();
    }
    return new Promise(function (resolve) {
        var head = document.getElementsByTagName('head')[0];
        var link = document.createElement('link');
        var loaded = function () {
            resolve();
            link.removeEventListener('load', loaded);
        };
        link.rel = 'stylesheet';
        link.href = url;
        link.addEventListener('load', loaded);
        head.appendChild(link);
    });
};
/**
 * Enum just for unify filestack module names
 */
var FILESTACK_MODULES;
(function (FILESTACK_MODULES) {
    FILESTACK_MODULES["FILESTACK_SDK"] = "filestack-sdk";
    FILESTACK_MODULES["TRANSFORMS_UI"] = "transforms-ui";
    FILESTACK_MODULES["PICKER"] = "picker";
})(FILESTACK_MODULES = exports.FILESTACK_MODULES || (exports.FILESTACK_MODULES = {}));
;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9saWIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFNLGFBQWEsR0FBRyxZQUFZLENBQUM7QUFDbkMsSUFBTSxZQUFZLEdBQVEsRUFBRSxDQUFDO0FBZTdCLElBQU0seUJBQXlCLEdBQUc7SUFDaEMsSUFBSSxNQUFVLENBQUM7SUFFZiwyREFBMkQ7SUFDM0QsSUFBSSxPQUFPLE1BQU0sS0FBSyxXQUFXLEVBQUU7UUFDakMsTUFBTSxHQUFHLFlBQVksQ0FBQztLQUN2QjtTQUFNO1FBQ0wsTUFBTSxHQUFHLE1BQU0sQ0FBQTtLQUNoQjtJQUVELGFBQWE7SUFDYixJQUFJLFNBQVMsR0FBYyxNQUFNLENBQUMsa0JBQWtCLENBQUM7SUFFckQsSUFBSSxDQUFDLFNBQVMsRUFBRTtRQUNkLFNBQVMsR0FBRztZQUNWLE9BQU8sRUFBRSxFQUFFO1NBQ1osQ0FBQztRQUVGLE1BQU0sQ0FBQyxrQkFBa0IsR0FBRyxTQUFTLENBQUM7S0FDdkM7SUFFRCxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRTtRQUN0QixTQUFTLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztLQUN4QjtJQUVELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUMsQ0FBQztBQUVGLElBQU0sa0JBQWtCLEdBQUcseUJBQXlCLEVBQUUsQ0FBQztBQUN2RCxJQUFNLE9BQU8sR0FBRyxrQkFBa0IsSUFBSSxrQkFBa0IsQ0FBQyxPQUFPLENBQUM7QUFFakU7Ozs7OztHQU1HO0FBQ0gsSUFBTSxjQUFjLEdBQUcsVUFBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUk7SUFDdEMsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO1FBQ3BCLElBQUksQ0FBQyxXQUFXLENBQUMsb0JBQW9CLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDOUM7U0FBTTtRQUNMLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxF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Qy9CLG9EQUErQixDQUFBO0lBQy9CLHNDQUFpQixDQUFBO0FBQ25CLENBQUMsRUFKVyxpQkFBaUIsR0FBakIseUJBQWlCLEtBQWpCLHlCQUFpQixRQUk1QjtBQUFBLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNT0RVTEVfUFJFRklYID0gJ2ZzLWxvYWRlci0nO1xuY29uc3QgZ2xvYmFsSG9sZGVyOiBhbnkgPSB7fTtcblxuZXhwb3J0IHR5cGUgTW9kdWxlRGVmID0ge1xuICBwcm9taXNlPzogUHJvbWlzZTxhbnk+XG4gIHJlc29sdmVQcm9taXNlPzogYW55O1xuICBpbnN0YW5jZT86IGFueTtcbiAgbWV0YWRhdGE/OiBhbnk7XG59XG5cbmV4cG9ydCB0eXBlIE5hbWVzcGFjZSA9IHtcbiAgICBtb2R1bGVzOiB7XG4gICAgIFtrZXk6IHN0cmluZ106IE1vZHVsZURlZlxuICAgIH1cbn07XG5cbmNvbnN0IGluaXRpYWxpemVHbG9iYWxOYW1lc3BhY2UgPSAoKSA9PiB7XG4gIGxldCBob2xkZXI6YW55O1xuXG4gIC8vIGlmIHRoZXJlIGlzIG5vIHdpbmRvdyBvYmogdXNlIG5vZGVqcyBnbG9iYWwgbGliIHZhcmlhYmxlXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIGhvbGRlciA9IGdsb2JhbEhvbGRlcjtcbiAgfSBlbHNlIHtcbiAgICBob2xkZXIgPSB3aW5kb3dcbiAgfVxuXG4gIC8vIEB0cy1pZ25vcmVcbiAgbGV0IG5hbWVzcGFjZTogTmFtZXNwYWNlID0gaG9sZGVyLmZpbGVzdGFja0ludGVybmFscztcblxuICBpZiAoIW5hbWVzcGFjZSkge1xuICAgIG5hbWVzcGFjZSA9IHtcbiAgICAgIG1vZHVsZXM6IHt9LFxuICAgIH07XG5cbiAgICBob2xkZXIuZmlsZXN0YWNrSW50ZXJuYWxzID0gbmFtZXNwYWNlO1xuICB9XG5cbiAgaWYgKCFuYW1lc3BhY2UubW9kdWxlcykge1xuICAgIG5hbWVzcGFjZS5tb2R1bGVzID0ge307XG4gIH1cbiAgXG4gIHJldHVybiBuYW1lc3BhY2U7XG59O1xuXG5jb25zdCBmaWxlc3RhY2tJbnRlcm5hbHMgPSBpbml0aWFsaXplR2xvYmFsTmFtZXNwYWNlKCk7XG5jb25zdCBtb2R1bGVzID0gZmlsZXN0YWNrSW50ZXJuYWxzICYmIGZpbGVzdGFja0ludGVybmFscy5tb2R1bGVzO1xuXG4vKipcbiAqIFJlbW92ZSBsaXN0ZW5lcnMgKGJyb3dzZXIgY29tcGF0aWJsZSlcbiAqIFxuICogQHBhcmFtIG5vZGUgXG4gKiBAcGFyYW0gZnVuYyBcbiAqIEBwYXJhbSBuYW1lIFxuICovXG5jb25zdCByZW1vdmVMaXN0ZW5lciA9IChub2RlLCBmdW5jLCBuYW1lLCApID0+IHtcbiAgaWYgKG5vZGUuZGV0YWNoRXZlbnQpIHtcbiAgICBub2RlLmRldGFjaEV2ZW50KCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBmdW5jKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgZnVuYywgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogTG9hZCBtdWx0aXBsZSBtb2R1bGVzXG4gKiBcbiAqIEBwYXJhbSB7Kn0gbW9kdWxlcyBcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRNb2R1bGVzID0gKG1vZHVsZXNMaXN0KSA9PiBQcm9taXNlLmFsbChtb2R1bGVzTGlzdC5tYXAoKHsgaWQsIHVybCB9KSA9PiBsb2FkTW9kdWxlKGlkLCB1cmwpKSkudGhlbigocmVzKSA9PiB7XG4gIGNvbnN0IHRvUmV0dXJuID0ge307XG5cbiAgcmVzLmZvckVhY2goKG1vZCwgaWR4KSA9PiB7XG4gICAgY29uc3QgZWwgPSBtb2R1bGVzTGlzdFtpZHhdO1xuICAgIHRvUmV0dXJuW2VsLmlkXSA9IG1vZDtcbiAgfSk7XG5cbiAgcmV0dXJuIHRvUmV0dXJuO1xufSk7XG5cbi8qKlxuICogTG9hZCBzaW5nbGUgbW9kdWxlIGZyb20gdXJsIHdpdGggZ2l2ZW4gaWRcbiAqXG4gKiBAcGFyYW0geyp9IGlkIC0gbW9kdWxlIGlkIFxuICogQHBhcmFtIHsqfSB1cmxcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRNb2R1bGUgPSAoaWQ6IHN0cmluZywgdXJsOiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTG9hZCBtb2R1bGUgaXMgd29ya2luZyBvbmx5IG9uIGJyb3dzZXIgZW52JykpO1xuICB9XG5cbiAgaWYgKCFpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTW9kdWxlIGlkIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlkID0gIE1PRFVMRV9QUkVGSVggKyBpZDtcbiAgbGV0IG1vZHVsZURlZmluaXRpb24gPSBtb2R1bGVzW2lkXTtcblxuICBpZiAoIW1vZHVsZURlZmluaXRpb24pIHtcbiAgICBtb2R1bGVzW2lkXSA9IHt9O1xuICAgIG1vZHVsZURlZmluaXRpb24gPSBtb2R1bGVzW2lkXTtcbiAgfVxuXG4gIGlmIChtb2R1bGVEZWZpbml0aW9uLmluc3RhbmNlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtb2R1bGVEZWZpbml0aW9uLmluc3RhbmNlKTtcbiAgfVxuXG4gIGlmIChtb2R1bGVEZWZpbml0aW9uLnByb21pc2UpIHtcbiAgICByZXR1cm4gbW9kdWxlRGVmaW5pdGlvbi5wcm9taXNlO1xuICB9XG5cbiAgcmV0dXJuIG1vZHVsZURlZmluaXRpb24ucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZWFkeVN0YXRlQ2hhbmdlID0gKGV2dDogYW55KSA9PiB7XG4gICAgICBpZiAoZXZ0LnR5cGUgPT09ICdsb2FkJyB8fCAoL14oY29tcGxldGV8bG9hZGVkKSQvLnRlc3QoKGV2dC5jdXJyZW50VGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50KS5yZWFkeVN0YXRlKSkpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9ICBldnQuY3VycmVudFRhcmdldCB8fCBldnQuc3JjRWxlbWVudDtcblxuICAgICAgICByZW1vdmVMaXN0ZW5lcihub2RlLCByZWFkeVN0YXRlQ2hhbmdlLCAnbG9hZCcpO1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihub2RlLCByZWplY3QsICdlcnJvcicpO1xuXG4gICAgICAgIC8vIHNsb3cgZG93IGNoZWNraW5nIGlmIG1vZHVsZSBpcyBsb2FkZWQgdG8gZW5zdXJlIHRoYXQgc2NyaXB0IHRoYXQgIHJlZ2lzdGVyIG1vZHVsZSBpcyBjYWxsZWRcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKG1vZHVsZXNbaWRdID8gbW9kdWxlc1tpZF0uaW5zdGFuY2UgOiB1bmRlZmluZWQpLCAxMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgXG4gICAgc2NyaXB0LmlkID0gaWQ7XG5cbiAgICAvLyBAdHMtaWdub3JlIGZpeCBmb3IgSUVcbiAgICBpZiAoc2NyaXB0LmF0dGFjaEV2ZW50ICYmICEoc2NyaXB0LmF0dGFjaEV2ZW50LnRvU3RyaW5nICYmIHNjcmlwdC5hdHRhY2hFdmVudC50b1N0cmluZygpLmluZGV4T2YoJ1tuYXRpdmUgY29kZScpIDwgMCkpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHNjcmlwdC5hdHRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgcmVhZHlTdGF0ZUNoYW5nZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgcmVhZHlTdGF0ZUNoYW5nZSwgZmFsc2UpO1xuICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ29uZXJyb3InLCByZWplY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdjcm9zc29yaWdpbicsICdhbm9ueW1vdXMnKTtcbiAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdjaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgnYXN5bmMnLCAndHJ1ZScpO1xuXG4gICAgc2NyaXB0LnNyYyA9IHVybDtcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIHRoYXQgbW9kdWxlIGlzIHJlYWR5XG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBcbiAqIEBwYXJhbSB7YW55fSBpbnN0YW5jZSBcbiAqIEBwYXJhbSB7YW55fSBtZXRhZGF0YSAtIGFkZGl0aW9uYWwgbW9kdWxlIG1ldGFkYXRhIGxpa2UgdmVyc2lvblxuICovXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJNb2R1bGUgPSAoaWQ6IHN0cmluZywgaW5zdGFuY2U6IGFueSwgbWV0YWRhdGE/OiBhbnkpID0+IHtcbiAgLy8gbG9hZGVyIG5vdCB3b3JraW5nIG9uIG5vZGVqcyBlbnZzXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZHVsZSBpZCBpcyByZXF1aXJlZCcpXG4gIH1cblxuICBpZiAoIW1vZHVsZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWRlciBpcyBub3QgaW5pdGlhbGl6ZWQnKVxuICB9XG5cbiAgaWQgPSBNT0RVTEVfUFJFRklYICsgaWQ7XG5cbiAgaWYgKG1vZHVsZXNbaWRdKSB7XG4gICAgbW9kdWxlc1tpZF0gPSB7IGluc3RhbmNlLCBtZXRhZGF0YSB9XG4gIH1cbn07XG5cbi8qKlxuICogTG9hZCBleHRlcm5hbCBjc3MgZnJvbSBnaXZlbiB1cmxcbiAqIFxuICogQHBhcmFtIHsqfSB1cmwgXG4gKi9cbmV4cG9ydCBjb25zdCBsb2FkQ3NzID0gKHVybCkgPT4ge1xuICBjb25zdCBhbHJlYWR5QWRkZWRUaGlzVGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgbGlua1tocmVmPVwiJHt1cmx9XCJdYCk7XG4gIGlmIChhbHJlYWR5QWRkZWRUaGlzVGFnICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcblxuICAgIGNvbnN0IGxvYWRlZCA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICAgIGxpbmsucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRlZCk7XG4gICAgfTtcblxuICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuICAgIGxpbmsuaHJlZiA9IHVybDtcbiAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsb2FkZWQpO1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFbnVtIGp1c3QgZm9yIHVuaWZ5IGZpbGVzdGFjayBtb2R1bGUgbmFtZXNcbiAqL1xuZXhwb3J0IGVudW0gRklMRVNUQUNLX01PRFVMRVMge1xuICBGSUxFU1RBQ0tfU0RLID0gJ2ZpbGVzdGFjay1zZGsnLFxuICBUUkFOU0ZPUk1TX1VJID0gJ3RyYW5zZm9ybXMtdWknLFxuICBQSUNLRVIgPSAncGlja2VyJyxcbn07XG4iXX0=

/***/ }),

/***/ 3803:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
const fs = __nccwpck_require__(5747);
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;


/***/ }),

/***/ 8838:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
const NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');
if (NODE_PROCESS_VERSION_PARTS[0] === undefined || NODE_PROCESS_VERSION_PARTS[1] === undefined) {
    throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
}
const MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
const MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
const SUPPORTED_MAJOR_VERSION = 10;
const SUPPORTED_MINOR_VERSION = 10;
const IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
const IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
/**
 * IS `true` for Node.js 10.10 and greater.
 */
exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;


/***/ }),

/***/ 5667:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Settings = exports.scandirSync = exports.scandir = void 0;
const async = __nccwpck_require__(4507);
const sync = __nccwpck_require__(9560);
const settings_1 = __nccwpck_require__(8662);
exports.Settings = settings_1.default;
function scandir(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
}
exports.scandir = scandir;
function scandirSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
}
exports.scandirSync = scandirSync;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),

/***/ 4507:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
const fsStat = __nccwpck_require__(109);
const rpl = __nccwpck_require__(5288);
const constants_1 = __nccwpck_require__(8838);
const utils = __nccwpck_require__(6297);
const common = __nccwpck_require__(3847);
function read(directory, settings, callback) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
    }
    readdir(directory, settings, callback);
}
exports.read = read;
function readdirWithFileTypes(directory, settings, callback) {
    settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
            callFailureCallback(callback, readdirError);
            return;
        }
        const entries = dirents.map((dirent) => ({
            dirent,
            name: dirent.name,
            path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
            callSuccessCallback(callback, entries);
            return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
            if (rplError !== null) {
                callFailureCallback(callback, rplError);
                return;
            }
            callSuccessCallback(callback, rplEntries);
        });
    });
}
exports.readdirWithFileTypes = readdirWithFileTypes;
function makeRplTaskEntry(entry, settings) {
    return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
            done(null, entry);
            return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    done(statError);
                    return;
                }
                done(null, entry);
                return;
            }
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            done(null, entry);
        });
    };
}
function readdir(directory, settings, callback) {
    settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
            callFailureCallback(callback, readdirError);
            return;
        }
        const tasks = names.map((name) => {
            const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
            return (done) => {
                fsStat.stat(path, settings.fsStatSettings, (error, stats) => {
                    if (error !== null) {
                        done(error);
                        return;
                    }
                    const entry = {
                        name,
                        path,
                        dirent: utils.fs.createDirentFromStats(name, stats)
                    };
                    if (settings.stats) {
                        entry.stats = stats;
                    }
                    done(null, entry);
                });
            };
        });
        rpl(tasks, (rplError, entries) => {
            if (rplError !== null) {
                callFailureCallback(callback, rplError);
                return;
            }
            callSuccessCallback(callback, entries);
        });
    });
}
exports.readdir = readdir;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, result) {
    callback(null, result);
}


/***/ }),

/***/ 3847:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.joinPathSegments = void 0;
function joinPathSegments(a, b, separator) {
    /**
     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
     */
    if (a.endsWith(separator)) {
        return a + b;
    }
    return a + separator + b;
}
exports.joinPathSegments = joinPathSegments;


/***/ }),

/***/ 9560:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
const fsStat = __nccwpck_require__(109);
const constants_1 = __nccwpck_require__(8838);
const utils = __nccwpck_require__(6297);
const common = __nccwpck_require__(3847);
function read(directory, settings) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
    }
    return readdir(directory, settings);
}
exports.read = read;
function readdirWithFileTypes(directory, settings) {
    const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
    return dirents.map((dirent) => {
        const entry = {
            dirent,
            name: dirent.name,
            path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
            try {
                const stats = settings.fs.statSync(entry.path);
                entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            }
            catch (error) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    throw error;
                }
            }
        }
        return entry;
    });
}
exports.readdirWithFileTypes = readdirWithFileTypes;
function readdir(directory, settings) {
    const names = settings.fs.readdirSync(directory);
    return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
            name,
            path: entryPath,
            dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
            entry.stats = stats;
        }
        return entry;
    });
}
exports.readdir = readdir;


/***/ }),

/***/ 8662:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __nccwpck_require__(5622);
const fsStat = __nccwpck_require__(109);
const fs = __nccwpck_require__(3803);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this.followSymbolicLinks,
            fs: this.fs,
            throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
exports.default = Settings;


/***/ }),

/***/ 883:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDirentFromStats = void 0;
class DirentFromStats {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
exports.createDirentFromStats = createDirentFromStats;


/***/ }),

/***/ 6297:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fs = void 0;
const fs = __nccwpck_require__(883);
exports.fs = fs;


/***/ }),

/***/ 2987:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
const fs = __nccwpck_require__(5747);
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;


/***/ }),

/***/ 109:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.statSync = exports.stat = exports.Settings = void 0;
const async = __nccwpck_require__(4147);
const sync = __nccwpck_require__(4527);
const settings_1 = __nccwpck_require__(2410);
exports.Settings = settings_1.default;
function stat(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
}
exports.stat = stat;
function statSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
}
exports.statSync = statSync;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),

/***/ 4147:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.read = void 0;
function read(path, settings, callback) {
    settings.fs.lstat(path, (lstatError, lstat) => {
        if (lstatError !== null) {
            callFailureCallback(callback, lstatError);
            return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
            callSuccessCallback(callback, lstat);
            return;
        }
        settings.fs.stat(path, (statError, stat) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    callFailureCallback(callback, statError);
                    return;
                }
                callSuccessCallback(callback, lstat);
                return;
            }
            if (settings.markSymbolicLink) {
                stat.isSymbolicLink = () => true;
            }
            callSuccessCallback(callback, stat);
        });
    });
}
exports.read = read;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, result) {
    callback(null, result);
}


/***/ }),

/***/ 4527:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.read = void 0;
function read(path, settings) {
    const lstat = settings.fs.lstatSync(path);
    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
    }
    try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
        }
        return stat;
    }
    catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
            return lstat;
        }
        throw error;
    }
}
exports.read = read;


/***/ }),

/***/ 2410:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __nccwpck_require__(2987);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
exports.default = Settings;


/***/ }),

/***/ 6026:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;
const async_1 = __nccwpck_require__(7523);
const stream_1 = __nccwpck_require__(6737);
const sync_1 = __nccwpck_require__(3068);
const settings_1 = __nccwpck_require__(141);
exports.Settings = settings_1.default;
function walk(directory, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
    }
    new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
}
exports.walk = walk;
function walkSync(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new sync_1.default(directory, settings);
    return provider.read();
}
exports.walkSync = walkSync;
function walkStream(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new stream_1.default(directory, settings);
    return provider.read();
}
exports.walkStream = walkStream;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),

/***/ 7523:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async_1 = __nccwpck_require__(5732);
class AsyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
    }
    read(callback) {
        this._reader.onError((error) => {
            callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
            this._storage.push(entry);
        });
        this._reader.onEnd(() => {
            callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
    }
}
exports.default = AsyncProvider;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, entries) {
    callback(null, entries);
}


/***/ }),

/***/ 6737:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __nccwpck_require__(2413);
const async_1 = __nccwpck_require__(5732);
class StreamProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
            objectMode: true,
            read: () => { },
            destroy: () => {
                if (!this._reader.isDestroyed) {
                    this._reader.destroy();
                }
            }
        });
    }
    read() {
        this._reader.onError((error) => {
            this._stream.emit('error', error);
        });
        this._reader.onEntry((entry) => {
            this._stream.push(entry);
        });
        this._reader.onEnd(() => {
            this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
    }
}
exports.default = StreamProvider;


/***/ }),

/***/ 3068:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sync_1 = __nccwpck_require__(3595);
class SyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
    }
    read() {
        return this._reader.read();
    }
}
exports.default = SyncProvider;


/***/ }),

/***/ 5732:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __nccwpck_require__(8614);
const fsScandir = __nccwpck_require__(5667);
const fastq = __nccwpck_require__(7340);
const common = __nccwpck_require__(7988);
const reader_1 = __nccwpck_require__(8311);
class AsyncReader extends reader_1.default {
    constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
            if (!this._isFatalError) {
                this._emitter.emit('end');
            }
        };
    }
    read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
            this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
    }
    get isDestroyed() {
        return this._isDestroyed;
    }
    destroy() {
        if (this._isDestroyed) {
            throw new Error('The reader is already destroyed');
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
    }
    onEntry(callback) {
        this._emitter.on('entry', callback);
    }
    onError(callback) {
        this._emitter.once('error', callback);
    }
    onEnd(callback) {
        this._emitter.once('end', callback);
    }
    _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
            if (error !== null) {
                this._handleError(error);
            }
        });
    }
    _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
            if (error !== null) {
                done(error, undefined);
                return;
            }
            for (const entry of entries) {
                this._handleEntry(entry, item.base);
            }
            done(null, undefined);
        });
    }
    _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
            return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit('error', error);
    }
    _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
            return;
        }
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
        }
    }
    _emitEntry(entry) {
        this._emitter.emit('entry', entry);
    }
}
exports.default = AsyncReader;


/***/ }),

/***/ 7988:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;
function isFatalError(settings, error) {
    if (settings.errorFilter === null) {
        return true;
    }
    return !settings.errorFilter(error);
}
exports.isFatalError = isFatalError;
function isAppliedFilter(filter, value) {
    return filter === null || filter(value);
}
exports.isAppliedFilter = isAppliedFilter;
function replacePathSegmentSeparator(filepath, separator) {
    return filepath.split(/[/\\]/).join(separator);
}
exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
function joinPathSegments(a, b, separator) {
    if (a === '') {
        return b;
    }
    /**
     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
     */
    if (a.endsWith(separator)) {
        return a + b;
    }
    return a + separator + b;
}
exports.joinPathSegments = joinPathSegments;


/***/ }),

/***/ 8311:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const common = __nccwpck_require__(7988);
class Reader {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
    }
}
exports.default = Reader;


/***/ }),

/***/ 3595:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsScandir = __nccwpck_require__(5667);
const common = __nccwpck_require__(7988);
const reader_1 = __nccwpck_require__(8311);
class SyncReader extends reader_1.default {
    constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = new Set();
    }
    read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
    }
    _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
    }
    _handleQueue() {
        for (const item of this._queue.values()) {
            this._handleDirectory(item.directory, item.base);
        }
    }
    _handleDirectory(directory, base) {
        try {
            const entries = this._scandir(directory, this._settings.fsScandirSettings);
            for (const entry of entries) {
                this._handleEntry(entry, base);
            }
        }
        catch (error) {
            this._handleError(error);
        }
    }
    _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
            return;
        }
        throw error;
    }
    _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
        }
    }
    _pushToStorage(entry) {
        this._storage.push(entry);
    }
}
exports.default = SyncReader;


/***/ }),

/***/ 141:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __nccwpck_require__(5622);
const fsScandir = __nccwpck_require__(5667);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, undefined);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.fsScandirSettings = new fsScandir.Settings({
            followSymbolicLinks: this._options.followSymbolicLinks,
            fs: this._options.fs,
            pathSegmentSeparator: this._options.pathSegmentSeparator,
            stats: this._options.stats,
            throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
exports.default = Settings;


/***/ }),

/***/ 369:
/***/ ((__unused_webpack_module, exports) => {

/*
 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
 * for users.
 *
 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
 * because some build tools have trouble tree-shaking imported guards.
 *
 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
 *
 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
 * replaced.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/** Flag that is true for debug builds, false otherwise. */
exports.IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;
//# sourceMappingURL=flags.js.map

/***/ }),

/***/ 3536:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var utils_1 = __nccwpck_require__(1620);
var flags_1 = __nccwpck_require__(369);
var scope_1 = __nccwpck_require__(4213);
var session_1 = __nccwpck_require__(2474);
/**
 * API compatibility version of this hub.
 *
 * WARNING: This number should only be increased when the global interface
 * changes and new methods are introduced.
 *
 * @hidden
 */
exports.API_VERSION = 4;
/**
 * Default maximum number of breadcrumbs added to an event. Can be overwritten
 * with {@link Options.maxBreadcrumbs}.
 */
var DEFAULT_BREADCRUMBS = 100;
/**
 * @inheritDoc
 */
var Hub = /** @class */ (function () {
    /**
     * Creates a new instance of the hub, will push one {@link Layer} into the
     * internal stack on creation.
     *
     * @param client bound to the hub.
     * @param scope bound to the hub.
     * @param version number, higher number means higher priority.
     */
    function Hub(client, scope, _version) {
        if (scope === void 0) { scope = new scope_1.Scope(); }
        if (_version === void 0) { _version = exports.API_VERSION; }
        this._version = _version;
        /** Is a {@link Layer}[] containing the client and scope */
        this._stack = [{}];
        this.getStackTop().scope = scope;
        if (client) {
            this.bindClient(client);
        }
    }
    /**
     * @inheritDoc
     */
    Hub.prototype.isOlderThan = function (version) {
        return this._version < version;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.bindClient = function (client) {
        var top = this.getStackTop();
        top.client = client;
        if (client && client.setupIntegrations) {
            client.setupIntegrations();
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.pushScope = function () {
        // We want to clone the content of prev scope
        var scope = scope_1.Scope.clone(this.getScope());
        this.getStack().push({
            client: this.getClient(),
            scope: scope,
        });
        return scope;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.popScope = function () {
        if (this.getStack().length <= 1)
            return false;
        return !!this.getStack().pop();
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.withScope = function (callback) {
        var scope = this.pushScope();
        try {
            callback(scope);
        }
        finally {
            this.popScope();
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.getClient = function () {
        return this.getStackTop().client;
    };
    /** Returns the scope of the top stack. */
    Hub.prototype.getScope = function () {
        return this.getStackTop().scope;
    };
    /** Returns the scope stack for domains or the process. */
    Hub.prototype.getStack = function () {
        return this._stack;
    };
    /** Returns the topmost scope layer in the order domain > local > process. */
    Hub.prototype.getStackTop = function () {
        return this._stack[this._stack.length - 1];
    };
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    Hub.prototype.captureException = function (exception, hint) {
        var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : utils_1.uuid4());
        var finalHint = hint;
        // If there's no explicit hint provided, mimic the same thing that would happen
        // in the minimal itself to create a consistent behavior.
        // We don't do this in the client, as it's the lowest level API, and doing this,
        // would prevent user from having full control over direct calls.
        if (!hint) {
            var syntheticException = void 0;
            try {
                throw new Error('Sentry syntheticException');
            }
            catch (exception) {
                syntheticException = exception;
            }
            finalHint = {
                originalException: exception,
                syntheticException: syntheticException,
            };
        }
        this._invokeClient('captureException', exception, tslib_1.__assign(tslib_1.__assign({}, finalHint), { event_id: eventId }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.captureMessage = function (message, level, hint) {
        var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : utils_1.uuid4());
        var finalHint = hint;
        // If there's no explicit hint provided, mimic the same thing that would happen
        // in the minimal itself to create a consistent behavior.
        // We don't do this in the client, as it's the lowest level API, and doing this,
        // would prevent user from having full control over direct calls.
        if (!hint) {
            var syntheticException = void 0;
            try {
                throw new Error(message);
            }
            catch (exception) {
                syntheticException = exception;
            }
            finalHint = {
                originalException: message,
                syntheticException: syntheticException,
            };
        }
        this._invokeClient('captureMessage', message, level, tslib_1.__assign(tslib_1.__assign({}, finalHint), { event_id: eventId }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.captureEvent = function (event, hint) {
        var eventId = hint && hint.event_id ? hint.event_id : utils_1.uuid4();
        if (event.type !== 'transaction') {
            this._lastEventId = eventId;
        }
        this._invokeClient('captureEvent', event, tslib_1.__assign(tslib_1.__assign({}, hint), { event_id: eventId }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.lastEventId = function () {
        return this._lastEventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.addBreadcrumb = function (breadcrumb, hint) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (!scope || !client)
            return;
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var _b = (client.getOptions && client.getOptions()) || {}, _c = _b.beforeBreadcrumb, beforeBreadcrumb = _c === void 0 ? null : _c, _d = _b.maxBreadcrumbs, maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS : _d;
        if (maxBreadcrumbs <= 0)
            return;
        var timestamp = utils_1.dateTimestampInSeconds();
        var mergedBreadcrumb = tslib_1.__assign({ timestamp: timestamp }, breadcrumb);
        var finalBreadcrumb = beforeBreadcrumb
            ? utils_1.consoleSandbox(function () { return beforeBreadcrumb(mergedBreadcrumb, hint); })
            : mergedBreadcrumb;
        if (finalBreadcrumb === null)
            return;
        scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setUser = function (user) {
        var scope = this.getScope();
        if (scope)
            scope.setUser(user);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setTags = function (tags) {
        var scope = this.getScope();
        if (scope)
            scope.setTags(tags);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setExtras = function (extras) {
        var scope = this.getScope();
        if (scope)
            scope.setExtras(extras);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setTag = function (key, value) {
        var scope = this.getScope();
        if (scope)
            scope.setTag(key, value);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setExtra = function (key, extra) {
        var scope = this.getScope();
        if (scope)
            scope.setExtra(key, extra);
    };
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Hub.prototype.setContext = function (name, context) {
        var scope = this.getScope();
        if (scope)
            scope.setContext(name, context);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.configureScope = function (callback) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (scope && client) {
            callback(scope);
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.run = function (callback) {
        var oldHub = makeMain(this);
        try {
            callback(this);
        }
        finally {
            makeMain(oldHub);
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.getIntegration = function (integration) {
        var client = this.getClient();
        if (!client)
            return null;
        try {
            return client.getIntegration(integration);
        }
        catch (_oO) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
            return null;
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.startSpan = function (context) {
        return this._callExtensionMethod('startSpan', context);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.startTransaction = function (context, customSamplingContext) {
        return this._callExtensionMethod('startTransaction', context, customSamplingContext);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.traceHeaders = function () {
        return this._callExtensionMethod('traceHeaders');
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.captureSession = function (endSession) {
        if (endSession === void 0) { endSession = false; }
        // both send the update and pull the session from the scope
        if (endSession) {
            return this.endSession();
        }
        // only send the update
        this._sendSessionUpdate();
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.endSession = function () {
        var layer = this.getStackTop();
        var scope = layer && layer.scope;
        var session = scope && scope.getSession();
        if (session) {
            session.close();
        }
        this._sendSessionUpdate();
        // the session is over; take it off of the scope
        if (scope) {
            scope.setSession();
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.startSession = function (context) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        var _b = (client && client.getOptions()) || {}, release = _b.release, environment = _b.environment;
        // Will fetch userAgent if called from browser sdk
        var global = utils_1.getGlobalObject();
        var userAgent = (global.navigator || {}).userAgent;
        var session = new session_1.Session(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ release: release,
            environment: environment }, (scope && { user: scope.getUser() })), (userAgent && { userAgent: userAgent })), context));
        if (scope) {
            // End existing session if there's one
            var currentSession = scope.getSession && scope.getSession();
            if (currentSession && currentSession.status === 'ok') {
                currentSession.update({ status: 'exited' });
            }
            this.endSession();
            // Afterwards we set the new session on the scope
            scope.setSession(session);
        }
        return session;
    };
    /**
     * Sends the current Session on the scope
     */
    Hub.prototype._sendSessionUpdate = function () {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (!scope)
            return;
        var session = scope.getSession && scope.getSession();
        if (session) {
            if (client && client.captureSession) {
                client.captureSession(session);
            }
        }
    };
    /**
     * Internal helper function to call a method on the top client if it exists.
     *
     * @param method The method to call on the client.
     * @param args Arguments to pass to the client function.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Hub.prototype._invokeClient = function (method) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
        if (client && client[method]) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
            (_a = client)[method].apply(_a, tslib_1.__spread(args, [scope]));
        }
    };
    /**
     * Calls global extension method and binding current instance to the function call
     */
    // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Hub.prototype._callExtensionMethod = function (method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var carrier = getMainCarrier();
        var sentry = carrier.__SENTRY__;
        if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {
            return sentry.extensions[method].apply(this, args);
        }
        flags_1.IS_DEBUG_BUILD && utils_1.logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
    };
    return Hub;
}());
exports.Hub = Hub;
/**
 * Returns the global shim registry.
 *
 * FIXME: This function is problematic, because despite always returning a valid Carrier,
 * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check
 * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.
 **/
function getMainCarrier() {
    var carrier = utils_1.getGlobalObject();
    carrier.__SENTRY__ = carrier.__SENTRY__ || {
        extensions: {},
        hub: undefined,
    };
    return carrier;
}
exports.getMainCarrier = getMainCarrier;
/**
 * Replaces the current main hub with the passed one on the global object
 *
 * @returns The old replaced hub
 */
function makeMain(hub) {
    var registry = getMainCarrier();
    var oldHub = getHubFromCarrier(registry);
    setHubOnCarrier(registry, hub);
    return oldHub;
}
exports.makeMain = makeMain;
/**
 * Returns the default hub instance.
 *
 * If a hub is already registered in the global carrier but this module
 * contains a more recent version, it replaces the registered version.
 * Otherwise, the currently registered hub will be returned.
 */
function getCurrentHub() {
    // Get main carrier (global for every environment)
    var registry = getMainCarrier();
    // If there's no hub, or its an old API, assign a new one
    if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(exports.API_VERSION)) {
        setHubOnCarrier(registry, new Hub());
    }
    // Prefer domains over global if they are there (applicable only to Node environment)
    if (utils_1.isNodeEnv()) {
        return getHubFromActiveDomain(registry);
    }
    // Return hub that lives on a global object
    return getHubFromCarrier(registry);
}
exports.getCurrentHub = getCurrentHub;
/**
 * Returns the active domain, if one exists
 * @deprecated No longer used; remove in v7
 * @returns The domain, or undefined if there is no active domain
 */
// eslint-disable-next-line deprecation/deprecation
function getActiveDomain() {
    flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Function `getActiveDomain` is deprecated and will be removed in a future version.');
    var sentry = getMainCarrier().__SENTRY__;
    return sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
}
exports.getActiveDomain = getActiveDomain;
/**
 * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist
 * @returns discovered hub
 */
function getHubFromActiveDomain(registry) {
    try {
        var sentry = getMainCarrier().__SENTRY__;
        var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
        // If there's no active domain, just return global hub
        if (!activeDomain) {
            return getHubFromCarrier(registry);
        }
        // If there's no hub on current domain, or it's an old API, assign a new one
        if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(exports.API_VERSION)) {
            var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
            setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, scope_1.Scope.clone(registryHubTopStack.scope)));
        }
        // Return hub that lives on a domain
        return getHubFromCarrier(activeDomain);
    }
    catch (_Oo) {
        // Return hub that lives on a global object
        return getHubFromCarrier(registry);
    }
}
/**
 * This will tell whether a carrier has a hub on it or not
 * @param carrier object
 */
function hasHubOnCarrier(carrier) {
    return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
}
/**
 * This will create a new {@link Hub} and add to the passed object on
 * __SENTRY__.hub.
 * @param carrier object
 * @hidden
 */
function getHubFromCarrier(carrier) {
    return utils_1.getGlobalSingleton('hub', function () { return new Hub(); }, carrier);
}
exports.getHubFromCarrier = getHubFromCarrier;
/**
 * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute
 * @param carrier object
 * @param hub Hub
 * @returns A boolean indicating success or failure
 */
function setHubOnCarrier(carrier, hub) {
    if (!carrier)
        return false;
    var __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});
    __SENTRY__.hub = hub;
    return true;
}
exports.setHubOnCarrier = setHubOnCarrier;
//# sourceMappingURL=hub.js.map

/***/ }),

/***/ 6393:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var scope_1 = __nccwpck_require__(4213);
exports.addGlobalEventProcessor = scope_1.addGlobalEventProcessor;
exports.Scope = scope_1.Scope;
var session_1 = __nccwpck_require__(2474);
exports.Session = session_1.Session;
var sessionflusher_1 = __nccwpck_require__(9695);
exports.SessionFlusher = sessionflusher_1.SessionFlusher;
var hub_1 = __nccwpck_require__(3536);
// eslint-disable-next-line deprecation/deprecation
exports.getActiveDomain = hub_1.getActiveDomain;
exports.getCurrentHub = hub_1.getCurrentHub;
exports.getHubFromCarrier = hub_1.getHubFromCarrier;
exports.getMainCarrier = hub_1.getMainCarrier;
exports.Hub = hub_1.Hub;
exports.makeMain = hub_1.makeMain;
exports.setHubOnCarrier = hub_1.setHubOnCarrier;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4213:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var utils_1 = __nccwpck_require__(1620);
/**
 * Absolute maximum number of breadcrumbs added to an event.
 * The `maxBreadcrumbs` option cannot be higher than this value.
 */
var MAX_BREADCRUMBS = 100;
/**
 * Holds additional event information. {@link Scope.applyToEvent} will be
 * called by the client before an event will be sent.
 */
var Scope = /** @class */ (function () {
    function Scope() {
        /** Flag if notifying is happening. */
        this._notifyingListeners = false;
        /** Callback for client to receive scope changes. */
        this._scopeListeners = [];
        /** Callback list that will be called after {@link applyToEvent}. */
        this._eventProcessors = [];
        /** Array of breadcrumbs. */
        this._breadcrumbs = [];
        /** User */
        this._user = {};
        /** Tags */
        this._tags = {};
        /** Extra */
        this._extra = {};
        /** Contexts */
        this._contexts = {};
        /**
         * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
         * sent to Sentry
         */
        this._sdkProcessingMetadata = {};
    }
    /**
     * Inherit values from the parent scope.
     * @param scope to clone.
     */
    Scope.clone = function (scope) {
        var newScope = new Scope();
        if (scope) {
            newScope._breadcrumbs = tslib_1.__spread(scope._breadcrumbs);
            newScope._tags = tslib_1.__assign({}, scope._tags);
            newScope._extra = tslib_1.__assign({}, scope._extra);
            newScope._contexts = tslib_1.__assign({}, scope._contexts);
            newScope._user = scope._user;
            newScope._level = scope._level;
            newScope._span = scope._span;
            newScope._session = scope._session;
            newScope._transactionName = scope._transactionName;
            newScope._fingerprint = scope._fingerprint;
            newScope._eventProcessors = tslib_1.__spread(scope._eventProcessors);
            newScope._requestSession = scope._requestSession;
        }
        return newScope;
    };
    /**
     * Add internal on change listener. Used for sub SDKs that need to store the scope.
     * @hidden
     */
    Scope.prototype.addScopeListener = function (callback) {
        this._scopeListeners.push(callback);
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.addEventProcessor = function (callback) {
        this._eventProcessors.push(callback);
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setUser = function (user) {
        this._user = user || {};
        if (this._session) {
            this._session.update({ user: user });
        }
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getUser = function () {
        return this._user;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getRequestSession = function () {
        return this._requestSession;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setRequestSession = function (requestSession) {
        this._requestSession = requestSession;
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setTags = function (tags) {
        this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), tags);
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setTag = function (key, value) {
        var _a;
        this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), (_a = {}, _a[key] = value, _a));
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setExtras = function (extras) {
        this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), extras);
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setExtra = function (key, extra) {
        var _a;
        this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), (_a = {}, _a[key] = extra, _a));
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setFingerprint = function (fingerprint) {
        this._fingerprint = fingerprint;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setLevel = function (level) {
        this._level = level;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setTransactionName = function (name) {
        this._transactionName = name;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * Can be removed in major version.
     * @deprecated in favor of {@link this.setTransactionName}
     */
    Scope.prototype.setTransaction = function (name) {
        return this.setTransactionName(name);
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setContext = function (key, context) {
        var _a;
        if (context === null) {
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete this._contexts[key];
        }
        else {
            this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), (_a = {}, _a[key] = context, _a));
        }
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setSpan = function (span) {
        this._span = span;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getSpan = function () {
        return this._span;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getTransaction = function () {
        // Often, this span (if it exists at all) will be a transaction, but it's not guaranteed to be. Regardless, it will
        // have a pointer to the currently-active transaction.
        var span = this.getSpan();
        return span && span.transaction;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setSession = function (session) {
        if (!session) {
            delete this._session;
        }
        else {
            this._session = session;
        }
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getSession = function () {
        return this._session;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.update = function (captureContext) {
        if (!captureContext) {
            return this;
        }
        if (typeof captureContext === 'function') {
            var updatedScope = captureContext(this);
            return updatedScope instanceof Scope ? updatedScope : this;
        }
        if (captureContext instanceof Scope) {
            this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), captureContext._tags);
            this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), captureContext._extra);
            this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), captureContext._contexts);
            if (captureContext._user && Object.keys(captureContext._user).length) {
                this._user = captureContext._user;
            }
            if (captureContext._level) {
                this._level = captureContext._level;
            }
            if (captureContext._fingerprint) {
                this._fingerprint = captureContext._fingerprint;
            }
            if (captureContext._requestSession) {
                this._requestSession = captureContext._requestSession;
            }
        }
        else if (utils_1.isPlainObject(captureContext)) {
            // eslint-disable-next-line no-param-reassign
            captureContext = captureContext;
            this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), captureContext.tags);
            this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), captureContext.extra);
            this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), captureContext.contexts);
            if (captureContext.user) {
                this._user = captureContext.user;
            }
            if (captureContext.level) {
                this._level = captureContext.level;
            }
            if (captureContext.fingerprint) {
                this._fingerprint = captureContext.fingerprint;
            }
            if (captureContext.requestSession) {
                this._requestSession = captureContext.requestSession;
            }
        }
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.clear = function () {
        this._breadcrumbs = [];
        this._tags = {};
        this._extra = {};
        this._user = {};
        this._contexts = {};
        this._level = undefined;
        this._transactionName = undefined;
        this._fingerprint = undefined;
        this._requestSession = undefined;
        this._span = undefined;
        this._session = undefined;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.addBreadcrumb = function (breadcrumb, maxBreadcrumbs) {
        var maxCrumbs = typeof maxBreadcrumbs === 'number' ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;
        // No data has been changed, so don't notify scope listeners
        if (maxCrumbs <= 0) {
            return this;
        }
        var mergedBreadcrumb = tslib_1.__assign({ timestamp: utils_1.dateTimestampInSeconds() }, breadcrumb);
        this._breadcrumbs = tslib_1.__spread(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxCrumbs);
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.clearBreadcrumbs = function () {
        this._breadcrumbs = [];
        this._notifyScopeListeners();
        return this;
    };
    /**
     * Applies the current context and fingerprint to the event.
     * Note that breadcrumbs will be added by the client.
     * Also if the event has already breadcrumbs on it, we do not merge them.
     * @param event Event
     * @param hint May contain additional information about the original exception.
     * @hidden
     */
    Scope.prototype.applyToEvent = function (event, hint) {
        if (this._extra && Object.keys(this._extra).length) {
            event.extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), event.extra);
        }
        if (this._tags && Object.keys(this._tags).length) {
            event.tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), event.tags);
        }
        if (this._user && Object.keys(this._user).length) {
            event.user = tslib_1.__assign(tslib_1.__assign({}, this._user), event.user);
        }
        if (this._contexts && Object.keys(this._contexts).length) {
            event.contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), event.contexts);
        }
        if (this._level) {
            event.level = this._level;
        }
        if (this._transactionName) {
            event.transaction = this._transactionName;
        }
        // We want to set the trace context for normal events only if there isn't already
        // a trace context on the event. There is a product feature in place where we link
        // errors with transaction and it relies on that.
        if (this._span) {
            event.contexts = tslib_1.__assign({ trace: this._span.getTraceContext() }, event.contexts);
            var transactionName = this._span.transaction && this._span.transaction.name;
            if (transactionName) {
                event.tags = tslib_1.__assign({ transaction: transactionName }, event.tags);
            }
        }
        this._applyFingerprint(event);
        event.breadcrumbs = tslib_1.__spread((event.breadcrumbs || []), this._breadcrumbs);
        event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;
        event.sdkProcessingMetadata = this._sdkProcessingMetadata;
        return this._notifyEventProcessors(tslib_1.__spread(getGlobalEventProcessors(), this._eventProcessors), event, hint);
    };
    /**
     * Add data which will be accessible during event processing but won't get sent to Sentry
     */
    Scope.prototype.setSDKProcessingMetadata = function (newData) {
        this._sdkProcessingMetadata = tslib_1.__assign(tslib_1.__assign({}, this._sdkProcessingMetadata), newData);
        return this;
    };
    /**
     * This will be called after {@link applyToEvent} is finished.
     */
    Scope.prototype._notifyEventProcessors = function (processors, event, hint, index) {
        var _this = this;
        if (index === void 0) { index = 0; }
        return new utils_1.SyncPromise(function (resolve, reject) {
            var processor = processors[index];
            if (event === null || typeof processor !== 'function') {
                resolve(event);
            }
            else {
                var result = processor(tslib_1.__assign({}, event), hint);
                if (utils_1.isThenable(result)) {
                    void result
                        .then(function (final) { return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve); })
                        .then(null, reject);
                }
                else {
                    void _this._notifyEventProcessors(processors, result, hint, index + 1)
                        .then(resolve)
                        .then(null, reject);
                }
            }
        });
    };
    /**
     * This will be called on every set call.
     */
    Scope.prototype._notifyScopeListeners = function () {
        var _this = this;
        // We need this check for this._notifyingListeners to be able to work on scope during updates
        // If this check is not here we'll produce endless recursion when something is done with the scope
        // during the callback.
        if (!this._notifyingListeners) {
            this._notifyingListeners = true;
            this._scopeListeners.forEach(function (callback) {
                callback(_this);
            });
            this._notifyingListeners = false;
        }
    };
    /**
     * Applies fingerprint from the scope to the event if there's one,
     * uses message if there's one instead or get rid of empty fingerprint
     */
    Scope.prototype._applyFingerprint = function (event) {
        // Make sure it's an array first and we actually have something in place
        event.fingerprint = event.fingerprint
            ? Array.isArray(event.fingerprint)
                ? event.fingerprint
                : [event.fingerprint]
            : [];
        // If we have something on the scope, then merge it with event
        if (this._fingerprint) {
            event.fingerprint = event.fingerprint.concat(this._fingerprint);
        }
        // If we have no data at all, remove empty array default
        if (event.fingerprint && !event.fingerprint.length) {
            delete event.fingerprint;
        }
    };
    return Scope;
}());
exports.Scope = Scope;
/**
 * Returns the global event processors.
 */
function getGlobalEventProcessors() {
    return utils_1.getGlobalSingleton('globalEventProcessors', function () { return []; });
}
/**
 * Add a EventProcessor to be kept globally.
 * @param callback EventProcessor to add
 */
function addGlobalEventProcessor(callback) {
    getGlobalEventProcessors().push(callback);
}
exports.addGlobalEventProcessor = addGlobalEventProcessor;
//# sourceMappingURL=scope.js.map

/***/ }),

/***/ 2474:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var utils_1 = __nccwpck_require__(1620);
/**
 * @inheritdoc
 */
var Session = /** @class */ (function () {
    function Session(context) {
        this.errors = 0;
        this.sid = utils_1.uuid4();
        this.duration = 0;
        this.status = 'ok';
        this.init = true;
        this.ignoreDuration = false;
        // Both timestamp and started are in seconds since the UNIX epoch.
        var startingTime = utils_1.timestampInSeconds();
        this.timestamp = startingTime;
        this.started = startingTime;
        if (context) {
            this.update(context);
        }
    }
    /** JSDoc */
    // eslint-disable-next-line complexity
    Session.prototype.update = function (context) {
        if (context === void 0) { context = {}; }
        if (context.user) {
            if (!this.ipAddress && context.user.ip_address) {
                this.ipAddress = context.user.ip_address;
            }
            if (!this.did && !context.did) {
                this.did = context.user.id || context.user.email || context.user.username;
            }
        }
        this.timestamp = context.timestamp || utils_1.timestampInSeconds();
        if (context.ignoreDuration) {
            this.ignoreDuration = context.ignoreDuration;
        }
        if (context.sid) {
            // Good enough uuid validation.  Kamil
            this.sid = context.sid.length === 32 ? context.sid : utils_1.uuid4();
        }
        if (context.init !== undefined) {
            this.init = context.init;
        }
        if (!this.did && context.did) {
            this.did = "" + context.did;
        }
        if (typeof context.started === 'number') {
            this.started = context.started;
        }
        if (this.ignoreDuration) {
            this.duration = undefined;
        }
        else if (typeof context.duration === 'number') {
            this.duration = context.duration;
        }
        else {
            var duration = this.timestamp - this.started;
            this.duration = duration >= 0 ? duration : 0;
        }
        if (context.release) {
            this.release = context.release;
        }
        if (context.environment) {
            this.environment = context.environment;
        }
        if (!this.ipAddress && context.ipAddress) {
            this.ipAddress = context.ipAddress;
        }
        if (!this.userAgent && context.userAgent) {
            this.userAgent = context.userAgent;
        }
        if (typeof context.errors === 'number') {
            this.errors = context.errors;
        }
        if (context.status) {
            this.status = context.status;
        }
    };
    /** JSDoc */
    Session.prototype.close = function (status) {
        if (status) {
            this.update({ status: status });
        }
        else if (this.status === 'ok') {
            this.update({ status: 'exited' });
        }
        else {
            this.update();
        }
    };
    /** JSDoc */
    Session.prototype.toJSON = function () {
        return utils_1.dropUndefinedKeys({
            sid: "" + this.sid,
            init: this.init,
            // Make sure that sec is converted to ms for date constructor
            started: new Date(this.started * 1000).toISOString(),
            timestamp: new Date(this.timestamp * 1000).toISOString(),
            status: this.status,
            errors: this.errors,
            did: typeof this.did === 'number' || typeof this.did === 'string' ? "" + this.did : undefined,
            duration: this.duration,
            attrs: {
                release: this.release,
                environment: this.environment,
                ip_address: this.ipAddress,
                user_agent: this.userAgent,
            },
        });
    };
    return Session;
}());
exports.Session = Session;
//# sourceMappingURL=session.js.map

/***/ }),

/***/ 9695:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var utils_1 = __nccwpck_require__(1620);
var flags_1 = __nccwpck_require__(369);
var hub_1 = __nccwpck_require__(3536);
/**
 * @inheritdoc
 */
var SessionFlusher = /** @class */ (function () {
    function SessionFlusher(transport, attrs) {
        var _this = this;
        this.flushTimeout = 60;
        this._pendingAggregates = {};
        this._isEnabled = true;
        this._transport = transport;
        // Call to setInterval, so that flush is called every 60 seconds
        this._intervalId = setInterval(function () { return _this.flush(); }, this.flushTimeout * 1000);
        this._sessionAttrs = attrs;
    }
    /** Sends session aggregates to Transport */
    SessionFlusher.prototype.sendSessionAggregates = function (sessionAggregates) {
        if (!this._transport.sendSession) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.warn("Dropping session because custom transport doesn't implement sendSession");
            return;
        }
        void this._transport.sendSession(sessionAggregates).then(null, function (reason) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Error while sending session:', reason);
        });
    };
    /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */
    SessionFlusher.prototype.flush = function () {
        var sessionAggregates = this.getSessionAggregates();
        if (sessionAggregates.aggregates.length === 0) {
            return;
        }
        this._pendingAggregates = {};
        this.sendSessionAggregates(sessionAggregates);
    };
    /** Massages the entries in `pendingAggregates` and returns aggregated sessions */
    SessionFlusher.prototype.getSessionAggregates = function () {
        var _this = this;
        var aggregates = Object.keys(this._pendingAggregates).map(function (key) {
            return _this._pendingAggregates[parseInt(key)];
        });
        var sessionAggregates = {
            attrs: this._sessionAttrs,
            aggregates: aggregates,
        };
        return utils_1.dropUndefinedKeys(sessionAggregates);
    };
    /** JSDoc */
    SessionFlusher.prototype.close = function () {
        clearInterval(this._intervalId);
        this._isEnabled = false;
        this.flush();
    };
    /**
     * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then
     * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to
     * `_incrementSessionStatusCount` along with the start date
     */
    SessionFlusher.prototype.incrementSessionStatusCount = function () {
        if (!this._isEnabled) {
            return;
        }
        var scope = hub_1.getCurrentHub().getScope();
        var requestSession = scope && scope.getRequestSession();
        if (requestSession && requestSession.status) {
            this._incrementSessionStatusCount(requestSession.status, new Date());
            // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in
            // case captureRequestSession is called more than once to prevent double count
            if (scope) {
                scope.setRequestSession(undefined);
            }
            /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        }
    };
    /**
     * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of
     * the session received
     */
    SessionFlusher.prototype._incrementSessionStatusCount = function (status, date) {
        // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys
        var sessionStartedTrunc = new Date(date).setSeconds(0, 0);
        this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};
        // corresponds to aggregated sessions in one specific minute bucket
        // for example, {"started":"2021-03-16T08:00:00.000Z","exited":4, "errored": 1}
        var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];
        if (!aggregationCounts.started) {
            aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();
        }
        switch (status) {
            case 'errored':
                aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;
                return aggregationCounts.errored;
            case 'ok':
                aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;
                return aggregationCounts.exited;
            default:
                aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;
                return aggregationCounts.crashed;
        }
    };
    return SessionFlusher;
}());
exports.SessionFlusher = SessionFlusher;
//# sourceMappingURL=sessionflusher.js.map

/***/ }),

/***/ 8455:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var hub_1 = __nccwpck_require__(6393);
/**
 * This calls a function on the current hub.
 * @param method function to call on hub.
 * @param args to pass to function.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function callOnHub(method) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var hub = hub_1.getCurrentHub();
    if (hub && hub[method]) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return hub[method].apply(hub, tslib_1.__spread(args));
    }
    throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
}
/**
 * Captures an exception event and sends it to Sentry.
 *
 * @param exception An exception-like object.
 * @returns The generated eventId.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
function captureException(exception, captureContext) {
    var syntheticException = new Error('Sentry syntheticException');
    return callOnHub('captureException', exception, {
        captureContext: captureContext,
        originalException: exception,
        syntheticException: syntheticException,
    });
}
exports.captureException = captureException;
/**
 * Captures a message event and sends it to Sentry.
 *
 * @param message The message to send to Sentry.
 * @param Severity Define the level of the message.
 * @returns The generated eventId.
 */
function captureMessage(message, captureContext) {
    var syntheticException = new Error(message);
    // This is necessary to provide explicit scopes upgrade, without changing the original
    // arity of the `captureMessage(message, level)` method.
    var level = typeof captureContext === 'string' ? captureContext : undefined;
    var context = typeof captureContext !== 'string' ? { captureContext: captureContext } : undefined;
    return callOnHub('captureMessage', message, level, tslib_1.__assign({ originalException: message, syntheticException: syntheticException }, context));
}
exports.captureMessage = captureMessage;
/**
 * Captures a manually created event and sends it to Sentry.
 *
 * @param event The event to send to Sentry.
 * @returns The generated eventId.
 */
function captureEvent(event) {
    return callOnHub('captureEvent', event);
}
exports.captureEvent = captureEvent;
/**
 * Callback to set context information onto the scope.
 * @param callback Callback function that receives Scope.
 */
function configureScope(callback) {
    callOnHub('configureScope', callback);
}
exports.configureScope = configureScope;
/**
 * Records a new breadcrumb which will be attached to future events.
 *
 * Breadcrumbs will be added to subsequent events to provide more context on
 * user's actions prior to an error or crash.
 *
 * @param breadcrumb The breadcrumb to record.
 */
function addBreadcrumb(breadcrumb) {
    callOnHub('addBreadcrumb', breadcrumb);
}
exports.addBreadcrumb = addBreadcrumb;
/**
 * Sets context data with the given name.
 * @param name of the context
 * @param context Any kind of data. This data will be normalized.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setContext(name, context) {
    callOnHub('setContext', name, context);
}
exports.setContext = setContext;
/**
 * Set an object that will be merged sent as extra data with the event.
 * @param extras Extras object to merge into current context.
 */
function setExtras(extras) {
    callOnHub('setExtras', extras);
}
exports.setExtras = setExtras;
/**
 * Set an object that will be merged sent as tags data with the event.
 * @param tags Tags context object to merge into current context.
 */
function setTags(tags) {
    callOnHub('setTags', tags);
}
exports.setTags = setTags;
/**
 * Set key:value that will be sent as extra data with the event.
 * @param key String of extra
 * @param extra Any kind of data. This data will be normalized.
 */
function setExtra(key, extra) {
    callOnHub('setExtra', key, extra);
}
exports.setExtra = setExtra;
/**
 * Set key:value that will be sent as tags data with the event.
 *
 * Can also be used to unset a tag, by passing `undefined`.
 *
 * @param key String key of tag
 * @param value Value of tag
 */
function setTag(key, value) {
    callOnHub('setTag', key, value);
}
exports.setTag = setTag;
/**
 * Updates user context information for future events.
 *
 * @param user User context object to be set in the current context. Pass `null` to unset the user.
 */
function setUser(user) {
    callOnHub('setUser', user);
}
exports.setUser = setUser;
/**
 * Creates a new scope with and executes the given operation within.
 * The scope is automatically removed once the operation
 * finishes or throws.
 *
 * This is essentially a convenience function for:
 *
 *     pushScope();
 *     callback();
 *     popScope();
 *
 * @param callback that will be enclosed into push/popScope.
 */
function withScope(callback) {
    callOnHub('withScope', callback);
}
exports.withScope = withScope;
/**
 * Calls a function on the latest client. Use this with caution, it's meant as
 * in "internal" helper so we don't need to expose every possible function in
 * the shim. It is not guaranteed that the client actually implements the
 * function.
 *
 * @param method The method to call on the client/client.
 * @param args Arguments to pass to the client/fontend.
 * @hidden
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _callOnClient(method) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    callOnHub.apply(void 0, tslib_1.__spread(['_invokeClient', method], args));
}
exports._callOnClient = _callOnClient;
/**
 * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
 *
 * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
 * new child span within the transaction or any span, call the respective `.startChild()` method.
 *
 * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
 *
 * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its
 * finished child spans will be sent to Sentry.
 *
 * @param context Properties of the new `Transaction`.
 * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
 * default values). See {@link Options.tracesSampler}.
 *
 * @returns The transaction which was just started
 */
function startTransaction(context, customSamplingContext) {
    return callOnHub('startTransaction', tslib_1.__assign({}, context), customSamplingContext);
}
exports.startTransaction = startTransaction;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3789:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var severity_1 = __nccwpck_require__(4124);
exports.Severity = severity_1.Severity;
var severity_2 = __nccwpck_require__(4124);
exports.SeverityLevels = severity_2.SeverityLevels;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4124:
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * TODO(v7): Remove this enum and replace with SeverityLevel
 */
var Severity;
(function (Severity) {
    /** JSDoc */
    Severity["Fatal"] = "fatal";
    /** JSDoc */
    Severity["Error"] = "error";
    /** JSDoc */
    Severity["Warning"] = "warning";
    /** JSDoc */
    Severity["Log"] = "log";
    /** JSDoc */
    Severity["Info"] = "info";
    /** JSDoc */
    Severity["Debug"] = "debug";
    /** JSDoc */
    Severity["Critical"] = "critical";
})(Severity = exports.Severity || (exports.Severity = {}));
// TODO: in v7, these can disappear, because they now also exist in `@sentry/utils`. (Having them there rather than here
// is nice because then it enforces the idea that only types are exported from `@sentry/types`.)
exports.SeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug', 'critical'];
//# sourceMappingURL=severity.js.map

/***/ }),

/***/ 8343:
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Consumes the promise and logs the error when it rejects.
 * @param promise A promise to forget.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function forget(promise) {
    void promise.then(null, function (e) {
        // TODO: Use a better logging mechanism
        // eslint-disable-next-line no-console
        console.error(e);
    });
}
exports.forget = forget;
//# sourceMappingURL=async.js.map

/***/ }),

/***/ 597:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var global_1 = __nccwpck_require__(8813);
var is_1 = __nccwpck_require__(2757);
/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function htmlTreeAsString(elem, keyAttrs) {
    // try/catch both:
    // - accessing event.target (see getsentry/raven-js#838, #768)
    // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
    // - can throw an exception in some circumstances.
    try {
        var currentElem = elem;
        var MAX_TRAVERSE_HEIGHT = 5;
        var MAX_OUTPUT_LEN = 80;
        var out = [];
        var height = 0;
        var len = 0;
        var separator = ' > ';
        var sepLength = separator.length;
        var nextStr = void 0;
        // eslint-disable-next-line no-plusplus
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
            nextStr = _htmlElementAsString(currentElem, keyAttrs);
            // bail out if
            // - nextStr is the 'html' element
            // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
            //   (ignore this limit if we are on the first iteration)
            if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {
                break;
            }
            out.push(nextStr);
            len += nextStr.length;
            currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
    }
    catch (_oO) {
        return '<unknown>';
    }
}
exports.htmlTreeAsString = htmlTreeAsString;
/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function _htmlElementAsString(el, keyAttrs) {
    var elem = el;
    var out = [];
    var className;
    var classes;
    var key;
    var attr;
    var i;
    if (!elem || !elem.tagName) {
        return '';
    }
    out.push(elem.tagName.toLowerCase());
    // Pairs of attribute keys defined in `serializeAttribute` and their values on element.
    var keyAttrPairs = keyAttrs && keyAttrs.length
        ? keyAttrs.filter(function (keyAttr) { return elem.getAttribute(keyAttr); }).map(function (keyAttr) { return [keyAttr, elem.getAttribute(keyAttr)]; })
        : null;
    if (keyAttrPairs && keyAttrPairs.length) {
        keyAttrPairs.forEach(function (keyAttrPair) {
            out.push("[" + keyAttrPair[0] + "=\"" + keyAttrPair[1] + "\"]");
        });
    }
    else {
        if (elem.id) {
            out.push("#" + elem.id);
        }
        // eslint-disable-next-line prefer-const
        className = elem.className;
        if (className && is_1.isString(className)) {
            classes = className.split(/\s+/);
            for (i = 0; i < classes.length; i++) {
                out.push("." + classes[i]);
            }
        }
    }
    var allowedAttrs = ['type', 'name', 'title', 'alt'];
    for (i = 0; i < allowedAttrs.length; i++) {
        key = allowedAttrs[i];
        attr = elem.getAttribute(key);
        if (attr) {
            out.push("[" + key + "=\"" + attr + "\"]");
        }
    }
    return out.join('');
}
/**
 * A safe form of location.href
 */
function getLocationHref() {
    var global = global_1.getGlobalObject();
    try {
        return global.document.location.href;
    }
    catch (oO) {
        return '';
    }
}
exports.getLocationHref = getLocationHref;
//# sourceMappingURL=browser.js.map

/***/ }),

/***/ 8857:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var envelope_1 = __nccwpck_require__(6222);
var time_1 = __nccwpck_require__(1735);
/**
 * Creates client report envelope
 * @param discarded_events An array of discard events
 * @param dsn A DSN that can be set on the header. Optional.
 */
function createClientReportEnvelope(discarded_events, dsn, timestamp) {
    var clientReportItem = [
        { type: 'client_report' },
        {
            timestamp: timestamp || time_1.dateTimestampInSeconds(),
            discarded_events: discarded_events,
        },
    ];
    return envelope_1.createEnvelope(dsn ? { dsn: dsn } : {}, [clientReportItem]);
}
exports.createClientReportEnvelope = createClientReportEnvelope;
//# sourceMappingURL=clientreport.js.map

/***/ }),

/***/ 3275:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var error_1 = __nccwpck_require__(6238);
var flags_1 = __nccwpck_require__(3710);
/** Regular expression used to parse a Dsn. */
var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function isValidProtocol(protocol) {
    return protocol === 'http' || protocol === 'https';
}
/**
 * Renders the string representation of this Dsn.
 *
 * By default, this will render the public representation without the password
 * component. To get the deprecated private representation, set `withPassword`
 * to true.
 *
 * @param withPassword When set to true, the password will be included.
 */
function dsnToString(dsn, withPassword) {
    if (withPassword === void 0) { withPassword = false; }
    var host = dsn.host, path = dsn.path, pass = dsn.pass, port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol, publicKey = dsn.publicKey;
    return (protocol + "://" + publicKey + (withPassword && pass ? ":" + pass : '') +
        ("@" + host + (port ? ":" + port : '') + "/" + (path ? path + "/" : path) + projectId));
}
exports.dsnToString = dsnToString;
function dsnFromString(str) {
    var match = DSN_REGEX.exec(str);
    if (!match) {
        throw new error_1.SentryError("Invalid Sentry Dsn: " + str);
    }
    var _a = tslib_1.__read(match.slice(1), 6), protocol = _a[0], publicKey = _a[1], _b = _a[2], pass = _b === void 0 ? '' : _b, host = _a[3], _c = _a[4], port = _c === void 0 ? '' : _c, lastPath = _a[5];
    var path = '';
    var projectId = lastPath;
    var split = projectId.split('/');
    if (split.length > 1) {
        path = split.slice(0, -1).join('/');
        projectId = split.pop();
    }
    if (projectId) {
        var projectMatch = projectId.match(/^\d+/);
        if (projectMatch) {
            projectId = projectMatch[0];
        }
    }
    return dsnFromComponents({ host: host, pass: pass, path: path, projectId: projectId, port: port, protocol: protocol, publicKey: publicKey });
}
function dsnFromComponents(components) {
    // TODO this is for backwards compatibility, and can be removed in a future version
    if ('user' in components && !('publicKey' in components)) {
        components.publicKey = components.user;
    }
    return {
        user: components.publicKey || '',
        protocol: components.protocol,
        publicKey: components.publicKey || '',
        pass: components.pass || '',
        host: components.host,
        port: components.port || '',
        path: components.path || '',
        projectId: components.projectId,
    };
}
function validateDsn(dsn) {
    if (!flags_1.IS_DEBUG_BUILD) {
        return;
    }
    var port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol;
    var requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];
    requiredComponents.forEach(function (component) {
        if (!dsn[component]) {
            throw new error_1.SentryError("Invalid Sentry Dsn: " + component + " missing");
        }
    });
    if (!projectId.match(/^\d+$/)) {
        throw new error_1.SentryError("Invalid Sentry Dsn: Invalid projectId " + projectId);
    }
    if (!isValidProtocol(protocol)) {
        throw new error_1.SentryError("Invalid Sentry Dsn: Invalid protocol " + protocol);
    }
    if (port && isNaN(parseInt(port, 10))) {
        throw new error_1.SentryError("Invalid Sentry Dsn: Invalid port " + port);
    }
    return true;
}
/** The Sentry Dsn, identifying a Sentry instance and project. */
function makeDsn(from) {
    var components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);
    validateDsn(components);
    return components;
}
exports.makeDsn = makeDsn;
//# sourceMappingURL=dsn.js.map

/***/ }),

/***/ 9489:
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug', 'critical'];
//# sourceMappingURL=enums.js.map

/***/ }),

/***/ 1913:
/***/ ((__unused_webpack_module, exports) => {

/*
 * This module exists for optimizations in the build process through rollup and terser.  We define some global
 * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these
 * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will
 * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to
 * `logger` and preventing node-related code from appearing in browser bundles.
 *
 * Attention:
 * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by
 * users. These fags should live in their respective packages, as we identified user tooling (specifically webpack)
 * having issues tree-shaking these constants across package boundaries.
 * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want
 * users to be able to shake away expressions that it guards.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Figures out if we're building a browser bundle.
 *
 * @returns true if this is a browser bundle build.
 */
function isBrowserBundle() {
    return typeof __SENTRY_BROWSER_BUNDLE__ !== 'undefined' && !!__SENTRY_BROWSER_BUNDLE__;
}
exports.isBrowserBundle = isBrowserBundle;
//# sourceMappingURL=env.js.map

/***/ }),

/***/ 6222:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var is_1 = __nccwpck_require__(2757);
/**
 * Creates an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
function createEnvelope(headers, items) {
    if (items === void 0) { items = []; }
    return [headers, items];
}
exports.createEnvelope = createEnvelope;
/**
 * Add an item to an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
function addItemToEnvelope(envelope, newItem) {
    var _a = tslib_1.__read(envelope, 2), headers = _a[0], items = _a[1];
    return [headers, tslib_1.__spread(items, [newItem])];
}
exports.addItemToEnvelope = addItemToEnvelope;
/**
 * Get the type of the envelope. Grabs the type from the first envelope item.
 */
function getEnvelopeType(envelope) {
    var _a = tslib_1.__read(envelope, 2), _b = tslib_1.__read(_a[1], 1), _c = tslib_1.__read(_b[0], 1), firstItemHeader = _c[0];
    return firstItemHeader.type;
}
exports.getEnvelopeType = getEnvelopeType;
/**
 * Serializes an envelope into a string.
 */
function serializeEnvelope(envelope) {
    var _a = tslib_1.__read(envelope, 2), headers = _a[0], items = _a[1];
    var serializedHeaders = JSON.stringify(headers);
    // Have to cast items to any here since Envelope is a union type
    // Fixed in Typescript 4.2
    // TODO: Remove any[] cast when we upgrade to TS 4.2
    // https://github.com/microsoft/TypeScript/issues/36390
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return items.reduce(function (acc, item) {
        var _a = tslib_1.__read(item, 2), itemHeaders = _a[0], payload = _a[1];
        // We do not serialize payloads that are primitives
        var serializedPayload = is_1.isPrimitive(payload) ? String(payload) : JSON.stringify(payload);
        return acc + "\n" + JSON.stringify(itemHeaders) + "\n" + serializedPayload;
    }, serializedHeaders);
}
exports.serializeEnvelope = serializeEnvelope;
//# sourceMappingURL=envelope.js.map

/***/ }),

/***/ 6238:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var polyfill_1 = __nccwpck_require__(1243);
/** An error emitted by Sentry SDKs and related utilities. */
var SentryError = /** @class */ (function (_super) {
    tslib_1.__extends(SentryError, _super);
    function SentryError(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = _newTarget.prototype.constructor.name;
        polyfill_1.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return SentryError;
}(Error));
exports.SentryError = SentryError;
//# sourceMappingURL=error.js.map

/***/ }),

/***/ 3710:
/***/ ((__unused_webpack_module, exports) => {

/*
 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
 * for users.
 *
 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
 * because some build tools have trouble tree-shaking imported guards.
 *
 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
 *
 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
 * replaced.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/** Flag that is true for debug builds, false otherwise. */
exports.IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;
//# sourceMappingURL=flags.js.map

/***/ }),

/***/ 8813:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var node_1 = __nccwpck_require__(6411);
var fallbackGlobalObject = {};
/**
 * Safely get global scope object
 *
 * @returns Global scope object
 */
function getGlobalObject() {
    return (node_1.isNodeEnv()
        ? global
        : typeof window !== 'undefined' // eslint-disable-line no-restricted-globals
            ? window // eslint-disable-line no-restricted-globals
            : typeof self !== 'undefined'
                ? self
                : fallbackGlobalObject);
}
exports.getGlobalObject = getGlobalObject;
/**
 * Returns a global singleton contained in the global `__SENTRY__` object.
 *
 * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory
 * function and added to the `__SENTRY__` object.
 *
 * @param name name of the global singleton on __SENTRY__
 * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`
 * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value
 * @returns the singleton
 */
function getGlobalSingleton(name, creator, obj) {
    var global = (obj || getGlobalObject());
    var __SENTRY__ = (global.__SENTRY__ = global.__SENTRY__ || {});
    var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
    return singleton;
}
exports.getGlobalSingleton = getGlobalSingleton;
//# sourceMappingURL=global.js.map

/***/ }),

/***/ 1620:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(8343), exports);
tslib_1.__exportStar(__nccwpck_require__(597), exports);
tslib_1.__exportStar(__nccwpck_require__(3275), exports);
tslib_1.__exportStar(__nccwpck_require__(9489), exports);
tslib_1.__exportStar(__nccwpck_require__(6238), exports);
tslib_1.__exportStar(__nccwpck_require__(8813), exports);
tslib_1.__exportStar(__nccwpck_require__(5474), exports);
tslib_1.__exportStar(__nccwpck_require__(2757), exports);
tslib_1.__exportStar(__nccwpck_require__(5577), exports);
tslib_1.__exportStar(__nccwpck_require__(9515), exports);
tslib_1.__exportStar(__nccwpck_require__(2154), exports);
tslib_1.__exportStar(__nccwpck_require__(6411), exports);
tslib_1.__exportStar(__nccwpck_require__(8592), exports);
tslib_1.__exportStar(__nccwpck_require__(9249), exports);
tslib_1.__exportStar(__nccwpck_require__(9188), exports);
tslib_1.__exportStar(__nccwpck_require__(1811), exports);
tslib_1.__exportStar(__nccwpck_require__(8853), exports);
tslib_1.__exportStar(__nccwpck_require__(5986), exports);
tslib_1.__exportStar(__nccwpck_require__(313), exports);
tslib_1.__exportStar(__nccwpck_require__(6538), exports);
tslib_1.__exportStar(__nccwpck_require__(8714), exports);
tslib_1.__exportStar(__nccwpck_require__(7833), exports);
tslib_1.__exportStar(__nccwpck_require__(1735), exports);
tslib_1.__exportStar(__nccwpck_require__(6850), exports);
tslib_1.__exportStar(__nccwpck_require__(1913), exports);
tslib_1.__exportStar(__nccwpck_require__(6222), exports);
tslib_1.__exportStar(__nccwpck_require__(8857), exports);
tslib_1.__exportStar(__nccwpck_require__(9377), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5474:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var flags_1 = __nccwpck_require__(3710);
var global_1 = __nccwpck_require__(8813);
var is_1 = __nccwpck_require__(2757);
var logger_1 = __nccwpck_require__(5577);
var object_1 = __nccwpck_require__(9249);
var stacktrace_1 = __nccwpck_require__(5986);
var supports_1 = __nccwpck_require__(8714);
var global = global_1.getGlobalObject();
/**
 * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.
 *  - Console API
 *  - Fetch API
 *  - XHR API
 *  - History API
 *  - DOM API (click/typing)
 *  - Error API
 *  - UnhandledRejection API
 */
var handlers = {};
var instrumented = {};
/** Instruments given API */
function instrument(type) {
    if (instrumented[type]) {
        return;
    }
    instrumented[type] = true;
    switch (type) {
        case 'console':
            instrumentConsole();
            break;
        case 'dom':
            instrumentDOM();
            break;
        case 'xhr':
            instrumentXHR();
            break;
        case 'fetch':
            instrumentFetch();
            break;
        case 'history':
            instrumentHistory();
            break;
        case 'error':
            instrumentError();
            break;
        case 'unhandledrejection':
            instrumentUnhandledRejection();
            break;
        default:
            flags_1.IS_DEBUG_BUILD && logger_1.logger.warn('unknown instrumentation type:', type);
            return;
    }
}
/**
 * Add handler that will be called when given type of instrumentation triggers.
 * Use at your own risk, this might break without changelog notice, only used internally.
 * @hidden
 */
function addInstrumentationHandler(type, callback) {
    handlers[type] = handlers[type] || [];
    handlers[type].push(callback);
    instrument(type);
}
exports.addInstrumentationHandler = addInstrumentationHandler;
/** JSDoc */
function triggerHandlers(type, data) {
    var e_1, _a;
    if (!type || !handlers[type]) {
        return;
    }
    try {
        for (var _b = tslib_1.__values(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {
            var handler = _c.value;
            try {
                handler(data);
            }
            catch (e) {
                flags_1.IS_DEBUG_BUILD &&
                    logger_1.logger.error("Error while triggering instrumentation handler.\nType: " + type + "\nName: " + stacktrace_1.getFunctionName(handler) + "\nError:", e);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
/** JSDoc */
function instrumentConsole() {
    if (!('console' in global)) {
        return;
    }
    logger_1.CONSOLE_LEVELS.forEach(function (level) {
        if (!(level in global.console)) {
            return;
        }
        object_1.fill(global.console, level, function (originalConsoleMethod) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                triggerHandlers('console', { args: args, level: level });
                // this fails for some browsers. :(
                if (originalConsoleMethod) {
                    originalConsoleMethod.apply(global.console, args);
                }
            };
        });
    });
}
/** JSDoc */
function instrumentFetch() {
    if (!supports_1.supportsNativeFetch()) {
        return;
    }
    object_1.fill(global, 'fetch', function (originalFetch) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var handlerData = {
                args: args,
                fetchData: {
                    method: getFetchMethod(args),
                    url: getFetchUrl(args),
                },
                startTimestamp: Date.now(),
            };
            triggerHandlers('fetch', tslib_1.__assign({}, handlerData));
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            return originalFetch.apply(global, args).then(function (response) {
                triggerHandlers('fetch', tslib_1.__assign(tslib_1.__assign({}, handlerData), { endTimestamp: Date.now(), response: response }));
                return response;
            }, function (error) {
                triggerHandlers('fetch', tslib_1.__assign(tslib_1.__assign({}, handlerData), { endTimestamp: Date.now(), error: error }));
                // NOTE: If you are a Sentry user, and you are seeing this stack frame,
                //       it means the sentry.javascript SDK caught an error invoking your application code.
                //       This is expected behavior and NOT indicative of a bug with sentry.javascript.
                throw error;
            });
        };
    });
}
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/** Extract `method` from fetch call arguments */
function getFetchMethod(fetchArgs) {
    if (fetchArgs === void 0) { fetchArgs = []; }
    if ('Request' in global && is_1.isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {
        return String(fetchArgs[0].method).toUpperCase();
    }
    if (fetchArgs[1] && fetchArgs[1].method) {
        return String(fetchArgs[1].method).toUpperCase();
    }
    return 'GET';
}
/** Extract `url` from fetch call arguments */
function getFetchUrl(fetchArgs) {
    if (fetchArgs === void 0) { fetchArgs = []; }
    if (typeof fetchArgs[0] === 'string') {
        return fetchArgs[0];
    }
    if ('Request' in global && is_1.isInstanceOf(fetchArgs[0], Request)) {
        return fetchArgs[0].url;
    }
    return String(fetchArgs[0]);
}
/* eslint-enable @typescript-eslint/no-unsafe-member-access */
/** JSDoc */
function instrumentXHR() {
    if (!('XMLHttpRequest' in global)) {
        return;
    }
    var xhrproto = XMLHttpRequest.prototype;
    object_1.fill(xhrproto, 'open', function (originalOpen) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var xhr = this;
            var url = args[1];
            var xhrInfo = (xhr.__sentry_xhr__ = {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                method: is_1.isString(args[0]) ? args[0].toUpperCase() : args[0],
                url: args[1],
            });
            // if Sentry key appears in URL, don't capture it as a request
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if (is_1.isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {
                xhr.__sentry_own_request__ = true;
            }
            var onreadystatechangeHandler = function () {
                if (xhr.readyState === 4) {
                    try {
                        // touching statusCode in some platforms throws
                        // an exception
                        xhrInfo.status_code = xhr.status;
                    }
                    catch (e) {
                        /* do nothing */
                    }
                    triggerHandlers('xhr', {
                        args: args,
                        endTimestamp: Date.now(),
                        startTimestamp: Date.now(),
                        xhr: xhr,
                    });
                }
            };
            if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {
                object_1.fill(xhr, 'onreadystatechange', function (original) {
                    return function () {
                        var readyStateArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            readyStateArgs[_i] = arguments[_i];
                        }
                        onreadystatechangeHandler();
                        return original.apply(xhr, readyStateArgs);
                    };
                });
            }
            else {
                xhr.addEventListener('readystatechange', onreadystatechangeHandler);
            }
            return originalOpen.apply(xhr, args);
        };
    });
    object_1.fill(xhrproto, 'send', function (originalSend) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (this.__sentry_xhr__ && args[0] !== undefined) {
                this.__sentry_xhr__.body = args[0];
            }
            triggerHandlers('xhr', {
                args: args,
                startTimestamp: Date.now(),
                xhr: this,
            });
            return originalSend.apply(this, args);
        };
    });
}
var lastHref;
/** JSDoc */
function instrumentHistory() {
    if (!supports_1.supportsHistory()) {
        return;
    }
    var oldOnPopState = global.onpopstate;
    global.onpopstate = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var to = global.location.href;
        // keep track of the current URL state, as we always receive only the updated state
        var from = lastHref;
        lastHref = to;
        triggerHandlers('history', {
            from: from,
            to: to,
        });
        if (oldOnPopState) {
            // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.
            // https://github.com/getsentry/sentry-javascript/issues/3344
            // https://github.com/bugsnag/bugsnag-js/issues/469
            try {
                return oldOnPopState.apply(this, args);
            }
            catch (_oO) {
                // no-empty
            }
        }
    };
    /** @hidden */
    function historyReplacementFunction(originalHistoryFunction) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var url = args.length > 2 ? args[2] : undefined;
            if (url) {
                // coerce to string (this is what pushState does)
                var from = lastHref;
                var to = String(url);
                // keep track of the current URL state, as we always receive only the updated state
                lastHref = to;
                triggerHandlers('history', {
                    from: from,
                    to: to,
                });
            }
            return originalHistoryFunction.apply(this, args);
        };
    }
    object_1.fill(global.history, 'pushState', historyReplacementFunction);
    object_1.fill(global.history, 'replaceState', historyReplacementFunction);
}
var debounceDuration = 1000;
var debounceTimerID;
var lastCapturedEvent;
/**
 * Decide whether the current event should finish the debounce of previously captured one.
 * @param previous previously captured event
 * @param current event to be captured
 */
function shouldShortcircuitPreviousDebounce(previous, current) {
    // If there was no previous event, it should always be swapped for the new one.
    if (!previous) {
        return true;
    }
    // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.
    if (previous.type !== current.type) {
        return true;
    }
    try {
        // If both events have the same type, it's still possible that actions were performed on different targets.
        // e.g. 2 clicks on different buttons.
        if (previous.target !== current.target) {
            return true;
        }
    }
    catch (e) {
        // just accessing `target` property can throw an exception in some rare circumstances
        // see: https://github.com/getsentry/sentry-javascript/issues/838
    }
    // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_
    // to which an event listener was attached), we treat them as the same action, as we want to capture
    // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.
    return false;
}
/**
 * Decide whether an event should be captured.
 * @param event event to be captured
 */
function shouldSkipDOMEvent(event) {
    // We are only interested in filtering `keypress` events for now.
    if (event.type !== 'keypress') {
        return false;
    }
    try {
        var target = event.target;
        if (!target || !target.tagName) {
            return true;
        }
        // Only consider keypress events on actual input elements. This will disregard keypresses targeting body
        // e.g.tabbing through elements, hotkeys, etc.
        if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
            return false;
        }
    }
    catch (e) {
        // just accessing `target` property can throw an exception in some rare circumstances
        // see: https://github.com/getsentry/sentry-javascript/issues/838
    }
    return true;
}
/**
 * Wraps addEventListener to capture UI breadcrumbs
 * @param handler function that will be triggered
 * @param globalListener indicates whether event was captured by the global event listener
 * @returns wrapped breadcrumb events handler
 * @hidden
 */
function makeDOMEventHandler(handler, globalListener) {
    if (globalListener === void 0) { globalListener = false; }
    return function (event) {
        // It's possible this handler might trigger multiple times for the same
        // event (e.g. event propagation through node ancestors).
        // Ignore if we've already captured that event.
        if (!event || lastCapturedEvent === event) {
            return;
        }
        // We always want to skip _some_ events.
        if (shouldSkipDOMEvent(event)) {
            return;
        }
        var name = event.type === 'keypress' ? 'input' : event.type;
        // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.
        if (debounceTimerID === undefined) {
            handler({
                event: event,
                name: name,
                global: globalListener,
            });
            lastCapturedEvent = event;
        }
        // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.
        // If that's the case, emit the previous event and store locally the newly-captured DOM event.
        else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
            handler({
                event: event,
                name: name,
                global: globalListener,
            });
            lastCapturedEvent = event;
        }
        // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.
        clearTimeout(debounceTimerID);
        debounceTimerID = global.setTimeout(function () {
            debounceTimerID = undefined;
        }, debounceDuration);
    };
}
/** JSDoc */
function instrumentDOM() {
    if (!('document' in global)) {
        return;
    }
    // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom
    // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before
    // we instrument `addEventListener` so that we don't end up attaching this handler twice.
    var triggerDOMHandler = triggerHandlers.bind(null, 'dom');
    var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
    global.document.addEventListener('click', globalDOMEventHandler, false);
    global.document.addEventListener('keypress', globalDOMEventHandler, false);
    // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled
    // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That
    // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler
    // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still
    // guaranteed to fire at least once.)
    ['EventTarget', 'Node'].forEach(function (target) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        var proto = global[target] && global[target].prototype;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins
        if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {
            return;
        }
        object_1.fill(proto, 'addEventListener', function (originalAddEventListener) {
            return function (type, listener, options) {
                if (type === 'click' || type == 'keypress') {
                    try {
                        var el = this;
                        var handlers_1 = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});
                        var handlerForType = (handlers_1[type] = handlers_1[type] || { refCount: 0 });
                        if (!handlerForType.handler) {
                            var handler = makeDOMEventHandler(triggerDOMHandler);
                            handlerForType.handler = handler;
                            originalAddEventListener.call(this, type, handler, options);
                        }
                        handlerForType.refCount += 1;
                    }
                    catch (e) {
                        // Accessing dom properties is always fragile.
                        // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
                    }
                }
                return originalAddEventListener.call(this, type, listener, options);
            };
        });
        object_1.fill(proto, 'removeEventListener', function (originalRemoveEventListener) {
            return function (type, listener, options) {
                if (type === 'click' || type == 'keypress') {
                    try {
                        var el = this;
                        var handlers_2 = el.__sentry_instrumentation_handlers__ || {};
                        var handlerForType = handlers_2[type];
                        if (handlerForType) {
                            handlerForType.refCount -= 1;
                            // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.
                            if (handlerForType.refCount <= 0) {
                                originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                                handlerForType.handler = undefined;
                                delete handlers_2[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete
                            }
                            // If there are no longer any custom handlers of any type on this element, cleanup everything.
                            if (Object.keys(handlers_2).length === 0) {
                                delete el.__sentry_instrumentation_handlers__;
                            }
                        }
                    }
                    catch (e) {
                        // Accessing dom properties is always fragile.
                        // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
                    }
                }
                return originalRemoveEventListener.call(this, type, listener, options);
            };
        });
    });
}
var _oldOnErrorHandler = null;
/** JSDoc */
function instrumentError() {
    _oldOnErrorHandler = global.onerror;
    global.onerror = function (msg, url, line, column, error) {
        triggerHandlers('error', {
            column: column,
            error: error,
            line: line,
            msg: msg,
            url: url,
        });
        if (_oldOnErrorHandler) {
            // eslint-disable-next-line prefer-rest-params
            return _oldOnErrorHandler.apply(this, arguments);
        }
        return false;
    };
}
var _oldOnUnhandledRejectionHandler = null;
/** JSDoc */
function instrumentUnhandledRejection() {
    _oldOnUnhandledRejectionHandler = global.onunhandledrejection;
    global.onunhandledrejection = function (e) {
        triggerHandlers('unhandledrejection', e);
        if (_oldOnUnhandledRejectionHandler) {
            // eslint-disable-next-line prefer-rest-params
            return _oldOnUnhandledRejectionHandler.apply(this, arguments);
        }
        return true;
    };
}
//# sourceMappingURL=instrument.js.map

/***/ }),

/***/ 2757:
/***/ ((__unused_webpack_module, exports) => {

/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
Object.defineProperty(exports, "__esModule", ({ value: true }));
// eslint-disable-next-line @typescript-eslint/unbound-method
var objectToString = Object.prototype.toString;
/**
 * Checks whether given value's type is one of a few Error or Error-like
 * {@link isError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isError(wat) {
    switch (objectToString.call(wat)) {
        case '[object Error]':
        case '[object Exception]':
        case '[object DOMException]':
            return true;
        default:
            return isInstanceOf(wat, Error);
    }
}
exports.isError = isError;
function isBuiltin(wat, ty) {
    return objectToString.call(wat) === "[object " + ty + "]";
}
/**
 * Checks whether given value's type is ErrorEvent
 * {@link isErrorEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isErrorEvent(wat) {
    return isBuiltin(wat, 'ErrorEvent');
}
exports.isErrorEvent = isErrorEvent;
/**
 * Checks whether given value's type is DOMError
 * {@link isDOMError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isDOMError(wat) {
    return isBuiltin(wat, 'DOMError');
}
exports.isDOMError = isDOMError;
/**
 * Checks whether given value's type is DOMException
 * {@link isDOMException}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isDOMException(wat) {
    return isBuiltin(wat, 'DOMException');
}
exports.isDOMException = isDOMException;
/**
 * Checks whether given value's type is a string
 * {@link isString}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isString(wat) {
    return isBuiltin(wat, 'String');
}
exports.isString = isString;
/**
 * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)
 * {@link isPrimitive}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isPrimitive(wat) {
    return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');
}
exports.isPrimitive = isPrimitive;
/**
 * Checks whether given value's type is an object literal
 * {@link isPlainObject}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isPlainObject(wat) {
    return isBuiltin(wat, 'Object');
}
exports.isPlainObject = isPlainObject;
/**
 * Checks whether given value's type is an Event instance
 * {@link isEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isEvent(wat) {
    return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
}
exports.isEvent = isEvent;
/**
 * Checks whether given value's type is an Element instance
 * {@link isElement}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isElement(wat) {
    return typeof Element !== 'undefined' && isInstanceOf(wat, Element);
}
exports.isElement = isElement;
/**
 * Checks whether given value's type is an regexp
 * {@link isRegExp}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isRegExp(wat) {
    return isBuiltin(wat, 'RegExp');
}
exports.isRegExp = isRegExp;
/**
 * Checks whether given value has a then function.
 * @param wat A value to be checked.
 */
function isThenable(wat) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    return Boolean(wat && wat.then && typeof wat.then === 'function');
}
exports.isThenable = isThenable;
/**
 * Checks whether given value's type is a SyntheticEvent
 * {@link isSyntheticEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isSyntheticEvent(wat) {
    return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;
}
exports.isSyntheticEvent = isSyntheticEvent;
/**
 * Checks whether given value is NaN
 * {@link isNaN}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isNaN(wat) {
    return typeof wat === 'number' && wat !== wat;
}
exports.isNaN = isNaN;
/**
 * Checks whether given value's type is an instance of provided constructor.
 * {@link isInstanceOf}.
 *
 * @param wat A value to be checked.
 * @param base A constructor to be used in a check.
 * @returns A boolean representing the result.
 */
function isInstanceOf(wat, base) {
    try {
        return wat instanceof base;
    }
    catch (_e) {
        return false;
    }
}
exports.isInstanceOf = isInstanceOf;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ 5577:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var flags_1 = __nccwpck_require__(3710);
var global_1 = __nccwpck_require__(8813);
// TODO: Implement different loggers for different environments
var global = global_1.getGlobalObject();
/** Prefix for logging strings */
var PREFIX = 'Sentry Logger ';
exports.CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert'];
/**
 * Temporarily disable sentry console instrumentations.
 *
 * @param callback The function to run against the original `console` messages
 * @returns The results of the callback
 */
function consoleSandbox(callback) {
    var global = global_1.getGlobalObject();
    if (!('console' in global)) {
        return callback();
    }
    var originalConsole = global.console;
    var wrappedLevels = {};
    // Restore all wrapped console methods
    exports.CONSOLE_LEVELS.forEach(function (level) {
        // TODO(v7): Remove this check as it's only needed for Node 6
        var originalWrappedFunc = originalConsole[level] && originalConsole[level].__sentry_original__;
        if (level in global.console && originalWrappedFunc) {
            wrappedLevels[level] = originalConsole[level];
            originalConsole[level] = originalWrappedFunc;
        }
    });
    try {
        return callback();
    }
    finally {
        // Revert restoration to wrapped state
        Object.keys(wrappedLevels).forEach(function (level) {
            originalConsole[level] = wrappedLevels[level];
        });
    }
}
exports.consoleSandbox = consoleSandbox;
function makeLogger() {
    var enabled = false;
    var logger = {
        enable: function () {
            enabled = true;
        },
        disable: function () {
            enabled = false;
        },
    };
    if (flags_1.IS_DEBUG_BUILD) {
        exports.CONSOLE_LEVELS.forEach(function (name) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            logger[name] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (enabled) {
                    consoleSandbox(function () {
                        var _a;
                        (_a = global.console)[name].apply(_a, tslib_1.__spread([PREFIX + "[" + name + "]:"], args));
                    });
                }
            };
        });
    }
    else {
        exports.CONSOLE_LEVELS.forEach(function (name) {
            logger[name] = function () { return undefined; };
        });
    }
    return logger;
}
// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used
var logger;
exports.logger = logger;
if (flags_1.IS_DEBUG_BUILD) {
    exports.logger = logger = global_1.getGlobalSingleton('logger', makeLogger);
}
else {
    exports.logger = logger = makeLogger();
}
//# sourceMappingURL=logger.js.map

/***/ }),

/***/ 9515:
/***/ ((__unused_webpack_module, exports) => {

/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Helper to decycle json objects
 */
function memoBuilder() {
    var hasWeakSet = typeof WeakSet === 'function';
    var inner = hasWeakSet ? new WeakSet() : [];
    function memoize(obj) {
        if (hasWeakSet) {
            if (inner.has(obj)) {
                return true;
            }
            inner.add(obj);
            return false;
        }
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (var i = 0; i < inner.length; i++) {
            var value = inner[i];
            if (value === obj) {
                return true;
            }
        }
        inner.push(obj);
        return false;
    }
    function unmemoize(obj) {
        if (hasWeakSet) {
            inner.delete(obj);
        }
        else {
            for (var i = 0; i < inner.length; i++) {
                if (inner[i] === obj) {
                    inner.splice(i, 1);
                    break;
                }
            }
        }
    }
    return [memoize, unmemoize];
}
exports.memoBuilder = memoBuilder;
//# sourceMappingURL=memo.js.map

/***/ }),

/***/ 2154:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var global_1 = __nccwpck_require__(8813);
var object_1 = __nccwpck_require__(9249);
var string_1 = __nccwpck_require__(6538);
/**
 * UUID4 generator
 *
 * @returns string Generated UUID4.
 */
function uuid4() {
    var global = global_1.getGlobalObject();
    var crypto = global.crypto || global.msCrypto;
    if (!(crypto === void 0) && crypto.getRandomValues) {
        // Use window.crypto API if available
        var arr = new Uint16Array(8);
        crypto.getRandomValues(arr);
        // set 4 in byte 7
        // eslint-disable-next-line no-bitwise
        arr[3] = (arr[3] & 0xfff) | 0x4000;
        // set 2 most significant bits of byte 9 to '10'
        // eslint-disable-next-line no-bitwise
        arr[4] = (arr[4] & 0x3fff) | 0x8000;
        var pad = function (num) {
            var v = num.toString(16);
            while (v.length < 4) {
                v = "0" + v;
            }
            return v;
        };
        return (pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]));
    }
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        // eslint-disable-next-line no-bitwise
        var r = (Math.random() * 16) | 0;
        // eslint-disable-next-line no-bitwise
        var v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}
exports.uuid4 = uuid4;
/**
 * Parses string form of URL into an object
 * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
 * // intentionally using regex and not <a/> href parsing trick because React Native and other
 * // environments where DOM might not be available
 * @returns parsed URL object
 */
function parseUrl(url) {
    if (!url) {
        return {};
    }
    var match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!match) {
        return {};
    }
    // coerce to undefined values to empty string so we don't get 'undefined'
    var query = match[6] || '';
    var fragment = match[8] || '';
    return {
        host: match[4],
        path: match[5],
        protocol: match[2],
        relative: match[5] + query + fragment,
    };
}
exports.parseUrl = parseUrl;
function getFirstException(event) {
    return event.exception && event.exception.values ? event.exception.values[0] : undefined;
}
/**
 * Extracts either message or type+value from an event that can be used for user-facing logs
 * @returns event's description
 */
function getEventDescription(event) {
    var message = event.message, eventId = event.event_id;
    if (message) {
        return message;
    }
    var firstException = getFirstException(event);
    if (firstException) {
        if (firstException.type && firstException.value) {
            return firstException.type + ": " + firstException.value;
        }
        return firstException.type || firstException.value || eventId || '<unknown>';
    }
    return eventId || '<unknown>';
}
exports.getEventDescription = getEventDescription;
/**
 * Adds exception values, type and value to an synthetic Exception.
 * @param event The event to modify.
 * @param value Value of the exception.
 * @param type Type of the exception.
 * @hidden
 */
function addExceptionTypeValue(event, value, type) {
    var exception = (event.exception = event.exception || {});
    var values = (exception.values = exception.values || []);
    var firstException = (values[0] = values[0] || {});
    if (!firstException.value) {
        firstException.value = value || '';
    }
    if (!firstException.type) {
        firstException.type = type || 'Error';
    }
}
exports.addExceptionTypeValue = addExceptionTypeValue;
/**
 * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.
 *
 * @param event The event to modify.
 * @param newMechanism Mechanism data to add to the event.
 * @hidden
 */
function addExceptionMechanism(event, newMechanism) {
    var firstException = getFirstException(event);
    if (!firstException) {
        return;
    }
    var defaultMechanism = { type: 'generic', handled: true };
    var currentMechanism = firstException.mechanism;
    firstException.mechanism = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, defaultMechanism), currentMechanism), newMechanism);
    if (newMechanism && 'data' in newMechanism) {
        var mergedData = tslib_1.__assign(tslib_1.__assign({}, (currentMechanism && currentMechanism.data)), newMechanism.data);
        firstException.mechanism.data = mergedData;
    }
}
exports.addExceptionMechanism = addExceptionMechanism;
// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string
var SEMVER_REGEXP = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
/**
 * Parses input into a SemVer interface
 * @param input string representation of a semver version
 */
function parseSemver(input) {
    var match = input.match(SEMVER_REGEXP) || [];
    var major = parseInt(match[1], 10);
    var minor = parseInt(match[2], 10);
    var patch = parseInt(match[3], 10);
    return {
        buildmetadata: match[5],
        major: isNaN(major) ? undefined : major,
        minor: isNaN(minor) ? undefined : minor,
        patch: isNaN(patch) ? undefined : patch,
        prerelease: match[4],
    };
}
exports.parseSemver = parseSemver;
/**
 * This function adds context (pre/post/line) lines to the provided frame
 *
 * @param lines string[] containing all lines
 * @param frame StackFrame that will be mutated
 * @param linesOfContext number of context lines we want to add pre/post
 */
function addContextToFrame(lines, frame, linesOfContext) {
    if (linesOfContext === void 0) { linesOfContext = 5; }
    var lineno = frame.lineno || 0;
    var maxLines = lines.length;
    var sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);
    frame.pre_context = lines
        .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)
        .map(function (line) { return string_1.snipLine(line, 0); });
    frame.context_line = string_1.snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);
    frame.post_context = lines
        .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)
        .map(function (line) { return string_1.snipLine(line, 0); });
}
exports.addContextToFrame = addContextToFrame;
/**
 * Strip the query string and fragment off of a given URL or path (if present)
 *
 * @param urlPath Full URL or path, including possible query string and/or fragment
 * @returns URL or path without query string or fragment
 */
function stripUrlQueryAndFragment(urlPath) {
    // eslint-disable-next-line no-useless-escape
    return urlPath.split(/[\?#]/, 1)[0];
}
exports.stripUrlQueryAndFragment = stripUrlQueryAndFragment;
/**
 * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object
 * in question), and marks it captured if not.
 *
 * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and
 * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so
 * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because
 * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not
 * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This
 * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we
 * see it.
 *
 * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on
 * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent
 * object wrapper forms so that this check will always work. However, because we need to flag the exact object which
 * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification
 * must be done before the exception captured.
 *
 * @param A thrown exception to check or flag as having been seen
 * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)
 */
function checkOrSetAlreadyCaught(exception) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    if (exception && exception.__sentry_captured__) {
        return true;
    }
    try {
        // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the
        // `ExtraErrorData` integration
        object_1.addNonEnumerableProperty(exception, '__sentry_captured__', true);
    }
    catch (err) {
        // `exception` is a primitive, so we can't mark it seen
    }
    return false;
}
exports.checkOrSetAlreadyCaught = checkOrSetAlreadyCaught;
//# sourceMappingURL=misc.js.map

/***/ }),

/***/ 6411:
/***/ ((module, exports, __nccwpck_require__) => {

/* module decorator */ module = __nccwpck_require__.nmd(module);
/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var env_1 = __nccwpck_require__(1913);
/**
 * Checks whether we're in the Node.js or Browser environment
 *
 * @returns Answer to given question
 */
function isNodeEnv() {
    // explicitly check for browser bundles as those can be optimized statically
    // by terser/rollup.
    return (!env_1.isBrowserBundle() &&
        Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]');
}
exports.isNodeEnv = isNodeEnv;
/**
 * Requires a module which is protected against bundler minification.
 *
 * @param request The module path to resolve
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
function dynamicRequire(mod, request) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    return mod.require(request);
}
exports.dynamicRequire = dynamicRequire;
/**
 * Helper for dynamically loading module that should work with linked dependencies.
 * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`
 * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during
 * build time. `require.resolve` is also not available in any other way, so we cannot create,
 * a fake helper like we do with `dynamicRequire`.
 *
 * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.
 * That is to mimic the behavior of `require.resolve` exactly.
 *
 * @param moduleName module name to require
 * @returns possibly required module
 */
function loadModule(moduleName) {
    var mod;
    try {
        mod = dynamicRequire(module, moduleName);
    }
    catch (e) {
        // no-empty
    }
    try {
        var cwd = dynamicRequire(module, 'process').cwd;
        mod = dynamicRequire(module, cwd() + "/node_modules/" + moduleName);
    }
    catch (e) {
        // no-empty
    }
    return mod;
}
exports.loadModule = loadModule;
//# sourceMappingURL=node.js.map

/***/ }),

/***/ 8592:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var is_1 = __nccwpck_require__(2757);
var memo_1 = __nccwpck_require__(9515);
var object_1 = __nccwpck_require__(9249);
var stacktrace_1 = __nccwpck_require__(5986);
/**
 * Recursively normalizes the given object.
 *
 * - Creates a copy to prevent original input mutation
 * - Skips non-enumerable properties
 * - When stringifying, calls `toJSON` if implemented
 * - Removes circular references
 * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format
 * - Translates known global objects/classes to a string representations
 * - Takes care of `Error` object serialization
 * - Optionally limits depth of final output
 * - Optionally limits number of properties/elements included in any single object/array
 *
 * @param input The object to be normalized.
 * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)
 * @param maxProperties The max number of elements or properties to be included in any single array or
 * object in the normallized output..
 * @returns A normalized version of the object, or `"**non-serializable**"` if any errors are thrown during normalization.
 */
function normalize(input, depth, maxProperties) {
    if (depth === void 0) { depth = +Infinity; }
    if (maxProperties === void 0) { maxProperties = +Infinity; }
    try {
        // since we're at the outermost level, there is no key
        return visit('', input, depth, maxProperties);
    }
    catch (err) {
        return { ERROR: "**non-serializable** (" + err + ")" };
    }
}
exports.normalize = normalize;
/** JSDoc */
function normalizeToSize(object, 
// Default Node.js REPL depth
depth, 
// 100kB, as 200kB is max payload size, so half sounds reasonable
maxSize) {
    if (depth === void 0) { depth = 3; }
    if (maxSize === void 0) { maxSize = 100 * 1024; }
    var normalized = normalize(object, depth);
    if (jsonSize(normalized) > maxSize) {
        return normalizeToSize(object, depth - 1, maxSize);
    }
    return normalized;
}
exports.normalizeToSize = normalizeToSize;
/**
 * Visits a node to perform normalization on it
 *
 * @param key The key corresponding to the given node
 * @param value The node to be visited
 * @param depth Optional number indicating the maximum recursion depth
 * @param maxProperties Optional maximum number of properties/elements included in any single object/array
 * @param memo Optional Memo class handling decycling
 */
function visit(key, value, depth, maxProperties, memo) {
    if (depth === void 0) { depth = +Infinity; }
    if (maxProperties === void 0) { maxProperties = +Infinity; }
    if (memo === void 0) { memo = memo_1.memoBuilder(); }
    var _a = tslib_1.__read(memo, 2), memoize = _a[0], unmemoize = _a[1];
    // If the value has a `toJSON` method, see if we can bail and let it do the work
    var valueWithToJSON = value;
    if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {
        try {
            return valueWithToJSON.toJSON();
        }
        catch (err) {
            // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)
        }
    }
    // Get the simple cases out of the way first
    if (value === null || (['number', 'boolean', 'string'].includes(typeof value) && !is_1.isNaN(value))) {
        return value;
    }
    var stringified = stringifyValue(key, value);
    // Anything we could potentially dig into more (objects or arrays) will have come back as `"[object XXXX]"`.
    // Everything else will have already been serialized, so if we don't see that pattern, we're done.
    if (!stringified.startsWith('[object ')) {
        return stringified;
    }
    // We're also done if we've reached the max depth
    if (depth === 0) {
        // At this point we know `serialized` is a string of the form `"[object XXXX]"`. Clean it up so it's just `"[XXXX]"`.
        return stringified.replace('object ', '');
    }
    // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.
    if (memoize(value)) {
        return '[Circular ~]';
    }
    // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse
    // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each
    // property/entry, and keep track of the number of items we add to it.
    var normalized = (Array.isArray(value) ? [] : {});
    var numAdded = 0;
    // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant
    // properties are non-enumerable and otherwise would get missed.
    var visitable = (is_1.isError(value) || is_1.isEvent(value) ? object_1.convertToPlainObject(value) : value);
    for (var visitKey in visitable) {
        // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.
        if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
            continue;
        }
        if (numAdded >= maxProperties) {
            normalized[visitKey] = '[MaxProperties ~]';
            break;
        }
        // Recursively visit all the child nodes
        var visitValue = visitable[visitKey];
        normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);
        numAdded += 1;
    }
    // Once we've visited all the branches, remove the parent from memo storage
    unmemoize(value);
    // Return accumulated values
    return normalized;
}
exports.walk = visit;
/**
 * Stringify the given value. Handles various known special values and types.
 *
 * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn
 * the number 1231 into "[Object Number]", nor on `null`, as it will throw.
 *
 * @param value The value to stringify
 * @returns A stringified representation of the given value
 */
function stringifyValue(key, 
// this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for
// our internal use, it'll do
value) {
    try {
        if (key === 'domain' && value && typeof value === 'object' && value._events) {
            return '[Domain]';
        }
        if (key === 'domainEmitter') {
            return '[DomainEmitter]';
        }
        // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first
        // which won't throw if they are not present.
        if (typeof global !== 'undefined' && value === global) {
            return '[Global]';
        }
        // eslint-disable-next-line no-restricted-globals
        if (typeof window !== 'undefined' && value === window) {
            return '[Window]';
        }
        // eslint-disable-next-line no-restricted-globals
        if (typeof document !== 'undefined' && value === document) {
            return '[Document]';
        }
        // React's SyntheticEvent thingy
        if (is_1.isSyntheticEvent(value)) {
            return '[SyntheticEvent]';
        }
        if (typeof value === 'number' && value !== value) {
            return '[NaN]';
        }
        // this catches `undefined` (but not `null`, which is a primitive and can be serialized on its own)
        if (value === void 0) {
            return '[undefined]';
        }
        if (typeof value === 'function') {
            return "[Function: " + stacktrace_1.getFunctionName(value) + "]";
        }
        if (typeof value === 'symbol') {
            return "[" + String(value) + "]";
        }
        // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion
        if (typeof value === 'bigint') {
            return "[BigInt: " + String(value) + "]";
        }
        // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting
        // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as
        // `"[object Object]"`. If we instead look at the constructor's name (which is the same as the name of the class),
        // we can make sure that only plain objects come out that way.
        return "[object " + Object.getPrototypeOf(value).constructor.name + "]";
    }
    catch (err) {
        return "**non-serializable** (" + err + ")";
    }
}
/** Calculates bytes size of input string */
function utf8Length(value) {
    // eslint-disable-next-line no-bitwise
    return ~-encodeURI(value).split(/%..|./).length;
}
/** Calculates bytes size of input object */
function jsonSize(value) {
    return utf8Length(JSON.stringify(value));
}
//# sourceMappingURL=normalize.js.map

/***/ }),

/***/ 9249:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var browser_1 = __nccwpck_require__(597);
var is_1 = __nccwpck_require__(2757);
var string_1 = __nccwpck_require__(6538);
/**
 * Replace a method in an object with a wrapped version of itself.
 *
 * @param source An object that contains a method to be wrapped.
 * @param name The name of the method to be wrapped.
 * @param replacementFactory A higher-order function that takes the original version of the given method and returns a
 * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to
 * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other
 * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.
 * @returns void
 */
function fill(source, name, replacementFactory) {
    if (!(name in source)) {
        return;
    }
    var original = source[name];
    var wrapped = replacementFactory(original);
    // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work
    // otherwise it'll throw "TypeError: Object.defineProperties called on non-object"
    if (typeof wrapped === 'function') {
        try {
            markFunctionWrapped(wrapped, original);
        }
        catch (_Oo) {
            // This can throw if multiple fill happens on a global object like XMLHttpRequest
            // Fixes https://github.com/getsentry/sentry-javascript/issues/2043
        }
    }
    source[name] = wrapped;
}
exports.fill = fill;
/**
 * Defines a non-enumerable property on the given object.
 *
 * @param obj The object on which to set the property
 * @param name The name of the property to be set
 * @param value The value to which to set the property
 */
function addNonEnumerableProperty(obj, name, value) {
    Object.defineProperty(obj, name, {
        // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
        value: value,
        writable: true,
        configurable: true,
    });
}
exports.addNonEnumerableProperty = addNonEnumerableProperty;
/**
 * Remembers the original function on the wrapped function and
 * patches up the prototype.
 *
 * @param wrapped the wrapper function
 * @param original the original function that gets wrapped
 */
function markFunctionWrapped(wrapped, original) {
    var proto = original.prototype || {};
    wrapped.prototype = original.prototype = proto;
    addNonEnumerableProperty(wrapped, '__sentry_original__', original);
}
exports.markFunctionWrapped = markFunctionWrapped;
/**
 * This extracts the original function if available.  See
 * `markFunctionWrapped` for more information.
 *
 * @param func the function to unwrap
 * @returns the unwrapped version of the function if available.
 */
function getOriginalFunction(func) {
    return func.__sentry_original__;
}
exports.getOriginalFunction = getOriginalFunction;
/**
 * Encodes given object into url-friendly format
 *
 * @param object An object that contains serializable values
 * @returns string Encoded
 */
function urlEncode(object) {
    return Object.keys(object)
        .map(function (key) { return encodeURIComponent(key) + "=" + encodeURIComponent(object[key]); })
        .join('&');
}
exports.urlEncode = urlEncode;
/**
 * Transforms any object into an object literal with all its attributes
 * attached to it.
 *
 * @param value Initial source that we have to transform in order for it to be usable by the serializer
 */
function convertToPlainObject(value) {
    var newObj = value;
    if (is_1.isError(value)) {
        newObj = tslib_1.__assign({ message: value.message, name: value.name, stack: value.stack }, getOwnProperties(value));
    }
    else if (is_1.isEvent(value)) {
        var event_1 = value;
        newObj = tslib_1.__assign({ type: event_1.type, target: serializeEventTarget(event_1.target), currentTarget: serializeEventTarget(event_1.currentTarget) }, getOwnProperties(event_1));
        if (typeof CustomEvent !== 'undefined' && is_1.isInstanceOf(value, CustomEvent)) {
            newObj.detail = event_1.detail;
        }
    }
    return newObj;
}
exports.convertToPlainObject = convertToPlainObject;
/** Creates a string representation of the target of an `Event` object */
function serializeEventTarget(target) {
    try {
        return is_1.isElement(target) ? browser_1.htmlTreeAsString(target) : Object.prototype.toString.call(target);
    }
    catch (_oO) {
        return '<unknown>';
    }
}
/** Filters out all but an object's own properties */
function getOwnProperties(obj) {
    var extractedProps = {};
    for (var property in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, property)) {
            extractedProps[property] = obj[property];
        }
    }
    return extractedProps;
}
/**
 * Given any captured exception, extract its keys and create a sorted
 * and truncated list that will be used inside the event message.
 * eg. `Non-error exception captured with keys: foo, bar, baz`
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function extractExceptionKeysForMessage(exception, maxLength) {
    if (maxLength === void 0) { maxLength = 40; }
    var keys = Object.keys(convertToPlainObject(exception));
    keys.sort();
    if (!keys.length) {
        return '[object has no keys]';
    }
    if (keys[0].length >= maxLength) {
        return string_1.truncate(keys[0], maxLength);
    }
    for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {
        var serialized = keys.slice(0, includedKeys).join(', ');
        if (serialized.length > maxLength) {
            continue;
        }
        if (includedKeys === keys.length) {
            return serialized;
        }
        return string_1.truncate(serialized, maxLength);
    }
    return '';
}
exports.extractExceptionKeysForMessage = extractExceptionKeysForMessage;
/**
 * Given any object, return the new object with removed keys that value was `undefined`.
 * Works recursively on objects and arrays.
 */
function dropUndefinedKeys(val) {
    var e_1, _a;
    if (is_1.isPlainObject(val)) {
        var rv = {};
        try {
            for (var _b = tslib_1.__values(Object.keys(val)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (typeof val[key] !== 'undefined') {
                    rv[key] = dropUndefinedKeys(val[key]);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return rv;
    }
    if (Array.isArray(val)) {
        return val.map(dropUndefinedKeys);
    }
    return val;
}
exports.dropUndefinedKeys = dropUndefinedKeys;
/**
 * Ensure that something is an object.
 *
 * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper
 * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.
 *
 * @param wat The subject of the objectification
 * @returns A version of `wat` which can safely be used with `Object` class methods
 */
function objectify(wat) {
    var objectified;
    switch (true) {
        case wat === undefined || wat === null:
            objectified = new String(wat);
            break;
        // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason
        // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as
        // an object in order to wrap it.
        case typeof wat === 'symbol' || typeof wat === 'bigint':
            objectified = Object(wat);
            break;
        // this will catch the remaining primitives: `String`, `Number`, and `Boolean`
        case is_1.isPrimitive(wat):
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            objectified = new wat.constructor(wat);
            break;
        // by process of elimination, at this point we know that `wat` must already be an object
        default:
            objectified = wat;
            break;
    }
    return objectified;
}
exports.objectify = objectify;
//# sourceMappingURL=object.js.map

/***/ }),

/***/ 9188:
/***/ ((__unused_webpack_module, exports) => {

// Slightly modified (no IE8 support, ES6) and transcribed to TypeScript
// https://raw.githubusercontent.com/calvinmetcalf/rollup-plugin-node-builtins/master/src/es6/path.js
Object.defineProperty(exports, "__esModule", ({ value: true }));
/** JSDoc */
function normalizeArray(parts, allowAboveRoot) {
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
            parts.splice(i, 1);
        }
        else if (last === '..') {
            parts.splice(i, 1);
            // eslint-disable-next-line no-plusplus
            up++;
        }
        else if (up) {
            parts.splice(i, 1);
            // eslint-disable-next-line no-plusplus
            up--;
        }
    }
    // if the path is allowed to go above the root, restore leading ..s
    if (allowAboveRoot) {
        // eslint-disable-next-line no-plusplus
        for (; up--; up) {
            parts.unshift('..');
        }
    }
    return parts;
}
// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^/]+?|)(\.[^./]*|))(?:[/]*)$/;
/** JSDoc */
function splitPath(filename) {
    var parts = splitPathRe.exec(filename);
    return parts ? parts.slice(1) : [];
}
// path.resolve([from ...], to)
// posix version
/** JSDoc */
function resolve() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var resolvedPath = '';
    var resolvedAbsolute = false;
    for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args[i] : '/';
        // Skip empty entries
        if (!path) {
            continue;
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
    }
    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)
    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function (p) { return !!p; }), !resolvedAbsolute).join('/');
    return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
}
exports.resolve = resolve;
/** JSDoc */
function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
        if (arr[start] !== '') {
            break;
        }
    }
    var end = arr.length - 1;
    for (; end >= 0; end--) {
        if (arr[end] !== '') {
            break;
        }
    }
    if (start > end) {
        return [];
    }
    return arr.slice(start, end - start + 1);
}
// path.relative(from, to)
// posix version
/** JSDoc */
function relative(from, to) {
    /* eslint-disable no-param-reassign */
    from = resolve(from).substr(1);
    to = resolve(to).substr(1);
    /* eslint-enable no-param-reassign */
    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
        }
    }
    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join('/');
}
exports.relative = relative;
// path.normalize(path)
// posix version
/** JSDoc */
function normalizePath(path) {
    var isPathAbsolute = isAbsolute(path);
    var trailingSlash = path.substr(-1) === '/';
    // Normalize the path
    var normalizedPath = normalizeArray(path.split('/').filter(function (p) { return !!p; }), !isPathAbsolute).join('/');
    if (!normalizedPath && !isPathAbsolute) {
        normalizedPath = '.';
    }
    if (normalizedPath && trailingSlash) {
        normalizedPath += '/';
    }
    return (isPathAbsolute ? '/' : '') + normalizedPath;
}
exports.normalizePath = normalizePath;
// posix version
/** JSDoc */
function isAbsolute(path) {
    return path.charAt(0) === '/';
}
exports.isAbsolute = isAbsolute;
// posix version
/** JSDoc */
function join() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return normalizePath(args.join('/'));
}
exports.join = join;
/** JSDoc */
function dirname(path) {
    var result = splitPath(path);
    var root = result[0];
    var dir = result[1];
    if (!root && !dir) {
        // No dirname whatsoever
        return '.';
    }
    if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
    }
    return root + dir;
}
exports.dirname = dirname;
/** JSDoc */
function basename(path, ext) {
    var f = splitPath(path)[2];
    if (ext && f.substr(ext.length * -1) === ext) {
        f = f.substr(0, f.length - ext.length);
    }
    return f;
}
exports.basename = basename;
//# sourceMappingURL=path.js.map

/***/ }),

/***/ 1243:
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setPrototypeOf = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
/**
 * setPrototypeOf polyfill using __proto__
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function setProtoOf(obj, proto) {
    // @ts-ignore __proto__ does not exist on obj
    obj.__proto__ = proto;
    return obj;
}
/**
 * setPrototypeOf polyfill using mixin
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function mixinProperties(obj, proto) {
    for (var prop in proto) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
            // @ts-ignore typescript complains about indexing so we remove
            obj[prop] = proto[prop];
        }
    }
    return obj;
}
//# sourceMappingURL=polyfill.js.map

/***/ }),

/***/ 1811:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var error_1 = __nccwpck_require__(6238);
var syncpromise_1 = __nccwpck_require__(7833);
/**
 * Creates an new PromiseBuffer object with the specified limit
 * @param limit max number of promises that can be stored in the buffer
 */
function makePromiseBuffer(limit) {
    var buffer = [];
    function isReady() {
        return limit === undefined || buffer.length < limit;
    }
    /**
     * Remove a promise from the queue.
     *
     * @param task Can be any PromiseLike<T>
     * @returns Removed promise.
     */
    function remove(task) {
        return buffer.splice(buffer.indexOf(task), 1)[0];
    }
    /**
     * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.
     *
     * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:
     *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor
     *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By
     *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer
     *        limit check.
     * @returns The original promise.
     */
    function add(taskProducer) {
        if (!isReady()) {
            return syncpromise_1.rejectedSyncPromise(new error_1.SentryError('Not adding Promise due to buffer limit reached.'));
        }
        // start the task and add its promise to the queue
        var task = taskProducer();
        if (buffer.indexOf(task) === -1) {
            buffer.push(task);
        }
        void task
            .then(function () { return remove(task); })
            // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`
            // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't
            // have promises, so TS has to polyfill when down-compiling.)
            .then(null, function () {
            return remove(task).then(null, function () {
                // We have to add another catch here because `remove()` starts a new promise chain.
            });
        });
        return task;
    }
    /**
     * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.
     *
     * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or
     * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to
     * `true`.
     * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and
     * `false` otherwise
     */
    function drain(timeout) {
        return new syncpromise_1.SyncPromise(function (resolve, reject) {
            var counter = buffer.length;
            if (!counter) {
                return resolve(true);
            }
            // wait for `timeout` ms and then resolve to `false` (if not cancelled first)
            var capturedSetTimeout = setTimeout(function () {
                if (timeout && timeout > 0) {
                    resolve(false);
                }
            }, timeout);
            // if all promises resolve in time, cancel the timer and resolve to `true`
            buffer.forEach(function (item) {
                void syncpromise_1.resolvedSyncPromise(item).then(function () {
                    // eslint-disable-next-line no-plusplus
                    if (!--counter) {
                        clearTimeout(capturedSetTimeout);
                        resolve(true);
                    }
                }, reject);
            });
        });
    }
    return {
        $: buffer,
        add: add,
        drain: drain,
    };
}
exports.makePromiseBuffer = makePromiseBuffer;
//# sourceMappingURL=promisebuffer.js.map

/***/ }),

/***/ 9377:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
exports.DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds
/**
 * Extracts Retry-After value from the request header or returns default value
 * @param header string representation of 'Retry-After' header
 * @param now current unix timestamp
 *
 */
function parseRetryAfterHeader(header, now) {
    if (now === void 0) { now = Date.now(); }
    var headerDelay = parseInt("" + header, 10);
    if (!isNaN(headerDelay)) {
        return headerDelay * 1000;
    }
    var headerDate = Date.parse("" + header);
    if (!isNaN(headerDate)) {
        return headerDate - now;
    }
    return exports.DEFAULT_RETRY_AFTER;
}
exports.parseRetryAfterHeader = parseRetryAfterHeader;
/**
 * Gets the time that given category is disabled until for rate limiting
 */
function disabledUntil(limits, category) {
    return limits[category] || limits.all || 0;
}
exports.disabledUntil = disabledUntil;
/**
 * Checks if a category is rate limited
 */
function isRateLimited(limits, category, now) {
    if (now === void 0) { now = Date.now(); }
    return disabledUntil(limits, category) > now;
}
exports.isRateLimited = isRateLimited;
/**
 * Update ratelimits from incoming headers.
 * Returns true if headers contains a non-empty rate limiting header.
 */
function updateRateLimits(limits, headers, now) {
    var e_1, _a, e_2, _b;
    if (now === void 0) { now = Date.now(); }
    var updatedRateLimits = tslib_1.__assign({}, limits);
    // "The name is case-insensitive."
    // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get
    var rateLimitHeader = headers['x-sentry-rate-limits'];
    var retryAfterHeader = headers['retry-after'];
    if (rateLimitHeader) {
        try {
            /**
             * rate limit headers are of the form
             *     <header>,<header>,..
             * where each <header> is of the form
             *     <retry_after>: <categories>: <scope>: <reason_code>
             * where
             *     <retry_after> is a delay in seconds
             *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form
             *         <category>;<category>;...
             *     <scope> is what's being limited (org, project, or key) - ignored by SDK
             *     <reason_code> is an arbitrary string like "org_quota" - ignored by SDK
             */
            for (var _c = tslib_1.__values(rateLimitHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {
                var limit = _d.value;
                var parameters = limit.split(':', 2);
                var headerDelay = parseInt(parameters[0], 10);
                var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default
                if (!parameters[1]) {
                    updatedRateLimits.all = now + delay;
                }
                else {
                    try {
                        for (var _e = (e_2 = void 0, tslib_1.__values(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var category = _f.value;
                            updatedRateLimits[category] = now + delay;
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else if (retryAfterHeader) {
        updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
    }
    return updatedRateLimits;
}
exports.updateRateLimits = updateRateLimits;
//# sourceMappingURL=ratelimit.js.map

/***/ }),

/***/ 8853:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var types_1 = __nccwpck_require__(3789);
var enums_1 = __nccwpck_require__(9489);
function isSupportedSeverity(level) {
    return enums_1.SeverityLevels.indexOf(level) !== -1;
}
/**
 * Converts a string-based level into a {@link Severity}.
 *
 * @param level string representation of Severity
 * @returns Severity
 */
function severityFromString(level) {
    if (level === 'warn')
        return types_1.Severity.Warning;
    if (isSupportedSeverity(level)) {
        return level;
    }
    return types_1.Severity.Log;
}
exports.severityFromString = severityFromString;
//# sourceMappingURL=severity.js.map

/***/ }),

/***/ 5986:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var STACKTRACE_LIMIT = 50;
/**
 * Creates a stack parser with the supplied line parsers
 *
 * StackFrames are returned in the correct order for Sentry Exception
 * frames and with Sentry SDK internal frames removed from the top and bottom
 *
 */
function createStackParser() {
    var parsers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        parsers[_i] = arguments[_i];
    }
    var sortedParsers = parsers.sort(function (a, b) { return a[0] - b[0]; }).map(function (p) { return p[1]; });
    return function (stack, skipFirst) {
        var e_1, _a, e_2, _b;
        if (skipFirst === void 0) { skipFirst = 0; }
        var frames = [];
        try {
            for (var _c = tslib_1.__values(stack.split('\n').slice(skipFirst)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var line = _d.value;
                try {
                    for (var sortedParsers_1 = (e_2 = void 0, tslib_1.__values(sortedParsers)), sortedParsers_1_1 = sortedParsers_1.next(); !sortedParsers_1_1.done; sortedParsers_1_1 = sortedParsers_1.next()) {
                        var parser = sortedParsers_1_1.value;
                        var frame = parser(line);
                        if (frame) {
                            frames.push(frame);
                            break;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (sortedParsers_1_1 && !sortedParsers_1_1.done && (_b = sortedParsers_1.return)) _b.call(sortedParsers_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return stripSentryFramesAndReverse(frames);
    };
}
exports.createStackParser = createStackParser;
/**
 * @hidden
 */
function stripSentryFramesAndReverse(stack) {
    if (!stack.length) {
        return [];
    }
    var localStack = stack;
    var firstFrameFunction = localStack[0].function || '';
    var lastFrameFunction = localStack[localStack.length - 1].function || '';
    // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)
    if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {
        localStack = localStack.slice(1);
    }
    // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)
    if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {
        localStack = localStack.slice(0, -1);
    }
    // The frame where the crash happened, should be the last entry in the array
    return localStack
        .slice(0, STACKTRACE_LIMIT)
        .map(function (frame) { return (tslib_1.__assign(tslib_1.__assign({}, frame), { filename: frame.filename || localStack[0].filename, function: frame.function || '?' })); })
        .reverse();
}
exports.stripSentryFramesAndReverse = stripSentryFramesAndReverse;
var defaultFunctionName = '<anonymous>';
/**
 * Safely extract function name from itself
 */
function getFunctionName(fn) {
    try {
        if (!fn || typeof fn !== 'function') {
            return defaultFunctionName;
        }
        return fn.name || defaultFunctionName;
    }
    catch (e) {
        // Just accessing custom props in some Selenium environments
        // can cause a "Permission denied" exception (see raven-js#495).
        return defaultFunctionName;
    }
}
exports.getFunctionName = getFunctionName;
//# sourceMappingURL=stacktrace.js.map

/***/ }),

/***/ 313:
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Converts an HTTP status code to sentry status {@link EventStatus}.
 *
 * @param code number HTTP status code
 * @returns EventStatus
 */
function eventStatusFromHttpCode(code) {
    if (code >= 200 && code < 300) {
        return 'success';
    }
    if (code === 429) {
        return 'rate_limit';
    }
    if (code >= 400 && code < 500) {
        return 'invalid';
    }
    if (code >= 500) {
        return 'failed';
    }
    return 'unknown';
}
exports.eventStatusFromHttpCode = eventStatusFromHttpCode;
//# sourceMappingURL=status.js.map

/***/ }),

/***/ 6538:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var is_1 = __nccwpck_require__(2757);
/**
 * Truncates given string to the maximum characters count
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string (0 = unlimited)
 * @returns string Encoded
 */
function truncate(str, max) {
    if (max === void 0) { max = 0; }
    if (typeof str !== 'string' || max === 0) {
        return str;
    }
    return str.length <= max ? str : str.substr(0, max) + "...";
}
exports.truncate = truncate;
/**
 * This is basically just `trim_line` from
 * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string
 * @returns string Encoded
 */
function snipLine(line, colno) {
    var newLine = line;
    var lineLength = newLine.length;
    if (lineLength <= 150) {
        return newLine;
    }
    if (colno > lineLength) {
        // eslint-disable-next-line no-param-reassign
        colno = lineLength;
    }
    var start = Math.max(colno - 60, 0);
    if (start < 5) {
        start = 0;
    }
    var end = Math.min(start + 140, lineLength);
    if (end > lineLength - 5) {
        end = lineLength;
    }
    if (end === lineLength) {
        start = Math.max(end - 140, 0);
    }
    newLine = newLine.slice(start, end);
    if (start > 0) {
        newLine = "'{snip} " + newLine;
    }
    if (end < lineLength) {
        newLine += ' {snip}';
    }
    return newLine;
}
exports.snipLine = snipLine;
/**
 * Join values in array
 * @param input array of values to be joined together
 * @param delimiter string to be placed in-between values
 * @returns Joined values
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function safeJoin(input, delimiter) {
    if (!Array.isArray(input)) {
        return '';
    }
    var output = [];
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (var i = 0; i < input.length; i++) {
        var value = input[i];
        try {
            output.push(String(value));
        }
        catch (e) {
            output.push('[value cannot be serialized]');
        }
    }
    return output.join(delimiter);
}
exports.safeJoin = safeJoin;
/**
 * Checks if the value matches a regex or includes the string
 * @param value The string value to be checked against
 * @param pattern Either a regex or a string that must be contained in value
 */
function isMatchingPattern(value, pattern) {
    if (!is_1.isString(value)) {
        return false;
    }
    if (is_1.isRegExp(pattern)) {
        return pattern.test(value);
    }
    if (typeof pattern === 'string') {
        return value.indexOf(pattern) !== -1;
    }
    return false;
}
exports.isMatchingPattern = isMatchingPattern;
/**
 * Given a string, escape characters which have meaning in the regex grammar, such that the result is safe to feed to
 * `new RegExp()`.
 *
 * Based on https://github.com/sindresorhus/escape-string-regexp. Vendored to a) reduce the size by skipping the runtime
 * type-checking, and b) ensure it gets down-compiled for old versions of Node (the published package only supports Node
 * 12+).
 *
 * @param regexString The string to escape
 * @returns An version of the string with all special regex characters escaped
 */
function escapeStringForRegex(regexString) {
    // escape the hyphen separately so we can also replace it with a unicode literal hyphen, to avoid the problems
    // discussed in https://github.com/sindresorhus/escape-string-regexp/issues/20.
    return regexString.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
}
exports.escapeStringForRegex = escapeStringForRegex;
//# sourceMappingURL=string.js.map

/***/ }),

/***/ 8714:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var flags_1 = __nccwpck_require__(3710);
var global_1 = __nccwpck_require__(8813);
var logger_1 = __nccwpck_require__(5577);
/**
 * Tells whether current environment supports ErrorEvent objects
 * {@link supportsErrorEvent}.
 *
 * @returns Answer to the given question.
 */
function supportsErrorEvent() {
    try {
        new ErrorEvent('');
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.supportsErrorEvent = supportsErrorEvent;
/**
 * Tells whether current environment supports DOMError objects
 * {@link supportsDOMError}.
 *
 * @returns Answer to the given question.
 */
function supportsDOMError() {
    try {
        // Chrome: VM89:1 Uncaught TypeError: Failed to construct 'DOMError':
        // 1 argument required, but only 0 present.
        // @ts-ignore It really needs 1 argument, not 0.
        new DOMError('');
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.supportsDOMError = supportsDOMError;
/**
 * Tells whether current environment supports DOMException objects
 * {@link supportsDOMException}.
 *
 * @returns Answer to the given question.
 */
function supportsDOMException() {
    try {
        new DOMException('');
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.supportsDOMException = supportsDOMException;
/**
 * Tells whether current environment supports Fetch API
 * {@link supportsFetch}.
 *
 * @returns Answer to the given question.
 */
function supportsFetch() {
    if (!('fetch' in global_1.getGlobalObject())) {
        return false;
    }
    try {
        new Headers();
        new Request('');
        new Response();
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.supportsFetch = supportsFetch;
/**
 * isNativeFetch checks if the given function is a native implementation of fetch()
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function isNativeFetch(func) {
    return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
}
exports.isNativeFetch = isNativeFetch;
/**
 * Tells whether current environment supports Fetch API natively
 * {@link supportsNativeFetch}.
 *
 * @returns true if `window.fetch` is natively implemented, false otherwise
 */
function supportsNativeFetch() {
    if (!supportsFetch()) {
        return false;
    }
    var global = global_1.getGlobalObject();
    // Fast path to avoid DOM I/O
    // eslint-disable-next-line @typescript-eslint/unbound-method
    if (isNativeFetch(global.fetch)) {
        return true;
    }
    // window.fetch is implemented, but is polyfilled or already wrapped (e.g: by a chrome extension)
    // so create a "pure" iframe to see if that has native fetch
    var result = false;
    var doc = global.document;
    // eslint-disable-next-line deprecation/deprecation
    if (doc && typeof doc.createElement === 'function') {
        try {
            var sandbox = doc.createElement('iframe');
            sandbox.hidden = true;
            doc.head.appendChild(sandbox);
            if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
                // eslint-disable-next-line @typescript-eslint/unbound-method
                result = isNativeFetch(sandbox.contentWindow.fetch);
            }
            doc.head.removeChild(sandbox);
        }
        catch (err) {
            flags_1.IS_DEBUG_BUILD &&
                logger_1.logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);
        }
    }
    return result;
}
exports.supportsNativeFetch = supportsNativeFetch;
/**
 * Tells whether current environment supports ReportingObserver API
 * {@link supportsReportingObserver}.
 *
 * @returns Answer to the given question.
 */
function supportsReportingObserver() {
    return 'ReportingObserver' in global_1.getGlobalObject();
}
exports.supportsReportingObserver = supportsReportingObserver;
/**
 * Tells whether current environment supports Referrer Policy API
 * {@link supportsReferrerPolicy}.
 *
 * @returns Answer to the given question.
 */
function supportsReferrerPolicy() {
    // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default'
    // (see https://caniuse.com/#feat=referrer-policy),
    // it doesn't. And it throws an exception instead of ignoring this parameter...
    // REF: https://github.com/getsentry/raven-js/issues/1233
    if (!supportsFetch()) {
        return false;
    }
    try {
        new Request('_', {
            referrerPolicy: 'origin',
        });
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.supportsReferrerPolicy = supportsReferrerPolicy;
/**
 * Tells whether current environment supports History API
 * {@link supportsHistory}.
 *
 * @returns Answer to the given question.
 */
function supportsHistory() {
    // NOTE: in Chrome App environment, touching history.pushState, *even inside
    //       a try/catch block*, will cause Chrome to output an error to console.error
    // borrowed from: https://github.com/angular/angular.js/pull/13945/files
    var global = global_1.getGlobalObject();
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var chrome = global.chrome;
    var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
    var hasHistoryApi = 'history' in global && !!global.history.pushState && !!global.history.replaceState;
    return !isChromePackagedApp && hasHistoryApi;
}
exports.supportsHistory = supportsHistory;
//# sourceMappingURL=supports.js.map

/***/ }),

/***/ 7833:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* eslint-disable @typescript-eslint/explicit-function-return-type */
/* eslint-disable @typescript-eslint/typedef */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
var is_1 = __nccwpck_require__(2757);
/**
 * Creates a resolved sync promise.
 *
 * @param value the value to resolve the promise with
 * @returns the resolved sync promise
 */
function resolvedSyncPromise(value) {
    return new SyncPromise(function (resolve) {
        resolve(value);
    });
}
exports.resolvedSyncPromise = resolvedSyncPromise;
/**
 * Creates a rejected sync promise.
 *
 * @param value the value to reject the promise with
 * @returns the rejected sync promise
 */
function rejectedSyncPromise(reason) {
    return new SyncPromise(function (_, reject) {
        reject(reason);
    });
}
exports.rejectedSyncPromise = rejectedSyncPromise;
/**
 * Thenable class that behaves like a Promise and follows it's interface
 * but is not async internally
 */
var SyncPromise = /** @class */ (function () {
    function SyncPromise(executor) {
        var _this = this;
        this._state = 0 /* PENDING */;
        this._handlers = [];
        /** JSDoc */
        this._resolve = function (value) {
            _this._setResult(1 /* RESOLVED */, value);
        };
        /** JSDoc */
        this._reject = function (reason) {
            _this._setResult(2 /* REJECTED */, reason);
        };
        /** JSDoc */
        this._setResult = function (state, value) {
            if (_this._state !== 0 /* PENDING */) {
                return;
            }
            if (is_1.isThenable(value)) {
                void value.then(_this._resolve, _this._reject);
                return;
            }
            _this._state = state;
            _this._value = value;
            _this._executeHandlers();
        };
        /** JSDoc */
        this._executeHandlers = function () {
            if (_this._state === 0 /* PENDING */) {
                return;
            }
            var cachedHandlers = _this._handlers.slice();
            _this._handlers = [];
            cachedHandlers.forEach(function (handler) {
                if (handler[0]) {
                    return;
                }
                if (_this._state === 1 /* RESOLVED */) {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    handler[1](_this._value);
                }
                if (_this._state === 2 /* REJECTED */) {
                    handler[2](_this._value);
                }
                handler[0] = true;
            });
        };
        try {
            executor(this._resolve, this._reject);
        }
        catch (e) {
            this._reject(e);
        }
    }
    /** JSDoc */
    SyncPromise.prototype.then = function (onfulfilled, onrejected) {
        var _this = this;
        return new SyncPromise(function (resolve, reject) {
            _this._handlers.push([
                false,
                function (result) {
                    if (!onfulfilled) {
                        // TODO: \_()_/
                        // TODO: FIXME
                        resolve(result);
                    }
                    else {
                        try {
                            resolve(onfulfilled(result));
                        }
                        catch (e) {
                            reject(e);
                        }
                    }
                },
                function (reason) {
                    if (!onrejected) {
                        reject(reason);
                    }
                    else {
                        try {
                            resolve(onrejected(reason));
                        }
                        catch (e) {
                            reject(e);
                        }
                    }
                },
            ]);
            _this._executeHandlers();
        });
    };
    /** JSDoc */
    SyncPromise.prototype.catch = function (onrejected) {
        return this.then(function (val) { return val; }, onrejected);
    };
    /** JSDoc */
    SyncPromise.prototype.finally = function (onfinally) {
        var _this = this;
        return new SyncPromise(function (resolve, reject) {
            var val;
            var isRejected;
            return _this.then(function (value) {
                isRejected = false;
                val = value;
                if (onfinally) {
                    onfinally();
                }
            }, function (reason) {
                isRejected = true;
                val = reason;
                if (onfinally) {
                    onfinally();
                }
            }).then(function () {
                if (isRejected) {
                    reject(val);
                    return;
                }
                resolve(val);
            });
        });
    };
    return SyncPromise;
}());
exports.SyncPromise = SyncPromise;
//# sourceMappingURL=syncpromise.js.map

/***/ }),

/***/ 1735:
/***/ ((module, exports, __nccwpck_require__) => {

/* module decorator */ module = __nccwpck_require__.nmd(module);
Object.defineProperty(exports, "__esModule", ({ value: true }));
var global_1 = __nccwpck_require__(8813);
var node_1 = __nccwpck_require__(6411);
/**
 * A TimestampSource implementation for environments that do not support the Performance Web API natively.
 *
 * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier
 * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It
 * is more obvious to explain "why does my span have negative duration" than "why my spans have zero duration".
 */
var dateTimestampSource = {
    nowSeconds: function () { return Date.now() / 1000; },
};
/**
 * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not
 * support the API.
 *
 * Wrapping the native API works around differences in behavior from different browsers.
 */
function getBrowserPerformance() {
    var performance = global_1.getGlobalObject().performance;
    if (!performance || !performance.now) {
        return undefined;
    }
    // Replace performance.timeOrigin with our own timeOrigin based on Date.now().
    //
    // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +
    // performance.now() gives a date arbitrarily in the past.
    //
    // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is
    // undefined.
    //
    // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to
    // interact with data coming out of performance entries.
    //
    // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that
    // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes
    // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have
    // observed skews that can be as long as days, weeks or months.
    //
    // See https://github.com/getsentry/sentry-javascript/issues/2590.
    //
    // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload
    // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation
    // transactions of long-lived web pages.
    var timeOrigin = Date.now() - performance.now();
    return {
        now: function () { return performance.now(); },
        timeOrigin: timeOrigin,
    };
}
/**
 * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't
 * implement the API.
 */
function getNodePerformance() {
    try {
        var perfHooks = node_1.dynamicRequire(module, 'perf_hooks');
        return perfHooks.performance;
    }
    catch (_) {
        return undefined;
    }
}
/**
 * The Performance API implementation for the current platform, if available.
 */
var platformPerformance = node_1.isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
var timestampSource = platformPerformance === undefined
    ? dateTimestampSource
    : {
        nowSeconds: function () { return (platformPerformance.timeOrigin + platformPerformance.now()) / 1000; },
    };
/**
 * Returns a timestamp in seconds since the UNIX epoch using the Date API.
 */
exports.dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
/**
 * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the
 * availability of the Performance API.
 *
 * See `usingPerformanceAPI` to test whether the Performance API is used.
 *
 * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is
 * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The
 * skew can grow to arbitrary amounts like days, weeks or months.
 * See https://github.com/getsentry/sentry-javascript/issues/2590.
 */
exports.timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
// Re-exported with an old name for backwards-compatibility.
exports.timestampWithMs = exports.timestampInSeconds;
/**
 * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.
 */
exports.usingPerformanceAPI = platformPerformance !== undefined;
/**
 * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the
 * performance API is available.
 */
exports.browserPerformanceTimeOrigin = (function () {
    // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or
    // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin
    // data as reliable if they are within a reasonable threshold of the current time.
    var performance = global_1.getGlobalObject().performance;
    if (!performance || !performance.now) {
        exports._browserPerformanceTimeOriginMode = 'none';
        return undefined;
    }
    var threshold = 3600 * 1000;
    var performanceNow = performance.now();
    var dateNow = Date.now();
    // if timeOrigin isn't available set delta to threshold so it isn't used
    var timeOriginDelta = performance.timeOrigin
        ? Math.abs(performance.timeOrigin + performanceNow - dateNow)
        : threshold;
    var timeOriginIsReliable = timeOriginDelta < threshold;
    // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin
    // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.
    // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always
    // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the
    // Date API.
    // eslint-disable-next-line deprecation/deprecation
    var navigationStart = performance.timing && performance.timing.navigationStart;
    var hasNavigationStart = typeof navigationStart === 'number';
    // if navigationStart isn't available set delta to threshold so it isn't used
    var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
    var navigationStartIsReliable = navigationStartDelta < threshold;
    if (timeOriginIsReliable || navigationStartIsReliable) {
        // Use the more reliable time origin
        if (timeOriginDelta <= navigationStartDelta) {
            exports._browserPerformanceTimeOriginMode = 'timeOrigin';
            return performance.timeOrigin;
        }
        else {
            exports._browserPerformanceTimeOriginMode = 'navigationStart';
            return navigationStart;
        }
    }
    // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.
    exports._browserPerformanceTimeOriginMode = 'dateNow';
    return dateNow;
})();
//# sourceMappingURL=time.js.map

/***/ }),

/***/ 6850:
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TRACEPARENT_REGEXP = new RegExp('^[ \\t]*' + // whitespace
    '([0-9a-f]{32})?' + // trace_id
    '-?([0-9a-f]{16})?' + // span_id
    '-?([01])?' + // sampled
    '[ \\t]*$');
/**
 * Extract transaction context data from a `sentry-trace` header.
 *
 * @param traceparent Traceparent string
 *
 * @returns Object containing data from the header, or undefined if traceparent string is malformed
 */
function extractTraceparentData(traceparent) {
    var matches = traceparent.match(exports.TRACEPARENT_REGEXP);
    if (matches) {
        var parentSampled = void 0;
        if (matches[3] === '1') {
            parentSampled = true;
        }
        else if (matches[3] === '0') {
            parentSampled = false;
        }
        return {
            traceId: matches[1],
            parentSampled: parentSampled,
            parentSpanId: matches[2],
        };
    }
    return undefined;
}
exports.extractTraceparentData = extractTraceparentData;
//# sourceMappingURL=tracing.js.map

/***/ }),

/***/ 610:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const stringify = __nccwpck_require__(8750);
const compile = __nccwpck_require__(9434);
const expand = __nccwpck_require__(5873);
const parse = __nccwpck_require__(6477);

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

const braces = (input, options = {}) => {
  let output = [];

  if (Array.isArray(input)) {
    for (let pattern of input) {
      let result = braces.create(pattern, options);
      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat(braces.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */

braces.parse = (input, options = {}) => parse(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.stringify = (input, options = {}) => {
  if (typeof input === 'string') {
    return stringify(braces.parse(input, options), options);
  }
  return stringify(input, options);
};

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.compile = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }
  return compile(input, options);
};

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.expand = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  }

  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  }

  return result;
};

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.create = (input, options = {}) => {
  if (input === '' || input.length < 3) {
    return [input];
  }

 return options.expand !== true
    ? braces.compile(input, options)
    : braces.expand(input, options);
};

/**
 * Expose "braces"
 */

module.exports = braces;


/***/ }),

/***/ 9434:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const fill = __nccwpck_require__(6330);
const utils = __nccwpck_require__(5207);

const compile = (ast, options = {}) => {
  let walk = (node, parent = {}) => {
    let invalidBlock = utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let invalid = invalidBlock === true || invalidNode === true;
    let prefix = options.escapeInvalid === true ? '\\' : '';
    let output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }
    if (node.isClose === true) {
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? (prefix + node.value) : '(';
    }

    if (node.type === 'close') {
      return invalid ? (prefix + node.value) : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);
      let range = fill(...args, { ...options, wrap: false, toRegex: true });

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? `(${range})` : range;
      }
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += walk(child, node);
      }
    }
    return output;
  };

  return walk(ast);
};

module.exports = compile;


/***/ }),

/***/ 8774:
/***/ ((module) => {

"use strict";


module.exports = {
  MAX_LENGTH: 1024 * 64,

  // Digits
  CHAR_0: '0', /* 0 */
  CHAR_9: '9', /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A', /* A */
  CHAR_LOWERCASE_A: 'a', /* a */
  CHAR_UPPERCASE_Z: 'Z', /* Z */
  CHAR_LOWERCASE_Z: 'z', /* z */

  CHAR_LEFT_PARENTHESES: '(', /* ( */
  CHAR_RIGHT_PARENTHESES: ')', /* ) */

  CHAR_ASTERISK: '*', /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&', /* & */
  CHAR_AT: '@', /* @ */
  CHAR_BACKSLASH: '\\', /* \ */
  CHAR_BACKTICK: '`', /* ` */
  CHAR_CARRIAGE_RETURN: '\r', /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */
  CHAR_COLON: ':', /* : */
  CHAR_COMMA: ',', /* , */
  CHAR_DOLLAR: '$', /* . */
  CHAR_DOT: '.', /* . */
  CHAR_DOUBLE_QUOTE: '"', /* " */
  CHAR_EQUAL: '=', /* = */
  CHAR_EXCLAMATION_MARK: '!', /* ! */
  CHAR_FORM_FEED: '\f', /* \f */
  CHAR_FORWARD_SLASH: '/', /* / */
  CHAR_HASH: '#', /* # */
  CHAR_HYPHEN_MINUS: '-', /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */
  CHAR_LEFT_CURLY_BRACE: '{', /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */
  CHAR_LINE_FEED: '\n', /* \n */
  CHAR_NO_BREAK_SPACE: '\u00A0', /* \u00A0 */
  CHAR_PERCENT: '%', /* % */
  CHAR_PLUS: '+', /* + */
  CHAR_QUESTION_MARK: '?', /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */
  CHAR_RIGHT_CURLY_BRACE: '}', /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */
  CHAR_SEMICOLON: ';', /* ; */
  CHAR_SINGLE_QUOTE: '\'', /* ' */
  CHAR_SPACE: ' ', /*   */
  CHAR_TAB: '\t', /* \t */
  CHAR_UNDERSCORE: '_', /* _ */
  CHAR_VERTICAL_LINE: '|', /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */
};


/***/ }),

/***/ 5873:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const fill = __nccwpck_require__(6330);
const stringify = __nccwpck_require__(8750);
const utils = __nccwpck_require__(5207);

const append = (queue = '', stash = '', enclose = false) => {
  let result = [];

  queue = [].concat(queue);
  stash = [].concat(stash);

  if (!stash.length) return queue;
  if (!queue.length) {
    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;
  }

  for (let item of queue) {
    if (Array.isArray(item)) {
      for (let value of item) {
        result.push(append(value, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));
      }
    }
  }
  return utils.flatten(result);
};

const expand = (ast, options = {}) => {
  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  let walk = (node, parent = {}) => {
    node.queue = [];

    let p = parent;
    let q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);

      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      let range = fill(...args, options);
      if (range.length === 0) {
        range = stringify(node, options);
      }

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
    }

    let enclose = utils.encloseBrace(node);
    let queue = node.queue;
    let block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push(append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push(append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return utils.flatten(walk(ast));
};

module.exports = expand;


/***/ }),

/***/ 6477:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const stringify = __nccwpck_require__(8750);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  CHAR_BACKSLASH, /* \ */
  CHAR_BACKTICK, /* ` */
  CHAR_COMMA, /* , */
  CHAR_DOT, /* . */
  CHAR_LEFT_PARENTHESES, /* ( */
  CHAR_RIGHT_PARENTHESES, /* ) */
  CHAR_LEFT_CURLY_BRACE, /* { */
  CHAR_RIGHT_CURLY_BRACE, /* } */
  CHAR_LEFT_SQUARE_BRACKET, /* [ */
  CHAR_RIGHT_SQUARE_BRACKET, /* ] */
  CHAR_DOUBLE_QUOTE, /* " */
  CHAR_SINGLE_QUOTE, /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = __nccwpck_require__(8774);

/**
 * parse
 */

const parse = (input, options = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  let opts = options || {};
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }

  let ast = { type: 'root', input, nodes: [] };
  let stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index = 0;
  let depth = 0;
  let value;
  let memo = {};

  /**
   * Helpers
   */

  const advance = () => input[index++];
  const push = node => {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({ type: 'bos' });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();

    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
      continue;
    }

    /**
     * Escaped chars
     */

    if (value === CHAR_BACKSLASH) {
      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });
      continue;
    }

    /**
     * Right square bracket (literal): ']'
     */

    if (value === CHAR_RIGHT_SQUARE_BRACKET) {
      push({ type: 'text', value: '\\' + value });
      continue;
    }

    /**
     * Left square bracket: '['
     */

    if (value === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;

      let closed = true;
      let next;

      while (index < length && (next = advance())) {
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }

        if (next === CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Parentheses
     */

    if (value === CHAR_LEFT_PARENTHESES) {
      block = push({ type: 'paren', nodes: [] });
      stack.push(block);
      push({ type: 'text', value });
      continue;
    }

    if (value === CHAR_RIGHT_PARENTHESES) {
      if (block.type !== 'paren') {
        push({ type: 'text', value });
        continue;
      }
      block = stack.pop();
      push({ type: 'text', value });
      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Quotes: '|"|`
     */

    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
      let open = value;
      let next;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (next = advance())) {
        if (next === CHAR_BACKSLASH) {
          value += next + advance();
          continue;
        }

        if (next === open) {
          if (options.keepQuotes === true) value += next;
          break;
        }

        value += next;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Left curly brace: '{'
     */

    if (value === CHAR_LEFT_CURLY_BRACE) {
      depth++;

      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      let brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };

      block = push(brace);
      stack.push(block);
      push({ type: 'open', value });
      continue;
    }

    /**
     * Right curly brace: '}'
     */

    if (value === CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== 'brace') {
        push({ type: 'text', value });
        continue;
      }

      let type = 'close';
      block = stack.pop();
      block.close = true;

      push({ type, value });
      depth--;

      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Comma: ','
     */

    if (value === CHAR_COMMA && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        let open = block.nodes.shift();
        block.nodes = [open, { type: 'text', value: stringify(block) }];
      }

      push({ type: 'comma', value });
      block.commas++;
      continue;
    }

    /**
     * Dot: '.'
     */

    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
      let siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({ type: 'text', value });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();

        let before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({ type: 'dot', value });
      continue;
    }

    /**
     * Text
     */

    push({ type: 'text', value });
  }

  // Mark imbalanced braces and brackets as invalid
  do {
    block = stack.pop();

    if (block.type !== 'root') {
      block.nodes.forEach(node => {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      });

      // get the location of the block on parent.nodes (block's siblings)
      let parent = stack[stack.length - 1];
      let index = parent.nodes.indexOf(block);
      // replace the (invalid) block with it's nodes
      parent.nodes.splice(index, 1, ...block.nodes);
    }
  } while (stack.length > 0);

  push({ type: 'eos' });
  return ast;
};

module.exports = parse;


/***/ }),

/***/ 8750:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const utils = __nccwpck_require__(5207);

module.exports = (ast, options = {}) => {
  let stringify = (node, parent = {}) => {
    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
        return '\\' + node.value;
      }
      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += stringify(child);
      }
    }
    return output;
  };

  return stringify(ast);
};



/***/ }),

/***/ 5207:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.isInteger = num => {
  if (typeof num === 'number') {
    return Number.isInteger(num);
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isInteger(Number(num));
  }
  return false;
};

/**
 * Find a node of the given type
 */

exports.find = (node, type) => node.nodes.find(node => node.type === type);

/**
 * Find a node of the given type
 */

exports.exceedsLimit = (min, max, step = 1, limit) => {
  if (limit === false) return false;
  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
  return ((Number(max) - Number(min)) / Number(step)) >= limit;
};

/**
 * Escape the given node with '\\' before node.value
 */

exports.escapeNode = (block, n = 0, type) => {
  let node = block.nodes[n];
  if (!node) return;

  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
    if (node.escaped !== true) {
      node.value = '\\' + node.value;
      node.escaped = true;
    }
  }
};

/**
 * Returns true if the given brace node should be enclosed in literal braces
 */

exports.encloseBrace = node => {
  if (node.type !== 'brace') return false;
  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
    node.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a brace node is invalid.
 */

exports.isInvalidBrace = block => {
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;
  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
    block.invalid = true;
    return true;
  }
  if (block.open !== true || block.close !== true) {
    block.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a node is an open or close node
 */

exports.isOpenOrClose = node => {
  if (node.type === 'open' || node.type === 'close') {
    return true;
  }
  return node.open === true || node.close === true;
};

/**
 * Reduce an array of text nodes.
 */

exports.reduce = nodes => nodes.reduce((acc, node) => {
  if (node.type === 'text') acc.push(node.value);
  if (node.type === 'range') node.type = 'text';
  return acc;
}, []);

/**
 * Flatten an array
 */

exports.flatten = (...args) => {
  const result = [];
  const flat = arr => {
    for (let i = 0; i < arr.length; i++) {
      let ele = arr[i];
      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
    }
    return result;
  };
  flat(args);
  return result;
};


/***/ }),

/***/ 8222:
/***/ ((module, exports, __nccwpck_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __nccwpck_require__(6243)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 6243:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __nccwpck_require__(900);

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 8237:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __nccwpck_require__(8222);
} else {
	module.exports = __nccwpck_require__(5332);
}


/***/ }),

/***/ 5332:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

const tty = __nccwpck_require__(3867);
const util = __nccwpck_require__(1669);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __nccwpck_require__(9318);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __nccwpck_require__(6243)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.replace(/\s*\n\s*/g, ' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ 2738:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const path = __nccwpck_require__(5622);
const pathType = __nccwpck_require__(3433);

const getExtensions = extensions => extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0];

const getPath = (filepath, cwd) => {
	const pth = filepath[0] === '!' ? filepath.slice(1) : filepath;
	return path.isAbsolute(pth) ? pth : path.join(cwd, pth);
};

const addExtensions = (file, extensions) => {
	if (path.extname(file)) {
		return `**/${file}`;
	}

	return `**/${file}.${getExtensions(extensions)}`;
};

const getGlob = (directory, options) => {
	if (options.files && !Array.isArray(options.files)) {
		throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
	}

	if (options.extensions && !Array.isArray(options.extensions)) {
		throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
	}

	if (options.files && options.extensions) {
		return options.files.map(x => path.posix.join(directory, addExtensions(x, options.extensions)));
	}

	if (options.files) {
		return options.files.map(x => path.posix.join(directory, `**/${x}`));
	}

	if (options.extensions) {
		return [path.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
	}

	return [path.posix.join(directory, '**')];
};

module.exports = async (input, options) => {
	options = {
		cwd: process.cwd(),
		...options
	};

	if (typeof options.cwd !== 'string') {
		throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
	}

	const globs = await Promise.all([].concat(input).map(async x => {
		const isDirectory = await pathType.isDirectory(getPath(x, options.cwd));
		return isDirectory ? getGlob(x, options) : x;
	}));

	return [].concat.apply([], globs); // eslint-disable-line prefer-spread
};

module.exports.sync = (input, options) => {
	options = {
		cwd: process.cwd(),
		...options
	};

	if (typeof options.cwd !== 'string') {
		throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
	}

	const globs = [].concat(input).map(x => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);

	return [].concat.apply([], globs); // eslint-disable-line prefer-spread
};


/***/ }),

/***/ 1848:
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ 3664:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const taskManager = __nccwpck_require__(2708);
const patternManager = __nccwpck_require__(8306);
const async_1 = __nccwpck_require__(5679);
const stream_1 = __nccwpck_require__(4630);
const sync_1 = __nccwpck_require__(2405);
const settings_1 = __nccwpck_require__(952);
const utils = __nccwpck_require__(5444);
async function FastGlob(source, options) {
    assertPatternsInput(source);
    const works = getWorks(source, async_1.default, options);
    const result = await Promise.all(works);
    return utils.array.flatten(result);
}
// https://github.com/typescript-eslint/typescript-eslint/issues/60
// eslint-disable-next-line no-redeclare
(function (FastGlob) {
    function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
    }
    FastGlob.sync = sync;
    function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        /**
         * The stream returned by the provider cannot work with an asynchronous iterator.
         * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
         * This affects performance (+25%). I don't see best solution right now.
         */
        return utils.stream.merge(works);
    }
    FastGlob.stream = stream;
    function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = patternManager.transform([].concat(source));
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
    }
    FastGlob.generateTasks = generateTasks;
    function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
    }
    FastGlob.isDynamicPattern = isDynamicPattern;
    function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
    }
    FastGlob.escapePath = escapePath;
})(FastGlob || (FastGlob = {}));
function getWorks(source, _Provider, options) {
    const patterns = patternManager.transform([].concat(source));
    const settings = new settings_1.default(options);
    const tasks = taskManager.generate(patterns, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
}
function assertPatternsInput(input) {
    const source = [].concat(input);
    const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
    if (!isValidSource) {
        throw new TypeError('Patterns must be a string (non empty) or an array of strings');
    }
}
module.exports = FastGlob;


/***/ }),

/***/ 8306:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeDuplicateSlashes = exports.transform = void 0;
/**
 * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.
 * The latter is due to the presence of the device path at the beginning of the UNC path.
 * @todo rewrite to negative lookbehind with the next major release.
 */
const DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
function transform(patterns) {
    return patterns.map((pattern) => removeDuplicateSlashes(pattern));
}
exports.transform = transform;
/**
 * This package only works with forward slashes as a path separator.
 * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.
 */
function removeDuplicateSlashes(pattern) {
    return pattern.replace(DOUBLE_SLASH_RE, '/');
}
exports.removeDuplicateSlashes = removeDuplicateSlashes;


/***/ }),

/***/ 2708:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;
const utils = __nccwpck_require__(5444);
function generate(patterns, settings) {
    const positivePatterns = getPositivePatterns(patterns);
    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
    const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
    const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);
    return staticTasks.concat(dynamicTasks);
}
exports.generate = generate;
/**
 * Returns tasks grouped by basic pattern directories.
 *
 * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.
 * This is necessary because directory traversal starts at the base directory and goes deeper.
 */
function convertPatternsToTasks(positive, negative, dynamic) {
    const tasks = [];
    const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
    const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
    const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
    const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
    tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
    /*
     * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory
     * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.
     */
    if ('.' in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));
    }
    else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
    }
    return tasks;
}
exports.convertPatternsToTasks = convertPatternsToTasks;
function getPositivePatterns(patterns) {
    return utils.pattern.getPositivePatterns(patterns);
}
exports.getPositivePatterns = getPositivePatterns;
function getNegativePatternsAsPositive(patterns, ignore) {
    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
    const positive = negative.map(utils.pattern.convertToPositivePattern);
    return positive;
}
exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
function groupPatternsByBaseDirectory(patterns) {
    const group = {};
    return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
            collection[base].push(pattern);
        }
        else {
            collection[base] = [pattern];
        }
        return collection;
    }, group);
}
exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
function convertPatternGroupsToTasks(positive, negative, dynamic) {
    return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
    });
}
exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
function convertPatternGroupToTask(base, positive, negative, dynamic) {
    return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
    };
}
exports.convertPatternGroupToTask = convertPatternGroupToTask;


/***/ }),

/***/ 5679:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __nccwpck_require__(2083);
const provider_1 = __nccwpck_require__(257);
class ProviderAsync extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_1.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve, reject) => {
            const stream = this.api(root, task, options);
            stream.once('error', reject);
            stream.on('data', (entry) => entries.push(options.transform(entry)));
            stream.once('end', () => resolve(entries));
        });
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderAsync;


/***/ }),

/***/ 6983:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(5444);
const partial_1 = __nccwpck_require__(5295);
class DeepFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
    }
    getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
    }
    _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }
    _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
            return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
            return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
            return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }
    _isSkippedByDeep(basePath, entryPath) {
        /**
         * Avoid unnecessary depth calculations when it doesn't matter.
         */
        if (this._settings.deep === Infinity) {
            return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
    }
    _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split('/').length;
        if (basePath === '') {
            return entryPathDepth;
        }
        const basePathDepth = basePath.split('/').length;
        return entryPathDepth - basePathDepth;
    }
    _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }
    _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
    }
}
exports.default = DeepFilter;


/***/ }),

/***/ 1343:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(5444);
class EntryFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
    }
    getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
    }
    _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
            return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
            return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
            return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
        if (this._settings.unique && isMatched) {
            this._createIndexRecord(entry);
        }
        return isMatched;
    }
    _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
    }
    _createIndexRecord(entry) {
        this.index.set(entry.path, undefined);
    }
    _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
    }
    _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }
    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
            return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
    }
    /**
     * First, just trying to apply patterns to the path.
     * Second, trying to apply patterns to the path with final slash.
     */
    _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        return utils.pattern.matchAny(filepath, patternsRe) || utils.pattern.matchAny(filepath + '/', patternsRe);
    }
}
exports.default = EntryFilter;


/***/ }),

/***/ 6654:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(5444);
class ErrorFilter {
    constructor(_settings) {
        this._settings = _settings;
    }
    getFilter() {
        return (error) => this._isNonFatalError(error);
    }
    _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
    }
}
exports.default = ErrorFilter;


/***/ }),

/***/ 2576:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(5444);
class Matcher {
    constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
    }
    _fillStorage() {
        /**
         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).
         * So, before expand patterns with brace expansion into separated patterns.
         */
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
            const segments = this._getPatternSegments(pattern);
            const sections = this._splitSegmentsIntoSections(segments);
            this._storage.push({
                complete: sections.length <= 1,
                pattern,
                segments,
                sections
            });
        }
    }
    _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
            if (!dynamic) {
                return {
                    dynamic: false,
                    pattern: part
                };
            }
            return {
                dynamic: true,
                pattern: part,
                patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
            };
        });
    }
    _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
    }
}
exports.default = Matcher;


/***/ }),

/***/ 5295:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const matcher_1 = __nccwpck_require__(2576);
class PartialMatcher extends matcher_1.default {
    match(filepath) {
        const parts = filepath.split('/');
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
            const section = pattern.sections[0];
            /**
             * In this case, the pattern has a globstar and we must read all directories unconditionally,
             * but only if the level has reached the end of the first group.
             *
             * fixtures/{a,b}/**
             *  ^ true/false  ^ always true
            */
            if (!pattern.complete && levels > section.length) {
                return true;
            }
            const match = parts.every((part, index) => {
                const segment = pattern.segments[index];
                if (segment.dynamic && segment.patternRe.test(part)) {
                    return true;
                }
                if (!segment.dynamic && segment.pattern === part) {
                    return true;
                }
                return false;
            });
            if (match) {
                return true;
            }
        }
        return false;
    }
}
exports.default = PartialMatcher;


/***/ }),

/***/ 257:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __nccwpck_require__(5622);
const deep_1 = __nccwpck_require__(6983);
const entry_1 = __nccwpck_require__(1343);
const error_1 = __nccwpck_require__(6654);
const entry_2 = __nccwpck_require__(4029);
class Provider {
    constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
    }
    _getRootDirectory(task) {
        return path.resolve(this._settings.cwd, task.base);
    }
    _getReaderOptions(task) {
        const basePath = task.base === '.' ? '' : task.base;
        return {
            basePath,
            pathSegmentSeparator: '/',
            concurrency: this._settings.concurrency,
            deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
            entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
            errorFilter: this.errorFilter.getFilter(),
            followSymbolicLinks: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            stats: this._settings.stats,
            throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
            transform: this.entryTransformer.getTransformer()
        };
    }
    _getMicromatchOptions() {
        return {
            dot: this._settings.dot,
            matchBase: this._settings.baseNameMatch,
            nobrace: !this._settings.braceExpansion,
            nocase: !this._settings.caseSensitiveMatch,
            noext: !this._settings.extglob,
            noglobstar: !this._settings.globstar,
            posix: true,
            strictSlashes: false
        };
    }
}
exports.default = Provider;


/***/ }),

/***/ 4630:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __nccwpck_require__(2413);
const stream_2 = __nccwpck_require__(2083);
const provider_1 = __nccwpck_require__(257);
class ProviderStream extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => { } });
        source
            .once('error', (error) => destination.emit('error', error))
            .on('data', (entry) => destination.emit('data', options.transform(entry)))
            .once('end', () => destination.emit('end'));
        destination
            .once('close', () => source.destroy());
        return destination;
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderStream;


/***/ }),

/***/ 2405:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sync_1 = __nccwpck_require__(6234);
const provider_1 = __nccwpck_require__(257);
class ProviderSync extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderSync;


/***/ }),

/***/ 4029:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(5444);
class EntryTransformer {
    constructor(_settings) {
        this._settings = _settings;
    }
    getTransformer() {
        return (entry) => this._transform(entry);
    }
    _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
            filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
            filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
            filepath += '/';
        }
        if (!this._settings.objectMode) {
            return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
    }
}
exports.default = EntryTransformer;


/***/ }),

/***/ 5582:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __nccwpck_require__(5622);
const fsStat = __nccwpck_require__(109);
const utils = __nccwpck_require__(5444);
class Reader {
    constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
    }
    _getFullEntryPath(filepath) {
        return path.resolve(this._settings.cwd, filepath);
    }
    _makeEntry(stats, pattern) {
        const entry = {
            name: pattern,
            path: pattern,
            dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
            entry.stats = stats;
        }
        return entry;
    }
    _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
    }
}
exports.default = Reader;


/***/ }),

/***/ 2083:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __nccwpck_require__(2413);
const fsStat = __nccwpck_require__(109);
const fsWalk = __nccwpck_require__(6026);
const reader_1 = __nccwpck_require__(5582);
class ReaderStream extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
    }
    dynamic(root, options) {
        return this._walkStream(root, options);
    }
    static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
            return this._getEntry(filepaths[index], patterns[index], options)
                .then((entry) => {
                if (entry !== null && options.entryFilter(entry)) {
                    stream.push(entry);
                }
                if (index === filepaths.length - 1) {
                    stream.end();
                }
                done();
            })
                .catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
            stream.write(i);
        }
        return stream;
    }
    _getEntry(filepath, pattern, options) {
        return this._getStat(filepath)
            .then((stats) => this._makeEntry(stats, pattern))
            .catch((error) => {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        });
    }
    _getStat(filepath) {
        return new Promise((resolve, reject) => {
            this._stat(filepath, this._fsStatSettings, (error, stats) => {
                return error === null ? resolve(stats) : reject(error);
            });
        });
    }
}
exports.default = ReaderStream;


/***/ }),

/***/ 6234:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsStat = __nccwpck_require__(109);
const fsWalk = __nccwpck_require__(6026);
const reader_1 = __nccwpck_require__(5582);
class ReaderSync extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
    }
    dynamic(root, options) {
        return this._walkSync(root, options);
    }
    static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
            const filepath = this._getFullEntryPath(pattern);
            const entry = this._getEntry(filepath, pattern, options);
            if (entry === null || !options.entryFilter(entry)) {
                continue;
            }
            entries.push(entry);
        }
        return entries;
    }
    _getEntry(filepath, pattern, options) {
        try {
            const stats = this._getStat(filepath);
            return this._makeEntry(stats, pattern);
        }
        catch (error) {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        }
    }
    _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
    }
}
exports.default = ReaderSync;


/***/ }),

/***/ 952:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
const fs = __nccwpck_require__(5747);
const os = __nccwpck_require__(2087);
/**
 * The `os.cpus` method can return zero. We expect the number of cores to be greater than zero.
 * https://github.com/nodejs/node/blob/7faeddf23a98c53896f8b574a6e66589e8fb1eb8/lib/os.js#L106-L107
 */
const CPU_COUNT = Math.max(os.cpus().length, 1);
exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    lstatSync: fs.lstatSync,
    stat: fs.stat,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
            this.onlyFiles = false;
        }
        if (this.stats) {
            this.objectMode = true;
        }
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
    _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
}
exports.default = Settings;


/***/ }),

/***/ 5325:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.splitWhen = exports.flatten = void 0;
function flatten(items) {
    return items.reduce((collection, item) => [].concat(collection, item), []);
}
exports.flatten = flatten;
function splitWhen(items, predicate) {
    const result = [[]];
    let groupIndex = 0;
    for (const item of items) {
        if (predicate(item)) {
            groupIndex++;
            result[groupIndex] = [];
        }
        else {
            result[groupIndex].push(item);
        }
    }
    return result;
}
exports.splitWhen = splitWhen;


/***/ }),

/***/ 1230:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isEnoentCodeError = void 0;
function isEnoentCodeError(error) {
    return error.code === 'ENOENT';
}
exports.isEnoentCodeError = isEnoentCodeError;


/***/ }),

/***/ 7543:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDirentFromStats = void 0;
class DirentFromStats {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
exports.createDirentFromStats = createDirentFromStats;


/***/ }),

/***/ 5444:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;
const array = __nccwpck_require__(5325);
exports.array = array;
const errno = __nccwpck_require__(1230);
exports.errno = errno;
const fs = __nccwpck_require__(7543);
exports.fs = fs;
const path = __nccwpck_require__(3873);
exports.path = path;
const pattern = __nccwpck_require__(1221);
exports.pattern = pattern;
const stream = __nccwpck_require__(8382);
exports.stream = stream;
const string = __nccwpck_require__(2203);
exports.string = string;


/***/ }),

/***/ 3873:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeLeadingDotSegment = exports.escape = exports.makeAbsolute = exports.unixify = void 0;
const path = __nccwpck_require__(5622);
const LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\
const UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
/**
 * Designed to work only with simple paths: `dir\\file`.
 */
function unixify(filepath) {
    return filepath.replace(/\\/g, '/');
}
exports.unixify = unixify;
function makeAbsolute(cwd, filepath) {
    return path.resolve(cwd, filepath);
}
exports.makeAbsolute = makeAbsolute;
function escape(pattern) {
    return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
}
exports.escape = escape;
function removeLeadingDotSegment(entry) {
    // We do not use `startsWith` because this is 10x slower than current implementation for some cases.
    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
    if (entry.charAt(0) === '.') {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === '/' || secondCharactery === '\\') {
            return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
    }
    return entry;
}
exports.removeLeadingDotSegment = removeLeadingDotSegment;


/***/ }),

/***/ 1221:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
const path = __nccwpck_require__(5622);
const globParent = __nccwpck_require__(4655);
const micromatch = __nccwpck_require__(6228);
const GLOBSTAR = '**';
const ESCAPE_SYMBOL = '\\';
const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
const BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
function isStaticPattern(pattern, options = {}) {
    return !isDynamicPattern(pattern, options);
}
exports.isStaticPattern = isStaticPattern;
function isDynamicPattern(pattern, options = {}) {
    /**
     * A special case with an empty string is necessary for matching patterns that start with a forward slash.
     * An empty string cannot be a dynamic pattern.
     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.
     */
    if (pattern === '') {
        return false;
    }
    /**
     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
     * filepath directly (without read directory).
     */
    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
    }
    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
    }
    return false;
}
exports.isDynamicPattern = isDynamicPattern;
function hasBraceExpansion(pattern) {
    const openingBraceIndex = pattern.indexOf('{');
    if (openingBraceIndex === -1) {
        return false;
    }
    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);
    if (closingBraceIndex === -1) {
        return false;
    }
    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
}
function convertToPositivePattern(pattern) {
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
}
exports.convertToPositivePattern = convertToPositivePattern;
function convertToNegativePattern(pattern) {
    return '!' + pattern;
}
exports.convertToNegativePattern = convertToNegativePattern;
function isNegativePattern(pattern) {
    return pattern.startsWith('!') && pattern[1] !== '(';
}
exports.isNegativePattern = isNegativePattern;
function isPositivePattern(pattern) {
    return !isNegativePattern(pattern);
}
exports.isPositivePattern = isPositivePattern;
function getNegativePatterns(patterns) {
    return patterns.filter(isNegativePattern);
}
exports.getNegativePatterns = getNegativePatterns;
function getPositivePatterns(patterns) {
    return patterns.filter(isPositivePattern);
}
exports.getPositivePatterns = getPositivePatterns;
/**
 * Returns patterns that can be applied inside the current directory.
 *
 * @example
 * // ['./*', '*', 'a/*']
 * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
 */
function getPatternsInsideCurrentDirectory(patterns) {
    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
}
exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
/**
 * Returns patterns to be expanded relative to (outside) the current directory.
 *
 * @example
 * // ['../*', './../*']
 * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
 */
function getPatternsOutsideCurrentDirectory(patterns) {
    return patterns.filter(isPatternRelatedToParentDirectory);
}
exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
function isPatternRelatedToParentDirectory(pattern) {
    return pattern.startsWith('..') || pattern.startsWith('./..');
}
exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
function getBaseDirectory(pattern) {
    return globParent(pattern, { flipBackslashes: false });
}
exports.getBaseDirectory = getBaseDirectory;
function hasGlobStar(pattern) {
    return pattern.includes(GLOBSTAR);
}
exports.hasGlobStar = hasGlobStar;
function endsWithSlashGlobStar(pattern) {
    return pattern.endsWith('/' + GLOBSTAR);
}
exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
function isAffectDepthOfReadingPattern(pattern) {
    const basename = path.basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
}
exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
function expandPatternsWithBraceExpansion(patterns) {
    return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
    }, []);
}
exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
function expandBraceExpansion(pattern) {
    return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
    });
}
exports.expandBraceExpansion = expandBraceExpansion;
function getPatternParts(pattern, options) {
    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
    /**
     * The scan method returns an empty array in some cases.
     * See micromatch/picomatch#58 for more details.
     */
    if (parts.length === 0) {
        parts = [pattern];
    }
    /**
     * The scan method does not return an empty part for the pattern with a forward slash.
     * This is another part of micromatch/picomatch#58.
     */
    if (parts[0].startsWith('/')) {
        parts[0] = parts[0].slice(1);
        parts.unshift('');
    }
    return parts;
}
exports.getPatternParts = getPatternParts;
function makeRe(pattern, options) {
    return micromatch.makeRe(pattern, options);
}
exports.makeRe = makeRe;
function convertPatternsToRe(patterns, options) {
    return patterns.map((pattern) => makeRe(pattern, options));
}
exports.convertPatternsToRe = convertPatternsToRe;
function matchAny(entry, patternsRe) {
    return patternsRe.some((patternRe) => patternRe.test(entry));
}
exports.matchAny = matchAny;


/***/ }),

/***/ 8382:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.merge = void 0;
const merge2 = __nccwpck_require__(2578);
function merge(streams) {
    const mergedStream = merge2(streams);
    streams.forEach((stream) => {
        stream.once('error', (error) => mergedStream.emit('error', error));
    });
    mergedStream.once('close', () => propagateCloseEventToSources(streams));
    mergedStream.once('end', () => propagateCloseEventToSources(streams));
    return mergedStream;
}
exports.merge = merge;
function propagateCloseEventToSources(streams) {
    streams.forEach((stream) => stream.emit('close'));
}


/***/ }),

/***/ 2203:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isEmpty = exports.isString = void 0;
function isString(input) {
    return typeof input === 'string';
}
exports.isString = isString;
function isEmpty(input) {
    return input === '';
}
exports.isEmpty = isEmpty;


/***/ }),

/***/ 5152:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

//parse Empty Node as self closing node
const buildOptions = __nccwpck_require__(8280).buildOptions;

const defaultOptions = {
  attributeNamePrefix: '@_',
  attrNodeName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  cdataTagName: false,
  cdataPositionChar: '\\c',
  format: false,
  indentBy: '  ',
  supressEmptyNode: false,
  tagValueProcessor: function(a) {
    return a;
  },
  attrValueProcessor: function(a) {
    return a;
  },
};

const props = [
  'attributeNamePrefix',
  'attrNodeName',
  'textNodeName',
  'ignoreAttributes',
  'cdataTagName',
  'cdataPositionChar',
  'format',
  'indentBy',
  'supressEmptyNode',
  'tagValueProcessor',
  'attrValueProcessor',
  'rootNodeName', //when array as root
];

function Parser(options) {
  this.options = buildOptions(options, defaultOptions, props);
  if (this.options.ignoreAttributes || this.options.attrNodeName) {
    this.isAttribute = function(/*a*/) {
      return false;
    };
  } else {
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }
  if (this.options.cdataTagName) {
    this.isCDATA = isCDATA;
  } else {
    this.isCDATA = function(/*a*/) {
      return false;
    };
  }
  this.replaceCDATAstr = replaceCDATAstr;
  this.replaceCDATAarr = replaceCDATAarr;

  this.processTextOrObjNode = processTextOrObjNode

  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = '>\n';
    this.newLine = '\n';
  } else {
    this.indentate = function() {
      return '';
    };
    this.tagEndChar = '>';
    this.newLine = '';
  }

  if (this.options.supressEmptyNode) {
    this.buildTextNode = buildEmptyTextNode;
    this.buildObjNode = buildEmptyObjNode;
  } else {
    this.buildTextNode = buildTextValNode;
    this.buildObjNode = buildObjectNode;
  }

  this.buildTextValNode = buildTextValNode;
  this.buildObjectNode = buildObjectNode;
}

Parser.prototype.parse = function(jObj) {
  if(Array.isArray(jObj) && this.options.rootNodeName && this.options.rootNodeName.length > 1){
    jObj = {
      [this.options.rootNodeName] : jObj
    }
  }
  return this.j2x(jObj, 0).val;
};

Parser.prototype.j2x = function(jObj, level) {
  let attrStr = '';
  let val = '';
  for (let key in jObj) {
    if (typeof jObj[key] === 'undefined') {
      // supress undefined node
    } else if (jObj[key] === null) {
      val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    } else if (jObj[key] instanceof Date) {
      val += this.buildTextNode(jObj[key], key, '', level);
    } else if (typeof jObj[key] !== 'object') {
      //premitive type
      const attr = this.isAttribute(key);
      if (attr) {
        attrStr += ' ' + attr + '="' + this.options.attrValueProcessor('' + jObj[key]) + '"';
      } else if (this.isCDATA(key)) {
        if (jObj[this.options.textNodeName]) {
          val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);
        } else {
          val += this.replaceCDATAstr('', jObj[key]);
        }
      } else {
        //tag value
        if (key === this.options.textNodeName) {
          if (jObj[this.options.cdataTagName]) {
            //value will added while processing cdata
          } else {
            val += this.options.tagValueProcessor('' + jObj[key]);
          }
        } else {
          val += this.buildTextNode(jObj[key], key, '', level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      //repeated nodes
      if (this.isCDATA(key)) {
        val += this.indentate(level);
        if (jObj[this.options.textNodeName]) {
          val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);
        } else {
          val += this.replaceCDATAarr('', jObj[key]);
        }
      } else {
        //nested nodes
        const arrLen = jObj[key].length;
        for (let j = 0; j < arrLen; j++) {
          const item = jObj[key][j];
          if (typeof item === 'undefined') {
            // supress undefined node
          } else if (item === null) {
            val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
          } else if (typeof item === 'object') {
            val += this.processTextOrObjNode(item, key, level)
          } else {
            val += this.buildTextNode(item, key, '', level);
          }
        }
      }
    } else {
      //nested node
      if (this.options.attrNodeName && key === this.options.attrNodeName) {
        const Ks = Object.keys(jObj[key]);
        const L = Ks.length;
        for (let j = 0; j < L; j++) {
          attrStr += ' ' + Ks[j] + '="' + this.options.attrValueProcessor('' + jObj[key][Ks[j]]) + '"';
        }
      } else {
        val += this.processTextOrObjNode(jObj[key], key, level)
      }
    }
  }
  return {attrStr: attrStr, val: val};
};

function processTextOrObjNode (object, key, level) {
  const result = this.j2x(object, level + 1);
  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
    return this.buildTextNode(result.val, key, result.attrStr, level);
  } else {
    return this.buildObjNode(result.val, key, result.attrStr, level);
  }
}

function replaceCDATAstr(str, cdata) {
  str = this.options.tagValueProcessor('' + str);
  if (this.options.cdataPositionChar === '' || str === '') {
    return str + '<![CDATA[' + cdata + ']]' + this.tagEndChar;
  } else {
    return str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata + ']]' + this.tagEndChar);
  }
}

function replaceCDATAarr(str, cdata) {
  str = this.options.tagValueProcessor('' + str);
  if (this.options.cdataPositionChar === '' || str === '') {
    return str + '<![CDATA[' + cdata.join(']]><![CDATA[') + ']]' + this.tagEndChar;
  } else {
    for (let v in cdata) {
      str = str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata[v] + ']]>');
    }
    return str + this.newLine;
  }
}

function buildObjectNode(val, key, attrStr, level) {
  if (attrStr && val.indexOf('<') === -1) {
    return (
      this.indentate(level) +
      '<' +
      key +
      attrStr +
      '>' +
      val +
      //+ this.newLine
      // + this.indentate(level)
      '</' +
      key +
      this.tagEndChar
    );
  } else {
    return (
      this.indentate(level) +
      '<' +
      key +
      attrStr +
      this.tagEndChar +
      val +
      //+ this.newLine
      this.indentate(level) +
      '</' +
      key +
      this.tagEndChar
    );
  }
}

function buildEmptyObjNode(val, key, attrStr, level) {
  if (val !== '') {
    return this.buildObjectNode(val, key, attrStr, level);
  } else {
    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
    //+ this.newLine
  }
}

function buildTextValNode(val, key, attrStr, level) {
  return (
    this.indentate(level) +
    '<' +
    key +
    attrStr +
    '>' +
    this.options.tagValueProcessor(val) +
    '</' +
    key +
    this.tagEndChar
  );
}

function buildEmptyTextNode(val, key, attrStr, level) {
  if (val !== '') {
    return this.buildTextValNode(val, key, attrStr, level);
  } else {
    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
  }
}

function indentate(level) {
  return this.options.indentBy.repeat(level);
}

function isAttribute(name /*, options*/) {
  if (name.startsWith(this.options.attributeNamePrefix)) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}

function isCDATA(name) {
  return name === this.options.cdataTagName;
}

//formatting
//indentation
//\n after each closing or self closing tag

module.exports = Parser;


/***/ }),

/***/ 1901:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

const char = function(a) {
  return String.fromCharCode(a);
};

const chars = {
  nilChar: char(176),
  missingChar: char(201),
  nilPremitive: char(175),
  missingPremitive: char(200),

  emptyChar: char(178),
  emptyValue: char(177), //empty Premitive

  boundryChar: char(179),

  objStart: char(198),
  arrStart: char(204),
  arrayEnd: char(185),
};

const charsArr = [
  chars.nilChar,
  chars.nilPremitive,
  chars.missingChar,
  chars.missingPremitive,
  chars.boundryChar,
  chars.emptyChar,
  chars.emptyValue,
  chars.arrayEnd,
  chars.objStart,
  chars.arrStart,
];

const _e = function(node, e_schema, options) {
  if (typeof e_schema === 'string') {
    //premitive
    if (node && node[0] && node[0].val !== undefined) {
      return getValue(node[0].val, e_schema);
    } else {
      return getValue(node, e_schema);
    }
  } else {
    const hasValidData = hasData(node);
    if (hasValidData === true) {
      let str = '';
      if (Array.isArray(e_schema)) {
        //attributes can't be repeated. hence check in children tags only
        str += chars.arrStart;
        const itemSchema = e_schema[0];
        //const itemSchemaType = itemSchema;
        const arr_len = node.length;

        if (typeof itemSchema === 'string') {
          for (let arr_i = 0; arr_i < arr_len; arr_i++) {
            const r = getValue(node[arr_i].val, itemSchema);
            str = processValue(str, r);
          }
        } else {
          for (let arr_i = 0; arr_i < arr_len; arr_i++) {
            const r = _e(node[arr_i], itemSchema, options);
            str = processValue(str, r);
          }
        }
        str += chars.arrayEnd; //indicates that next item is not array item
      } else {
        //object
        str += chars.objStart;
        const keys = Object.keys(e_schema);
        if (Array.isArray(node)) {
          node = node[0];
        }
        for (let i in keys) {
          const key = keys[i];
          //a property defined in schema can be present either in attrsMap or children tags
          //options.textNodeName will not present in both maps, take it's value from val
          //options.attrNodeName will be present in attrsMap
          let r;
          if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {
            r = _e(node.attrsMap[key], e_schema[key], options);
          } else if (key === options.textNodeName) {
            r = _e(node.val, e_schema[key], options);
          } else {
            r = _e(node.child[key], e_schema[key], options);
          }
          str = processValue(str, r);
        }
      }
      return str;
    } else {
      return hasValidData;
    }
  }
};

const getValue = function(a /*, type*/) {
  switch (a) {
    case undefined:
      return chars.missingPremitive;
    case null:
      return chars.nilPremitive;
    case '':
      return chars.emptyValue;
    default:
      return a;
  }
};

const processValue = function(str, r) {
  if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {
    str += chars.boundryChar;
  }
  return str + r;
};

const isAppChar = function(ch) {
  return charsArr.indexOf(ch) !== -1;
};

function hasData(jObj) {
  if (jObj === undefined) {
    return chars.missingChar;
  } else if (jObj === null) {
    return chars.nilChar;
  } else if (
    jObj.child &&
    Object.keys(jObj.child).length === 0 &&
    (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)
  ) {
    return chars.emptyChar;
  } else {
    return true;
  }
}

const x2j = __nccwpck_require__(6712);
const buildOptions = __nccwpck_require__(8280).buildOptions;

const convert2nimn = function(node, e_schema, options) {
  options = buildOptions(options, x2j.defaultOptions, x2j.props);
  return _e(node, e_schema, options);
};

exports.convert2nimn = convert2nimn;


/***/ }),

/***/ 8270:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const util = __nccwpck_require__(8280);

const convertToJson = function(node, options, parentTagName) {
  const jObj = {};

  // when no child node or attr is present
  if (!options.alwaysCreateTextNode && (!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {
    return util.isExist(node.val) ? node.val : '';
  }

  // otherwise create a textnode if node has some text
  if (util.isExist(node.val) && !(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {
    const asArray = util.isTagNameInArrayMode(node.tagname, options.arrayMode, parentTagName)
    jObj[options.textNodeName] = asArray ? [node.val] : node.val;
  }

  util.merge(jObj, node.attrsMap, options.arrayMode);

  const keys = Object.keys(node.child);
  for (let index = 0; index < keys.length; index++) {
    const tagName = keys[index];
    if (node.child[tagName] && node.child[tagName].length > 1) {
      jObj[tagName] = [];
      for (let tag in node.child[tagName]) {
        if (node.child[tagName].hasOwnProperty(tag)) {
          jObj[tagName].push(convertToJson(node.child[tagName][tag], options, tagName));
        }
      }
    } else {
      const result = convertToJson(node.child[tagName][0], options, tagName);
      const asArray = (options.arrayMode === true && typeof result === 'object') || util.isTagNameInArrayMode(tagName, options.arrayMode, parentTagName);
      jObj[tagName] = asArray ? [result] : result;
    }
  }

  //add value
  return jObj;
};

exports.convertToJson = convertToJson;


/***/ }),

/***/ 6014:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const util = __nccwpck_require__(8280);
const buildOptions = __nccwpck_require__(8280).buildOptions;
const x2j = __nccwpck_require__(6712);

//TODO: do it later
const convertToJsonString = function(node, options) {
  options = buildOptions(options, x2j.defaultOptions, x2j.props);

  options.indentBy = options.indentBy || '';
  return _cToJsonStr(node, options, 0);
};

const _cToJsonStr = function(node, options, level) {
  let jObj = '{';

  //traver through all the children
  const keys = Object.keys(node.child);

  for (let index = 0; index < keys.length; index++) {
    const tagname = keys[index];
    if (node.child[tagname] && node.child[tagname].length > 1) {
      jObj += '"' + tagname + '" : [ ';
      for (let tag in node.child[tagname]) {
        jObj += _cToJsonStr(node.child[tagname][tag], options) + ' , ';
      }
      jObj = jObj.substr(0, jObj.length - 1) + ' ] '; //remove extra comma in last
    } else {
      jObj += '"' + tagname + '" : ' + _cToJsonStr(node.child[tagname][0], options) + ' ,';
    }
  }
  util.merge(jObj, node.attrsMap);
  //add attrsMap as new children
  if (util.isEmptyObject(jObj)) {
    return util.isExist(node.val) ? node.val : '';
  } else {
    if (util.isExist(node.val)) {
      if (!(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {
        jObj += '"' + options.textNodeName + '" : ' + stringval(node.val);
      }
    }
  }
  //add value
  if (jObj[jObj.length - 1] === ',') {
    jObj = jObj.substr(0, jObj.length - 2);
  }
  return jObj + '}';
};

function stringval(v) {
  if (v === true || v === false || !isNaN(v)) {
    return v;
  } else {
    return '"' + v + '"';
  }
}

function indentate(options, level) {
  return options.indentBy.repeat(level);
}

exports.convertToJsonString = convertToJsonString;


/***/ }),

/***/ 7448:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const nodeToJson = __nccwpck_require__(8270);
const xmlToNodeobj = __nccwpck_require__(6712);
const x2xmlnode = __nccwpck_require__(6712);
const buildOptions = __nccwpck_require__(8280).buildOptions;
const validator = __nccwpck_require__(1739);

exports.parse = function(xmlData, givenOptions = {}, validationOption) {
  if( validationOption){
    if(validationOption === true) validationOption = {}
    
    const result = validator.validate(xmlData, validationOption);
    if (result !== true) {
      throw Error( result.err.msg)
    }
  }
  if(givenOptions.parseTrueNumberOnly 
    && givenOptions.parseNodeValue !== false
    && !givenOptions.numParseOptions){
    
      givenOptions.numParseOptions = {
        leadingZeros: false,
      }
  }
  let options = buildOptions(givenOptions, x2xmlnode.defaultOptions, x2xmlnode.props);

  const traversableObj = xmlToNodeobj.getTraversalObj(xmlData, options)
  //print(traversableObj, "  ");
  return nodeToJson.convertToJson(traversableObj, options);
};
exports.convertTonimn = __nccwpck_require__(1901).convert2nimn;
exports.getTraversalObj = xmlToNodeobj.getTraversalObj;
exports.convertToJson = nodeToJson.convertToJson;
exports.convertToJsonString = __nccwpck_require__(6014).convertToJsonString;
exports.validate = validator.validate;
exports.j2xParser = __nccwpck_require__(5152);
exports.parseToNimn = function(xmlData, schema, options) {
  return exports.convertTonimn(exports.getTraversalObj(xmlData, options), schema, options);
};


function print(xmlNode, indentation){
  if(xmlNode){
    console.log(indentation + "{")
    console.log(indentation + "  \"tagName\": \"" + xmlNode.tagname + "\", ");
    if(xmlNode.parent){
      console.log(indentation + "  \"parent\": \"" + xmlNode.parent.tagname  + "\", ");
    }
    console.log(indentation + "  \"val\": \"" + xmlNode.val  + "\", ");
    console.log(indentation + "  \"attrs\": " + JSON.stringify(xmlNode.attrsMap,null,4)  + ", ");

    if(xmlNode.child){
      console.log(indentation + "\"child\": {")
      const indentation2 = indentation + indentation;
      Object.keys(xmlNode.child).forEach( function(key) {
        const node = xmlNode.child[key];

        if(Array.isArray(node)){
          console.log(indentation +  "\""+key+"\" :[")
          node.forEach( function(item,index) {
            //console.log(indentation + " \""+index+"\" : [")
            print(item, indentation2);
          })
          console.log(indentation + "],")  
        }else{
          console.log(indentation + " \""+key+"\" : {")
          print(node, indentation2);
          console.log(indentation + "},")  
        }
      });
      console.log(indentation + "},")
    }
    console.log(indentation + "},")
  }
}


/***/ }),

/***/ 8280:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'
const regexName = new RegExp('^' + nameRegexp + '$');

const getAllMatches = function(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  while (match) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) {
      allmatches.push(match[index]);
    }
    matches.push(allmatches);
    match = regex.exec(string);
  }
  return matches;
};

const isName = function(string) {
  const match = regexName.exec(string);
  return !(match === null || typeof match === 'undefined');
};

exports.isExist = function(v) {
  return typeof v !== 'undefined';
};

exports.isEmptyObject = function(obj) {
  return Object.keys(obj).length === 0;
};

/**
 * Copy all the properties of a into b.
 * @param {*} target
 * @param {*} a
 */
exports.merge = function(target, a, arrayMode) {
  if (a) {
    const keys = Object.keys(a); // will return an array of own properties
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      if (arrayMode === 'strict') {
        target[keys[i]] = [ a[keys[i]] ];
      } else {
        target[keys[i]] = a[keys[i]];
      }
    }
  }
};
/* exports.merge =function (b,a){
  return Object.assign(b,a);
} */

exports.getValue = function(v) {
  if (exports.isExist(v)) {
    return v;
  } else {
    return '';
  }
};

// const fakeCall = function(a) {return a;};
// const fakeCallNoReturn = function() {};

exports.buildOptions = function(options, defaultOptions, props) {
  let newOptions = {};
  if (!options) {
    return defaultOptions; //if there are not options
  }

  for (let i = 0; i < props.length; i++) {
    if (options[props[i]] !== undefined) {
      newOptions[props[i]] = options[props[i]];
    } else {
      newOptions[props[i]] = defaultOptions[props[i]];
    }
  }
  return newOptions;
};

/**
 * Check if a tag name should be treated as array
 *
 * @param tagName the node tagname
 * @param arrayMode the array mode option
 * @param parentTagName the parent tag name
 * @returns {boolean} true if node should be parsed as array
 */
exports.isTagNameInArrayMode = function (tagName, arrayMode, parentTagName) {
  if (arrayMode === false) {
    return false;
  } else if (arrayMode instanceof RegExp) {
    return arrayMode.test(tagName);
  } else if (typeof arrayMode === 'function') {
    return !!arrayMode(tagName, parentTagName);
  }

  return arrayMode === "strict";
}

exports.isName = isName;
exports.getAllMatches = getAllMatches;
exports.nameRegexp = nameRegexp;


/***/ }),

/***/ 1739:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const util = __nccwpck_require__(8280);

const defaultOptions = {
  allowBooleanAttributes: false, //A tag can have attributes without any value
};

const props = ['allowBooleanAttributes'];

//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
exports.validate = function (xmlData, options) {
  options = util.buildOptions(options, defaultOptions, props);

  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
  const tags = [];
  let tagFound = false;

  //indicates that the root tag has been closed (aka. depth 0 has been reached)
  let reachedRoot = false;

  if (xmlData[0] === '\ufeff') {
    // check for byte order mark (BOM)
    xmlData = xmlData.substr(1);
  }

  for (let i = 0; i < xmlData.length; i++) {

    if (xmlData[i] === '<' && xmlData[i+1] === '?') {
      i+=2;
      i = readPI(xmlData,i);
      if (i.err) return i;
    }else if (xmlData[i] === '<') {
      //starting of tag
      //read until you reach to '>' avoiding any '>' in attribute value
      let tagStartPos = i;
      i++;
      
      if (xmlData[i] === '!') {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === '/') {
          //closing tag
          closingTag = true;
          i++;
        }
        //read tagname
        let tagName = '';
        for (; i < xmlData.length &&
          xmlData[i] !== '>' &&
          xmlData[i] !== ' ' &&
          xmlData[i] !== '\t' &&
          xmlData[i] !== '\n' &&
          xmlData[i] !== '\r'; i++
        ) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        //console.log(tagName);

        if (tagName[tagName.length - 1] === '/') {
          //self closing tag without attributes
          tagName = tagName.substring(0, tagName.length - 1);
          //continue;
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '"+tagName+"' is an invalid name.";
          }
          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
        }

        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject('InvalidAttr', "Attributes for '"+tagName+"' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;

        if (attrStr[attrStr.length - 1] === '/') {
          //self closing tag
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
            //continue; //text may presents after self closing tag
          } else {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject('InvalidTag',
                "Expected closing tag '"+otg.tagName+"' (opened in line "+openPos.line+", col "+openPos.col+") instead of closing tag '"+tagName+"'.",
                getLineNumberForPosition(xmlData, tagStartPos));
            }

            //when there are no more tags, we reached the root level.
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }

          //if the root level has been reached before ...
          if (reachedRoot === true) {
            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
          } else {
            tags.push({tagName, tagStartPos});
          }
          tagFound = true;
        }

        //skip tag text value
        //It may include comments and CDATA value
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === '<') {
            if (xmlData[i + 1] === '!') {
              //comment or CADATA
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i+1] === '?') {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else{
              break;
            }
          } else if (xmlData[i] === '&') {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          }
        } //end of reading tag text value
        if (xmlData[i] === '<') {
          i--;
        }
      }
    } else {
      if (xmlData[i] === ' ' || xmlData[i] === '\t' || xmlData[i] === '\n' || xmlData[i] === '\r') {
        continue;
      }
      return getErrorObject('InvalidChar', "char '"+xmlData[i]+"' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }

  if (!tagFound) {
    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
  }else if (tags.length == 1) {
      return getErrorObject('InvalidTag', "Unclosed tag '"+tags[0].tagName+"'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  }else if (tags.length > 0) {
      return getErrorObject('InvalidXml', "Invalid '"+
          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\r?\n/g, '')+
          "' found.", {line: 1, col: 1});
  }

  return true;
};

/**
 * Read Processing insstructions and skip
 * @param {*} xmlData
 * @param {*} i
 */
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == '?' || xmlData[i] == ' ') {
      //tagname
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === 'xml') {
        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
        //check if valid attribut string
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}

function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
    //comment
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  } else if (
    xmlData.length > i + 8 &&
    xmlData[i + 1] === 'D' &&
    xmlData[i + 2] === 'O' &&
    xmlData[i + 3] === 'C' &&
    xmlData[i + 4] === 'T' &&
    xmlData[i + 5] === 'Y' &&
    xmlData[i + 6] === 'P' &&
    xmlData[i + 7] === 'E'
  ) {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === '<') {
        angleBracketsCount++;
      } else if (xmlData[i] === '>') {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (
    xmlData.length > i + 9 &&
    xmlData[i + 1] === '[' &&
    xmlData[i + 2] === 'C' &&
    xmlData[i + 3] === 'D' &&
    xmlData[i + 4] === 'A' &&
    xmlData[i + 5] === 'T' &&
    xmlData[i + 6] === 'A' &&
    xmlData[i + 7] === '['
  ) {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  }

  return i;
}

const doubleQuote = '"';
const singleQuote = "'";

/**
 * Keep reading xmlData until '<' is found outside the attribute value.
 * @param {string} xmlData
 * @param {number} i
 */
function readAttributeStr(xmlData, i) {
  let attrStr = '';
  let startChar = '';
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === '') {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) {
        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
      } else {
        startChar = '';
      }
    } else if (xmlData[i] === '>') {
      if (startChar === '') {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== '') {
    return false;
  }

  return {
    value: attrStr,
    index: i,
    tagClosed: tagClosed
  };
}

/**
 * Select all the attributes whether valid or invalid.
 */
const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

function validateAttributeString(attrStr, options) {
  //console.log("start:"+attrStr+":end");

  //if(attrStr.trim().length === 0) return true; //empty string

  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};

  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      //nospace before attribute name: a="sd"b="saf"
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' has no space in starting.", getPositionFromMatch(matches[i]))
    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
      //independent attribute: ab
      return getErrorObject('InvalidAttr', "boolean attribute '"+matches[i][2]+"' is not allowed.", getPositionFromMatch(matches[i]));
    }
    /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      //check for duplicate attribute.
      attrNames[attrName] = 1;
    } else {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is repeated.", getPositionFromMatch(matches[i]));
    }
  }

  return true;
}

function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === 'x') {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ';')
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}

function validateAmpersand(xmlData, i) {
  // https://www.w3.org/TR/xml/#dt-charref
  i++;
  if (xmlData[i] === ';')
    return -1;
  if (xmlData[i] === '#') {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ';')
      break;
    return -1;
  }
  return i;
}

function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code: code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col,
    },
  };
}

function validateAttrName(attrName) {
  return util.isName(attrName);
}

// const startsWithXML = /^xml/i;

function validateTagName(tagname) {
  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
}

//this function returns the line number for the character at the given index
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,

    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}

//this function returns the position of the first character of match within attrStr
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}


/***/ }),

/***/ 9539:
/***/ ((module) => {

"use strict";


module.exports = function(tagname, parent, val) {
  this.tagname = tagname;
  this.parent = parent;
  this.child = {}; //child tags
  this.attrsMap = {}; //attributes map
  this.val = val; //text only
  this.addChild = function(child) {
    if (Array.isArray(this.child[child.tagname])) {
      //already presents
      this.child[child.tagname].push(child);
    } else {
      this.child[child.tagname] = [child];
    }
  };
};


/***/ }),

/***/ 6712:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const util = __nccwpck_require__(8280);
const buildOptions = __nccwpck_require__(8280).buildOptions;
const xmlNode = __nccwpck_require__(9539);
const toNumber = __nccwpck_require__(4526);

const regx =
  '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
  .replace(/NAME/g, util.nameRegexp);

//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

//polyfill
if (!Number.parseInt && window.parseInt) {
  Number.parseInt = window.parseInt;
}
if (!Number.parseFloat && window.parseFloat) {
  Number.parseFloat = window.parseFloat;
}

const defaultOptions = {
  attributeNamePrefix: '@_',
  attrNodeName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  ignoreNameSpace: false,
  allowBooleanAttributes: false, //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseNodeValue: true,
  parseAttributeValue: false,
  arrayMode: false,
  trimValues: true, //Trim string values of tag and attributes
  cdataTagName: false,
  cdataPositionChar: '\\c',
  numParseOptions: {
    hex: true,
    leadingZeros: true
  },
  tagValueProcessor: function(a, tagName) {
    return a;
  },
  attrValueProcessor: function(a, attrName) {
    return a;
  },
  stopNodes: [],
  alwaysCreateTextNode: false
  //decodeStrict: false,
};

exports.defaultOptions = defaultOptions;

const props = [
  'attributeNamePrefix',
  'attrNodeName',
  'textNodeName',
  'ignoreAttributes',
  'ignoreNameSpace',
  'allowBooleanAttributes',
  'parseNodeValue',
  'parseAttributeValue',
  'arrayMode',
  'trimValues',
  'cdataTagName',
  'cdataPositionChar',
  'tagValueProcessor',
  'attrValueProcessor',
  'parseTrueNumberOnly',
  'numParseOptions',
  'stopNodes',
  'alwaysCreateTextNode'
];
exports.props = props;

/**
 * Trim -> valueProcessor -> parse value
 * @param {string} tagName
 * @param {string} val
 * @param {object} options
 */
function processTagValue(tagName, val, options) {
  if (val) {
    if (options.trimValues) {
      val = val.trim();
    }
    val = options.tagValueProcessor(val, tagName);
    val = parseValue(val, options.parseNodeValue, options.numParseOptions);
  }

  return val;
}

function resolveNameSpace(tagname, options) {
  if (options.ignoreNameSpace) {
    const tags = tagname.split(':');
    const prefix = tagname.charAt(0) === '/' ? '/' : '';
    if (tags[0] === 'xmlns') {
      return '';
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}

function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === 'string') {
    //console.log(options)
    const newval = val.trim();
    if(newval === 'true' ) return true;
    else if(newval === 'false' ) return false;
    else return toNumber(val, options);
  } else {
    if (util.isExist(val)) {
      return val;
    } else {
      return '';
    }
  }
}

//TODO: change regex to capture NS
//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])(.*?)\\3)?', 'g');

function buildAttributesMap(attrStr, options) {
  if (!options.ignoreAttributes && typeof attrStr === 'string') {
    attrStr = attrStr.replace(/\r?\n/g, ' ');
    //attrStr = attrStr || attrStr.trim();

    const matches = util.getAllMatches(attrStr, attrsRegx);
    const len = matches.length; //don't make it inline
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = resolveNameSpace(matches[i][1], options);
      if (attrName.length) {
        if (matches[i][4] !== undefined) {
          if (options.trimValues) {
            matches[i][4] = matches[i][4].trim();
          }
          matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);
          attrs[options.attributeNamePrefix + attrName] = parseValue(
            matches[i][4],
            options.parseAttributeValue,
            options.numParseOptions
          );
        } else if (options.allowBooleanAttributes) {
          attrs[options.attributeNamePrefix + attrName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (options.attrNodeName) {
      const attrCollection = {};
      attrCollection[options.attrNodeName] = attrs;
      return attrCollection;
    }
    return attrs;
  }
}

const getTraversalObj = function(xmlData, options) {
  xmlData = xmlData.replace(/\r\n?/g, "\n");
  options = buildOptions(options, defaultOptions, props);
  const xmlObj = new xmlNode('!xml');
  let currentNode = xmlObj;
  let textData = "";

//function match(xmlData){
  for(let i=0; i< xmlData.length; i++){
    const ch = xmlData[i];
    if(ch === '<'){
      if( xmlData[i+1] === '/') {//Closing Tag
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.")
        let tagName = xmlData.substring(i+2,closeIndex).trim();

        if(options.ignoreNameSpace){
          const colonIndex = tagName.indexOf(":");
          if(colonIndex !== -1){
            tagName = tagName.substr(colonIndex+1);
          }
        }

        /* if (currentNode.parent) {
          currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue2(tagName, textData , options);
        } */
        if(currentNode){
          if(currentNode.val){
            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tagName, textData , options);
          }else{
            currentNode.val = processTagValue(tagName, textData , options);
          }
        }

        if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {
          currentNode.child = []
          if (currentNode.attrsMap == undefined) { currentNode.attrsMap = {}}
          currentNode.val = xmlData.substr(currentNode.startIndex + 1, i - currentNode.startIndex - 1)
        }
        currentNode = currentNode.parent;
        textData = "";
        i = closeIndex;
      } else if( xmlData[i+1] === '?') {
        i = findClosingIndex(xmlData, "?>", i, "Pi Tag is not closed.")
      } else if(xmlData.substr(i + 1, 3) === '!--') {
        i = findClosingIndex(xmlData, "-->", i, "Comment is not closed.")
      } else if( xmlData.substr(i + 1, 2) === '!D') {
        const closeIndex = findClosingIndex(xmlData, ">", i, "DOCTYPE is not closed.")
        const tagExp = xmlData.substring(i, closeIndex);
        if(tagExp.indexOf("[") >= 0){
          i = xmlData.indexOf("]>", i) + 1;
        }else{
          i = closeIndex;
        }
      }else if(xmlData.substr(i + 1, 2) === '![') {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2
        const tagExp = xmlData.substring(i + 9,closeIndex);

        //considerations
        //1. CDATA will always have parent node
        //2. A tag with CDATA is not a leaf node so it's value would be string type.
        if(textData){
          currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData , options);
          textData = "";
        }

        if (options.cdataTagName) {
          //add cdata node
          const childNode = new xmlNode(options.cdataTagName, currentNode, tagExp);
          currentNode.addChild(childNode);
          //for backtracking
          currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;
          //add rest value to parent node
          if (tagExp) {
            childNode.val = tagExp;
          }
        } else {
          currentNode.val = (currentNode.val || '') + (tagExp || '');
        }

        i = closeIndex + 2;
      }else {//Opening tag
        const result = closingIndexForOpeningTag(xmlData, i+1)
        let tagExp = result.data;
        const closeIndex = result.index;
        const separatorIndex = tagExp.indexOf(" ");
        let tagName = tagExp;
        let shouldBuildAttributesMap = true;
        if(separatorIndex !== -1){
          tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, '');
          tagExp = tagExp.substr(separatorIndex + 1);
        }

        if(options.ignoreNameSpace){
          const colonIndex = tagName.indexOf(":");
          if(colonIndex !== -1){
            tagName = tagName.substr(colonIndex+1);
            shouldBuildAttributesMap = tagName !== result.data.substr(colonIndex + 1);
          }
        }

        //save text to parent node
        if (currentNode && textData) {
          if(currentNode.tagname !== '!xml'){
            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue( currentNode.tagname, textData, options);
          }
        }

        if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){//selfClosing tag

          if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
            tagName = tagName.substr(0, tagName.length - 1);
            tagExp = tagName;
          }else{
            tagExp = tagExp.substr(0, tagExp.length - 1);
          }

          const childNode = new xmlNode(tagName, currentNode, '');
          if(tagName !== tagExp){
            childNode.attrsMap = buildAttributesMap(tagExp, options);
          }
          currentNode.addChild(childNode);
        }else{//opening tag

          const childNode = new xmlNode( tagName, currentNode );
          if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {
            childNode.startIndex=closeIndex;
          }
          if(tagName !== tagExp && shouldBuildAttributesMap){
            childNode.attrsMap = buildAttributesMap(tagExp, options);
          }
          currentNode.addChild(childNode);
          currentNode = childNode;
        }
        textData = "";
        i = closeIndex;
      }
    }else{
      textData += xmlData[i];
    }
  }
  return xmlObj;
}

function closingIndexForOpeningTag(data, i){
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < data.length; index++) {
    let ch = data[index];
    if (attrBoundary) {
        if (ch === attrBoundary) attrBoundary = "";//reset
    } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
    } else if (ch === '>') {
        return {
          data: tagExp,
          index: index
        }
    } else if (ch === '\t') {
      ch = " "
    }
    tagExp += ch;
  }
}

function findClosingIndex(xmlData, str, i, errMsg){
  const closingIndex = xmlData.indexOf(str, i);
  if(closingIndex === -1){
    throw new Error(errMsg)
  }else{
    return closingIndex + str.length - 1;
  }
}

exports.getTraversalObj = getTraversalObj;


/***/ }),

/***/ 7340:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/* eslint-disable no-var */

var reusify = __nccwpck_require__(2113)

function fastqueue (context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker
    worker = context
    context = null
  }

  if (concurrency < 1) {
    throw new Error('fastqueue concurrency must be greater than 1')
  }

  var cache = reusify(Task)
  var queueHead = null
  var queueTail = null
  var _running = 0
  var errorHandler = null

  var self = {
    push: push,
    drain: noop,
    saturated: noop,
    pause: pause,
    paused: false,
    concurrency: concurrency,
    running: running,
    resume: resume,
    idle: idle,
    length: length,
    getQueue: getQueue,
    unshift: unshift,
    empty: noop,
    kill: kill,
    killAndDrain: killAndDrain,
    error: error
  }

  return self

  function running () {
    return _running
  }

  function pause () {
    self.paused = true
  }

  function length () {
    var current = queueHead
    var counter = 0

    while (current) {
      current = current.next
      counter++
    }

    return counter
  }

  function getQueue () {
    var current = queueHead
    var tasks = []

    while (current) {
      tasks.push(current.value)
      current = current.next
    }

    return tasks
  }

  function resume () {
    if (!self.paused) return
    self.paused = false
    for (var i = 0; i < self.concurrency; i++) {
      _running++
      release()
    }
  }

  function idle () {
    return _running === 0 && self.length() === 0
  }

  function push (value, done) {
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop
    current.errorHandler = errorHandler

    if (_running === self.concurrency || self.paused) {
      if (queueTail) {
        queueTail.next = current
        queueTail = current
      } else {
        queueHead = current
        queueTail = current
        self.saturated()
      }
    } else {
      _running++
      worker.call(context, current.value, current.worked)
    }
  }

  function unshift (value, done) {
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop

    if (_running === self.concurrency || self.paused) {
      if (queueHead) {
        current.next = queueHead
        queueHead = current
      } else {
        queueHead = current
        queueTail = current
        self.saturated()
      }
    } else {
      _running++
      worker.call(context, current.value, current.worked)
    }
  }

  function release (holder) {
    if (holder) {
      cache.release(holder)
    }
    var next = queueHead
    if (next) {
      if (!self.paused) {
        if (queueTail === queueHead) {
          queueTail = null
        }
        queueHead = next.next
        next.next = null
        worker.call(context, next.value, next.worked)
        if (queueTail === null) {
          self.empty()
        }
      } else {
        _running--
      }
    } else if (--_running === 0) {
      self.drain()
    }
  }

  function kill () {
    queueHead = null
    queueTail = null
    self.drain = noop
  }

  function killAndDrain () {
    queueHead = null
    queueTail = null
    self.drain()
    self.drain = noop
  }

  function error (handler) {
    errorHandler = handler
  }
}

function noop () {}

function Task () {
  this.value = null
  this.callback = noop
  this.next = null
  this.release = noop
  this.context = null
  this.errorHandler = null

  var self = this

  this.worked = function worked (err, result) {
    var callback = self.callback
    var errorHandler = self.errorHandler
    var val = self.value
    self.value = null
    self.callback = noop
    if (self.errorHandler) {
      errorHandler(err, val)
    }
    callback.call(self.context, err, result)
    self.release(self)
  }
}

function queueAsPromised (context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker
    worker = context
    context = null
  }

  function asyncWrapper (arg, cb) {
    worker.call(this, arg)
      .then(function (res) {
        cb(null, res)
      }, cb)
  }

  var queue = fastqueue(context, asyncWrapper, concurrency)

  var pushCb = queue.push
  var unshiftCb = queue.unshift

  queue.push = push
  queue.unshift = unshift
  queue.drained = drained

  return queue

  function push (value) {
    var p = new Promise(function (resolve, reject) {
      pushCb(value, function (err, result) {
        if (err) {
          reject(err)
          return
        }
        resolve(result)
      })
    })

    // Let's fork the promise chain to
    // make the error bubble up to the user but
    // not lead to a unhandledRejection
    p.catch(noop)

    return p
  }

  function unshift (value) {
    var p = new Promise(function (resolve, reject) {
      unshiftCb(value, function (err, result) {
        if (err) {
          reject(err)
          return
        }
        resolve(result)
      })
    })

    // Let's fork the promise chain to
    // make the error bubble up to the user but
    // not lead to a unhandledRejection
    p.catch(noop)

    return p
  }

  function drained () {
    var previousDrain = queue.drain

    var p = new Promise(function (resolve) {
      queue.drain = function () {
        previousDrain()
        resolve()
      }
    })

    return p
  }
}

module.exports = fastqueue
module.exports.promise = queueAsPromised


/***/ }),

/***/ 4930:
/***/ ((module) => {

"use strict";

const toBytes = s => [...s].map(c => c.charCodeAt(0));
const xpiZipFilename = toBytes('META-INF/mozilla.rsa');
const oxmlContentTypes = toBytes('[Content_Types].xml');
const oxmlRels = toBytes('_rels/.rels');

function readUInt64LE(buf, offset = 0) {
	let n = buf[offset];
	let mul = 1;
	let i = 0;
	while (++i < 8) {
		mul *= 0x100;
		n += buf[offset + i] * mul;
	}

	return n;
}

const fileType = input => {
	if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
		throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
	}

	const buf = input instanceof Uint8Array ? input : new Uint8Array(input);

	if (!(buf && buf.length > 1)) {
		return null;
	}

	const check = (header, options) => {
		options = Object.assign({
			offset: 0
		}, options);

		for (let i = 0; i < header.length; i++) {
			// If a bitmask is set
			if (options.mask) {
				// If header doesn't equal `buf` with bits masked off
				if (header[i] !== (options.mask[i] & buf[i + options.offset])) {
					return false;
				}
			} else if (header[i] !== buf[i + options.offset]) {
				return false;
			}
		}

		return true;
	};

	const checkString = (header, options) => check(toBytes(header), options);

	if (check([0xFF, 0xD8, 0xFF])) {
		return {
			ext: 'jpg',
			mime: 'image/jpeg'
		};
	}

	if (check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {
		return {
			ext: 'png',
			mime: 'image/png'
		};
	}

	if (check([0x47, 0x49, 0x46])) {
		return {
			ext: 'gif',
			mime: 'image/gif'
		};
	}

	if (check([0x57, 0x45, 0x42, 0x50], {offset: 8})) {
		return {
			ext: 'webp',
			mime: 'image/webp'
		};
	}

	if (check([0x46, 0x4C, 0x49, 0x46])) {
		return {
			ext: 'flif',
			mime: 'image/flif'
		};
	}

	// Needs to be before `tif` check
	if (
		(check([0x49, 0x49, 0x2A, 0x0]) || check([0x4D, 0x4D, 0x0, 0x2A])) &&
		check([0x43, 0x52], {offset: 8})
	) {
		return {
			ext: 'cr2',
			mime: 'image/x-canon-cr2'
		};
	}

	if (
		check([0x49, 0x49, 0x2A, 0x0]) ||
		check([0x4D, 0x4D, 0x0, 0x2A])
	) {
		return {
			ext: 'tif',
			mime: 'image/tiff'
		};
	}

	if (check([0x42, 0x4D])) {
		return {
			ext: 'bmp',
			mime: 'image/bmp'
		};
	}

	if (check([0x49, 0x49, 0xBC])) {
		return {
			ext: 'jxr',
			mime: 'image/vnd.ms-photo'
		};
	}

	if (check([0x38, 0x42, 0x50, 0x53])) {
		return {
			ext: 'psd',
			mime: 'image/vnd.adobe.photoshop'
		};
	}

	// Zip-based file formats
	// Need to be before the `zip` check
	if (check([0x50, 0x4B, 0x3, 0x4])) {
		if (
			check([0x6D, 0x69, 0x6D, 0x65, 0x74, 0x79, 0x70, 0x65, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x65, 0x70, 0x75, 0x62, 0x2B, 0x7A, 0x69, 0x70], {offset: 30})
		) {
			return {
				ext: 'epub',
				mime: 'application/epub+zip'
			};
		}

		// Assumes signed `.xpi` from addons.mozilla.org
		if (check(xpiZipFilename, {offset: 30})) {
			return {
				ext: 'xpi',
				mime: 'application/x-xpinstall'
			};
		}

		if (checkString('mimetypeapplication/vnd.oasis.opendocument.text', {offset: 30})) {
			return {
				ext: 'odt',
				mime: 'application/vnd.oasis.opendocument.text'
			};
		}

		if (checkString('mimetypeapplication/vnd.oasis.opendocument.spreadsheet', {offset: 30})) {
			return {
				ext: 'ods',
				mime: 'application/vnd.oasis.opendocument.spreadsheet'
			};
		}

		if (checkString('mimetypeapplication/vnd.oasis.opendocument.presentation', {offset: 30})) {
			return {
				ext: 'odp',
				mime: 'application/vnd.oasis.opendocument.presentation'
			};
		}

		// The docx, xlsx and pptx file types extend the Office Open XML file format:
		// https://en.wikipedia.org/wiki/Office_Open_XML_file_formats
		// We look for:
		// - one entry named '[Content_Types].xml' or '_rels/.rels',
		// - one entry indicating specific type of file.
		// MS Office, OpenOffice and LibreOffice may put the parts in different order, so the check should not rely on it.
		const findNextZipHeaderIndex = (arr, startAt = 0) => arr.findIndex((el, i, arr) => i >= startAt && arr[i] === 0x50 && arr[i + 1] === 0x4B && arr[i + 2] === 0x3 && arr[i + 3] === 0x4);

		let zipHeaderIndex = 0; // The first zip header was already found at index 0
		let oxmlFound = false;
		let type = null;

		do {
			const offset = zipHeaderIndex + 30;

			if (!oxmlFound) {
				oxmlFound = (check(oxmlContentTypes, {offset}) || check(oxmlRels, {offset}));
			}

			if (!type) {
				if (checkString('word/', {offset})) {
					type = {
						ext: 'docx',
						mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
					};
				} else if (checkString('ppt/', {offset})) {
					type = {
						ext: 'pptx',
						mime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
					};
				} else if (checkString('xl/', {offset})) {
					type = {
						ext: 'xlsx',
						mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
					};
				}
			}

			if (oxmlFound && type) {
				return type;
			}

			zipHeaderIndex = findNextZipHeaderIndex(buf, offset);
		} while (zipHeaderIndex >= 0);

		// No more zip parts available in the buffer, but maybe we are almost certain about the type?
		if (type) {
			return type;
		}
	}

	if (
		check([0x50, 0x4B]) &&
		(buf[2] === 0x3 || buf[2] === 0x5 || buf[2] === 0x7) &&
		(buf[3] === 0x4 || buf[3] === 0x6 || buf[3] === 0x8)
	) {
		return {
			ext: 'zip',
			mime: 'application/zip'
		};
	}

	if (check([0x75, 0x73, 0x74, 0x61, 0x72], {offset: 257})) {
		return {
			ext: 'tar',
			mime: 'application/x-tar'
		};
	}

	if (
		check([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7]) &&
		(buf[6] === 0x0 || buf[6] === 0x1)
	) {
		return {
			ext: 'rar',
			mime: 'application/x-rar-compressed'
		};
	}

	if (check([0x1F, 0x8B, 0x8])) {
		return {
			ext: 'gz',
			mime: 'application/gzip'
		};
	}

	if (check([0x42, 0x5A, 0x68])) {
		return {
			ext: 'bz2',
			mime: 'application/x-bzip2'
		};
	}

	if (check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {
		return {
			ext: '7z',
			mime: 'application/x-7z-compressed'
		};
	}

	if (check([0x78, 0x01])) {
		return {
			ext: 'dmg',
			mime: 'application/x-apple-diskimage'
		};
	}

	if (check([0x33, 0x67, 0x70, 0x35]) || // 3gp5
		(
			check([0x0, 0x0, 0x0]) && check([0x66, 0x74, 0x79, 0x70], {offset: 4}) &&
				(
					check([0x6D, 0x70, 0x34, 0x31], {offset: 8}) || // MP41
					check([0x6D, 0x70, 0x34, 0x32], {offset: 8}) || // MP42
					check([0x69, 0x73, 0x6F, 0x6D], {offset: 8}) || // ISOM
					check([0x69, 0x73, 0x6F, 0x32], {offset: 8}) || // ISO2
					check([0x6D, 0x6D, 0x70, 0x34], {offset: 8}) || // MMP4
					check([0x4D, 0x34, 0x56], {offset: 8}) || // M4V
					check([0x64, 0x61, 0x73, 0x68], {offset: 8}) // DASH
				)
		)) {
		return {
			ext: 'mp4',
			mime: 'video/mp4'
		};
	}

	if (check([0x4D, 0x54, 0x68, 0x64])) {
		return {
			ext: 'mid',
			mime: 'audio/midi'
		};
	}

	// https://github.com/threatstack/libmagic/blob/master/magic/Magdir/matroska
	if (check([0x1A, 0x45, 0xDF, 0xA3])) {
		const sliced = buf.subarray(4, 4 + 4096);
		const idPos = sliced.findIndex((el, i, arr) => arr[i] === 0x42 && arr[i + 1] === 0x82);

		if (idPos !== -1) {
			const docTypePos = idPos + 3;
			const findDocType = type => [...type].every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));

			if (findDocType('matroska')) {
				return {
					ext: 'mkv',
					mime: 'video/x-matroska'
				};
			}

			if (findDocType('webm')) {
				return {
					ext: 'webm',
					mime: 'video/webm'
				};
			}
		}
	}

	if (check([0x0, 0x0, 0x0, 0x14, 0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20]) ||
		check([0x66, 0x72, 0x65, 0x65], {offset: 4}) || // Type: `free`
		check([0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20], {offset: 4}) ||
		check([0x6D, 0x64, 0x61, 0x74], {offset: 4}) || // MJPEG
		check([0x6D, 0x6F, 0x6F, 0x76], {offset: 4}) || // Type: `moov`
		check([0x77, 0x69, 0x64, 0x65], {offset: 4})) {
		return {
			ext: 'mov',
			mime: 'video/quicktime'
		};
	}

	// RIFF file format which might be AVI, WAV, QCP, etc
	if (check([0x52, 0x49, 0x46, 0x46])) {
		if (check([0x41, 0x56, 0x49], {offset: 8})) {
			return {
				ext: 'avi',
				mime: 'video/vnd.avi'
			};
		}

		if (check([0x57, 0x41, 0x56, 0x45], {offset: 8})) {
			return {
				ext: 'wav',
				mime: 'audio/vnd.wave'
			};
		}

		// QLCM, QCP file
		if (check([0x51, 0x4C, 0x43, 0x4D], {offset: 8})) {
			return {
				ext: 'qcp',
				mime: 'audio/qcelp'
			};
		}
	}

	// ASF_Header_Object first 80 bytes
	if (check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {
		// Search for header should be in first 1KB of file.

		let offset = 30;
		do {
			const objectSize = readUInt64LE(buf, offset + 16);
			if (check([0x91, 0x07, 0xDC, 0xB7, 0xB7, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65], {offset})) {
				// Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)
				if (check([0x40, 0x9E, 0x69, 0xF8, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B], {offset: offset + 24})) {
					// Found audio:
					return {
						ext: 'wma',
						mime: 'audio/x-ms-wma'
					};
				}

				if (check([0xC0, 0xEF, 0x19, 0xBC, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B], {offset: offset + 24})) {
					// Found video:
					return {
						ext: 'wmv',
						mime: 'video/x-ms-asf'
					};
				}

				break;
			}

			offset += objectSize;
		} while (offset + 24 <= buf.length);

		// Default to ASF generic extension
		return {
			ext: 'asf',
			mime: 'application/vnd.ms-asf'
		};
	}

	if (
		check([0x0, 0x0, 0x1, 0xBA]) ||
		check([0x0, 0x0, 0x1, 0xB3])
	) {
		return {
			ext: 'mpg',
			mime: 'video/mpeg'
		};
	}

	if (check([0x66, 0x74, 0x79, 0x70, 0x33, 0x67], {offset: 4})) {
		return {
			ext: '3gp',
			mime: 'video/3gpp'
		};
	}

	// Check for MPEG header at different starting offsets
	for (let start = 0; start < 2 && start < (buf.length - 16); start++) {
		if (
			check([0x49, 0x44, 0x33], {offset: start}) || // ID3 header
			check([0xFF, 0xE2], {offset: start, mask: [0xFF, 0xE2]}) // MPEG 1 or 2 Layer 3 header
		) {
			return {
				ext: 'mp3',
				mime: 'audio/mpeg'
			};
		}

		if (
			check([0xFF, 0xE4], {offset: start, mask: [0xFF, 0xE4]}) // MPEG 1 or 2 Layer 2 header
		) {
			return {
				ext: 'mp2',
				mime: 'audio/mpeg'
			};
		}

		if (
			check([0xFF, 0xF8], {offset: start, mask: [0xFF, 0xFC]}) // MPEG 2 layer 0 using ADTS
		) {
			return {
				ext: 'mp2',
				mime: 'audio/mpeg'
			};
		}

		if (
			check([0xFF, 0xF0], {offset: start, mask: [0xFF, 0xFC]}) // MPEG 4 layer 0 using ADTS
		) {
			return {
				ext: 'mp4',
				mime: 'audio/mpeg'
			};
		}
	}

	if (
		check([0x66, 0x74, 0x79, 0x70, 0x4D, 0x34, 0x41], {offset: 4})
	) {
		return { // MPEG-4 layer 3 (audio)
			ext: 'm4a',
			mime: 'audio/mp4' // RFC 4337
		};
	}

	// Needs to be before `ogg` check
	if (check([0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64], {offset: 28})) {
		return {
			ext: 'opus',
			mime: 'audio/opus'
		};
	}

	// If 'OggS' in first  bytes, then OGG container
	if (check([0x4F, 0x67, 0x67, 0x53])) {
		// This is a OGG container

		// If ' theora' in header.
		if (check([0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61], {offset: 28})) {
			return {
				ext: 'ogv',
				mime: 'video/ogg'
			};
		}

		// If '\x01video' in header.
		if (check([0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00], {offset: 28})) {
			return {
				ext: 'ogm',
				mime: 'video/ogg'
			};
		}

		// If ' FLAC' in header  https://xiph.org/flac/faq.html
		if (check([0x7F, 0x46, 0x4C, 0x41, 0x43], {offset: 28})) {
			return {
				ext: 'oga',
				mime: 'audio/ogg'
			};
		}

		// 'Speex  ' in header https://en.wikipedia.org/wiki/Speex
		if (check([0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20], {offset: 28})) {
			return {
				ext: 'spx',
				mime: 'audio/ogg'
			};
		}

		// If '\x01vorbis' in header
		if (check([0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73], {offset: 28})) {
			return {
				ext: 'ogg',
				mime: 'audio/ogg'
			};
		}

		// Default OGG container https://www.iana.org/assignments/media-types/application/ogg
		return {
			ext: 'ogx',
			mime: 'application/ogg'
		};
	}

	if (check([0x66, 0x4C, 0x61, 0x43])) {
		return {
			ext: 'flac',
			mime: 'audio/x-flac'
		};
	}

	if (check([0x4D, 0x41, 0x43, 0x20])) { // 'MAC '
		return {
			ext: 'ape',
			mime: 'audio/ape'
		};
	}

	if (check([0x77, 0x76, 0x70, 0x6B])) { // 'wvpk'
		return {
			ext: 'wv',
			mime: 'audio/wavpack'
		};
	}

	if (check([0x23, 0x21, 0x41, 0x4D, 0x52, 0x0A])) {
		return {
			ext: 'amr',
			mime: 'audio/amr'
		};
	}

	if (check([0x25, 0x50, 0x44, 0x46])) {
		return {
			ext: 'pdf',
			mime: 'application/pdf'
		};
	}

	if (check([0x4D, 0x5A])) {
		return {
			ext: 'exe',
			mime: 'application/x-msdownload'
		};
	}

	if (
		(buf[0] === 0x43 || buf[0] === 0x46) &&
		check([0x57, 0x53], {offset: 1})
	) {
		return {
			ext: 'swf',
			mime: 'application/x-shockwave-flash'
		};
	}

	if (check([0x7B, 0x5C, 0x72, 0x74, 0x66])) {
		return {
			ext: 'rtf',
			mime: 'application/rtf'
		};
	}

	if (check([0x00, 0x61, 0x73, 0x6D])) {
		return {
			ext: 'wasm',
			mime: 'application/wasm'
		};
	}

	if (
		check([0x77, 0x4F, 0x46, 0x46]) &&
		(
			check([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||
			check([0x4F, 0x54, 0x54, 0x4F], {offset: 4})
		)
	) {
		return {
			ext: 'woff',
			mime: 'font/woff'
		};
	}

	if (
		check([0x77, 0x4F, 0x46, 0x32]) &&
		(
			check([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||
			check([0x4F, 0x54, 0x54, 0x4F], {offset: 4})
		)
	) {
		return {
			ext: 'woff2',
			mime: 'font/woff2'
		};
	}

	if (
		check([0x4C, 0x50], {offset: 34}) &&
		(
			check([0x00, 0x00, 0x01], {offset: 8}) ||
			check([0x01, 0x00, 0x02], {offset: 8}) ||
			check([0x02, 0x00, 0x02], {offset: 8})
		)
	) {
		return {
			ext: 'eot',
			mime: 'application/vnd.ms-fontobject'
		};
	}

	if (check([0x00, 0x01, 0x00, 0x00, 0x00])) {
		return {
			ext: 'ttf',
			mime: 'font/ttf'
		};
	}

	if (check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {
		return {
			ext: 'otf',
			mime: 'font/otf'
		};
	}

	if (check([0x00, 0x00, 0x01, 0x00])) {
		return {
			ext: 'ico',
			mime: 'image/x-icon'
		};
	}

	if (check([0x00, 0x00, 0x02, 0x00])) {
		return {
			ext: 'cur',
			mime: 'image/x-icon'
		};
	}

	if (check([0x46, 0x4C, 0x56, 0x01])) {
		return {
			ext: 'flv',
			mime: 'video/x-flv'
		};
	}

	if (check([0x25, 0x21])) {
		return {
			ext: 'ps',
			mime: 'application/postscript'
		};
	}

	if (check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {
		return {
			ext: 'xz',
			mime: 'application/x-xz'
		};
	}

	if (check([0x53, 0x51, 0x4C, 0x69])) {
		return {
			ext: 'sqlite',
			mime: 'application/x-sqlite3'
		};
	}

	if (check([0x4E, 0x45, 0x53, 0x1A])) {
		return {
			ext: 'nes',
			mime: 'application/x-nintendo-nes-rom'
		};
	}

	if (check([0x43, 0x72, 0x32, 0x34])) {
		return {
			ext: 'crx',
			mime: 'application/x-google-chrome-extension'
		};
	}

	if (
		check([0x4D, 0x53, 0x43, 0x46]) ||
		check([0x49, 0x53, 0x63, 0x28])
	) {
		return {
			ext: 'cab',
			mime: 'application/vnd.ms-cab-compressed'
		};
	}

	// Needs to be before `ar` check
	if (check([0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E, 0x0A, 0x64, 0x65, 0x62, 0x69, 0x61, 0x6E, 0x2D, 0x62, 0x69, 0x6E, 0x61, 0x72, 0x79])) {
		return {
			ext: 'deb',
			mime: 'application/x-deb'
		};
	}

	if (check([0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E])) {
		return {
			ext: 'ar',
			mime: 'application/x-unix-archive'
		};
	}

	if (check([0xED, 0xAB, 0xEE, 0xDB])) {
		return {
			ext: 'rpm',
			mime: 'application/x-rpm'
		};
	}

	if (
		check([0x1F, 0xA0]) ||
		check([0x1F, 0x9D])
	) {
		return {
			ext: 'Z',
			mime: 'application/x-compress'
		};
	}

	if (check([0x4C, 0x5A, 0x49, 0x50])) {
		return {
			ext: 'lz',
			mime: 'application/x-lzip'
		};
	}

	if (check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {
		return {
			ext: 'msi',
			mime: 'application/x-msi'
		};
	}

	if (check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {
		return {
			ext: 'mxf',
			mime: 'application/mxf'
		};
	}

	if (check([0x47], {offset: 4}) && (check([0x47], {offset: 192}) || check([0x47], {offset: 196}))) {
		return {
			ext: 'mts',
			mime: 'video/mp2t'
		};
	}

	if (check([0x42, 0x4C, 0x45, 0x4E, 0x44, 0x45, 0x52])) {
		return {
			ext: 'blend',
			mime: 'application/x-blender'
		};
	}

	if (check([0x42, 0x50, 0x47, 0xFB])) {
		return {
			ext: 'bpg',
			mime: 'image/bpg'
		};
	}

	if (check([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {
		// JPEG-2000 family

		if (check([0x6A, 0x70, 0x32, 0x20], {offset: 20})) {
			return {
				ext: 'jp2',
				mime: 'image/jp2'
			};
		}

		if (check([0x6A, 0x70, 0x78, 0x20], {offset: 20})) {
			return {
				ext: 'jpx',
				mime: 'image/jpx'
			};
		}

		if (check([0x6A, 0x70, 0x6D, 0x20], {offset: 20})) {
			return {
				ext: 'jpm',
				mime: 'image/jpm'
			};
		}

		if (check([0x6D, 0x6A, 0x70, 0x32], {offset: 20})) {
			return {
				ext: 'mj2',
				mime: 'image/mj2'
			};
		}
	}

	if (check([0x46, 0x4F, 0x52, 0x4D])) {
		return {
			ext: 'aif',
			mime: 'audio/aiff'
		};
	}

	if (checkString('<?xml ')) {
		return {
			ext: 'xml',
			mime: 'application/xml'
		};
	}

	if (check([0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49], {offset: 60})) {
		return {
			ext: 'mobi',
			mime: 'application/x-mobipocket-ebook'
		};
	}

	// File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)
	if (check([0x66, 0x74, 0x79, 0x70], {offset: 4})) {
		if (check([0x6D, 0x69, 0x66, 0x31], {offset: 8})) {
			return {
				ext: 'heic',
				mime: 'image/heif'
			};
		}

		if (check([0x6D, 0x73, 0x66, 0x31], {offset: 8})) {
			return {
				ext: 'heic',
				mime: 'image/heif-sequence'
			};
		}

		if (check([0x68, 0x65, 0x69, 0x63], {offset: 8}) || check([0x68, 0x65, 0x69, 0x78], {offset: 8})) {
			return {
				ext: 'heic',
				mime: 'image/heic'
			};
		}

		if (check([0x68, 0x65, 0x76, 0x63], {offset: 8}) || check([0x68, 0x65, 0x76, 0x78], {offset: 8})) {
			return {
				ext: 'heic',
				mime: 'image/heic-sequence'
			};
		}
	}

	if (check([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A])) {
		return {
			ext: 'ktx',
			mime: 'image/ktx'
		};
	}

	if (check([0x44, 0x49, 0x43, 0x4D], {offset: 128})) {
		return {
			ext: 'dcm',
			mime: 'application/dicom'
		};
	}

	// Musepack, SV7
	if (check([0x4D, 0x50, 0x2B])) {
		return {
			ext: 'mpc',
			mime: 'audio/x-musepack'
		};
	}

	// Musepack, SV8
	if (check([0x4D, 0x50, 0x43, 0x4B])) {
		return {
			ext: 'mpc',
			mime: 'audio/x-musepack'
		};
	}

	if (check([0x42, 0x45, 0x47, 0x49, 0x4E, 0x3A])) {
		return {
			ext: 'ics',
			mime: 'text/calendar'
		};
	}

	if (check([0x67, 0x6C, 0x54, 0x46, 0x02, 0x00, 0x00, 0x00])) {
		return {
			ext: 'glb',
			mime: 'model/gltf-binary'
		};
	}

	if (check([0xD4, 0xC3, 0xB2, 0xA1]) || check([0xA1, 0xB2, 0xC3, 0xD4])) {
		return {
			ext: 'pcap',
			mime: 'application/vnd.tcpdump.pcap'
		};
	}

	return null;
};

module.exports = fileType;
// TODO: Remove this for the next major release
module.exports.default = fileType;

Object.defineProperty(fileType, 'minimumBytes', {value: 4100});

module.exports.stream = readableStream => new Promise((resolve, reject) => {
	// Using `eval` to work around issues when bundling with Webpack
	const stream = eval('require')('stream'); // eslint-disable-line no-eval

	readableStream.once('readable', () => {
		const pass = new stream.PassThrough();
		const chunk = readableStream.read(module.exports.minimumBytes) || readableStream.read();
		try {
			pass.fileType = fileType(chunk);
		} catch (error) {
			reject(error);
		}

		readableStream.unshift(chunk);

		if (stream.pipeline) {
			resolve(stream.pipeline(readableStream, pass, () => {}));
		} else {
			resolve(readableStream.pipe(pass));
		}
	});
});


/***/ }),

/***/ 9670:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * @private
 */
var PICKER_VERSION = '1.23.0';
exports.config = {
    urls: {
        processUrl: 'https://process.filestackapi.com',
        fileApiUrl: 'https://www.filestackapi.com/api/file',
        uploadApiUrl: 'https://upload.filestackapi.com',
        cloudApiUrl: 'https://cloud.filestackapi.com',
        cdnUrl: 'https://cdn.filestackcontent.com',
        pickerUrl: "https://static.filestackapi.com/picker/" + PICKER_VERSION + "/picker.js",
    },
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb25maWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRzs7QUFFSDs7R0FFRztBQUNILElBQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQztBQXNCbkIsUUFBQSxNQUFNLEdBQUc7SUFDcEIsSUFBSSxFQUFFO1FBQ0osVUFBVSxFQUFFLGtDQUFrQztRQUM5QyxVQUFVLEVBQUUsdUNBQXVDO1FBQ25ELFlBQVksRUFBRSxpQ0FBaUM7UUFDL0MsV0FBVyxFQUFFLGdDQUFnQztRQUM3QyxNQUFNLEVBQUUsa0NBQWtDO1FBQzFDLFNBQVMsRUFBRSw0Q0FBMEMsY0FBYyxlQUFZO0tBQ2hGO0NBQ0YsQ0FBQyIsImZpbGUiOiJjb25maWcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IFBJQ0tFUl9WRVJTSU9OID0gJzEuMjMuMCc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIb3N0cyB7XG4gIFt1cmw6IHN0cmluZ106IHN0cmluZztcbiAgZmlsZUFwaVVybDogc3RyaW5nO1xuICB1cGxvYWRBcGlVcmw6IHN0cmluZztcbiAgY2xvdWRBcGlVcmw6IHN0cmluZztcbiAgY2RuVXJsOiBzdHJpbmc7XG4gIHBpY2tlclVybDogc3RyaW5nO1xuICBwcm9jZXNzVXJsOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25maWcge1xuICB1cmxzOiBIb3N0cztcbn1cblxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IHtcbiAgdXJsczoge1xuICAgIHByb2Nlc3NVcmw6ICdodHRwczovL3Byb2Nlc3MuZmlsZXN0YWNrYXBpLmNvbScsXG4gICAgZmlsZUFwaVVybDogJ2h0dHBzOi8vd3d3LmZpbGVzdGFja2FwaS5jb20vYXBpL2ZpbGUnLFxuICAgIHVwbG9hZEFwaVVybDogJ2h0dHBzOi8vdXBsb2FkLmZpbGVzdGFja2FwaS5jb20nLFxuICAgIGNsb3VkQXBpVXJsOiAnaHR0cHM6Ly9jbG91ZC5maWxlc3RhY2thcGkuY29tJyxcbiAgICBjZG5Vcmw6ICdodHRwczovL2Nkbi5maWxlc3RhY2tjb250ZW50LmNvbScsXG4gICAgcGlja2VyVXJsOiBgaHR0cHM6Ly9zdGF0aWMuZmlsZXN0YWNrYXBpLmNvbS9waWNrZXIvJHtQSUNLRVJfVkVSU0lPTn0vcGlja2VyLmpzYCxcbiAgfSxcbn07XG4iXX0=


/***/ }),

/***/ 4257:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var FilestackErrorType;
(function (FilestackErrorType) {
    FilestackErrorType["VALIDATION"] = "validation";
    FilestackErrorType["REQUEST"] = "request";
    FilestackErrorType["ABORTED"] = "aborted";
    FilestackErrorType["OTHER"] = "other";
})(FilestackErrorType = exports.FilestackErrorType || (exports.FilestackErrorType = {}));
var FilestackError = /** @class */ (function (_super) {
    tslib_1.__extends(FilestackError, _super);
    function FilestackError(message, details, type) {
        var _this = 
        /* istanbul ignore next */
        _super.call(this, message) || this;
        Object.setPrototypeOf(_this, FilestackError.prototype);
        _this.details = details;
        _this.type = type;
        return _this;
    }
    return FilestackError;
}(Error));
exports.FilestackError = FilestackError;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9maWxlc3RhY2tfZXJyb3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRzs7O0FBRUgsSUFBWSxrQkFLWDtBQUxELFdBQVksa0JBQWtCO0lBQzVCLCtDQUF5QixDQUFBO0lBQ3pCLHlDQUFtQixDQUFBO0lBQ25CLHlDQUFtQixDQUFBO0lBQ25CLHFDQUFlLENBQUE7QUFDakIsQ0FBQyxFQUxXLGtCQUFrQixHQUFsQiwwQkFBa0IsS0FBbEIsMEJBQWtCLFFBSzdCO0FBRUQ7SUFBb0MsMENBQUs7SUFXdkMsd0JBQVksT0FBZ0IsRUFBRSxPQUFhLEVBQUUsSUFBeUI7UUFBdEU7UUFFRSwwQkFBMEI7UUFDMUIsa0JBQU0sT0FBTyxDQUFDLFNBSWY7UUFIQyxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQUksRUFBRSxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdEQsS0FBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDdkIsS0FBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7O0lBQ25CLENBQUM7SUFFSCxxQkFBQztBQUFELENBcEJBLEFBb0JDLENBcEJtQyxLQUFLLEdBb0J4QztBQXBCWSx3Q0FBYyIsImZpbGUiOiJmaWxlc3RhY2tfZXJyb3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZW51bSBGaWxlc3RhY2tFcnJvclR5cGUge1xuICBWQUxJREFUSU9OID0gJ3ZhbGlkYXRpb24nLFxuICBSRVFVRVNUID0gJ3JlcXVlc3QnLFxuICBBQk9SVEVEID0gJ2Fib3J0ZWQnLFxuICBPVEhFUiA9ICdvdGhlcicsXG59XG5cbmV4cG9ydCBjbGFzcyBGaWxlc3RhY2tFcnJvciBleHRlbmRzIEVycm9yIHtcblxuICAvKipcbiAgICogRXJyb3IgZGV0YWlscywgaWUgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICpcbiAgICogQHR5cGUgeyp9XG4gICAqIEBtZW1iZXJvZiBGaWxlc3RhY2tFcnJvclxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGRldGFpbHM6IGFueTtcbiAgcHVibGljIHJlYWRvbmx5IHR5cGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nLCBkZXRhaWxzPzogYW55LCB0eXBlPzogRmlsZXN0YWNrRXJyb3JUeXBlKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBGaWxlc3RhY2tFcnJvci5wcm90b3R5cGUpO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuXG59XG4iXX0=


/***/ }),

/***/ 3222:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var loader_1 = __nccwpck_require__(2995);
var security_1 = __nccwpck_require__(167);
exports.getSecurity = security_1.getSecurity;
exports.validateWebhookSignature = security_1.validateWebhookSignature;
var client_1 = __nccwpck_require__(9725);
exports.Client = client_1.Client;
var picker_1 = __nccwpck_require__(291);
exports.PickerDisplayMode = picker_1.PickerDisplayMode;
var transforms_schema_1 = __nccwpck_require__(5037);
exports.TransformSchema = transforms_schema_1.TransformSchema;
var prefetch_1 = __nccwpck_require__(7953);
exports.PrefetchEvents = prefetch_1.PrefetchEvents;
var filestack_error_1 = __nccwpck_require__(4257);
exports.FilestackError = filestack_error_1.FilestackError;
var index_1 = __nccwpck_require__(8123);
exports.getMimetype = index_1.getMimetype;
/**
 * Initialize client with given config
 *
 * @param apikey
 * @param options
 */
exports.Filestack = function (apikey, options) {
    return new client_1.Client(apikey, options);
};
// This will be deprecated in feature use
exports.init = exports.Filestack;
/**
 * filestack-js version. Interpolated at build time.
 */
exports.version = '3.25.0';
loader_1.registerModule(loader_1.FILESTACK_MODULES.FILESTACK_SDK, exports.Filestack, { version: '3.25.0' });
tslib_1.__exportStar(__nccwpck_require__(6110), exports);
tslib_1.__exportStar(__nccwpck_require__(4915), exports);
tslib_1.__exportStar(__nccwpck_require__(4257), exports);
tslib_1.__exportStar(__nccwpck_require__(5606), exports);
tslib_1.__exportStar(__nccwpck_require__(8123), exports);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCw0Q0FBc0U7QUFDdEUsK0NBQW9IO0FBNkNsSCxzQkE3Q3dCLHNCQUFXLENBNkN4QjtBQUNYLG1DQTlDcUMsbUNBQXdCLENBOENyQztBQTdDMUIsdUNBQStEO0FBNkQ3RCxpQkE3RE8sZUFBTSxDQTZEUDtBQTVEUix1Q0FBOEk7QUE4RDVJLDRCQTlEb0csMEJBQWlCLENBOERwRztBQTdEbkIsZ0VBQTZEO0FBd0MzRCwwQkF4Q08sbUNBQWUsQ0F3Q1A7QUFoQ2pCLCtDQUE0RztBQTBEMUcseUJBMUQrRCx5QkFBYyxDQTBEL0Q7QUF6RGhCLHFEQUFtRDtBQW1EakQseUJBbkRPLGdDQUFjLENBbURQO0FBbERoQiwyQ0FBZ0Q7QUFvRDlDLHNCQXBETyxtQkFBVyxDQW9EUDtBQWxEYjs7Ozs7R0FLRztBQUNVLFFBQUEsU0FBUyxHQUFHLFVBQUMsTUFBYyxFQUFFLE9BQXVCO0lBQy9ELE9BQU8sSUFBSSxlQUFNLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3JDLENBQUMsQ0FBQztBQUVGLHlDQUF5QztBQUM1QixRQUFBLElBQUksR0FBRyxpQkFBUyxDQUFDO0FBRTlCOztHQUVHO0FBQ1UsUUFBQSxPQUFPLEdBQUcsWUFBWSxDQUFDO0FBRXBDLHVCQUFjLENBQUMsMEJBQWlCLENBQUMsYUFBYSxFQUFFLGlCQUFTLEVBQUUsRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLENBQUMsQ0FBQztBQUV0Riw4REFBb0M7QUFDcEMseURBQStCO0FBQy9CLDREQUFrQztBQUNsQyx3REFBOEI7QUFDOUIsc0RBQTRCIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2suXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IHJlZ2lzdGVyTW9kdWxlLCBGSUxFU1RBQ0tfTU9EVUxFUyB9IGZyb20gJ0BmaWxlc3RhY2svbG9hZGVyJztcbmltcG9ydCB7IFNlY3VyaXR5T3B0aW9ucywgZ2V0U2VjdXJpdHksIHZhbGlkYXRlV2ViaG9va1NpZ25hdHVyZSwgV2ViaG9va1ZhbGlkYXRlUGF5bG9hZCB9IGZyb20gJy4vbGliL2FwaS9zZWN1cml0eSc7XG5pbXBvcnQgeyBDbGllbnQsIENsaWVudE9wdGlvbnMsIFNlY3VyaXR5IH0gZnJvbSAnLi9saWIvY2xpZW50JztcbmltcG9ydCB7IFBpY2tlck9wdGlvbnMsIFBpY2tlckluc3RhbmNlLCBQaWNrZXJVcGxvYWREb25lQ2FsbGJhY2ssIFBpY2tlckZpbGVNZXRhZGF0YSwgUGlja2VyUmVzcG9uc2UsIFBpY2tlckRpc3BsYXlNb2RlIH0gZnJvbSAnLi9saWIvcGlja2VyJztcbmltcG9ydCB7IFRyYW5zZm9ybVNjaGVtYSB9IGZyb20gJy4vc2NoZW1hL3RyYW5zZm9ybXMuc2NoZW1hJztcbmltcG9ydCB7IFRyYW5zZm9ybU9wdGlvbnMgfSBmcm9tICcuL2xpYi9hcGkvdHJhbnNmb3JtJztcbmltcG9ydCB7IFJldHJpZXZlT3B0aW9ucywgTWV0YWRhdGFPcHRpb25zIH0gZnJvbSAnLi9saWIvYXBpL2ZpbGUnO1xuaW1wb3J0IHsgVXBsb2FkVGFncyB9IGZyb20gJy4vbGliL2FwaS91cGxvYWQvZmlsZSc7XG5pbXBvcnQgeyBJbnB1dEZpbGUgfSBmcm9tICcuL2xpYi9hcGkvdXBsb2FkL2ZpbGVfdG9vbHMnO1xuaW1wb3J0IHsgVXBsb2FkT3B0aW9ucyB9IGZyb20gJy4vbGliL2FwaS91cGxvYWQvdHlwZXMnO1xuaW1wb3J0IHsgU3RvcmVVcGxvYWRPcHRpb25zIH0gZnJvbSAnLi9saWIvYXBpL3VwbG9hZCc7XG5pbXBvcnQgeyBQcmV2aWV3T3B0aW9ucyB9IGZyb20gJy4vbGliL2FwaS9wcmV2aWV3JztcbmltcG9ydCB7IFByZWZldGNoT3B0aW9ucywgUHJlZmV0Y2hSZXNwb25zZSwgUHJlZmV0Y2hQZXJtaXNzaW9ucywgUHJlZmV0Y2hFdmVudHMgfSBmcm9tICcuL2xpYi9hcGkvcHJlZmV0Y2gnO1xuaW1wb3J0IHsgRmlsZXN0YWNrRXJyb3IgfSBmcm9tICcuL2ZpbGVzdGFja19lcnJvcic7XG5pbXBvcnQgeyBnZXRNaW1ldHlwZSB9IGZyb20gJy4vbGliL3V0aWxzL2luZGV4JztcblxuLyoqXG4gKiBJbml0aWFsaXplIGNsaWVudCB3aXRoIGdpdmVuIGNvbmZpZ1xuICpcbiAqIEBwYXJhbSBhcGlrZXlcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBGaWxlc3RhY2sgPSAoYXBpa2V5OiBzdHJpbmcsIG9wdGlvbnM/OiBDbGllbnRPcHRpb25zKTogQ2xpZW50ID0+IHtcbiAgcmV0dXJuIG5ldyBDbGllbnQoYXBpa2V5LCBvcHRpb25zKTtcbn07XG5cbi8vIFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGluIGZlYXR1cmUgdXNlXG5leHBvcnQgY29uc3QgaW5pdCA9IEZpbGVzdGFjaztcblxuLyoqXG4gKiBmaWxlc3RhY2stanMgdmVyc2lvbi4gSW50ZXJwb2xhdGVkIGF0IGJ1aWxkIHRpbWUuXG4gKi9cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJ0B7VkVSU0lPTn0nO1xuXG5yZWdpc3Rlck1vZHVsZShGSUxFU1RBQ0tfTU9EVUxFUy5GSUxFU1RBQ0tfU0RLLCBGaWxlc3RhY2ssIHsgdmVyc2lvbjogJ0B7VkVSU0lPTn0nIH0pO1xuXG5leHBvcnQgKiBmcm9tICcuL2xpYi9hcGkvdHJhbnNmb3JtJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL2ZpbGVsaW5rJztcbmV4cG9ydCAqIGZyb20gJy4vZmlsZXN0YWNrX2Vycm9yJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL3JlcXVlc3QnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvdXRpbHMnO1xuXG5leHBvcnQge1xuICBVcGxvYWRUYWdzLFxuICBUcmFuc2Zvcm1TY2hlbWEsXG4gIFNlY3VyaXR5T3B0aW9ucyxcbiAgZ2V0U2VjdXJpdHksXG4gIHZhbGlkYXRlV2ViaG9va1NpZ25hdHVyZSxcbiAgV2ViaG9va1ZhbGlkYXRlUGF5bG9hZCxcbiAgQ2xpZW50T3B0aW9ucyxcbiAgUGlja2VyT3B0aW9ucyxcbiAgUGlja2VySW5zdGFuY2UsXG4gIFNlY3VyaXR5LFxuICBUcmFuc2Zvcm1PcHRpb25zLFxuICBSZXRyaWV2ZU9wdGlvbnMsXG4gIElucHV0RmlsZSxcbiAgVXBsb2FkT3B0aW9ucyxcbiAgU3RvcmVVcGxvYWRPcHRpb25zLFxuICBNZXRhZGF0YU9wdGlvbnMsXG4gIFByZXZpZXdPcHRpb25zLFxuICBQaWNrZXJVcGxvYWREb25lQ2FsbGJhY2ssXG4gIFBpY2tlckZpbGVNZXRhZGF0YSxcbiAgUGlja2VyUmVzcG9uc2UsXG4gIENsaWVudCxcbiAgRmlsZXN0YWNrRXJyb3IsXG4gIFBpY2tlckRpc3BsYXlNb2RlLFxuICBnZXRNaW1ldHlwZSxcbiAgUHJlZmV0Y2hPcHRpb25zLFxuICBQcmVmZXRjaFJlc3BvbnNlLFxuICBQcmVmZXRjaFBlcm1pc3Npb25zLFxuICBQcmVmZXRjaEV2ZW50c1xufTtcbiJdfQ==


/***/ }),

/***/ 8577:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var utils_1 = __nccwpck_require__(8123);
var filestack_error_1 = __nccwpck_require__(4257);
var request_1 = __nccwpck_require__(5606);
var store_1 = __nccwpck_require__(6373);
/**
 * @private
 */
exports.PICKER_KEY = '__fs_picker_token';
/**
 * key for picker callback url (specifies which tab will be opened after opening picker)
 * @private
 */
exports.CALLBACK_URL_KEY = 'fs-tab';
/**
 * @private
 */
var CloudClient = /** @class */ (function () {
    function CloudClient(session, options) {
        /**
         * Returns flag if token should be cached in local storage
         *
         * @private
         * @type {boolean}
         * @memberof CloudClient
         */
        this.cache = false;
        this.session = session;
        this.storeAdapter = new store_1.Store();
        this.cloudApiUrl = session.urls.cloudApiUrl;
        if (options && options.sessionCache) {
            this.cache = options.sessionCache;
        }
    }
    Object.defineProperty(CloudClient.prototype, "token", {
        get: function () {
            if (this.cache) {
                var token = this.storeAdapter.getItem(exports.PICKER_KEY, store_1.STORE_TYPE.LOCAL);
                if (token)
                    return token;
            }
            if (this.isInAppBrowser) {
                return this.storeAdapter.getItem(exports.PICKER_KEY, store_1.STORE_TYPE.SESSION);
            }
            return this._token;
        },
        set: function (key) {
            if (this.cache) {
                this.storeAdapter.setItem(exports.PICKER_KEY, key, store_1.STORE_TYPE.LOCAL);
            }
            if (this.isInAppBrowser) {
                this.storeAdapter.setItem(exports.PICKER_KEY, key, store_1.STORE_TYPE.SESSION);
            }
            this._token = key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CloudClient.prototype, "isInAppBrowser", {
        /**
         * Return information is inappbrowser flag is set
         *
         * @readonly
         * @memberof CloudClient
         */
        get: function () {
            if (this.session
                && this.session.prefetch
                && this.session.prefetch.settings
                && this.session.prefetch.settings.inapp_browser) {
                return this.session.prefetch.settings.inapp_browser;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    CloudClient.prototype.list = function (clouds, cancelTokenInput, accept) {
        var _this = this;
        var payload = {
            apikey: this.session.apikey,
            clouds: clouds,
            flow: 'web',
            token: this.token,
        };
        if (accept) {
            if (!Array.isArray(accept)) {
                accept = [accept];
            }
            // filtering mimetypes in clouds
            payload.accept = accept;
        }
        if (this.isInAppBrowser) {
            payload.appurl = this.currentAppUrl();
        }
        if (this.session.policy && this.session.signature) {
            payload.policy = this.session.policy;
            payload.signature = this.session.signature;
        }
        var options = {};
        if (cancelTokenInput) {
            var cancelToken = new request_1.FsCancelToken();
            cancelTokenInput.cancel = cancelToken.cancel.bind(cancelToken);
            options.cancelToken = cancelToken;
        }
        return request_1.FsRequest.post(this.cloudApiUrl + "/folder/list", payload, options).then(function (res) {
            if (res.data && res.data.token) {
                _this.token = res.data.token;
            }
            return res.data;
        });
    };
    CloudClient.prototype.store = function (name, path, options, customSource, cancelTokenInput, uploadTags) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        if (customSource === void 0) { customSource = {}; }
        if (uploadTags === void 0) { uploadTags = null; }
        // Default to S3
        if (options.location === undefined) {
            options.location = 's3';
        }
        var payload = {
            apikey: this.session.apikey,
            token: this.token,
            flow: 'web',
            upload_tags: uploadTags ? uploadTags : undefined,
            clouds: (_a = {},
                _a[name] = {
                    path: path,
                    store: utils_1.removeEmpty(options),
                },
                _a),
        };
        if (name === 'customsource' && customSource.customSourcePath) {
            payload.clouds.customsource.customSourcePath = customSource.customSourcePath;
        }
        if (name === 'customsource' && customSource.customSourceContainer) {
            payload.clouds.customsource.customSourceContainer = customSource.customSourceContainer;
        }
        if (this.session.policy && this.session.signature) {
            payload.policy = this.session.policy;
            payload.signature = this.session.signature;
        }
        var requestOptions = {};
        if (cancelTokenInput) {
            var cancelToken = new request_1.FsCancelToken();
            cancelTokenInput.cancel = cancelToken.cancel.bind(cancelToken);
            requestOptions.cancelToken = cancelToken;
        }
        return request_1.FsRequest.post(this.cloudApiUrl + "/store/", payload, requestOptions).then(function (res) {
            if (res.data && res.data.token) {
                _this.token = res.data.token;
            }
            if (res.data && res.data[name]) {
                return res.data[name];
            }
            return res.data;
        });
    };
    CloudClient.prototype.logout = function (name) {
        var _a;
        var payload = {
            apikey: this.session.apikey,
            flow: 'web',
            token: this.token,
        };
        if (name) {
            payload.clouds = (_a = {}, _a[name] = {}, _a);
        }
        else {
            if (this.cache) {
                // No name means logout of ALL clouds. Clear local session.
                this.storeAdapter.removeItem(exports.PICKER_KEY, store_1.STORE_TYPE.LOCAL);
            }
            if (this.isInAppBrowser) {
                this.storeAdapter.removeItem(exports.PICKER_KEY, store_1.STORE_TYPE.SESSION);
            }
        }
        return request_1.FsRequest.post(this.cloudApiUrl + "/auth/logout", payload).then(function (res) {
            if (res.data && res.data[name]) {
                return res.data[name];
            }
            return res.data;
        });
    };
    CloudClient.prototype.metadata = function (url, headers) {
        var payload = {
            apikey: this.session.apikey,
            url: url,
            headers: headers,
        };
        if (this.session.policy && this.session.signature) {
            payload.policy = this.session.policy;
            payload.signature = this.session.signature;
        }
        return request_1.FsRequest.post(this.cloudApiUrl + "/metadata", payload).then(function (res) { return res.data; });
    };
    // OpenTok API Endpoints
    CloudClient.prototype.tokInit = function (type) {
        if (type !== 'video' && type !== 'audio') {
            throw new filestack_error_1.FilestackError('Type must be one of video or audio.');
        }
        return request_1.FsRequest.post(this.cloudApiUrl + "/recording/" + type + "/init").then(function (res) { return res.data; });
    };
    CloudClient.prototype.tokStart = function (type, key, sessionId) {
        if (type !== 'video' && type !== 'audio') {
            throw new filestack_error_1.FilestackError('Type must be one of video or audio.');
        }
        var payload = {
            apikey: key,
            session_id: sessionId,
        };
        return request_1.FsRequest.post(this.cloudApiUrl + "/recording/" + type + "/start", payload).then(function (res) { return res.data; });
    };
    CloudClient.prototype.tokStop = function (type, key, sessionId, archiveId) {
        if (type !== 'video' && type !== 'audio') {
            throw new filestack_error_1.FilestackError('Type must be one of video or audio.');
        }
        var payload = {
            apikey: key,
            session_id: sessionId,
            archive_id: archiveId,
        };
        return request_1.FsRequest.post(this.cloudApiUrl + "/recording/" + type + "/stop", payload).then(function (res) { return res.data; });
    };
    CloudClient.prototype.currentAppUrl = function () {
        if (!window.URLSearchParams) {
            return undefined;
        }
        // set init string for clouds backend,
        // After this cloud service can make redirect back to current page url with selected tab for given cloud
        // if param exists and its value is init, backend will fill it with cloud name
        var searchParams = new URLSearchParams(window.location.search);
        searchParams.set(exports.CALLBACK_URL_KEY, 'init');
        return window.location.protocol + "//" + window.location.host + window.location.pathname + "?" + searchParams.toString();
    };
    return CloudClient;
}());
exports.CloudClient = CloudClient;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL2Nsb3VkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7O0FBRUgsa0NBQXVDO0FBR3ZDLDJEQUF5RDtBQUV6RCxzQ0FBc0Q7QUFDdEQsMENBQXFEO0FBRXJEOztHQUVHO0FBQ1UsUUFBQSxVQUFVLEdBQUcsbUJBQW1CLENBQUM7QUFFOUM7OztHQUdHO0FBQ1UsUUFBQSxnQkFBZ0IsR0FBRyxRQUFRLENBQUM7QUFFekM7O0dBRUc7QUFDSDtJQStCRSxxQkFBWSxPQUFnQixFQUFFLE9BQXVCO1FBM0JyRDs7Ozs7O1dBTUc7UUFDSyxVQUFLLEdBQVksS0FBSyxDQUFDO1FBcUI3QixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksYUFBSyxFQUFFLENBQUM7UUFFaEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUU1QyxJQUFJLE9BQU8sSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFO1lBQ25DLElBQUksQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQztTQUNuQztJQUNILENBQUM7SUFFRCxzQkFBSSw4QkFBSzthQUFUO1lBQ0UsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNkLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLGtCQUFVLEVBQUUsa0JBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDdEUsSUFBSSxLQUFLO29CQUFFLE9BQU8sS0FBSyxDQUFDO2FBQ3pCO1lBRUQsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFO2dCQUN2QixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLGtCQUFVLEVBQUUsa0JBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUNsRTtZQUVELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FB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QUNqRTtRQUVELElBQU0sT0FBTyxHQUFHO1lBQ2QsTUFBTSxFQUFFLEdBQUc7WUFDWCxVQUFVLEVBQUUsU0FBUztZQUNyQixVQUFVLEVBQUUsU0FBUztTQUN0QixDQUFDO1FBRUYsT0FBTyxtQkFBUyxDQUFDLElBQUksQ0FBSSxJQUFJLENBQUMsV0FBVyxtQkFBYyxJQUFJLFVBQU8sRUFBRSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBQSxHQUFHLElBQUksT0FBQSxHQUFHLENBQUMsSUFBSSxFQUFSLENBQVEsQ0FBQyxDQUFDO0lBQ3JHLENBQUM7SUFFTyxtQ0FBYSxHQUFyQjtRQUNFLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUFFO1lBQzNCLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBRUQsc0NBQXNDO1FBQ3RDLHdHQUF3RztRQUN4Ryw4RUFBOEU7UUFDOUUsSUFBTSxZQUFZLEdBQUcsSUFBSSxlQUFlLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNqRSxZQUFZLENBQUMsR0FBRyxDQUFDLHdCQUFnQixFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRTNDLE9BQVUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxRQUFRLFVBQUssTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxRQUFRLFNBQUksWUFBWSxDQUFDLFFBQVEsRUFBSSxDQUFDO0lBQ3RILENBQUM7SUFDSCxrQkFBQztBQUFELENBN1FBLEFBNlFDLElBQUE7QUE3UVksa0NBQVciLCJmaWxlIjoibGliL2FwaS9jbG91ZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IHJlbW92ZUVtcHR5IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgU3RvcmVQYXJhbXMgfSBmcm9tICcuLi9maWxlbGluayc7XG5pbXBvcnQgeyBDbGllbnRPcHRpb25zLCBTZXNzaW9uIH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7IEZpbGVzdGFja0Vycm9yIH0gZnJvbSAnLi8uLi8uLi9maWxlc3RhY2tfZXJyb3InO1xuaW1wb3J0IHsgVXBsb2FkVGFncyB9IGZyb20gJy4vdXBsb2FkL2ZpbGUnO1xuaW1wb3J0IHsgRnNSZXF1ZXN0LCBGc0NhbmNlbFRva2VuIH0gZnJvbSAnLi4vcmVxdWVzdCc7XG5pbXBvcnQgeyBTdG9yZSwgU1RPUkVfVFlQRSB9IGZyb20gJy4vLi4vdXRpbHMvc3RvcmUnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBQSUNLRVJfS0VZID0gJ19fZnNfcGlja2VyX3Rva2VuJztcblxuLyoqXG4gKiBrZXkgZm9yIHBpY2tlciBjYWxsYmFjayB1cmwgKHNwZWNpZmllcyB3aGljaCB0YWIgd2lsbCBiZSBvcGVuZWQgYWZ0ZXIgb3BlbmluZyBwaWNrZXIpXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgQ0FMTEJBQ0tfVVJMX0tFWSA9ICdmcy10YWInO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBDbG91ZENsaWVudCB7XG4gIHNlc3Npb246IFNlc3Npb247XG4gIGNsb3VkQXBpVXJsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmxhZyBpZiB0b2tlbiBzaG91bGQgYmUgY2FjaGVkIGluIGxvY2FsIHN0b3JhZ2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBDbG91ZENsaWVudFxuICAgKi9cbiAgcHJpdmF0ZSBjYWNoZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUb2tlbiByZXR1cm5lZCBmcm9tIGFwaSBmb3IgYWNjZXNzaW5nIGNsb3Vkc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2xvdWRDbGllbnRcbiAgICovXG4gIHByaXZhdGUgX3Rva2VuOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFN0b3JlIGFkYXB0ZXIgaW5zdGFuY2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge1N0b3JlfVxuICAgKiBAbWVtYmVyb2YgQ2xvdWRDbGllbnRcbiAgICovXG4gIHByaXZhdGUgc3RvcmVBZGFwdGVyOiBTdG9yZTtcblxuICBjb25zdHJ1Y3RvcihzZXNzaW9uOiBTZXNzaW9uLCBvcHRpb25zPzogQ2xpZW50T3B0aW9ucykge1xuICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgdGhpcy5zdG9yZUFkYXB0ZXIgPSBuZXcgU3RvcmUoKTtcblxuICAgIHRoaXMuY2xvdWRBcGlVcmwgPSBzZXNzaW9uLnVybHMuY2xvdWRBcGlVcmw7XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNlc3Npb25DYWNoZSkge1xuICAgICAgdGhpcy5jYWNoZSA9IG9wdGlvbnMuc2Vzc2lvbkNhY2hlO1xuICAgIH1cbiAgfVxuXG4gIGdldCB0b2tlbigpIHtcbiAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLnN0b3JlQWRhcHRlci5nZXRJdGVtKFBJQ0tFUl9LRVksIFNUT1JFX1RZUEUuTE9DQUwpO1xuICAgICAgaWYgKHRva2VuKSByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNJbkFwcEJyb3dzZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JlQWRhcHRlci5nZXRJdGVtKFBJQ0tFUl9LRVksIFNUT1JFX1RZUEUuU0VTU0lPTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3Rva2VuO1xuICB9XG5cbiAgc2V0IHRva2VuKGtleSkge1xuICAgIGlmICh0aGlzLmNhY2hlKSB7XG4gICAgICB0aGlzLnN0b3JlQWRhcHRlci5zZXRJdGVtKFBJQ0tFUl9LRVksIGtleSwgU1RPUkVfVFlQRS5MT0NBTCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNJbkFwcEJyb3dzZXIpIHtcbiAgICAgIHRoaXMuc3RvcmVBZGFwdGVyLnNldEl0ZW0oUElDS0VSX0tFWSwga2V5LCBTVE9SRV9UWVBFLlNFU1NJT04pO1xuICAgIH1cblxuICAgIHRoaXMuX3Rva2VuID0ga2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBpbmZvcm1hdGlvbiBpcyBpbmFwcGJyb3dzZXIgZmxhZyBpcyBzZXRcbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEBtZW1iZXJvZiBDbG91ZENsaWVudFxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgaXNJbkFwcEJyb3dzZXIoKSB7XG4gICAgaWYgKHRoaXMuc2Vzc2lvblxuICAgICAgJiYgdGhpcy5zZXNzaW9uLnByZWZldGNoXG4gICAgICAmJiB0aGlzLnNlc3Npb24ucHJlZmV0Y2guc2V0dGluZ3NcbiAgICAgICYmIHRoaXMuc2Vzc2lvbi5wcmVmZXRjaC5zZXR0aW5ncy5pbmFwcF9icm93c2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLnByZWZldGNoLnNldHRpbmdzLmluYXBwX2Jyb3dzZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGlzdChjbG91ZHM6IGFueSwgY2FuY2VsVG9rZW5JbnB1dD86IGFueSwgYWNjZXB0Pzogc3RyaW5nW10gfCBzdHJpbmcpIHtcbiAgICBjb25zdCBwYXlsb2FkOiBhbnkgPSB7XG4gICAgICBhcGlrZXk6IHRoaXMuc2Vzc2lvbi5hcGlrZXksXG4gICAgICBjbG91ZHMsXG4gICAgICBmbG93OiAnd2ViJyxcbiAgICAgIHRva2VuOiB0aGlzLnRva2VuLFxuICAgIH07XG5cbiAgICBpZiAoYWNjZXB0KSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWNjZXB0KSkge1xuICAgICAgICBhY2NlcHQgPSBbYWNjZXB0XTtcbiAgICAgIH1cbiAgICAgIC8vIGZpbHRlcmluZyBtaW1ldHlwZXMgaW4gY2xvdWRzXG4gICAgICBwYXlsb2FkLmFjY2VwdCA9IGFjY2VwdDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0luQXBwQnJvd3Nlcikge1xuICAgICAgcGF5bG9hZC5hcHB1cmwgPSB0aGlzLmN1cnJlbnRBcHBVcmwoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZXNzaW9uLnBvbGljeSAmJiB0aGlzLnNlc3Npb24uc2lnbmF0dXJlKSB7XG4gICAgICBwYXlsb2FkLnBvbGljeSA9IHRoaXMuc2Vzc2lvbi5wb2xpY3k7XG4gICAgICBwYXlsb2FkLnNpZ25hdHVyZSA9IHRoaXMuc2Vzc2lvbi5zaWduYXR1cmU7XG4gICAgfVxuXG4gICAgbGV0IG9wdGlvbnM6IGFueSA9IHt9O1xuXG4gICAgaWYgKGNhbmNlbFRva2VuSW5wdXQpIHtcbiAgICAgIGNvbnN0IGNhbmNlbFRva2VuID0gbmV3IEZzQ2FuY2VsVG9rZW4oKTtcbiAgICAgIGNhbmNlbFRva2VuSW5wdXQuY2FuY2VsID0gY2FuY2VsVG9rZW4uY2FuY2VsLmJpbmQoY2FuY2VsVG9rZW4pO1xuICAgICAgb3B0aW9ucy5jYW5jZWxUb2tlbiA9IGNhbmNlbFRva2VuO1xuICAgIH1cblxuICAgIHJldHVybiBGc1JlcXVlc3QucG9zdChgJHt0aGlzLmNsb3VkQXBpVXJsfS9mb2xkZXIvbGlzdGAsIHBheWxvYWQsIG9wdGlvbnMpLnRoZW4ocmVzID0+IHtcbiAgICAgIGlmIChyZXMuZGF0YSAmJiByZXMuZGF0YS50b2tlbikge1xuICAgICAgICB0aGlzLnRva2VuID0gcmVzLmRhdGEudG9rZW47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXMuZGF0YTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0b3JlKG5hbWU6IHN0cmluZywgcGF0aDogc3RyaW5nLCBvcHRpb25zOiBTdG9yZVBhcmFtcyA9IHt9LCBjdXN0b21Tb3VyY2U6IGFueSA9IHt9LCBjYW5jZWxUb2tlbklucHV0PzogYW55LCB1cGxvYWRUYWdzOiBVcGxvYWRUYWdzID0gbnVsbCkge1xuICAgIC8vIERlZmF1bHQgdG8gUzNcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmxvY2F0aW9uID0gJ3MzJztcbiAgICB9XG5cbiAgICBjb25zdCBwYXlsb2FkOiBhbnkgPSB7XG4gICAgICBhcGlrZXk6IHRoaXMuc2Vzc2lvbi5hcGlrZXksXG4gICAgICB0b2tlbjogdGhpcy50b2tlbixcbiAgICAgIGZsb3c6ICd3ZWInLFxuICAgICAgdXBsb2FkX3RhZ3M6IHVwbG9hZFRhZ3MgPyB1cGxvYWRUYWdzIDogdW5kZWZpbmVkLFxuICAgICAgY2xvdWRzOiB7XG4gICAgICAgIFtuYW1lXToge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgc3RvcmU6IHJlbW92ZUVtcHR5KG9wdGlvbnMpLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgaWYgKG5hbWUgPT09ICdjdXN0b21zb3VyY2UnICYmIGN1c3RvbVNvdXJjZS5jdXN0b21Tb3VyY2VQYXRoKSB7XG4gICAgICBwYXlsb2FkLmNsb3Vkcy5jdXN0b21zb3VyY2UuY3VzdG9tU291cmNlUGF0aCA9IGN1c3RvbVNvdXJjZS5jdXN0b21Tb3VyY2VQYXRoO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnY3VzdG9tc291cmNlJyAmJiBjdXN0b21Tb3VyY2UuY3VzdG9tU291cmNlQ29udGFpbmVyKSB7XG4gICAgICBwYXlsb2FkLmNsb3Vkcy5jdXN0b21zb3VyY2UuY3VzdG9tU291cmNlQ29udGFpbmVyID0gY3VzdG9tU291cmNlLmN1c3RvbVNvdXJjZUNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZXNzaW9uLnBvbGljeSAmJiB0aGlzLnNlc3Npb24uc2lnbmF0dXJlKSB7XG4gICAgICBwYXlsb2FkLnBvbGljeSA9IHRoaXMuc2Vzc2lvbi5wb2xpY3k7XG4gICAgICBwYXlsb2FkLnNpZ25hdHVyZSA9IHRoaXMuc2Vzc2lvbi5zaWduYXR1cmU7XG4gICAgfVxuXG4gICAgbGV0IHJlcXVlc3RPcHRpb25zOiBhbnkgPSB7fTtcblxuICAgIGlmIChjYW5jZWxUb2tlbklucHV0KSB7XG4gICAgICBjb25zdCBjYW5jZWxUb2tlbiA9IG5ldyBGc0NhbmNlbFRva2VuKCk7XG4gICAgICBjYW5jZWxUb2tlbklucHV0LmNhbmNlbCA9IGNhbmNlbFRva2VuLmNhbmNlbC5iaW5kKGNhbmNlbFRva2VuKTtcbiAgICAgIHJlcXVlc3RPcHRpb25zLmNhbmNlbFRva2VuID0gY2FuY2VsVG9rZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIEZzUmVxdWVzdC5wb3N0KGAke3RoaXMuY2xvdWRBcGlVcmx9L3N0b3JlL2AsIHBheWxvYWQsIHJlcXVlc3RPcHRpb25zKS50aGVuKHJlcyA9PiB7XG4gICAgICBpZiAocmVzLmRhdGEgJiYgcmVzLmRhdGEudG9rZW4pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHJlcy5kYXRhLnRva2VuO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzLmRhdGEgJiYgcmVzLmRhdGFbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHJlcy5kYXRhW25hbWVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzLmRhdGE7XG4gICAgfSk7XG4gIH1cblxuICBsb2dvdXQobmFtZT86IHN0cmluZykge1xuICAgIGNvbnN0IHBheWxvYWQ6IGFueSA9IHtcbiAgICAgIGFwaWtleTogdGhpcy5zZXNzaW9uLmFwaWtleSxcbiAgICAgIGZsb3c6ICd3ZWInLFxuICAgICAgdG9rZW46IHRoaXMudG9rZW4sXG4gICAgfTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBwYXlsb2FkLmNsb3VkcyA9IHsgW25hbWVdOiB7fSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgICAvLyBObyBuYW1lIG1lYW5zIGxvZ291dCBvZiBBTEwgY2xvdWRzLiBDbGVhciBsb2NhbCBzZXNzaW9uLlxuICAgICAgICB0aGlzLnN0b3JlQWRhcHRlci5yZW1vdmVJdGVtKFBJQ0tFUl9LRVksIFNUT1JFX1RZUEUuTE9DQUwpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0luQXBwQnJvd3Nlcikge1xuICAgICAgICB0aGlzLnN0b3JlQWRhcHRlci5yZW1vdmVJdGVtKFBJQ0tFUl9LRVksIFNUT1JFX1RZUEUuU0VTU0lPTik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEZzUmVxdWVzdC5wb3N0KGAke3RoaXMuY2xvdWRBcGlVcmx9L2F1dGgvbG9nb3V0YCwgcGF5bG9hZCkudGhlbihyZXMgPT4ge1xuICAgICAgaWYgKHJlcy5kYXRhICYmIHJlcy5kYXRhW25hbWVdKSB7XG4gICAgICAgIHJldHVybiByZXMuZGF0YVtuYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMuZGF0YTtcbiAgICB9KTtcbiAgfVxuXG4gIG1ldGFkYXRhKHVybDogc3RyaW5nLCBoZWFkZXJzPzoge1trZXk6IHN0cmluZ106IHN0cmluZ30pIHtcbiAgICBjb25zdCBwYXlsb2FkOiBhbnkgPSB7XG4gICAgICBhcGlrZXk6IHRoaXMuc2Vzc2lvbi5hcGlrZXksXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzLFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5zZXNzaW9uLnBvbGljeSAmJiB0aGlzLnNlc3Npb24uc2lnbmF0dXJlKSB7XG4gICAgICBwYXlsb2FkLnBvbGljeSA9IHRoaXMuc2Vzc2lvbi5wb2xpY3k7XG4gICAgICBwYXlsb2FkLnNpZ25hdHVyZSA9IHRoaXMuc2Vzc2lvbi5zaWduYXR1cmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZzUmVxdWVzdC5wb3N0KGAke3RoaXMuY2xvdWRBcGlVcmx9L21ldGFkYXRhYCwgcGF5bG9hZCkudGhlbihyZXMgPT4gcmVzLmRhdGEpO1xuICB9XG5cbiAgLy8gT3BlblRvayBBUEkgRW5kcG9pbnRzXG4gIHRva0luaXQodHlwZTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGUgIT09ICd2aWRlbycgJiYgdHlwZSAhPT0gJ2F1ZGlvJykge1xuICAgICAgdGhyb3cgbmV3IEZpbGVzdGFja0Vycm9yKCdUeXBlIG11c3QgYmUgb25lIG9mIHZpZGVvIG9yIGF1ZGlvLicpO1xuICAgIH1cbiAgICByZXR1cm4gRnNSZXF1ZXN0LnBvc3QoYCR7dGhpcy5jbG91ZEFwaVVybH0vcmVjb3JkaW5nLyR7dHlwZX0vaW5pdGApLnRoZW4ocmVzID0+IHJlcy5kYXRhKTtcbiAgfVxuXG4gIHRva1N0YXJ0KHR5cGU6IHN0cmluZywga2V5OiBzdHJpbmcsIHNlc3Npb25JZDogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGUgIT09ICd2aWRlbycgJiYgdHlwZSAhPT0gJ2F1ZGlvJykge1xuICAgICAgdGhyb3cgbmV3IEZpbGVzdGFja0Vycm9yKCdUeXBlIG11c3QgYmUgb25lIG9mIHZpZGVvIG9yIGF1ZGlvLicpO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgYXBpa2V5OiBrZXksXG4gICAgICBzZXNzaW9uX2lkOiBzZXNzaW9uSWQsXG4gICAgfTtcblxuICAgIHJldHVybiBGc1JlcXVlc3QucG9zdChgJHt0aGlzLmNsb3VkQXBpVXJsfS9yZWNvcmRpbmcvJHt0eXBlfS9zdGFydGAsIHBheWxvYWQpLnRoZW4ocmVzID0+IHJlcy5kYXRhKTtcbiAgfVxuXG4gIHRva1N0b3AodHlwZTogc3RyaW5nLCBrZXk6IHN0cmluZywgc2Vzc2lvbklkOiBzdHJpbmcsIGFyY2hpdmVJZDogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGUgIT09ICd2aWRlbycgJiYgdHlwZSAhPT0gJ2F1ZGlvJykge1xuICAgICAgdGhyb3cgbmV3IEZpbGVzdGFja0Vycm9yKCdUeXBlIG11c3QgYmUgb25lIG9mIHZpZGVvIG9yIGF1ZGlvLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICBhcGlrZXk6IGtleSxcbiAgICAgIHNlc3Npb25faWQ6IHNlc3Npb25JZCxcbiAgICAgIGFyY2hpdmVfaWQ6IGFyY2hpdmVJZCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZzUmVxdWVzdC5wb3N0KGAke3RoaXMuY2xvdWRBcGlVcmx9L3JlY29yZGluZy8ke3R5cGV9L3N0b3BgLCBwYXlsb2FkKS50aGVuKHJlcyA9PiByZXMuZGF0YSk7XG4gIH1cblxuICBwcml2YXRlIGN1cnJlbnRBcHBVcmwoKSB7XG4gICAgaWYgKCF3aW5kb3cuVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIHNldCBpbml0IHN0cmluZyBmb3IgY2xvdWRzIGJhY2tlbmQsXG4gICAgLy8gQWZ0ZXIgdGhpcyBjbG91ZCBzZXJ2aWNlIGNhbiBtYWtlIHJlZGlyZWN0IGJhY2sgdG8gY3VycmVudCBwYWdlIHVybCB3aXRoIHNlbGVjdGVkIHRhYiBmb3IgZ2l2ZW4gY2xvdWRcbiAgICAvLyBpZiBwYXJhbSBleGlzdHMgYW5kIGl0cyB2YWx1ZSBpcyBpbml0LCBiYWNrZW5kIHdpbGwgZmlsbCBpdCB3aXRoIGNsb3VkIG5hbWVcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoQ0FMTEJBQ0tfVVJMX0tFWSwgJ2luaXQnKTtcblxuICAgIHJldHVybiBgJHt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9Ly8ke3dpbmRvdy5sb2NhdGlvbi5ob3N0fSR7d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfT8ke3NlYXJjaFBhcmFtcy50b1N0cmluZygpfWA7XG4gIH1cbn1cbiJdfQ==


/***/ }),

/***/ 9016:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var filelink_1 = __nccwpck_require__(4915);
var utils_1 = __nccwpck_require__(8123);
var filestack_error_1 = __nccwpck_require__(4257);
var schema_1 = __nccwpck_require__(2782);
var request_1 = __nccwpck_require__(5606);
/**
 * Remove given file
 *
 * @private
 * @param session
 * @param handle
 * @param security
 */
exports.remove = function (session, handle, skipStorage, security) {
    if (!handle || typeof handle !== 'string') {
        throw new filestack_error_1.FilestackError('A valid Filestack handle is required for remove');
    }
    if (!(session.policy && session.signature) && (!security || !(security.policy && security.signature))) {
        throw new filestack_error_1.FilestackError('Security policy and signature are required for remove');
    }
    var fileApiUrl = session.urls.fileApiUrl;
    var baseURL = fileApiUrl + "/" + handle;
    var options = {
        key: session.apikey,
        policy: (security && security.policy) || session.policy,
        signature: (security && security.signature) || session.signature,
    };
    if (skipStorage) {
        options.skip_storage = true;
    }
    return request_1.FsRequest.delete(baseURL, {
        filestackHeaders: false,
        params: utils_1.removeEmpty(options),
    });
};
/**
 * Returns file metadata
 *
 * @private
 * @param session
 * @param handle
 * @param opts
 * @param security
 */
exports.metadata = function (session, handle, opts, security) {
    if (!handle || typeof handle !== 'string') {
        throw new filestack_error_1.FilestackError('A valid Filestack handle is required for metadata');
    }
    var validateRes = schema_1.getValidator(schema_1.MetadataParamsSchema)(opts);
    if (validateRes.errors.length) {
        throw new filestack_error_1.FilestackError("Invalid metadata params", validateRes.errors);
    }
    var options = tslib_1.__assign({}, opts);
    options.source_url = options.sourceUrl; // source_url is snake_case
    options.policy = (security && security.policy) || session.policy;
    options.signature = (security && security.signature) || session.signature;
    var baseURL = session.urls.fileApiUrl + "/" + handle + "/metadata";
    return new Promise(function (resolve, reject) {
        request_1.FsRequest.get(baseURL, { params: utils_1.removeEmpty(options), filestackHeaders: false })
            .then(function (res) { return resolve(tslib_1.__assign(tslib_1.__assign({}, res.data), { handle: handle })); })
            .catch(reject);
    });
};
/**
 * Download file to blob or buffer format
 *
 * @param session
 * @param handle
 */
exports.download = function (session, handle, security) {
    var fl = new filelink_1.Filelink(handle, session.apikey);
    var policy = (security && security.policy) || session.policy;
    var signature = (security && security.signature) || session.signature;
    if (policy && signature) {
        fl.security({ signature: signature, policy: policy });
    }
    return request_1.FsRequest.dispatch(fl.toString(), { method: request_1.FsHttpMethod.GET, blobResponse: true });
};
/**
 * Returns file information
 *
 * @private
 * @deprecated
 * @param session
 * @param handle
 * @param options
 * @param security
 */
exports.retrieve = function (session, handle, options, security) {
    if (options === void 0) { options = {}; }
    if (!handle || handle.length === 0 || typeof handle !== 'string') {
        throw new filestack_error_1.FilestackError('File handle is required');
    }
    console.info('Retrieve method is deprecated and it will be removed. Please use metadata or download');
    var validateRes = schema_1.getValidator(schema_1.RetrieveParamsSchema)(options);
    if (validateRes.errors.length) {
        throw new filestack_error_1.FilestackError("Invalid retrieve params", validateRes.errors);
    }
    var requestOptions = tslib_1.__assign({}, options);
    requestOptions.key = session.apikey;
    requestOptions.policy = (security && security.policy) || session.policy;
    requestOptions.signature = (security && security.signature) || session.signature;
    var method = request_1.FsHttpMethod.GET;
    if (requestOptions.head) {
        method = request_1.FsHttpMethod.HEAD;
        delete requestOptions.head;
    }
    var extension;
    if (requestOptions.extension && requestOptions.extension.length) {
        extension = requestOptions.extension;
        delete requestOptions.extension;
    }
    var metadata;
    if (requestOptions.metadata) {
        if (method === request_1.FsHttpMethod.HEAD) {
            throw new filestack_error_1.FilestackError('Head and metadata options cannot be used together');
        }
        metadata = requestOptions.metadata;
        delete requestOptions.metadata;
    }
    var baseURL = session.urls.fileApiUrl + "/" + handle + (extension ? "+" + extension : '') + (metadata ? '/metadata' : '');
    return new Promise(function (resolve, reject) {
        request_1.FsRequest.dispatch(baseURL, {
            method: method,
            filestackHeaders: false,
            params: utils_1.removeEmpty(requestOptions),
        })
            .then(function (res) { return resolve(method === request_1.FsHttpMethod.HEAD ? res.headers : res.data); })
            .catch(reject);
    });
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL2ZpbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRzs7O0FBR0gsMENBQXlDO0FBQ3pDLGtDQUF1QztBQUV2QywyREFBeUQ7QUFDekQseUNBQTBGO0FBQzFGLHNDQUFxRDtBQUVyRDs7Ozs7OztHQU9HO0FBQ1UsUUFBQSxNQUFNLEdBQUcsVUFBQyxPQUFnQixFQUFFLE1BQWUsRUFBRSxXQUFxQixFQUFFLFFBQW1CO0lBQ2xHLElBQUksQ0FBQyxNQUFNLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFO1FBQ3pDLE1BQU0sSUFBSSxnQ0FBYyxDQUFDLGlEQUFpRCxDQUFDLENBQUM7S0FDN0U7SUFFRCxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxJQUFJLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFO1FBQ3JHLE1BQU0sSUFBSSxnQ0FBYyxDQUFDLHVEQUF1RCxDQUFDLENBQUM7S0FDbkY7SUFFRCxJQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUMzQyxJQUFNLE9BQU8sR0FBTSxVQUFVLFNBQUksTUFBUSxDQUFDO0lBQzFDLElBQU0sT0FBTyxHQUFRO1FBQ25CLEdBQUcsRUFBRSxPQUFPLENBQUMsTUFBTTtRQUNuQixNQUFNLEVBQUUsQ0FBQyxRQUFRLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxNQUFNO1FBQ3ZELFNBQVMsRUFBRSxDQUFDLFFBQVEsSUFBSSxRQUFRLENBQUMsU0FBUyxDQUFDLElBQUksT0FBTyxDQUFDLFNBQVM7S0FDakUsQ0FBQztJQUVGLElBQUksV0FBVyxFQUFFO1FBQ2YsT0FBTyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7S0FDN0I7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UUFBUSxDQUFDO0lBQ2IsSUFBSSxjQUFjLENBQUMsUUFBUSxFQUFFO1FBQzNCLElBQUksTUFBTSxLQUFLLHNCQUFZLENBQUMsSUFBSSxFQUFFO1lBQ2hDLE1BQU0sSUFBSSxnQ0FBYyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7U0FDL0U7UUFFRCxRQUFRLEdBQUcsY0FBYyxDQUFDLFFBQVEsQ0FBQztRQUNuQyxPQUFPLGNBQWMsQ0FBQyxRQUFRLENBQUM7S0FDaEM7SUFFRCxJQUFNLE9BQU8sR0FBTSxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsU0FBSSxNQUFRLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE1BQUksU0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUU1SCxPQUFPLElBQUksT0FBTyxDQUFDLFVBQUMsT0FBTyxFQUFFLE1BQU07UUFDakMsbUJBQVMsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFO1lBQzFCLE1BQU0sUUFBQTtZQUNOLGdCQUFnQixFQUFFLEtBQUs7WUFDdkIsTUFBTSxFQUFFLG1CQUFXLENBQUMsY0FBYyxDQUFDO1NBQ3BDLENBQUM7YUFDQyxJQUFJLENBQUMsVUFBQSxHQUFHLElBQUksT0FBQSxPQUFPLENBQUMsTUFBTSxLQUFLLHNCQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQTlELENBQThELENBQUM7YUFDM0UsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25CLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDIiwiZmlsZSI6ImxpYi9hcGkvZmlsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFNlY3VyaXR5LCBTZXNzaW9uIH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7IEZpbGVsaW5rIH0gZnJvbSAnLi8uLi9maWxlbGluayc7XG5pbXBvcnQgeyByZW1vdmVFbXB0eSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEZzUmVzcG9uc2UgfSBmcm9tICcuLy4uL3JlcXVlc3QvdHlwZXMnO1xuaW1wb3J0IHsgRmlsZXN0YWNrRXJyb3IgfSBmcm9tICcuLy4uLy4uL2ZpbGVzdGFja19lcnJvcic7XG5pbXBvcnQgeyBnZXRWYWxpZGF0b3IsIE1ldGFkYXRhUGFyYW1zU2NoZW1hLCBSZXRyaWV2ZVBhcmFtc1NjaGVtYSB9IGZyb20gJy4vLi4vLi4vc2NoZW1hJztcbmltcG9ydCB7IEZzUmVxdWVzdCwgRnNIdHRwTWV0aG9kIH0gZnJvbSAnLi4vcmVxdWVzdCc7XG5cbi8qKlxuICogUmVtb3ZlIGdpdmVuIGZpbGVcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHNlc3Npb25cbiAqIEBwYXJhbSBoYW5kbGVcbiAqIEBwYXJhbSBzZWN1cml0eVxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlID0gKHNlc3Npb246IFNlc3Npb24sIGhhbmRsZT86IHN0cmluZywgc2tpcFN0b3JhZ2U/OiBib29sZWFuLCBzZWN1cml0eT86IFNlY3VyaXR5KTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgaWYgKCFoYW5kbGUgfHwgdHlwZW9mIGhhbmRsZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRmlsZXN0YWNrRXJyb3IoJ0EgdmFsaWQgRmlsZXN0YWNrIGhhbmRsZSBpcyByZXF1aXJlZCBmb3IgcmVtb3ZlJyk7XG4gIH1cblxuICBpZiAoIShzZXNzaW9uLnBvbGljeSAmJiBzZXNzaW9uLnNpZ25hdHVyZSkgJiYgKCFzZWN1cml0eSB8fCAhKHNlY3VyaXR5LnBvbGljeSAmJiBzZWN1cml0eS5zaWduYXR1cmUpKSkge1xuICAgIHRocm93IG5ldyBGaWxlc3RhY2tFcnJvcignU2VjdXJpdHkgcG9saWN5IGFuZCBzaWduYXR1cmUgYXJlIHJlcXVpcmVkIGZvciByZW1vdmUnKTtcbiAgfVxuXG4gIGNvbnN0IGZpbGVBcGlVcmwgPSBzZXNzaW9uLnVybHMuZmlsZUFwaVVybDtcbiAgY29uc3QgYmFzZVVSTCA9IGAke2ZpbGVBcGlVcmx9LyR7aGFuZGxlfWA7XG4gIGNvbnN0IG9wdGlvbnM6IGFueSA9IHtcbiAgICBrZXk6IHNlc3Npb24uYXBpa2V5LFxuICAgIHBvbGljeTogKHNlY3VyaXR5ICYmIHNlY3VyaXR5LnBvbGljeSkgfHwgc2Vzc2lvbi5wb2xpY3ksXG4gICAgc2lnbmF0dXJlOiAoc2VjdXJpdHkgJiYgc2VjdXJpdHkuc2lnbmF0dXJlKSB8fCBzZXNzaW9uLnNpZ25hdHVyZSxcbiAgfTtcblxuICBpZiAoc2tpcFN0b3JhZ2UpIHtcbiAgICBvcHRpb25zLnNraXBfc3RvcmFnZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gRnNSZXF1ZXN0LmRlbGV0ZShiYXNlVVJMLCB7XG4gICAgZmlsZXN0YWNrSGVhZGVyczogZmFsc2UsXG4gICAgcGFyYW1zOiByZW1vdmVFbXB0eShvcHRpb25zKSxcbiAgfSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIE1ldGFkYXRhT3B0aW9ucyB7XG4gIHNpemU/OiBib29sZWFuO1xuICBtaW1ldHlwZT86IGJvb2xlYW47XG4gIGZpbGVuYW1lPzogYm9vbGVhbjtcbiAgd2lkdGg/OiBib29sZWFuO1xuICBoZWlnaHQ/OiBib29sZWFuO1xuICB1cGxvYWRlZD86IGJvb2xlYW47XG4gIHdyaXRlYWJsZT86IGJvb2xlYW47XG4gIGNsb3VkPzogYm9vbGVhbjtcbiAgc291cmNlVXJsPzogYm9vbGVhbjtcbiAgbWQ1PzogYm9vbGVhbjtcbiAgc2hhMT86IGJvb2xlYW47XG4gIHNoYTIyND86IGJvb2xlYW47XG4gIHNoYTI1Nj86IGJvb2xlYW47XG4gIHNoYTM4ND86IGJvb2xlYW47XG4gIHNoYTUxMj86IGJvb2xlYW47XG4gIGxvY2F0aW9uPzogYm9vbGVhbjtcbiAgcGF0aD86IGJvb2xlYW47XG4gIGNvbnRhaW5lcj86IGJvb2xlYW47XG4gIGV4aWY/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFJldHVybnMgZmlsZSBtZXRhZGF0YVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gc2Vzc2lvblxuICogQHBhcmFtIGhhbmRsZVxuICogQHBhcmFtIG9wdHNcbiAqIEBwYXJhbSBzZWN1cml0eVxuICovXG5leHBvcnQgY29uc3QgbWV0YWRhdGEgPSAoc2Vzc2lvbjogU2Vzc2lvbiwgaGFuZGxlPzogc3RyaW5nLCBvcHRzPzogTWV0YWRhdGFPcHRpb25zLCBzZWN1cml0eT86IFNlY3VyaXR5KTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgaWYgKCFoYW5kbGUgfHwgdHlwZW9mIGhhbmRsZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRmlsZXN0YWNrRXJyb3IoJ0EgdmFsaWQgRmlsZXN0YWNrIGhhbmRsZSBpcyByZXF1aXJlZCBmb3IgbWV0YWRhdGEnKTtcbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRlUmVzID0gZ2V0VmFsaWRhdG9yKE1ldGFkYXRhUGFyYW1zU2NoZW1hKShvcHRzKTtcblxuICBpZiAodmFsaWRhdGVSZXMuZXJyb3JzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBGaWxlc3RhY2tFcnJvcihgSW52YWxpZCBtZXRhZGF0YSBwYXJhbXNgLCB2YWxpZGF0ZVJlcy5lcnJvcnMpO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9uczogYW55ID0geyAuLi5vcHRzIH07XG4gIG9wdGlvbnMuc291cmNlX3VybCA9IG9wdGlvbnMuc291cmNlVXJsOyAvLyBzb3VyY2VfdXJsIGlzIHNuYWtlX2Nhc2VcbiAgb3B0aW9ucy5wb2xpY3kgPSAoc2VjdXJpdHkgJiYgc2VjdXJpdHkucG9saWN5KSB8fCBzZXNzaW9uLnBvbGljeTtcbiAgb3B0aW9ucy5zaWduYXR1cmUgPSAoc2VjdXJpdHkgJiYgc2VjdXJpdHkuc2lnbmF0dXJlKSB8fCBzZXNzaW9uLnNpZ25hdHVyZTtcblxuICBjb25zdCBiYXNlVVJMID0gYCR7c2Vzc2lvbi51cmxzLmZpbGVBcGlVcmx9LyR7aGFuZGxlfS9tZXRhZGF0YWA7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgRnNSZXF1ZXN0LmdldChiYXNlVVJMLCB7IHBhcmFtczogcmVtb3ZlRW1wdHkob3B0aW9ucyksIGZpbGVzdGFja0hlYWRlcnM6IGZhbHNlIH0pXG4gICAgICAudGhlbihyZXMgPT4gcmVzb2x2ZSh7IC4uLnJlcy5kYXRhLCBoYW5kbGUgfSkpXG4gICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIERvd25sb2FkIGZpbGUgdG8gYmxvYiBvciBidWZmZXIgZm9ybWF0XG4gKlxuICogQHBhcmFtIHNlc3Npb25cbiAqIEBwYXJhbSBoYW5kbGVcbiAqL1xuZXhwb3J0IGNvbnN0IGRvd25sb2FkID0gKHNlc3Npb246IFNlc3Npb24sIGhhbmRsZTogc3RyaW5nLCAgc2VjdXJpdHk/OiBTZWN1cml0eSk6IFByb21pc2U8RnNSZXNwb25zZT4gPT4ge1xuICBjb25zdCBmbCA9IG5ldyBGaWxlbGluayhoYW5kbGUsIHNlc3Npb24uYXBpa2V5KTtcblxuICBjb25zdCBwb2xpY3kgPSAoc2VjdXJpdHkgJiYgc2VjdXJpdHkucG9saWN5KSB8fCBzZXNzaW9uLnBvbGljeTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gKHNlY3VyaXR5ICYmIHNlY3VyaXR5LnNpZ25hdHVyZSkgfHwgc2Vzc2lvbi5zaWduYXR1cmU7XG5cbiAgaWYgKHBvbGljeSAmJiBzaWduYXR1cmUpIHtcbiAgICBmbC5zZWN1cml0eSh7IHNpZ25hdHVyZSwgcG9saWN5IH0pO1xuICB9XG5cbiAgcmV0dXJuIEZzUmVxdWVzdC5kaXNwYXRjaChmbC50b1N0cmluZygpLCB7IG1ldGhvZDogRnNIdHRwTWV0aG9kLkdFVCwgYmxvYlJlc3BvbnNlOiB0cnVlIH0pO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBSZXRyaWV2ZU9wdGlvbnMge1xuICBtZXRhZGF0YT86IGJvb2xlYW47XG4gIGhlYWQ/OiBib29sZWFuO1xuICBkbD86IGJvb2xlYW47XG4gIGV4dGVuc2lvbj86IHN0cmluZztcbiAgY2FjaGU/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFJldHVybnMgZmlsZSBpbmZvcm1hdGlvblxuICpcbiAqIEBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHNlc3Npb25cbiAqIEBwYXJhbSBoYW5kbGVcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gc2VjdXJpdHlcbiAqL1xuZXhwb3J0IGNvbnN0IHJldHJpZXZlID0gKHNlc3Npb246IFNlc3Npb24sIGhhbmRsZTogc3RyaW5nLCBvcHRpb25zOiBSZXRyaWV2ZU9wdGlvbnMgPSB7fSwgc2VjdXJpdHk/OiBTZWN1cml0eSk6IFByb21pc2U8T2JqZWN0IHwgQmxvYj4gPT4ge1xuICBpZiAoIWhhbmRsZSB8fCBoYW5kbGUubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBoYW5kbGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEZpbGVzdGFja0Vycm9yKCdGaWxlIGhhbmRsZSBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgY29uc29sZS5pbmZvKCdSZXRyaWV2ZSBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgaXQgd2lsbCBiZSByZW1vdmVkLiBQbGVhc2UgdXNlIG1ldGFkYXRhIG9yIGRvd25sb2FkJyk7XG5cbiAgY29uc3QgdmFsaWRhdGVSZXMgPSBnZXRWYWxpZGF0b3IoUmV0cmlldmVQYXJhbXNTY2hlbWEpKG9wdGlvbnMpO1xuXG4gIGlmICh2YWxpZGF0ZVJlcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEZpbGVzdGFja0Vycm9yKGBJbnZhbGlkIHJldHJpZXZlIHBhcmFtc2AsIHZhbGlkYXRlUmVzLmVycm9ycyk7XG4gIH1cblxuICBjb25zdCByZXF1ZXN0T3B0aW9uczogYW55ID0geyAuLi5vcHRpb25zIH07XG4gIHJlcXVlc3RPcHRpb25zLmtleSA9IHNlc3Npb24uYXBpa2V5O1xuICByZXF1ZXN0T3B0aW9ucy5wb2xpY3kgPSAoc2VjdXJpdHkgJiYgc2VjdXJpdHkucG9saWN5KSB8fCBzZXNzaW9uLnBvbGljeTtcbiAgcmVxdWVzdE9wdGlvbnMuc2lnbmF0dXJlID0gKHNlY3VyaXR5ICYmIHNlY3VyaXR5LnNpZ25hdHVyZSkgfHwgc2Vzc2lvbi5zaWduYXR1cmU7XG5cbiAgbGV0IG1ldGhvZDogRnNIdHRwTWV0aG9kID0gRnNIdHRwTWV0aG9kLkdFVDtcblxuICBpZiAocmVxdWVzdE9wdGlvbnMuaGVhZCkge1xuICAgIG1ldGhvZCA9IEZzSHR0cE1ldGhvZC5IRUFEO1xuICAgIGRlbGV0ZSByZXF1ZXN0T3B0aW9ucy5oZWFkO1xuICB9XG5cbiAgbGV0IGV4dGVuc2lvbjtcblxuICBpZiAocmVxdWVzdE9wdGlvbnMuZXh0ZW5zaW9uICYmIHJlcXVlc3RPcHRpb25zLmV4dGVuc2lvbi5sZW5ndGgpIHtcbiAgICBleHRlbnNpb24gPSByZXF1ZXN0T3B0aW9ucy5leHRlbnNpb247XG4gICAgZGVsZXRlIHJlcXVlc3RPcHRpb25zLmV4dGVuc2lvbjtcbiAgfVxuXG4gIGxldCBtZXRhZGF0YTtcbiAgaWYgKHJlcXVlc3RPcHRpb25zLm1ldGFkYXRhKSB7XG4gICAgaWYgKG1ldGhvZCA9PT0gRnNIdHRwTWV0aG9kLkhFQUQpIHtcbiAgICAgIHRocm93IG5ldyBGaWxlc3RhY2tFcnJvcignSGVhZCBhbmQgbWV0YWRhdGEgb3B0aW9ucyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlcicpO1xuICAgIH1cblxuICAgIG1ldGFkYXRhID0gcmVxdWVzdE9wdGlvbnMubWV0YWRhdGE7XG4gICAgZGVsZXRlIHJlcXVlc3RPcHRpb25zLm1ldGFkYXRhO1xuICB9XG5cbiAgY29uc3QgYmFzZVVSTCA9IGAke3Nlc3Npb24udXJscy5maWxlQXBpVXJsfS8ke2hhbmRsZX1gICsgKGV4dGVuc2lvbiA/IGArJHtleHRlbnNpb259YCA6ICcnKSArIChtZXRhZGF0YSA/ICcvbWV0YWRhdGEnIDogJycpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgRnNSZXF1ZXN0LmRpc3BhdGNoKGJhc2VVUkwsIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGZpbGVzdGFja0hlYWRlcnM6IGZhbHNlLFxuICAgICAgcGFyYW1zOiByZW1vdmVFbXB0eShyZXF1ZXN0T3B0aW9ucyksXG4gICAgfSlcbiAgICAgIC50aGVuKHJlcyA9PiByZXNvbHZlKG1ldGhvZCA9PT0gRnNIdHRwTWV0aG9kLkhFQUQgPyByZXMuaGVhZGVycyA6IHJlcy5kYXRhKSlcbiAgICAgIC5jYXRjaChyZWplY3QpO1xuICB9KTtcbn07XG4iXX0=


/***/ }),

/***/ 7953:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
// import Debug from 'debug';
var filestack_error_1 = __nccwpck_require__(4257);
var client_1 = __nccwpck_require__(9725);
var request_1 = __nccwpck_require__(5606);
var utils_1 = __nccwpck_require__(8123);
var cloneDeep = __nccwpck_require__(2061);
var PrefetchEvents;
(function (PrefetchEvents) {
    PrefetchEvents["PICKER"] = "picker";
    PrefetchEvents["TRANSFORM_UI"] = "transform_ui";
})(PrefetchEvents = exports.PrefetchEvents || (exports.PrefetchEvents = {}));
/**
 * @private
 */
var Prefetch = /** @class */ (function () {
    function Prefetch(param) {
        if (param instanceof client_1.Client) {
            this.session = param.session;
        }
        else {
            this.session = param;
        }
    }
    /**
     * Returns filestack options from backend according to input params
     *
     * @param param0
     */
    Prefetch.prototype.getConfig = function (_a) {
        var pickerOptions = _a.pickerOptions, settings = _a.settings, permissions = _a.permissions, events = _a.events;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var paramsToSend, pickerOptionsToSend;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                paramsToSend = {
                    apikey: this.session.apikey,
                };
                if (this.session.policy && this.session.signature) {
                    paramsToSend.security = { policy: this.session.policy, signature: this.session.signature };
                }
                // if (this.session.prefetch && events) {
                //   return FsRequest.post(`${this.session.urls.uploadApiUrl}/prefetch`, { ...paramsToSend, events }).then(() => this.session.prefetch);
                // }
                // we should always ask for this setting for picker
                if (!settings) {
                    settings = ['inapp_browser'];
                }
                else {
                    settings = settings.concat(['inapp_browser']);
                    // make arrray unique
                    settings = settings.filter(function (v, i) { return settings.indexOf(v) === i; });
                }
                if (pickerOptions && Object.keys(pickerOptions).length) {
                    pickerOptionsToSend = utils_1.cleanUpCallbacks(cloneDeep(tslib_1.__assign({}, pickerOptions)));
                }
                paramsToSend = tslib_1.__assign(tslib_1.__assign({}, paramsToSend), { permissions: permissions,
                    settings: settings, picker_config: pickerOptionsToSend, events: events });
                this.session.prefetch = null;
                return [2 /*return*/, request_1.FsRequest.post(this.session.urls.uploadApiUrl + "/prefetch", paramsToSend).then(function (res) {
                        /* istanbul ignore if */
                        if (res.status !== 200) {
                            throw new filestack_error_1.FilestackError('There is a problem with prefetch request');
                        }
                        var data = res.data;
                        // if backend not returning updated_config cay we take old config and return
                        if (data.updated_config) {
                            // reassign callback from old config to new one returned from backend
                            data.pickerOptions = _this.reassignCallbacks(pickerOptions, data.updated_config || {});
                            delete data.updated_config;
                        }
                        else {
                            data.pickerOptions = pickerOptions;
                        }
                        _this.session.prefetch = data;
                        return data;
                    })];
            });
        });
    };
    /**
     * Reassign callbacks from old picker configuration
     *
     * @param objOld
     * @param objTarget
     */
    Prefetch.prototype.reassignCallbacks = function (objOld, objTarget) {
        if (!objOld || Object.keys(objOld).length === 0) {
            return objOld;
        }
        for (var k in objOld) {
            if (typeof objOld[k] === 'function') {
                objTarget[k] = objOld[k];
            }
            if (objOld[k] === Object(objOld[k])) {
                objTarget[k] = this.reassignCallbacks(objOld[k], objTarget[k]);
            }
        }
        return objTarget;
    };
    return Prefetch;
}());
exports.Prefetch = Prefetch;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3ByZWZldGNoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7OztBQUVILDZCQUE2QjtBQUM3QiwyREFBeUQ7QUFDekQsc0NBQXdEO0FBRXhELHNDQUF1QztBQUN2QyxvQ0FBOEM7QUFDOUMsNENBQThDO0FBZ0I5QyxJQUFZLGNBR1g7QUFIRCxXQUFZLGNBQWM7SUFDeEIsbUNBQWlCLENBQUE7SUFDakIsK0NBQTZCLENBQUE7QUFDL0IsQ0FBQyxFQUhXLGNBQWMsR0FBZCxzQkFBYyxLQUFkLHNCQUFjLFFBR3pCO0FBeUJEOztHQUVHO0FBQ0g7SUFJRSxrQkFBWSxLQUF1QjtRQUNqQyxJQUFJLEtBQUssWUFBWSxlQUFNLEVBQUU7WUFDM0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDO1NBQzlCO2FBQU07WUFDTCxJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztTQUN0QjtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0csNEJBQVMsR0FBZixVQUFnQixFQUFpRTtZQUEvRCxnQ0FBYSxFQUFFLHNCQUFRLEVBQUUsNEJBQVcsRUFBRSxrQkFBTTs7Ozs7Z0JBQ3hELFlBQVksR0FBb0I7b0JBQ2xDLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU07aUJBQzVCLENBQUM7Z0JBRUYsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRTtvQkFDakQsWUFBWSxDQUFDLFFBQVEsR0FBRyxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQztpQkFDNUY7Z0JBRUQseUNBQXlDO2dCQUN6Qyx3SUFBd0k7Z0JBQ3hJLElBQUk7Z0JBRUosbURBQW1EO2dCQUNuRCxJQUFJLENBQUMs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KSAyMDE4IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vLyBpbXBvcnQgRGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgRmlsZXN0YWNrRXJyb3IgfSBmcm9tICcuLy4uLy4uL2ZpbGVzdGFja19lcnJvcic7XG5pbXBvcnQgeyBTZXNzaW9uLCBTZWN1cml0eSwgQ2xpZW50IH0gZnJvbSAnLi8uLi9jbGllbnQnO1xuaW1wb3J0IHsgUGlja2VyT3B0aW9ucyB9IGZyb20gJy4vLi4vcGlja2VyJztcbmltcG9ydCB7IEZzUmVxdWVzdCB9IGZyb20gJy4uL3JlcXVlc3QnO1xuaW1wb3J0IHsgY2xlYW5VcENhbGxiYWNrcyB9IGZyb20gJy4vLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgY2xvbmVEZWVwIGZyb20gJ2xvZGFzaC5jbG9uZWRlZXAnO1xuXG4vLyBjb25zdCBkZWJ1ZyA9IERlYnVnKCdmczpwcmVmZXRjaCcpO1xuXG5leHBvcnQgdHlwZSBQcmVmZXRjaFNldHRpbmdzID0ge1xuICBpbmFwcF9icm93c2VyPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIFByZWZldGNoUGVybWlzc2lvbnMgPSB7XG4gIGludGVsbGlnZW50X2luZ2VzdGlvbj86IGJvb2xlYW47XG4gIHdoaXRlbGFiZWw/OiBib29sZWFuO1xuICB0cmFuc2Zvcm1zX3VpPzogYm9vbGVhbjtcbiAgZW5oYW5jZT86IGJvb2xlYW47XG4gIGFkdmFuY2VkX2VuaGFuY2U/OiBib29sZWFuO1xufTtcblxuZXhwb3J0IGVudW0gUHJlZmV0Y2hFdmVudHMge1xuICBQSUNLRVIgPSAncGlja2VyJyxcbiAgVFJBTlNGT1JNX1VJID0gJ3RyYW5zZm9ybV91aScsXG59XG5cbmV4cG9ydCB0eXBlIFByZWZldGNoT3B0aW9ucyA9IHtcbiAgcGlja2VyT3B0aW9ucz86IFBpY2tlck9wdGlvbnM7XG4gIHNldHRpbmdzPzogQXJyYXk8a2V5b2YgUHJlZmV0Y2hTZXR0aW5ncz47XG4gIHBlcm1pc3Npb25zPzogQXJyYXk8a2V5b2YgUHJlZmV0Y2hQZXJtaXNzaW9ucz47XG4gIGV2ZW50cz86IFByZWZldGNoRXZlbnRzW107XG59O1xuXG5pbnRlcmZhY2UgUHJlZmV0Y2hSZXF1ZXN0IHtcbiAgYXBpa2V5OiBzdHJpbmc7XG4gIHNlY3VyaXR5PzogU2VjdXJpdHk7XG4gIHBlcm1pc3Npb25zPzogQXJyYXk8a2V5b2YgUHJlZmV0Y2hQZXJtaXNzaW9ucz47XG4gIHNldHRpbmdzPzogQXJyYXk8a2V5b2YgUHJlZmV0Y2hTZXR0aW5ncz47XG4gIGV2ZW50cz86IFByZWZldGNoRXZlbnRzW107XG4gIHBpY2tlcl9jb25maWc/OiBQaWNrZXJPcHRpb25zO1xufVxuXG5leHBvcnQgdHlwZSBQcmVmZXRjaFJlc3BvbnNlID0ge1xuICBibG9ja2VkPzogYm9vbGVhbiB8IHN0cmluZztcbiAgc2V0dGluZ3M/OiBQcmVmZXRjaFNldHRpbmdzO1xuICBwZXJtaXNzaW9ucz86IFByZWZldGNoUGVybWlzc2lvbnM7XG4gIHBpY2tlck9wdGlvbnM6IFBpY2tlck9wdGlvbnM7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBQcmVmZXRjaCB7XG5cbiAgcHJpdmF0ZSBzZXNzaW9uOiBTZXNzaW9uO1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtOiBTZXNzaW9uIHwgQ2xpZW50KSB7XG4gICAgaWYgKHBhcmFtIGluc3RhbmNlb2YgQ2xpZW50KSB7XG4gICAgICB0aGlzLnNlc3Npb24gPSBwYXJhbS5zZXNzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlc3Npb24gPSBwYXJhbTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmaWxlc3RhY2sgb3B0aW9ucyBmcm9tIGJhY2tlbmQgYWNjb3JkaW5nIHRvIGlucHV0IHBhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0gcGFyYW0wXG4gICAqL1xuICBhc3luYyBnZXRDb25maWcoeyBwaWNrZXJPcHRpb25zLCBzZXR0aW5ncywgcGVybWlzc2lvbnMsIGV2ZW50cyB9OiBQcmVmZXRjaE9wdGlvbnMpOiBQcm9taXNlPFByZWZldGNoUmVzcG9uc2U+IHtcbiAgICBsZXQgcGFyYW1zVG9TZW5kOiBQcmVmZXRjaFJlcXVlc3QgPSB7XG4gICAgICBhcGlrZXk6IHRoaXMuc2Vzc2lvbi5hcGlrZXksXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnNlc3Npb24ucG9saWN5ICYmIHRoaXMuc2Vzc2lvbi5zaWduYXR1cmUpIHtcbiAgICAgIHBhcmFtc1RvU2VuZC5zZWN1cml0eSA9IHsgcG9saWN5OiB0aGlzLnNlc3Npb24ucG9saWN5LCBzaWduYXR1cmU6IHRoaXMuc2Vzc2lvbi5zaWduYXR1cmUgfTtcbiAgICB9XG5cbiAgICAvLyBpZiAodGhpcy5zZXNzaW9uLnByZWZldGNoICYmIGV2ZW50cykge1xuICAgIC8vICAgcmV0dXJuIEZzUmVxdWVzdC5wb3N0KGAke3RoaXMuc2Vzc2lvbi51cmxzLnVwbG9hZEFwaVVybH0vcHJlZmV0Y2hgLCB7IC4uLnBhcmFtc1RvU2VuZCwgZXZlbnRzIH0pLnRoZW4oKCkgPT4gdGhpcy5zZXNzaW9uLnByZWZldGNoKTtcbiAgICAvLyB9XG5cbiAgICAvLyB3ZSBzaG91bGQgYWx3YXlzIGFzayBmb3IgdGhpcyBzZXR0aW5nIGZvciBwaWNrZXJcbiAgICBpZiAoIXNldHRpbmdzKSB7XG4gICAgICBzZXR0aW5ncyA9IFsnaW5hcHBfYnJvd3NlciddO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXR0aW5ncyA9IHNldHRpbmdzLmNvbmNhdChbJ2luYXBwX2Jyb3dzZXInXSk7XG4gICAgICAvLyBtYWtlIGFycnJheSB1bmlxdWVcbiAgICAgIHNldHRpbmdzID0gc2V0dGluZ3MuZmlsdGVyKCh2LCBpKSA9PiBzZXR0aW5ncy5pbmRleE9mKHYpID09PSBpKTtcbiAgICB9XG5cbiAgICBsZXQgcGlja2VyT3B0aW9uc1RvU2VuZDtcbiAgICBpZiAocGlja2VyT3B0aW9ucyAmJiBPYmplY3Qua2V5cyhwaWNrZXJPcHRpb25zKS5sZW5ndGgpIHtcbiAgICAgIHBpY2tlck9wdGlvbnNUb1NlbmQgPSBjbGVhblVwQ2FsbGJhY2tzKGNsb25lRGVlcCh7IC4uLnBpY2tlck9wdGlvbnMgfSkpO1xuICAgIH1cblxuICAgIHBhcmFtc1RvU2VuZCA9IHtcbiAgICAgIC4uLnBhcmFtc1RvU2VuZCxcbiAgICAgIHBlcm1pc3Npb25zLFxuICAgICAgc2V0dGluZ3MsXG4gICAgICBwaWNrZXJfY29uZmlnOiBwaWNrZXJPcHRpb25zVG9TZW5kLFxuICAgICAgZXZlbnRzLFxuICAgIH07XG5cbiAgICB0aGlzLnNlc3Npb24ucHJlZmV0Y2ggPSBudWxsO1xuXG4gICAgcmV0dXJuIEZzUmVxdWVzdC5wb3N0KGAke3RoaXMuc2Vzc2lvbi51cmxzLnVwbG9hZEFwaVVybH0vcHJlZmV0Y2hgLCBwYXJhbXNUb1NlbmQpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWxlc3RhY2tFcnJvcignVGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggcHJlZmV0Y2ggcmVxdWVzdCcpO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YSA9IHJlcy5kYXRhO1xuXG4gICAgICAvLyBpZiBiYWNrZW5kIG5vdCByZXR1cm5pbmcgdXBkYXRlZF9jb25maWcgY2F5IHdlIHRha2Ugb2xkIGNvbmZpZyBhbmQgcmV0dXJuXG4gICAgICBpZiAoZGF0YS51cGRhdGVkX2NvbmZpZykge1xuICAgICAgICAvLyByZWFzc2lnbiBjYWxsYmFjayBmcm9tIG9sZCBjb25maWcgdG8gbmV3IG9uZSByZXR1cm5lZCBmcm9tIGJhY2tlbmRcbiAgICAgICAgZGF0YS5waWNrZXJPcHRpb25zID0gdGhpcy5yZWFzc2lnbkNhbGxiYWNrcyhwaWNrZXJPcHRpb25zLCBkYXRhLnVwZGF0ZWRfY29uZmlnIHx8IHt9KTtcbiAgICAgICAgZGVsZXRlIGRhdGEudXBkYXRlZF9jb25maWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLnBpY2tlck9wdGlvbnMgPSBwaWNrZXJPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNlc3Npb24ucHJlZmV0Y2ggPSBkYXRhO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFzc2lnbiBjYWxsYmFja3MgZnJvbSBvbGQgcGlja2VyIGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQHBhcmFtIG9iak9sZFxuICAgKiBAcGFyYW0gb2JqVGFyZ2V0XG4gICAqL1xuICBwcml2YXRlIHJlYXNzaWduQ2FsbGJhY2tzKG9iak9sZCwgb2JqVGFyZ2V0KSB7XG4gICAgaWYgKCFvYmpPbGQgfHwgT2JqZWN0LmtleXMob2JqT2xkKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBvYmpPbGQ7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrIGluIG9iak9sZCkge1xuICAgICAgaWYgKHR5cGVvZiBvYmpPbGRba10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqVGFyZ2V0W2tdID0gb2JqT2xkW2tdO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqT2xkW2tdID09PSBPYmplY3Qob2JqT2xkW2tdKSkge1xuICAgICAgICBvYmpUYXJnZXRba10gPSB0aGlzLnJlYXNzaWduQ2FsbGJhY2tzKG9iak9sZFtrXSwgb2JqVGFyZ2V0W2tdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqVGFyZ2V0O1xuICB9XG59XG4iXX0=


/***/ }),

/***/ 5653:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var utils_1 = __nccwpck_require__(8123);
var schema_1 = __nccwpck_require__(2782);
var filestack_error_1 = __nccwpck_require__(4257);
/**
 * Returns file preview url
 *
 * @private
 * @param session
 * @param handle
 * @param opts
 * @param security
 */
exports.getUrl = function (session, handle, opts, security) {
    var options = tslib_1.__assign({}, opts);
    var policy = security && security.policy || session.policy;
    var signature = security && security.signature || session.signature;
    var hasSecurity = signature && policy;
    var baseUrl = [session.urls.cdnUrl];
    var css = options.css && encodeURIComponent("\"" + options.css + "\"");
    var previewTask = css ? "preview=css:" + css : 'preview';
    // @todo move to utils?
    if (handle.indexOf('src:') !== -1) {
        baseUrl.push(session.apikey + "/" + previewTask);
    }
    else {
        baseUrl.push(previewTask);
    }
    if (hasSecurity) {
        baseUrl.push("security=policy:" + policy + ",signature:" + signature);
    }
    baseUrl.push(handle);
    return baseUrl.join('/');
};
/**
 * Appends image preview into page
 *
 * @private
 * @param session
 * @param handle
 * @param opts
 */
exports.preview = function (session, handle, opts) {
    if (!handle || typeof handle !== 'string') {
        throw new Error('A valid Filestack handle or storage alias is required for preview');
    }
    var validateRes = schema_1.getValidator(schema_1.PreviewParamsSchema)(opts);
    if (validateRes.errors.length) {
        throw new filestack_error_1.FilestackError("Invalid preview params", validateRes.errors, filestack_error_1.FilestackErrorType.VALIDATION);
    }
    var options = utils_1.removeEmpty(opts || {});
    var url = exports.getUrl(session, handle, options);
    if (options && options.id) {
        var id = options.id;
        var iframe = document.createElement('iframe');
        var domElement = document.getElementById(id);
        iframe.src = url;
        iframe.width = '100%';
        iframe.height = '100%';
        if (!domElement) {
            throw new Error("DOM Element with id \"" + id + "\" not found.");
        }
        return domElement.appendChild(iframe);
    }
    return window.open(url, handle);
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3ByZXZpZXcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRzs7O0FBR0gsa0NBQXVDO0FBQ3ZDLHlDQUFtRTtBQUNuRSwyREFBNkU7QUFjN0U7Ozs7Ozs7O0dBUUc7QUFDVSxRQUFBLE1BQU0sR0FBRyxVQUNwQixPQUFnQixFQUNoQixNQUFjLEVBQ2QsSUFBVSxFQUNWLFFBQW1CO0lBRW5CLElBQU0sT0FBTyx3QkFBUSxJQUFJLENBQUUsQ0FBQztJQUM1QixJQUFNLE1BQU0sR0FBRyxRQUFRLElBQUksUUFBUSxDQUFDLE1BQU0sSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDO0lBQzdELElBQU0sU0FBUyxHQUFHLFFBQVEsSUFBSSxRQUFRLENBQUMsU0FBUyxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUM7SUFDdEUsSUFBTSxXQUFXLEdBQUcsU0FBUyxJQUFJLE1BQU0sQ0FBQztJQUN4QyxJQUFNLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdEMsSUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsSUFBSSxrQkFBa0IsQ0FBQyxPQUFJLE9BQU8sQ0FBQyxHQUFHLE9BQUcsQ0FBQyxDQUFDO0lBQ2xFLElBQU0sV0FBVyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsaUJBQWUsR0FBSyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFFM0QsdUJBQXVCO0lBQ3ZCLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtRQUNqQyxPQUFPLENBQUMsSUFBSSxDQUFJLE9BQU8sQ0FBQyxNQUFNLFNBQUksV0FBYSxDQUFDLENBQUM7S0FDbEQ7U0FBTTtRQUNMLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7S0FDM0I7SUFDRCxJQUFJLFdBQVcsRUFBRTtRQUNmLE9BQU8sQ0FBQyxJQUFJLENBQUMscUJBQW1CLE1BQU0sbUJBQWMsU0FBVyxDQUFDLENBQUM7S0FDbEU7SUFFRCxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3JCLE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUMzQixDQUFDLENBQUM7QUFFRjs7Ozs7OztHQU9HO0FBQ1UsUUFBQSxPQUFPLEdBQUcsVUFBQyxPQUFnQixFQUFFLE1BQWUsRUFBRSxJQUFxQjtJQUM5RSxJQUFJLENBQUMsTUFBTSxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRTtRQUN6QyxNQUFNLElBQUksS0FBSyxDQUFDLG1FQUFtRSxDQUFDLENBQUM7S0FDdEY7SUFFRCxJQUFNLFdBQVcsR0FBRyxxQkFBWSxDQUFDLDRCQUFtQixDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFNUQsSUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTtRQUM3QixNQUFNLElBQUksZ0NBQWMsQ0FBQyx3QkFBd0IsRUFBRSxXQUFXLENBQUMsTUFBTSxFQUFFLG9DQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUFDO0tBQ3ZHO0lBRUQsSUFBTSxPQUFPLEdBQUcsbUJBQVcsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDLENBQUM7SUFDeEMsSUFBTSxHQUFHLEdBQUcsY0FBTSxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFFN0MsSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLEVBQUUsRUFBRTtRQUN6QixJQUFNLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDO1FBQ3RCLElBQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEQsSUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUUvQyxNQUFNLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNqQixNQUFNLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQztRQUN0QixNQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUV2QixJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ2YsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBd0IsRUFBRSxrQkFBYyxDQUFDLENBQUM7U0FDM0Q7UUFDRCxPQUFPLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDdkM7SUFDRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ2xDLENBQUMsQ0FBQyIsImZpbGUiOiJsaWIvYXBpL3ByZXZpZXcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBTZWN1cml0eSwgU2Vzc2lvbiB9IGZyb20gJy4uL2NsaWVudCc7XG5pbXBvcnQgeyByZW1vdmVFbXB0eSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldFZhbGlkYXRvciwgUHJldmlld1BhcmFtc1NjaGVtYSB9IGZyb20gJy4vLi4vLi4vc2NoZW1hJztcbmltcG9ydCB7IEZpbGVzdGFja0Vycm9yLCBGaWxlc3RhY2tFcnJvclR5cGUgfSBmcm9tICcuLy4uLy4uL2ZpbGVzdGFja19lcnJvcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJldmlld09wdGlvbnMge1xuICAvKipcbiAgICogSWQgZm9yIERPTSBlbGVtZW50IHRvIGVtYmVkIHByZXZpZXcgaW50by5cbiAgICogT21pdCB0aGlzIHRvIG9wZW4gdGhlIHByZXZpZXcgaW4gYSBuZXcgdGFiXG4gICAqL1xuICBpZDogc3RyaW5nO1xuICAvKipcbiAgICogVVJMIHRvIGN1c3RvbSBDU1NcbiAgICovXG4gIGNzcz86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGZpbGUgcHJldmlldyB1cmxcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHNlc3Npb25cbiAqIEBwYXJhbSBoYW5kbGVcbiAqIEBwYXJhbSBvcHRzXG4gKiBAcGFyYW0gc2VjdXJpdHlcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFVybCA9IChcbiAgc2Vzc2lvbjogU2Vzc2lvbixcbiAgaGFuZGxlOiBzdHJpbmcsXG4gIG9wdHM/OiBhbnksXG4gIHNlY3VyaXR5PzogU2VjdXJpdHlcbikgPT4ge1xuICBjb25zdCBvcHRpb25zID0geyAuLi5vcHRzIH07XG4gIGNvbnN0IHBvbGljeSA9IHNlY3VyaXR5ICYmIHNlY3VyaXR5LnBvbGljeSB8fCBzZXNzaW9uLnBvbGljeTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gc2VjdXJpdHkgJiYgc2VjdXJpdHkuc2lnbmF0dXJlIHx8IHNlc3Npb24uc2lnbmF0dXJlO1xuICBjb25zdCBoYXNTZWN1cml0eSA9IHNpZ25hdHVyZSAmJiBwb2xpY3k7XG4gIGNvbnN0IGJhc2VVcmwgPSBbc2Vzc2lvbi51cmxzLmNkblVybF07XG4gIGNvbnN0IGNzcyA9IG9wdGlvbnMuY3NzICYmIGVuY29kZVVSSUNvbXBvbmVudChgXCIke29wdGlvbnMuY3NzfVwiYCk7XG4gIGNvbnN0IHByZXZpZXdUYXNrID0gY3NzID8gYHByZXZpZXc9Y3NzOiR7Y3NzfWAgOiAncHJldmlldyc7XG5cbiAgLy8gQHRvZG8gbW92ZSB0byB1dGlscz9cbiAgaWYgKGhhbmRsZS5pbmRleE9mKCdzcmM6JykgIT09IC0xKSB7XG4gICAgYmFzZVVybC5wdXNoKGAke3Nlc3Npb24uYXBpa2V5fS8ke3ByZXZpZXdUYXNrfWApO1xuICB9IGVsc2Uge1xuICAgIGJhc2VVcmwucHVzaChwcmV2aWV3VGFzayk7XG4gIH1cbiAgaWYgKGhhc1NlY3VyaXR5KSB7XG4gICAgYmFzZVVybC5wdXNoKGBzZWN1cml0eT1wb2xpY3k6JHtwb2xpY3l9LHNpZ25hdHVyZToke3NpZ25hdHVyZX1gKTtcbiAgfVxuXG4gIGJhc2VVcmwucHVzaChoYW5kbGUpO1xuICByZXR1cm4gYmFzZVVybC5qb2luKCcvJyk7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgaW1hZ2UgcHJldmlldyBpbnRvIHBhZ2VcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHNlc3Npb25cbiAqIEBwYXJhbSBoYW5kbGVcbiAqIEBwYXJhbSBvcHRzXG4gKi9cbmV4cG9ydCBjb25zdCBwcmV2aWV3ID0gKHNlc3Npb246IFNlc3Npb24sIGhhbmRsZT86IHN0cmluZywgb3B0cz86IFByZXZpZXdPcHRpb25zKSA9PiB7XG4gIGlmICghaGFuZGxlIHx8IHR5cGVvZiBoYW5kbGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIHZhbGlkIEZpbGVzdGFjayBoYW5kbGUgb3Igc3RvcmFnZSBhbGlhcyBpcyByZXF1aXJlZCBmb3IgcHJldmlldycpO1xuICB9XG5cbiAgY29uc3QgdmFsaWRhdGVSZXMgPSBnZXRWYWxpZGF0b3IoUHJldmlld1BhcmFtc1NjaGVtYSkob3B0cyk7XG5cbiAgaWYgKHZhbGlkYXRlUmVzLmVycm9ycy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRmlsZXN0YWNrRXJyb3IoYEludmFsaWQgcHJldmlldyBwYXJhbXNgLCB2YWxpZGF0ZVJlcy5lcnJvcnMsIEZpbGVzdGFja0Vycm9yVHlwZS5WQUxJREFUSU9OKTtcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSByZW1vdmVFbXB0eShvcHRzIHx8IHt9KTtcbiAgY29uc3QgdXJsID0gZ2V0VXJsKHNlc3Npb24sIGhhbmRsZSwgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pZCkge1xuICAgIGNvbnN0IGlkID0gb3B0aW9ucy5pZDtcbiAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXG4gICAgaWZyYW1lLnNyYyA9IHVybDtcbiAgICBpZnJhbWUud2lkdGggPSAnMTAwJSc7XG4gICAgaWZyYW1lLmhlaWdodCA9ICcxMDAlJztcblxuICAgIGlmICghZG9tRWxlbWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBET00gRWxlbWVudCB3aXRoIGlkIFwiJHtpZH1cIiBub3QgZm91bmQuYCk7XG4gICAgfVxuICAgIHJldHVybiBkb21FbGVtZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5vcGVuKHVybCwgaGFuZGxlKTtcbn07XG4iXX0=


/***/ }),

/***/ 167:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(1051), exports);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3NlY3VyaXR5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7OztBQXVCSCwwREFBZ0MiLCJmaWxlIjoibGliL2FwaS9zZWN1cml0eS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQ29uZmlndXJlcyBhIHNlY3VyaXR5IHBvbGljeVxuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2NvbmNlcHRzL3NlY3VyaXR5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VjdXJpdHlPcHRpb25zIHtcbiAgZXhwaXJ5OiBudW1iZXI7XG4gIGNhbGw/OiBhbnlbXTtcbiAgaGFuZGxlPzogc3RyaW5nO1xuICB1cmw/OiBzdHJpbmc7XG4gIG1heFNpemU/OiBudW1iZXI7XG4gIG1pblNpemU/OiBudW1iZXI7XG4gIHBhdGg/OiBzdHJpbmc7XG4gIGNvbnRhaW5lcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXZWJob29rVmFsaWRhdGVQYXlsb2FkIHtcbiAgdGltZXN0YW1wOiBzdHJpbmc7XG4gIHNpZ25hdHVyZTogc3RyaW5nO1xufVxuXG5leHBvcnQgKiBmcm9tICcuL3NlY3VyaXR5Lm5vZGUnO1xuIl19


/***/ }),

/***/ 1051:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var filestack_error_1 = __nccwpck_require__(4257);
var schema_1 = __nccwpck_require__(2782);
var crypto = __nccwpck_require__(6417);
/**
 * Returns Filestack base64 policy and HMAC-SHA256 signature
 *
 * ### Example
 *
 * ```js
 * import * as filestack from 'filestack-js';
 *
 * const jsonPolicy = { 'expiry': 253381964415 };
 * const security = filestack.getSecurity(jsonPolicy, '<YOUR_APP_SECRET>');
 * ```
 *
 * @param policyOptions
 * @param appSecret
 */
exports.getSecurity = function (policyOptions, appSecret) {
    var validateRes = schema_1.getValidator(schema_1.SecurityParamsSchema)(policyOptions);
    if (validateRes.errors.length) {
        throw new filestack_error_1.FilestackError("Invalid security params", validateRes.errors, filestack_error_1.FilestackErrorType.VALIDATION);
    }
    var policy = Buffer.from(JSON.stringify(policyOptions)).toString('base64');
    var signature = crypto.createHmac('sha256', appSecret)
        .update(policy)
        .digest('hex');
    return { policy: policy, signature: signature };
};
/**
 * Check webhook signature
 *
 * @param secret - app secred
 * @param rawBody - unchanged raw webhook body
 * @param toCompare - data from wh response headers
 */
exports.validateWebhookSignature = function (secret, rawBody, toCompare) {
    var hash = crypto.createHmac('sha256', secret)
        .update(toCompare.timestamp + "." + rawBody)
        .digest('hex');
    return hash === toCompare.signature;
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3NlY3VyaXR5Lm5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRzs7QUFJSCwyREFBNkU7QUFDN0UseUNBQW9FO0FBQ3BFLCtCQUFpQztBQUVqQzs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUNVLFFBQUEsV0FBVyxHQUFHLFVBQUMsYUFBOEIsRUFBRSxTQUFpQjtJQUMzRSxJQUFNLFdBQVcsR0FBRyxxQkFBWSxDQUFDLDZCQUFvQixDQUFDLENBQUMsYUFBYSxDQUFDLENBQUM7SUFFdEUsSUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTtRQUM3QixNQUFNLElBQUksZ0NBQWMsQ0FBQyx5QkFBeUIsRUFBRSxXQUFXLENBQUMsTUFBTSxFQUFFLG9DQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUFDO0tBQ3hHO0lBRUQsSUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdFLElBQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQztTQUN0QyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQ2QsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRWhDLE9BQU8sRUFBRSxNQUFNLFFBQUEsRUFBRSxTQUFTLFdBQUEsRUFBRSxDQUFDO0FBQy9CLENBQUMsQ0FBQztBQUVGOzs7Ozs7R0FNRztBQUNVLFFBQUEsd0JBQXdCLEdBQUcsVUFBQyxNQUFjLEVBQUUsT0FBZSxFQUFFLFNBQWlDO0lBQ3pHLElBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQztTQUNqQyxNQUFNLENBQUksU0FBUyxDQUFDLFNBQVMsU0FBSSxPQUFTLENBQUM7U0FDM0MsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRTdCLE9BQU8sSUFBSSxLQUFLLFNBQVMsQ0FBQyxTQUFTLENBQUM7QUFDdEMsQ0FBQyxDQUFDIiwiZmlsZSI6ImxpYi9hcGkvc2VjdXJpdHkubm9kZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFNlY3VyaXR5IH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7IFdlYmhvb2tWYWxpZGF0ZVBheWxvYWQsIFNlY3VyaXR5T3B0aW9ucyB9IGZyb20gJy4vc2VjdXJpdHknO1xuaW1wb3J0IHsgRmlsZXN0YWNrRXJyb3IsIEZpbGVzdGFja0Vycm9yVHlwZSB9IGZyb20gJy4vLi4vLi4vZmlsZXN0YWNrX2Vycm9yJztcbmltcG9ydCB7IGdldFZhbGlkYXRvciwgU2VjdXJpdHlQYXJhbXNTY2hlbWEgfSBmcm9tICcuLy4uLy4uL3NjaGVtYSc7XG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuLyoqXG4gKiBSZXR1cm5zIEZpbGVzdGFjayBiYXNlNjQgcG9saWN5IGFuZCBITUFDLVNIQTI1NiBzaWduYXR1cmVcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgKiBhcyBmaWxlc3RhY2sgZnJvbSAnZmlsZXN0YWNrLWpzJztcbiAqXG4gKiBjb25zdCBqc29uUG9saWN5ID0geyAnZXhwaXJ5JzogMjUzMzgxOTY0NDE1IH07XG4gKiBjb25zdCBzZWN1cml0eSA9IGZpbGVzdGFjay5nZXRTZWN1cml0eShqc29uUG9saWN5LCAnPFlPVVJfQVBQX1NFQ1JFVD4nKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwb2xpY3lPcHRpb25zXG4gKiBAcGFyYW0gYXBwU2VjcmV0XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTZWN1cml0eSA9IChwb2xpY3lPcHRpb25zOiBTZWN1cml0eU9wdGlvbnMsIGFwcFNlY3JldDogc3RyaW5nKTogU2VjdXJpdHkgPT4ge1xuICBjb25zdCB2YWxpZGF0ZVJlcyA9IGdldFZhbGlkYXRvcihTZWN1cml0eVBhcmFtc1NjaGVtYSkocG9saWN5T3B0aW9ucyk7XG5cbiAgaWYgKHZhbGlkYXRlUmVzLmVycm9ycy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRmlsZXN0YWNrRXJyb3IoYEludmFsaWQgc2VjdXJpdHkgcGFyYW1zYCwgdmFsaWRhdGVSZXMuZXJyb3JzLCBGaWxlc3RhY2tFcnJvclR5cGUuVkFMSURBVElPTik7XG4gIH1cblxuICBjb25zdCBwb2xpY3kgPSBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShwb2xpY3lPcHRpb25zKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICBjb25zdCBzaWduYXR1cmUgPSBjcnlwdG8uY3JlYXRlSG1hYygnc2hhMjU2JywgYXBwU2VjcmV0KVxuICAgICAgICAgICAgICAgICAgIC51cGRhdGUocG9saWN5KVxuICAgICAgICAgICAgICAgICAgIC5kaWdlc3QoJ2hleCcpO1xuXG4gIHJldHVybiB7IHBvbGljeSwgc2lnbmF0dXJlIH07XG59O1xuXG4vKipcbiAqIENoZWNrIHdlYmhvb2sgc2lnbmF0dXJlXG4gKlxuICogQHBhcmFtIHNlY3JldCAtIGFwcCBzZWNyZWRcbiAqIEBwYXJhbSByYXdCb2R5IC0gdW5jaGFuZ2VkIHJhdyB3ZWJob29rIGJvZHlcbiAqIEBwYXJhbSB0b0NvbXBhcmUgLSBkYXRhIGZyb20gd2ggcmVzcG9uc2UgaGVhZGVyc1xuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVXZWJob29rU2lnbmF0dXJlID0gKHNlY3JldDogc3RyaW5nLCByYXdCb2R5OiBzdHJpbmcsIHRvQ29tcGFyZTogV2ViaG9va1ZhbGlkYXRlUGF5bG9hZCkgPT4ge1xuICBjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIHNlY3JldClcbiAgICAgICAgICAgICAgICAudXBkYXRlKGAke3RvQ29tcGFyZS50aW1lc3RhbXB9LiR7cmF3Qm9keX1gKVxuICAgICAgICAgICAgICAgIC5kaWdlc3QoJ2hleCcpO1xuXG4gIHJldHVybiBoYXNoID09PSB0b0NvbXBhcmUuc2lnbmF0dXJlO1xufTtcbiJdfQ==


/***/ }),

/***/ 1989:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var filelink_1 = __nccwpck_require__(4915);
var filestack_error_1 = __nccwpck_require__(4257);
var schema_1 = __nccwpck_require__(2782);
var request_1 = __nccwpck_require__(5606);
/**
 * Store given url with options and
 *
 * @param session
 * @param url
 * @param storeOpts
 * @param token
 * @param security
 * @param uploadTags
 * @param workflowIds
 */
exports.storeURL = function (_a) {
    var session = _a.session, url = _a.url, storeParams = _a.storeParams, token = _a.token, security = _a.security, uploadTags = _a.uploadTags, headers = _a.headers, workflowIds = _a.workflowIds;
    if (!url || typeof url !== 'string') {
        return Promise.reject(new filestack_error_1.FilestackError('url is required for storeURL'));
    }
    var validateRes = schema_1.getValidator(schema_1.StoreParamsSchema)(storeParams);
    if (validateRes.errors.length) {
        return Promise.reject(new filestack_error_1.FilestackError("Invalid store params", validateRes.errors));
    }
    session.policy = security && security.policy || session.policy;
    session.signature = security && security.signature || session.signature;
    var filelink = new filelink_1.Filelink(url, session.apikey);
    filelink.store(storeParams);
    if (session.policy && session.signature) {
        filelink.security({
            policy: session.policy,
            signature: session.signature,
        });
    }
    var options = {};
    if (token) {
        var cancelToken = new request_1.FsCancelToken();
        token.cancel = cancelToken.cancel.bind(cancelToken);
        options.cancelToken = cancelToken;
    }
    var sources = [url];
    if (headers) {
        sources = [{
                source: url,
                headers: headers,
            }];
    }
    if (workflowIds && workflowIds.length > 0) {
        filelink.addTask('store', { workflows: workflowIds });
    }
    return request_1.FsRequest.post(session.urls.processUrl + "/process", {
        apikey: session.apikey,
        sources: sources,
        tasks: filelink.getTasks(),
        upload_tags: uploadTags,
    }, options).then(function (res) {
        if (res.data && res.data.handle) {
            if (res.data.upload_tags) {
                res.data.uploadTags = res.data.upload_tags;
                delete res.data.upload_tags;
            }
            return tslib_1.__assign(tslib_1.__assign({}, res.data), { mimetype: res.data.type });
        }
        throw new filestack_error_1.FilestackError("Invalid store response " + JSON.stringify(res.data));
    });
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3N0b3JlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7OztBQUdILDBDQUFzRDtBQUN0RCwyREFBeUQ7QUFDekQseUNBQWlFO0FBQ2pFLHNDQUFzRDtBQWN0RDs7Ozs7Ozs7OztHQVVHO0FBQ1UsUUFBQSxRQUFRLEdBQUcsVUFBQyxFQVNSO1FBUmYsb0JBQU8sRUFDUCxZQUFHLEVBQ0gsNEJBQVcsRUFDWCxnQkFBSyxFQUNMLHNCQUFRLEVBQ1IsMEJBQVUsRUFDVixvQkFBTyxFQUNQLDRCQUFXO0lBRVgsSUFBSSxDQUFDLEdBQUcsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7UUFDbkMsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksZ0NBQWMsQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDLENBQUM7S0FDM0U7SUFFRCxJQUFNLFdBQVcsR0FBRyxxQkFBWSxDQUFDLDBCQUFpQixDQUFDLENBQUMsV0FBVyxDQUFDLENBQUM7SUFFakUsSUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTtRQUM3QixPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxnQ0FBYyxDQUFDLHNCQUFzQixFQUFFLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0tBQ3ZGO0lBRUQsT0FBTyxDQUFDLE1BQU0sR0FBRyxRQUFRLElBQUksUUFBUSxDQUFDLE1BQU0sSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDO0lBQy9ELE9BQU8sQ0FBQyxTQUFTLEdBQUcsUUFBUSxJQUFJLFFBQVEsQ0FBQyxTQUFTLElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQztJQUV4RSxJQUFNLFFBQVEsR0FBRyxJQUFJLG1CQUFRLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNuRCxRQUFRLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBRTVCLElBQUksT0FBTyxDQUFDLE1BQU0sSUFBSSxPQUFPLENBQUMsU0FBUyxFQUFFO1FBQ3ZDLFFBQVEsQ0FBQyxRQUFRLENBQUM7WUFDaEIsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQUFNO1lBQ3RCLFNBQVMsRUFBRSxPQUFPLENBQUMsU0FBUztTQUM3QixDQUFDLENBQUM7S0FDSjtJQUVELElBQUksT0FBTyxHQUFRLEVBQUUsQ0FBQztJQUV0QixJQUFJLEtBQUssRUFBRTtRQUNULElBQU0sV0FBVyxHQUFHLElBQUksdUJBQWEsRUFBRSxDQUFDO1FBQ3hDLEtBQUssQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDcEQsT0FBTyxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7S0FDbkM7SUFFRCxJQUFJLE9BQU8sR0FBUSxDQUFFLEdBQUcsQ0FBRSxDQUFDO0lBRTNCLElBQUksT0FBTyxFQUFFO1FBQ1gsT0FBTyxHQUFHLENBQUM7Z0JBQ1QsTUFBTSxFQUFFLEdBQUc7Z0JBQ1gsT0FBTyxTQUFBO2FBQ1IsQ0FBQyxDQUFDO0tBQ0o7SUFFRCxJQUFJLFdBQVcsSUFBSSxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUN6QyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDO0tBQ3ZEO0lBRUQsT0FBTyxtQkFBUyxDQUFDLElBQUksQ0FBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsYUFBVSxFQUFFO1FBQzFELE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTTtRQUN0QixPQUFPLFNBQUE7UUFDUCxLQUFLLEVBQUUsUUFBUSxDQUFDLFFBQVEsRUFBRTtRQUMxQixXQUFXLEVBQUUsVUFBVTtLQUN4QixFQUFFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFDLEdBQUc7UUFDbkIsSUFBSSxHQUFHLENBQUMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQy9CLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7Z0JBQ3hCLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDO2dCQUMzQyxPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDO2FBQzdCO1lBRUQsNkNBQVksR0FBRyxDQUFDLElBQUksS0FBRSxRQUFRLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUc7U0FDakQ7UUFFRCxNQUFNLElBQUksZ0NBQWMsQ0FBQyw0QkFBMEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFHLENBQUMsQ0FBQztJQUNqRixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyIsImZpbGUiOiJsaWIvYXBpL3N0b3JlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2suXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgU2VjdXJpdHksIFNlc3Npb24gfSBmcm9tICcuLi9jbGllbnQnO1xuaW1wb3J0IHsgRmlsZWxpbmssIFN0b3JlUGFyYW1zIH0gZnJvbSAnLi8uLi9maWxlbGluayc7XG5pbXBvcnQgeyBGaWxlc3RhY2tFcnJvciB9IGZyb20gJy4vLi4vLi4vZmlsZXN0YWNrX2Vycm9yJztcbmltcG9ydCB7IGdldFZhbGlkYXRvciwgU3RvcmVQYXJhbXNTY2hlbWEgfSBmcm9tICcuLy4uLy4uL3NjaGVtYSc7XG5pbXBvcnQgeyBGc1JlcXVlc3QsIEZzQ2FuY2VsVG9rZW4gfSBmcm9tICcuLi9yZXF1ZXN0JztcbmltcG9ydCB7IFVwbG9hZFRhZ3MgfSBmcm9tICcuL3VwbG9hZC9maWxlJztcblxuZXhwb3J0IHR5cGUgU3RvcmVVcmxQYXJhbXMgPSB7XG4gIHNlc3Npb246IFNlc3Npb247XG4gIHVybD86IHN0cmluZztcbiAgc3RvcmVQYXJhbXM/OiBTdG9yZVBhcmFtcztcbiAgdG9rZW4/OiBhbnk7XG4gIHNlY3VyaXR5PzogU2VjdXJpdHk7XG4gIHVwbG9hZFRhZ3M/OiBVcGxvYWRUYWdzO1xuICBoZWFkZXJzPzoge1trZXk6IHN0cmluZ106IHN0cmluZ30sXG4gIHdvcmtmbG93SWRzPzogc3RyaW5nW11cbn07XG5cbi8qKlxuICogU3RvcmUgZ2l2ZW4gdXJsIHdpdGggb3B0aW9ucyBhbmRcbiAqXG4gKiBAcGFyYW0gc2Vzc2lvblxuICogQHBhcmFtIHVybFxuICogQHBhcmFtIHN0b3JlT3B0c1xuICogQHBhcmFtIHRva2VuXG4gKiBAcGFyYW0gc2VjdXJpdHlcbiAqIEBwYXJhbSB1cGxvYWRUYWdzXG4gKiBAcGFyYW0gd29ya2Zsb3dJZHNcbiAqL1xuZXhwb3J0IGNvbnN0IHN0b3JlVVJMID0gKHtcbiAgc2Vzc2lvbixcbiAgdXJsLFxuICBzdG9yZVBhcmFtcyxcbiAgdG9rZW4sXG4gIHNlY3VyaXR5LFxuICB1cGxvYWRUYWdzLFxuICBoZWFkZXJzLFxuICB3b3JrZmxvd0lkcyxcbn06IFN0b3JlVXJsUGFyYW1zKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgaWYgKCF1cmwgfHwgdHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEZpbGVzdGFja0Vycm9yKCd1cmwgaXMgcmVxdWlyZWQgZm9yIHN0b3JlVVJMJykpO1xuICB9XG5cbiAgY29uc3QgdmFsaWRhdGVSZXMgPSBnZXRWYWxpZGF0b3IoU3RvcmVQYXJhbXNTY2hlbWEpKHN0b3JlUGFyYW1zKTtcblxuICBpZiAodmFsaWRhdGVSZXMuZXJyb3JzLmxlbmd0aCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRmlsZXN0YWNrRXJyb3IoYEludmFsaWQgc3RvcmUgcGFyYW1zYCwgdmFsaWRhdGVSZXMuZXJyb3JzKSk7XG4gIH1cblxuICBzZXNzaW9uLnBvbGljeSA9IHNlY3VyaXR5ICYmIHNlY3VyaXR5LnBvbGljeSB8fCBzZXNzaW9uLnBvbGljeTtcbiAgc2Vzc2lvbi5zaWduYXR1cmUgPSBzZWN1cml0eSAmJiBzZWN1cml0eS5zaWduYXR1cmUgfHwgc2Vzc2lvbi5zaWduYXR1cmU7XG5cbiAgY29uc3QgZmlsZWxpbmsgPSBuZXcgRmlsZWxpbmsodXJsLCBzZXNzaW9uLmFwaWtleSk7XG4gIGZpbGVsaW5rLnN0b3JlKHN0b3JlUGFyYW1zKTtcblxuICBpZiAoc2Vzc2lvbi5wb2xpY3kgJiYgc2Vzc2lvbi5zaWduYXR1cmUpIHtcbiAgICBmaWxlbGluay5zZWN1cml0eSh7XG4gICAgICBwb2xpY3k6IHNlc3Npb24ucG9saWN5LFxuICAgICAgc2lnbmF0dXJlOiBzZXNzaW9uLnNpZ25hdHVyZSxcbiAgICB9KTtcbiAgfVxuXG4gIGxldCBvcHRpb25zOiBhbnkgPSB7fTtcblxuICBpZiAodG9rZW4pIHtcbiAgICBjb25zdCBjYW5jZWxUb2tlbiA9IG5ldyBGc0NhbmNlbFRva2VuKCk7XG4gICAgdG9rZW4uY2FuY2VsID0gY2FuY2VsVG9rZW4uY2FuY2VsLmJpbmQoY2FuY2VsVG9rZW4pO1xuICAgIG9wdGlvbnMuY2FuY2VsVG9rZW4gPSBjYW5jZWxUb2tlbjtcbiAgfVxuXG4gIGxldCBzb3VyY2VzOiBhbnkgPSBbIHVybCBdO1xuXG4gIGlmIChoZWFkZXJzKSB7XG4gICAgc291cmNlcyA9IFt7XG4gICAgICBzb3VyY2U6IHVybCxcbiAgICAgIGhlYWRlcnMsXG4gICAgfV07XG4gIH1cblxuICBpZiAod29ya2Zsb3dJZHMgJiYgd29ya2Zsb3dJZHMubGVuZ3RoID4gMCkge1xuICAgIGZpbGVsaW5rLmFkZFRhc2soJ3N0b3JlJywgeyB3b3JrZmxvd3M6IHdvcmtmbG93SWRzIH0pO1xuICB9XG5cbiAgcmV0dXJuIEZzUmVxdWVzdC5wb3N0KGAke3Nlc3Npb24udXJscy5wcm9jZXNzVXJsfS9wcm9jZXNzYCwge1xuICAgIGFwaWtleTogc2Vzc2lvbi5hcGlrZXksXG4gICAgc291cmNlcyxcbiAgICB0YXNrczogZmlsZWxpbmsuZ2V0VGFza3MoKSxcbiAgICB1cGxvYWRfdGFnczogdXBsb2FkVGFncyxcbiAgfSwgb3B0aW9ucykudGhlbigocmVzKSA9PiB7XG4gICAgaWYgKHJlcy5kYXRhICYmIHJlcy5kYXRhLmhhbmRsZSkge1xuICAgICAgaWYgKHJlcy5kYXRhLnVwbG9hZF90YWdzKSB7XG4gICAgICAgIHJlcy5kYXRhLnVwbG9hZFRhZ3MgPSByZXMuZGF0YS51cGxvYWRfdGFncztcbiAgICAgICAgZGVsZXRlIHJlcy5kYXRhLnVwbG9hZF90YWdzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyAuLi5yZXMuZGF0YSwgbWltZXR5cGU6IHJlcy5kYXRhLnR5cGUgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRmlsZXN0YWNrRXJyb3IoYEludmFsaWQgc3RvcmUgcmVzcG9uc2UgJHtKU09OLnN0cmluZ2lmeShyZXMuZGF0YSl9YCk7XG4gIH0pO1xufTtcbiJdfQ==


/***/ }),

/***/ 6110:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var filelink_1 = __nccwpck_require__(4915);
/**
 * @private
 */
var toSnakeCase = function (original) {
    var snakeCased = {};
    var keys = Object.keys(original);
    for (var i = 0; i < keys.length; i++) {
        var newKey = keys[i].split(/(?=[A-Z])/).join('_').toLowerCase();
        if (typeof original[keys[i]] === 'object' && !Array.isArray(original[keys[i]])) {
            snakeCased[newKey] = toSnakeCase(original[keys[i]]);
        }
        else {
            snakeCased[newKey] = original[keys[i]];
        }
    }
    return snakeCased;
};
/**
 * Align enum
 */
var EAlignOptions;
(function (EAlignOptions) {
    EAlignOptions["left"] = "left";
    EAlignOptions["right"] = "right";
    EAlignOptions["center"] = "center";
    EAlignOptions["bottom"] = "bottom";
    EAlignOptions["top"] = "top";
})(EAlignOptions = exports.EAlignOptions || (exports.EAlignOptions = {}));
/**
 * Align enum with faces option
 */
var EAlignFacesOptions;
(function (EAlignFacesOptions) {
    EAlignFacesOptions["left"] = "left";
    EAlignFacesOptions["right"] = "right";
    EAlignFacesOptions["center"] = "center";
    EAlignFacesOptions["bottom"] = "bottom";
    EAlignFacesOptions["top"] = "top";
    EAlignFacesOptions["faces"] = "faces";
})(EAlignFacesOptions = exports.EAlignFacesOptions || (exports.EAlignFacesOptions = {}));
/**
 * Fit enum
 */
var EFitOptions;
(function (EFitOptions) {
    EFitOptions["clip"] = "clip";
    EFitOptions["crop"] = "crop";
    EFitOptions["scale"] = "scale";
    EFitOptions["max"] = "max";
})(EFitOptions = exports.EFitOptions || (exports.EFitOptions = {}));
/**
 * Blur enum
 */
var EBlurMode;
(function (EBlurMode) {
    EBlurMode["linear"] = "linear";
    EBlurMode["gaussian"] = "gaussian";
})(EBlurMode = exports.EBlurMode || (exports.EBlurMode = {}));
/**
 * Shapes enum
 */
var EShapeType;
(function (EShapeType) {
    EShapeType["oval"] = "oval";
    EShapeType["rect"] = "rect";
})(EShapeType = exports.EShapeType || (exports.EShapeType = {}));
/**
 * Noise type enum
 */
var ENoiseType;
(function (ENoiseType) {
    ENoiseType["none"] = "none";
    ENoiseType["low"] = "low";
    ENoiseType["medium"] = "medium";
    ENoiseType["high"] = "high";
})(ENoiseType = exports.ENoiseType || (exports.ENoiseType = {}));
/**
 * Style type enum
 */
var EStyleType;
(function (EStyleType) {
    EStyleType["artwork"] = "artwork";
    EStyleType["photo"] = "photo";
})(EStyleType = exports.EStyleType || (exports.EStyleType = {}));
/**
 * Color space enum
 */
var EColorspaceType;
(function (EColorspaceType) {
    EColorspaceType["RGB"] = "RGB";
    EColorspaceType["CMYK"] = "CMYK";
    EColorspaceType["Input"] = "Input";
})(EColorspaceType = exports.EColorspaceType || (exports.EColorspaceType = {}));
/**
 * Crop faces options enum
 */
var ECropfacesType;
(function (ECropfacesType) {
    ECropfacesType["thumb"] = "thumb";
    ECropfacesType["crop"] = "crop";
    ECropfacesType["fill"] = "fill";
})(ECropfacesType = exports.ECropfacesType || (exports.ECropfacesType = {}));
/**
 * SmartCrop mode options enum
 */
var ESmartCropMode;
(function (ESmartCropMode) {
    ESmartCropMode["fit"] = "fit";
    ESmartCropMode["auto"] = "auto";
})(ESmartCropMode = exports.ESmartCropMode || (exports.ESmartCropMode = {}));
var EImageWatermarkPosition;
(function (EImageWatermarkPosition) {
    EImageWatermarkPosition["top"] = "top";
    EImageWatermarkPosition["middle"] = "middle";
    EImageWatermarkPosition["bottom"] = "bottom";
    EImageWatermarkPosition["left"] = "left";
    EImageWatermarkPosition["center"] = "center";
    EImageWatermarkPosition["right"] = "right";
})(EImageWatermarkPosition = exports.EImageWatermarkPosition || (exports.EImageWatermarkPosition = {}));
/**
 * Convert to format
 */
var EVideoTypes;
(function (EVideoTypes) {
    EVideoTypes["h264"] = "h264";
    EVideoTypes["h264_hi"] = "h264.hi";
    EVideoTypes["webm"] = "webm";
    EVideoTypes["webm-hi"] = "webm.hi";
    EVideoTypes["ogg"] = "ogg";
    EVideoTypes["ogg-hi"] = "ogg.hi";
    EVideoTypes["hls-variant"] = "hls.variant";
    EVideoTypes["mp3"] = "mp3";
    EVideoTypes["oga"] = "oga";
    EVideoTypes["m4a"] = "m4a";
    EVideoTypes["aac"] = "aac";
    EVideoTypes["hls"] = "hls.variant.audio";
})(EVideoTypes = exports.EVideoTypes || (exports.EVideoTypes = {}));
var EUrlscreenshotAgent;
(function (EUrlscreenshotAgent) {
    EUrlscreenshotAgent["desktop"] = "desktop";
    EUrlscreenshotAgent["mobile"] = "mobile";
})(EUrlscreenshotAgent = exports.EUrlscreenshotAgent || (exports.EUrlscreenshotAgent = {}));
var EUrlscreenshotMode;
(function (EUrlscreenshotMode) {
    EUrlscreenshotMode["all"] = "all";
    EUrlscreenshotMode["window"] = "window";
})(EUrlscreenshotMode = exports.EUrlscreenshotMode || (exports.EUrlscreenshotMode = {}));
var EUrlscreenshotOrientation;
(function (EUrlscreenshotOrientation) {
    EUrlscreenshotOrientation["portrait"] = "portrait";
    EUrlscreenshotOrientation["landscape"] = "landscape";
})(EUrlscreenshotOrientation = exports.EUrlscreenshotOrientation || (exports.EUrlscreenshotOrientation = {}));
/**
 * Video storage location
 */
var EVideoLocations;
(function (EVideoLocations) {
    EVideoLocations["s3"] = "s3";
    EVideoLocations["azure"] = "azure";
    EVideoLocations["gcs"] = "gcs";
    EVideoLocations["rackspace"] = "rackspace";
    EVideoLocations["dropbox"] = "dropbox";
})(EVideoLocations = exports.EVideoLocations || (exports.EVideoLocations = {}));
var EVideoAccess;
(function (EVideoAccess) {
    EVideoAccess["private"] = "private";
    EVideoAccess["public"] = "public";
})(EVideoAccess = exports.EVideoAccess || (exports.EVideoAccess = {}));
var EVideoAccessMode;
(function (EVideoAccessMode) {
    EVideoAccessMode["preserve"] = "preserve";
    EVideoAccessMode["constrain"] = "constrain";
    EVideoAccessMode["letterbox"] = "letterbox";
    EVideoAccessMode["pad"] = "pad";
    EVideoAccessMode["crop"] = "crop";
})(EVideoAccessMode = exports.EVideoAccessMode || (exports.EVideoAccessMode = {}));
/**
 * Creates filestack transform url.
 * Transform params can be provided in camelCase or snakeCase style
 *
 * @example
 * ```js
 * // camelCase
 * console.log(transform(session, {
 *    partialPixelate: {
 *      objects: [[10, 20, 200, 250], [275, 91, 500, 557]],
 *    },
 *  }, 'testfile'));
 * ```
 * result => https://cdn.filestackcontent.com/partial_pixelate=objects:[[10,20,200,250],[275,91,500,557]]/testfile
 *
 * ```js
 * // snake_case
 * console.log(transform(session, {
 *    partial_pixelate: {
 *      objects: [[10, 20, 200, 250], [275, 91, 500, 557]],
 *    },
 *  }, 'testfile'));
 * ```
 * result => https://cdn.filestackcontent.com/partial_pixelate=objects:[[10,20,200,250],[275,91,500,557]]/testfile
 *
 * Client.transform is deprecated. Use Filelink class instead
 *
 * @private
 * @throws Error
 * @param options Transformation options
 * @param url url, handle or array of elements
 */
exports.transform = function (session, url, options, b64) {
    if (options === void 0) { options = {}; }
    if (b64 === void 0) { b64 = false; }
    options = toSnakeCase(options);
    if (session.policy && session.signature) {
        options.security = {
            policy: session.policy,
            signature: session.signature,
        };
    }
    var filelink = new filelink_1.Filelink(url, session.apikey);
    filelink.setCname(session.cname);
    filelink.setBase64(b64);
    Object.keys(options).forEach(function (key) {
        if (typeof options[key] === 'boolean' && !options[key] && key !== 'cache') {
            return;
        }
        filelink.addTask(key, options[key]);
    });
    return filelink.toString();
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3RyYW5zZm9ybS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHOztBQUdILDBDQUF5QztBQUV6Qzs7R0FFRztBQUNILElBQU0sV0FBVyxHQUFHLFVBQUMsUUFBa0M7SUFDckQsSUFBSSxVQUFVLEdBQTZCLEVBQUUsQ0FBQztJQUU5QyxJQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBRW5DLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3BDLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRWhFLElBQUksT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUM5RSxVQUFVLENBQUMsTUFBTSxDQUFDLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3JEO2FBQU07WUFDTCxVQUFVLENBQUMsTUFBTSxDQUFDLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3hDO0tBQ0Y7SUFFRCxPQUFPLFVBQVUsQ0FBQztBQUNwQixDQUFDLENBQUM7QUFFRjs7R0FFRztBQUNILElBQVksYUFNWDtBQU5ELFdBQVksYUFBYTtJQUN2Qiw4QkFBYSxDQUFBO0lBQ2IsZ0NBQWUsQ0FBQTtJQUNmLGtDQUFpQixDQUFBO0lBQ2pCLGtDQUFpQixDQUFB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R0ErQkc7QUFDVSxRQUFBLFNBQVMsR0FBRyxVQUFDLE9BQWdCLEVBQUUsR0FBc0IsRUFBRSxPQUE4QixFQUFFLEdBQW9CO0lBQXBELHdCQUFBLEVBQUEsWUFBOEI7SUFBRSxvQkFBQSxFQUFBLFdBQW9CO0lBQ3RILE9BQU8sR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFL0IsSUFBSSxPQUFPLENBQUMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxTQUFTLEVBQUU7UUFDdkMsT0FBTyxDQUFDLFFBQVEsR0FBRztZQUNqQixNQUFNLEVBQUUsT0FBTyxDQUFDLE1BQU07WUFDdEIsU0FBUyxFQUFFLE9BQU8sQ0FBQyxTQUFTO1NBQzdCLENBQUM7S0FDSDtJQUVELElBQU0sUUFBUSxHQUFHLElBQUksbUJBQVEsQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25ELFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2pDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFeEIsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxHQUEyQjtRQUN2RCxJQUFJLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLFNBQVMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLEtBQUssT0FBTyxFQUFFO1lBQ3pFLE9BQU87U0FDUjtRQUVELFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3RDLENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDN0IsQ0FBQyxDQUFDIiwiZmlsZSI6ImxpYi9hcGkvdHJhbnNmb3JtLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2suXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgU2Vzc2lvbiB9IGZyb20gJy4uL2NsaWVudCc7XG5pbXBvcnQgeyBGaWxlbGluayB9IGZyb20gJy4vLi4vZmlsZWxpbmsnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHRvU25ha2VDYXNlID0gKG9yaWdpbmFsOiB7IFtpbmRleDogc3RyaW5nXTogYW55IH0pOiB7IFtpbmRleDogc3RyaW5nXTogYW55IH0gPT4ge1xuICBsZXQgc25ha2VDYXNlZDogeyBbaW5kZXg6IHN0cmluZ106IGFueSB9ID0ge307XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9yaWdpbmFsKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbmV3S2V5ID0ga2V5c1tpXS5zcGxpdCgvKD89W0EtWl0pLykuam9pbignXycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsW2tleXNbaV1dID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvcmlnaW5hbFtrZXlzW2ldXSkpIHtcbiAgICAgIHNuYWtlQ2FzZWRbbmV3S2V5XSA9IHRvU25ha2VDYXNlKG9yaWdpbmFsW2tleXNbaV1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc25ha2VDYXNlZFtuZXdLZXldID0gb3JpZ2luYWxba2V5c1tpXV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNuYWtlQ2FzZWQ7XG59O1xuXG4vKipcbiAqIEFsaWduIGVudW1cbiAqL1xuZXhwb3J0IGVudW0gRUFsaWduT3B0aW9ucyB7XG4gIGxlZnQgPSAnbGVmdCcsXG4gIHJpZ2h0ID0gJ3JpZ2h0JyxcbiAgY2VudGVyID0gJ2NlbnRlcicsXG4gIGJvdHRvbSA9ICdib3R0b20nLFxuICB0b3AgPSAndG9wJyxcbn1cblxuLyoqXG4gKiBBbGlnbiBlbnVtIHdpdGggZmFjZXMgb3B0aW9uXG4gKi9cbmV4cG9ydCBlbnVtIEVBbGlnbkZhY2VzT3B0aW9ucyB7XG4gIGxlZnQgPSAnbGVmdCcsXG4gIHJpZ2h0ID0gJ3JpZ2h0JyxcbiAgY2VudGVyID0gJ2NlbnRlcicsXG4gIGJvdHRvbSA9ICdib3R0b20nLFxuICB0b3AgPSAndG9wJyxcbiAgZmFjZXMgPSAnZmFjZXMnLFxufVxuXG4vKipcbiAqIEZpdCBlbnVtXG4gKi9cbmV4cG9ydCBlbnVtIEVGaXRPcHRpb25zIHtcbiAgY2xpcCA9ICdjbGlwJyxcbiAgY3JvcCA9ICdjcm9wJyxcbiAgc2NhbGUgPSAnc2NhbGUnLFxuICBtYXggPSAnbWF4Jyxcbn1cblxuLyoqXG4gKiBCbHVyIGVudW1cbiAqL1xuZXhwb3J0IGVudW0gRUJsdXJNb2RlIHtcbiAgbGluZWFyID0gJ2xpbmVhcicsXG4gIGdhdXNzaWFuID0gJ2dhdXNzaWFuJyxcbn1cblxuLyoqXG4gKiBTaGFwZXMgZW51bVxuICovXG5leHBvcnQgZW51bSBFU2hhcGVUeXBlIHtcbiAgb3ZhbCA9ICdvdmFsJyxcbiAgcmVjdCA9ICdyZWN0Jyxcbn1cblxuLyoqXG4gKiBOb2lzZSB0eXBlIGVudW1cbiAqL1xuZXhwb3J0IGVudW0gRU5vaXNlVHlwZSB7XG4gIG5vbmUgPSAnbm9uZScsXG4gIGxvdyA9ICdsb3cnLFxuICBtZWRpdW0gPSAnbWVkaXVtJyxcbiAgaGlnaCA9ICdoaWdoJyxcbn1cblxuLyoqXG4gKiBTdHlsZSB0eXBlIGVudW1cbiAqL1xuZXhwb3J0IGVudW0gRVN0eWxlVHlwZSB7XG4gIGFydHdvcmsgPSAnYXJ0d29yaycsXG4gIHBob3RvID0gJ3Bob3RvJyxcbn1cblxuLyoqXG4gKiBDb2xvciBzcGFjZSBlbnVtXG4gKi9cbmV4cG9ydCBlbnVtIEVDb2xvcnNwYWNlVHlwZSB7XG4gIFJHQiA9ICdSR0InLFxuICBDTVlLID0gJ0NNWUsnLFxuICBJbnB1dCA9ICdJbnB1dCcsXG59XG5cbi8qKlxuICogQ3JvcCBmYWNlcyBvcHRpb25zIGVudW1cbiAqL1xuZXhwb3J0IGVudW0gRUNyb3BmYWNlc1R5cGUge1xuICB0aHVtYiA9ICd0aHVtYicsXG4gIGNyb3AgPSAnY3JvcCcsXG4gIGZpbGwgPSAnZmlsbCcsXG59XG5cbi8qKlxuICogU21hcnRDcm9wIG1vZGUgb3B0aW9ucyBlbnVtXG4gKi9cbmV4cG9ydCBlbnVtIEVTbWFydENyb3BNb2RlIHtcbiAgZml0ID0gJ2ZpdCcsXG4gIGF1dG8gPSAnYXV0bycsXG59XG5cbmV4cG9ydCBlbnVtIEVJbWFnZVdhdGVybWFya1Bvc2l0aW9uIHtcbiAgdG9wID0gJ3RvcCcsXG4gIG1pZGRsZSA9ICdtaWRkbGUnLFxuICBib3R0b20gPSAnYm90dG9tJyxcbiAgbGVmdCA9ICdsZWZ0JyxcbiAgY2VudGVyID0gJ2NlbnRlcicsXG4gIHJpZ2h0ID0gJ3JpZ2h0Jyxcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRvIGZvcm1hdFxuICovXG5leHBvcnQgZW51bSBFVmlkZW9UeXBlcyB7XG4gICAgaDI2NCA9ICdoMjY0JyxcbiAgICBoMjY0X2hpID0gJ2gyNjQuaGknLFxuICAgIHdlYm0gPSAnd2VibScsXG4gICAgJ3dlYm0taGknID0gJ3dlYm0uaGknLFxuICAgIG9nZyA9ICdvZ2cnLFxuICAgICdvZ2ctaGknID0gJ29nZy5oaScsXG4gICAgJ2hscy12YXJpYW50JyA9ICdobHMudmFyaWFudCcsXG4gICAgbXAzID0gJ21wMycsXG4gICAgb2dhID0gJ29nYScsXG4gICAgbTRhID0gJ200YScsXG4gICAgYWFjID0gJ2FhYycsXG4gICAgaGxzID0gJ2hscy52YXJpYW50LmF1ZGlvJyxcbn1cblxuZXhwb3J0IGVudW0gRVVybHNjcmVlbnNob3RBZ2VudCB7XG4gIGRlc2t0b3AgPSAnZGVza3RvcCcsXG4gIG1vYmlsZSA9ICdtb2JpbGUnLFxufVxuXG5leHBvcnQgZW51bSBFVXJsc2NyZWVuc2hvdE1vZGUge1xuICBhbGwgPSAnYWxsJyxcbiAgd2luZG93ID0gJ3dpbmRvdycsXG59XG5cbmV4cG9ydCBlbnVtIEVVcmxzY3JlZW5zaG90T3JpZW50YXRpb24ge1xuICBwb3J0cmFpdCA9ICdwb3J0cmFpdCcsXG4gIGxhbmRzY2FwZSA9ICdsYW5kc2NhcGUnLFxufVxuXG4vKipcbiAqIFZpZGVvIHN0b3JhZ2UgbG9jYXRpb25cbiAqL1xuZXhwb3J0IGVudW0gRVZpZGVvTG9jYXRpb25zIHtcbiAgczMgPSAnczMnLFxuICBhenVyZSA9ICdhenVyZScsXG4gIGdjcyA9ICdnY3MnLFxuICByYWNrc3BhY2UgPSAncmFja3NwYWNlJyxcbiAgZHJvcGJveCA9ICdkcm9wYm94Jyxcbn1cblxuZXhwb3J0IGVudW0gRVZpZGVvQWNjZXNzIHtcbiAgcHJpdmF0ZSA9ICdwcml2YXRlJyxcbiAgcHVibGljID0gJ3B1YmxpYycsXG59XG5cbmV4cG9ydCBlbnVtIEVWaWRlb0FjY2Vzc01vZGUge1xuICBwcmVzZXJ2ZSA9ICdwcmVzZXJ2ZScsXG4gIGNvbnN0cmFpbiA9ICdjb25zdHJhaW4nLFxuICBsZXR0ZXJib3ggPSAnbGV0dGVyYm94JyxcbiAgcGFkID0gJ3BhZCcsXG4gIGNyb3AgPSAnY3JvcCcsXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvaW1hZ2UtdHJhbnNmb3JtYXRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmb3JtT3B0aW9ucyB7XG4gIGZsaXA/OiBib29sZWFuO1xuICBjb21wcmVzcz86IGJvb2xlYW47XG4gIGZsb3A/OiBib29sZWFuO1xuICBub19tZXRhZGF0YT86IGJvb2xlYW47XG4gIHBqcGc/OiB7XG4gICAgcXVhbGl0eTogbnVtYmVyO1xuICAgIG1ldGFkYXRhOiBib29sZWFuO1xuICB9O1xuICBzbWFydF9jcm9wPzoge1xuICAgIG1vZGU/OiBFU21hcnRDcm9wTW9kZVxuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gIH07XG4gIHdhdGVybWFyaz86IHtcbiAgICBmaWxlczogc3RyaW5nO1xuICAgIHNpemU/OiBudW1iZXI7XG4gICAgcG9zaXRpb24/OiBFSW1hZ2VXYXRlcm1hcmtQb3NpdGlvbiB8IEVJbWFnZVdhdGVybWFya1Bvc2l0aW9uW107XG4gIH07XG4gIGltYWdlc2l6ZT86IGJvb2xlYW47XG4gIGVuY2hhbmNlPzogYm9vbGVhbjtcbiAgcmVkZXllPzogYm9vbGVhbjtcbiAgbW9ub2Nocm9tZT86IGJvb2xlYW47XG4gIG5lZ2F0aXZlPzogYm9vbGVhbjtcbiAgdGFncz86IGJvb2xlYW47XG4gIHNmdz86IGJvb2xlYW47XG4gIHN0b3JlPzoge1xuICAgIGZpbGVuYW1lPzogc3RyaW5nLFxuICAgIGxvY2F0aW9uPzogc3RyaW5nLFxuICAgIHBhdGg/OiBzdHJpbmcsXG4gICAgY29udGFpbmVyPzogc3RyaW5nLFxuICAgIHJlZ2lvbj86IHN0cmluZztcbiAgICBhY2Nlc3M/OiBzdHJpbmc7XG4gICAgYmFzZTY0ZGVjb2RlPzogYm9vbGVhbjtcbiAgfTtcbiAgcmVzaXplPzoge1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGhlaWdodD86IG51bWJlcjtcbiAgICBmaXQ/OiBFRml0T3B0aW9ucztcbiAgICBhbGlnbj86IEVBbGlnbkZhY2VzT3B0aW9ucztcbiAgfTtcbiAgY3JvcD86IHtcbiAgICBkaW06IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdXG4gIH07XG4gIHJvdGF0ZT86IHtcbiAgICBkZWc6IG51bWJlciB8IHN0cmluZztcbiAgICBjb2xvcj86IHN0cmluZztcbiAgICBiYWNrZ3JvdW5kPzogc3RyaW5nO1xuICB9O1xuICBkZXRlY3RfZmFjZXM/OiB7XG4gICAgbWluc2l6ZT86IG51bWJlcjtcbiAgICBtYXhzaXplPzogbnVtYmVyO1xuICAgIGNvbG9yPzogc3RyaW5nO1xuICAgIGV4cG9ydD86IGJvb2xlYW47XG4gIH0gfCB0cnVlO1xuICBjcm9wX2ZhY2VzPzoge1xuICAgIG1vZGU/OiBFQ3JvcGZhY2VzVHlwZTtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBoZWlnaHQ/OiBudW1iZXI7XG4gICAgZmFjZXM/OiBudW1iZXIgfCBzdHJpbmc7XG4gICAgYnVmZmVyPzogbnVtYmVyO1xuICB9O1xuICBwaXhlbGF0ZV9mYWNlcz86IHtcbiAgICBmYWNlcz86IG51bWJlciB8IHN0cmluZztcbiAgICBtaW5zaXplPzogbnVtYmVyO1xuICAgIG1heHNpemU/OiBudW1iZXI7XG4gICAgYnVmZmVyPzogbnVtYmVyO1xuICAgIGFtb3VudD86IG51bWJlcjtcbiAgICBibHVyPzogbnVtYmVyO1xuICAgIHR5cGU/OiBFU2hhcGVUeXBlO1xuICB9O1xuICBibHVyX2ZhY2VzPzoge1xuICAgIGZhY2VzPzogbnVtYmVyIHwgc3RyaW5nO1xuICAgIG1pbnNpemU/OiBudW1iZXI7XG4gICAgbWF4c2l6ZT86IG51bWJlcjtcbiAgICBidWZmZXI/OiBudW1iZXI7XG4gICAgYW1vdW50PzogbnVtYmVyO1xuICAgIGJsdXI/OiBudW1iZXI7XG4gICAgdHlwZT86IEVTaGFwZVR5cGU7XG4gIH07XG4gIHJvdW5kZWRfY29ybmVycz86IHtcbiAgICByYWRpdXM/OiBudW1iZXI7XG4gICAgYmx1cj86IG51bWJlcjtcbiAgICBiYWNrZ3JvdW5kPzogc3RyaW5nO1xuICB9IHwgdHJ1ZTtcbiAgdmlnbmV0dGU/OiB7XG4gICAgYW1vdW50PzogbnVtYmVyO1xuICAgIGJsdXJtb2RlPzogRUJsdXJNb2RlO1xuICAgIGJhY2tncm91bmQ/OiBzdHJpbmc7XG4gIH07XG4gIHBvbGFyb2lkPzoge1xuICAgIGNvbG9yPzogc3RyaW5nO1xuICAgIHJvdGF0ZT86IG51bWJlcjtcbiAgICBiYWNrZ3JvdW5kPzogc3RyaW5nO1xuICB9IHwgdHJ1ZTtcbiAgdG9ybl9lZGdlcz86IHtcbiAgICBzcHJlYWQ/OiBbbnVtYmVyLCBudW1iZXJdO1xuICAgIGJhY2tncm91bmQ/OiBzdHJpbmc7XG4gIH0gfCB0cnVlO1xuICBzaGFkb3c/OiB7XG4gICAgYmx1cj86IG51bWJlcjtcbiAgICBvcGFjaXR5PzogbnVtYmVyO1xuICAgIHZlY3Rvcj86IFtudW1iZXIsIG51bWJlcl07XG4gICAgY29sb3I/OiBzdHJpbmc7XG4gICAgYmFja2dyb3VuZD86IHN0cmluZztcbiAgfSB8IHRydWU7XG4gIGNpcmNsZT86IHtcbiAgICBiYWNrZ3JvdW5kPzogc3RyaW5nO1xuICB9IHwgdHJ1ZTtcbiAgYm9yZGVyPzoge1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGNvbG9yPzogc3RyaW5nO1xuICAgIGJhY2tncm91bmQ/OiBzdHJpbmc7XG4gIH0gfCB0cnVlO1xuICBzaGFycGVuPzoge1xuICAgIGFtb3VudDogbnVtYmVyO1xuICB9IHwgdHJ1ZTtcbiAgYmx1cj86IHtcbiAgICBhbW91bnQ6IG51bWJlcjtcbiAgfSB8IHRydWU7XG4gIGJsYWNrd2hpdGU/OiB7XG4gICAgdGhyZXNob2xkOiBudW1iZXI7XG4gIH0gfCB0cnVlO1xuICBzZXBpYT86IHtcbiAgICB0b25lOiBudW1iZXI7XG4gIH0gfCB0cnVlO1xuICBwaXhlbGF0ZT86IHtcbiAgICBhbW91bnQ6IG51bWJlcjtcbiAgfSB8IHRydWU7XG4gIG9pbF9wYWludD86IHtcbiAgICBhbW91bnQ6IG51bWJlcjtcbiAgfSB8IHRydWU7XG4gIG1vZHVsYXRlPzoge1xuICAgIGJyaWdodG5lc3M/OiBudW1iZXI7XG4gICAgaHVlPzogbnVtYmVyO1xuICAgIHNhdHVyYXRpb24/OiBudW1iZXI7XG4gIH0gfCB0cnVlO1xuICBwYXJ0aWFsX3BpeGVsYXRlPzoge1xuICAgIGFtb3VudD86IG51bWJlcjtcbiAgICBibHVyPzogbnVtYmVyO1xuICAgIHR5cGU/OiBFU2hhcGVUeXBlO1xuICAgIG9iamVjdHM/OiBbW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1dO1xuICB9O1xuICBwYXJ0aWFsX2JsdXI/OiB7XG4gICAgYW1vdW50OiBudW1iZXI7XG4gICAgYmx1cj86IG51bWJlcjtcbiAgICB0eXBlPzogRVNoYXBlVHlwZTtcbiAgICBvYmplY3RzPzogW1tudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdXTtcbiAgfTtcbiAgY29sbGFnZT86IHtcbiAgICBtYXJnaW4/OiBudW1iZXI7XG4gICAgd2lkdGg/OiBudW1iZXI7XG4gICAgaGVpZ2h0PzogbnVtYmVyO1xuICAgIGNvbG9yPzogc3RyaW5nO1xuICAgIGZpdD86IEVGaXRPcHRpb25zLFxuICAgIGZpbGVzOiBbc3RyaW5nXTtcbiAgfTtcbiAgdXBzY2FsZT86IHtcbiAgICB1cHNjYWxlPzogYm9vbGVhbjtcbiAgICBub2lzZT86IEVOb2lzZVR5cGU7XG4gICAgc3R5bGU/OiBFU3R5bGVUeXBlO1xuICB9IHwgdHJ1ZTtcbiAgYXNjaWk/OiB7XG4gICAgYmFja2dyb3VuZD86IHN0cmluZztcbiAgICBmb3JlZ3JvdW5kPzogc3RyaW5nO1xuICAgIGNvbG9yZWQ/OiBib29sZWFuO1xuICAgIHNpemU/OiBudW1iZXI7XG4gICAgcmV2ZXJzZT86IGJvb2xlYW47XG4gIH0gfCB0cnVlO1xuICBxdWFsaXR5Pzoge1xuICAgIHZhbHVlOiBudW1iZXI7XG4gIH07XG4gIHNlY3VyaXR5Pzoge1xuICAgIHBvbGljeTogc3RyaW5nO1xuICAgIHNpZ25hdHVyZT86IHN0cmluZztcbiAgfTtcbiAgb3V0cHV0Pzoge1xuICAgIGZvcm1hdDogc3RyaW5nO1xuICAgIGNvbG9yc3BhY2U/OiBzdHJpbmc7XG4gICAgc3RyaXA/OiBib29sZWFuO1xuICAgIHF1YWxpdHk/OiBudW1iZXI7XG4gICAgcGFnZT86IG51bWJlcjtcbiAgICBjb21wcmVzcz86IGJvb2xlYW47XG4gICAgZGVuc2l0eT86IG51bWJlcjtcbiAgICBiYWNrZ3JvdW5kPzogc3RyaW5nO1xuICAgIHNlY3VyZT86IGJvb2xlYW47XG4gICAgZG9jaW5mbz86IGJvb2xlYW47XG4gICAgcGFnZWZvcm1hdD86IHN0cmluZztcbiAgICBwYWdlb3JpZW50YXRpb24/OiBzdHJpbmc7XG4gIH07XG4gIGNhY2hlPzoge1xuICAgIGNhY2hlPzogYm9vbGVhbjtcbiAgICBleHBpcnk6IG51bWJlcjtcbiAgfTtcbiAgLy8gYXVkaW8vdmlkZW9cbiAgdmlkZW9fY29udmVydD86IHtcbiAgICBhc3BlY3RfbW9kZTogRVZpZGVvQWNjZXNzTW9kZTtcbiAgICBwcmVzZXQ/OiBFVmlkZW9UeXBlcztcbiAgICBmb3JjZT86IGJvb2xlYW47XG4gICAgdGl0bGU/OiBzdHJpbmc7XG4gICAgZXh0bmFtZT86IHN0cmluZztcbiAgICBmaWxlbmFtZT86IHN0cmluZztcbiAgICBsb2NhdGlvbj86IEVWaWRlb0xvY2F0aW9ucztcbiAgICBwYXRoPzogc3RyaW5nO1xuICAgIGFjY2Vzcz86IEVWaWRlb0FjY2VzcztcbiAgICBjb250YWluZXI/OiBzdHJpbmc7XG4gICAgYXVkaW9fYml0cmF0ZT86IG51bWJlcjtcbiAgICB1cHNjYWxlOiBib29sZWFuO1xuICAgIHZpZGVvX2JpdHJhdGU/OiBudW1iZXI7XG4gICAgYXVkaW9fc2FtcGxlX3JhdGU/OiBudW1iZXI7XG4gICAgYXVkaW9fY2hhbm5lbHM/OiBudW1iZXI7XG4gICAgY2xpcF9sZW5ndGg/OiBzdHJpbmc7XG4gICAgY2xpcF9vZmZzZXQ/OiBzdHJpbmc7XG4gICAgd2lkdGg/OiBudW1iZXI7XG4gICAgaGVpZ2h0PzogbnVtYmVyO1xuICAgIHR3b19wYXNzPzogYm9vbGVhbjtcbiAgICBmcHM/OiBudW1iZXI7XG4gICAga2V5ZnJhbWVfaW50ZXJ2YWw/OiBudW1iZXI7XG4gICAgd2F0ZXJtYXJrX3VybD86IHN0cmluZztcbiAgICB3YXRlcm1hcmtfdG9wPzogbnVtYmVyO1xuICAgIHdhdGVybWFya19ib3R0b20/OiBudW1iZXI7XG4gICAgd2F0ZXJtYXJrX3JpZ2h0PzogbnVtYmVyO1xuICAgIHdhdGVybWFya19sZWZ0PzogbnVtYmVyO1xuICAgIHdhdGVybWFya193aWR0aD86IG51bWJlcjtcbiAgICB3YXRlcm1hcmtfaGVpZ2h0PzogbnVtYmVyO1xuICB9O1xuICB1cmxzY3JlZW5zaG90Pzoge1xuICAgIGFnZW50PzogRVVybHNjcmVlbnNob3RBZ2VudDtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBoZWlnaHQ/OiBudW1iZXI7XG4gICAgbW9kZT86IEVVcmxzY3JlZW5zaG90TW9kZTtcbiAgICBkZWxheT86IG51bWJlcjtcbiAgICBvcmllbnRhdGlvbj86IEVVcmxzY3JlZW5zaG90T3JpZW50YXRpb247XG4gICAgZGV2aWNlPzogc3RyaW5nO1xuICB9IHwgdHJ1ZTtcbiAgcGRmaW5mbz86IHtcbiAgICBjb2xvcmluZm8/OiBib29sZWFuXG4gIH0gfCB0cnVlO1xuICBwZGZjb252ZXJ0Pzoge1xuICAgIHBhZ2VvcmllbnRhdGlvbj86IHN0cmluZ1xuICAgIHBhZ2Vmb3JtYXQ/OiBzdHJpbmdcbiAgICBwYWdlcz86IChzdHJpbmcgfCBudW1iZXIpW11cbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGZpbGVzdGFjayB0cmFuc2Zvcm0gdXJsLlxuICogVHJhbnNmb3JtIHBhcmFtcyBjYW4gYmUgcHJvdmlkZWQgaW4gY2FtZWxDYXNlIG9yIHNuYWtlQ2FzZSBzdHlsZVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogLy8gY2FtZWxDYXNlXG4gKiBjb25zb2xlLmxvZyh0cmFuc2Zvcm0oc2Vzc2lvbiwge1xuICogICAgcGFydGlhbFBpeGVsYXRlOiB7XG4gKiAgICAgIG9iamVjdHM6IFtbMTAsIDIwLCAyMDAsIDI1MF0sIFsyNzUsIDkxLCA1MDAsIDU1N11dLFxuICogICAgfSxcbiAqICB9LCAndGVzdGZpbGUnKSk7XG4gKiBgYGBcbiAqIHJlc3VsdCA9PiBodHRwczovL2Nkbi5maWxlc3RhY2tjb250ZW50LmNvbS9wYXJ0aWFsX3BpeGVsYXRlPW9iamVjdHM6W1sxMCwyMCwyMDAsMjUwXSxbMjc1LDkxLDUwMCw1NTddXS90ZXN0ZmlsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBzbmFrZV9jYXNlXG4gKiBjb25zb2xlLmxvZyh0cmFuc2Zvcm0oc2Vzc2lvbiwge1xuICogICAgcGFydGlhbF9waXhlbGF0ZToge1xuICogICAgICBvYmplY3RzOiBbWzEwLCAyMCwgMjAwLCAyNTBdLCBbMjc1LCA5MSwgNTAwLCA1NTddXSxcbiAqICAgIH0sXG4gKiAgfSwgJ3Rlc3RmaWxlJykpO1xuICogYGBgXG4gKiByZXN1bHQgPT4gaHR0cHM6Ly9jZG4uZmlsZXN0YWNrY29udGVudC5jb20vcGFydGlhbF9waXhlbGF0ZT1vYmplY3RzOltbMTAsMjAsMjAwLDI1MF0sWzI3NSw5MSw1MDAsNTU3XV0vdGVzdGZpbGVcbiAqXG4gKiBDbGllbnQudHJhbnNmb3JtIGlzIGRlcHJlY2F0ZWQuIFVzZSBGaWxlbGluayBjbGFzcyBpbnN0ZWFkXG4gKlxuICogQHByaXZhdGVcbiAqIEB0aHJvd3MgRXJyb3JcbiAqIEBwYXJhbSBvcHRpb25zIFRyYW5zZm9ybWF0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB1cmwgdXJsLCBoYW5kbGUgb3IgYXJyYXkgb2YgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybSA9IChzZXNzaW9uOiBTZXNzaW9uLCB1cmw6IHN0cmluZyB8IHN0cmluZ1tdLCBvcHRpb25zOiBUcmFuc2Zvcm1PcHRpb25zID0ge30sIGI2NDogYm9vbGVhbiA9IGZhbHNlKTogc3RyaW5nID0+IHtcbiAgb3B0aW9ucyA9IHRvU25ha2VDYXNlKG9wdGlvbnMpO1xuXG4gIGlmIChzZXNzaW9uLnBvbGljeSAmJiBzZXNzaW9uLnNpZ25hdHVyZSkge1xuICAgIG9wdGlvbnMuc2VjdXJpdHkgPSB7XG4gICAgICBwb2xpY3k6IHNlc3Npb24ucG9saWN5LFxuICAgICAgc2lnbmF0dXJlOiBzZXNzaW9uLnNpZ25hdHVyZSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgZmlsZWxpbmsgPSBuZXcgRmlsZWxpbmsodXJsLCBzZXNzaW9uLmFwaWtleSk7XG4gIGZpbGVsaW5rLnNldENuYW1lKHNlc3Npb24uY25hbWUpO1xuICBmaWxlbGluay5zZXRCYXNlNjQoYjY0KTtcblxuICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKChrZXk6IGtleW9mIFRyYW5zZm9ybU9wdGlvbnMpID0+IHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNba2V5XSA9PT0gJ2Jvb2xlYW4nICYmICFvcHRpb25zW2tleV0gJiYga2V5ICE9PSAnY2FjaGUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmlsZWxpbmsuYWRkVGFzayhrZXksIG9wdGlvbnNba2V5XSk7XG4gIH0pO1xuXG4gIHJldHVybiBmaWxlbGluay50b1N0cmluZygpO1xufTtcbiJdfQ==


/***/ }),

/***/ 6669:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var utils_1 = __nccwpck_require__(8123);
/**
 * File representation to unify file object in nodejs and browser
 *
 * @export
 * @class File
 */
var File = /** @class */ (function () {
    function File(_file, _sanitizeOptions) {
        this._file = _file;
        this._sanitizeOptions = _sanitizeOptions;
        this._file.name = utils_1.sanitizeName(this._file.name, this._sanitizeOptions);
    }
    Object.defineProperty(File.prototype, "name", {
        /**
         * Returns file name
         *
         * @returns {string}
         * @memberof File
         */
        get: function () {
            return this._file.name;
        },
        /**
         * Sets new file name  and cleanup extra chars
         *
         * @memberof File
         */
        set: function (val) {
            this._file.name = utils_1.sanitizeName(val, this._sanitizeOptions);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "filename", {
        /**
         * Alias for name getter
         *
         * @readonly
         * @type {string}
         * @memberof File
         */
        get: function () {
            return this.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "customName", {
        /**
         * Sets custom name using string or function
         * Name will be sanitized
         *
         * @memberof File
         */
        set: function (val) {
            switch (typeof val) {
                case 'string':
                    this.name = val;
                    break;
                case 'function':
                    var newName = val(this);
                    if (typeof newName !== 'string') {
                        throw new Error("Name function must return a string. Current return type is " + typeof val);
                    }
                    this.name = val(this);
                    break;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "type", {
        /**
         * Returns file type
         *
         * @default 'application/octet-stream'
         * @returns {string}
         * @memberof File
         */
        get: function () {
            /* istanbul ignore next */
            return this._file.type || 'application/octet-stream';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "mimetype", {
        /**
         * Alias for file type
         *
         * @readonly
         * @type {string}
         * @memberof File
         */
        get: function () {
            return this.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "size", {
        /**
         * Returns file size
         *
         * @returns {number}
         * @memberof File
         */
        get: function () {
            return this._file.size;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns number of parts according to part size
     *
     * @param {number} size - part size in bytes
     * @returns {number}
     * @memberof File
     */
    File.prototype.getPartsCount = function (size) {
        return Math.ceil(this._file.size / size);
    };
    /**
     * Returns part metadata
     *
     * @param {number} [partNum=0]
     * @param {*} size
     * @returns {FilePartMetadata}
     * @memberof File
     */
    File.prototype.getPartMetadata = function (partNum, size) {
        var startByte = size * partNum;
        if (startByte > this._file.size) {
            throw new Error("Start byte of the part is higher than buffer size");
        }
        var endByte = Math.min(startByte + size, this._file.size);
        return {
            partNumber: partNum,
            startByte: startByte,
            endByte: endByte,
            size: endByte - startByte,
        };
    };
    /**
     * Returns part metadata + buffer
     *
     * @param {FilePartMetadata} meta
     * @returns {FilePart}
     * @memberof File
     */
    File.prototype.getPartByMetadata = function (meta, md5Enabled) {
        if (md5Enabled === void 0) { md5Enabled = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var slice;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._file.slice(meta.startByte, meta.endByte)];
                    case 1:
                        slice = _a.sent();
                        return [2 /*return*/, Promise.resolve(tslib_1.__assign(tslib_1.__assign({}, meta), { buffer: slice, md5: md5Enabled ? utils_1.md5(slice) : undefined }))];
                }
            });
        });
    };
    /**
     * Returns part chunk
     *
     * @param {FilePartMetadata} meta
     * @param {number} offset
     * @param {number} chunkSize
     * @returns {FilePart}
     * @memberof File
     */
    File.prototype.getChunkByMetadata = function (meta, offset, chunkSize, md5Enabled) {
        if (md5Enabled === void 0) { md5Enabled = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var startByte, endByte, slice;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        startByte = meta.startByte + offset;
                        endByte = Math.min(startByte + chunkSize, meta.endByte);
                        return [4 /*yield*/, this._file.slice(startByte, endByte)];
                    case 1:
                        slice = _a.sent();
                        return [2 /*return*/, Promise.resolve(tslib_1.__assign(tslib_1.__assign({}, meta), { buffer: slice, md5: md5Enabled ? utils_1.md5(slice) : undefined, size: slice.byteLength, startByte: startByte,
                                endByte: endByte,
                                offset: offset }))];
                }
            });
        });
    };
    /**
     * Cleanup file buffer to release memory
     *
     * @memberof File
     */
    File.prototype.release = function () {
        if (this._file.release) {
            this._file.release();
        }
    };
    File.prototype.toJSON = function () {
        return {
            name: this.name,
            status: this.status,
            type: this.type,
            size: this.size,
            url: this.url,
            handle: this.handle,
            uploadTags: this.uploadTags,
        };
    };
    return File;
}());
exports.File = File;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC9maWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILHVDQUFtRTtBQXNDbkU7Ozs7O0dBS0c7QUFDSDtJQWdCRSxjQUE2QixLQUFtQixFQUFtQixnQkFBa0M7UUFBeEUsVUFBSyxHQUFMLEtBQUssQ0FBYztRQUFtQixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ25HLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLG9CQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDekUsQ0FBQztJQVFELHNCQUFXLHNCQUFJO1FBTmY7Ozs7O1dBS0c7YUFDSDtZQUNFLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7UUFDekIsQ0FBQztRQWFEOzs7O1dBSUc7YUFDSCxVQUFnQixHQUFXO1lBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLG9CQUFZLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQzdELENBQUM7OztPQXBCQTtJQVNELHNCQUFXLDBCQUFRO1FBUG5COzs7Ozs7V0FNRzthQUNIO1lBQ0UsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ25CLENBQUM7OztPQUFBO0lBaUJELHNCQUFXLDRCQUFVO1FBTnJCOzs7OztXQUtHO2FBQ0gsVUFBc0IsR0FBc0M7WUFDMUQsUUFBUSxPQUFPLEdBQUcsRUFBRTtnQkFDbEIsS0FBSyxRQUFRO29CQUNYLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO29CQUNoQixNQUFNO2dCQUNSLEtBQUssVUFBVTtvQkFDYixJQUFNLE9BQU8sR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQzFCLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO3dCQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLGdFQUE4RCxPQUFPLEdBQUssQ0FBQyxDQUFDO3FCQUM3RjtvQkFFRCxJQUFJLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDdEIsTUFBTTthQUNUO1FBQ0gsQ0FBQzs7O09BQUE7SUFTRCxzQkFBVyxzQkFBSTtRQVBmOzs7Ozs7V0FNRzthQUNIO1lBQ0UsMEJBQTBCO1lBQzFCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksMEJBQTBCLENBQUM7UUFDdkQsQ0FBQzs7O09BQUE7SUFTRCxzQkFBVywwQkFBUTtRQVBuQjs7Ozs7O1dBTUc7YUFDSDtZQUNFLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztRQUNuQixDQUFDOzs7T0FBQTtJQVFELHNCQUFXLHNCQUFJO1FBTmY7Ozs7O1dBS0c7YUFDSDtZQUNFLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7UUFDekIsQ0FBQzs7O09BQUE7SUFFRDs7Ozs7O09BTUc7SUFDSSw0QkFBYSxHQUFwQixVQUFzQixJQUFZO1FBQ2hDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLDhCQUFlLEdBQXRCLFVBQXdCLE9BQWUsRUFBRSxJQUFZO1FBQ25ELElBQU0sU0FBUyxHQUFHLElBQUksR0FBRyxPQUFPLENBQUM7UUFFakMsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUU7WUFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxtREFBbUQsQ0FBQyxDQUFDO1NBQ3RFO1FBRUQsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFNUQsT0FBTztZQUNMLFVBQVUsRUFBRSxPQUFPO1lBQ25CLFNBQVMsV0FBQTtZQUNULE9BQU8sU0FBQTtZQUNQLElBQUksRUFBRSxPQUFPLEdBQUcsU0FBUztTQUMxQixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNVLGdDQUFpQixHQUE5QixVQUErQixJQUFzQixFQUFFLFVBQTBCO1FBQTFCLDJCQUFBLEVBQUEsaUJBQTBCOzs7Ozs0QkFDbkUscUJBQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUE7O3dCQUE1RCxLQUFLLEdBQUcsU0FBb0Q7d0JBRWhFLHNCQUFPLE9BQU8sQ0FBQyxPQUFPLHVDQUNqQixJQUFJLEtBQ1AsTUFBTSxFQUFFLEtBQUssRUFDYixHQUFHLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxXQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsSUFDeEMsRUFBQzs7OztLQUNKO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDVSxpQ0FBa0IsR0FBL0IsVUFBZ0MsSUFBc0IsRUFBRSxNQUFjLEVBQUUsU0FBaUIsRUFBRSxVQUEwQjtRQUExQiwyQkFBQSxFQUFBLGlCQUEwQjs7Ozs7O3dCQUM3RyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUM7d0JBQ3BDLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxTQUFTLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO3dCQUVsRCxxQkFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLEVBQUE7O3dCQUFsRCxLQUFLLEdBQUcsU0FBMEM7d0JBRXRELHNCQUFPLE9BQU8sQ0FBQyxPQUFPLHVDQUNqQixJQUFJLEtBQ1AsTUFBTSxFQUFFLEtBQUssRUFDYixHQUFHLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxXQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFDeEMsSUFBSSxFQUFFLEtBQUssQ0FBQyxVQUFVLEVBQ3RCLFNBQVMsV0FBQTtnQ0FDVCxPQUFPLFNBQUE7Z0NBQ1AsTUFBTSxRQUFBLElBQ04sRUFBQzs7OztLQUNKO0lBQ0Q7Ozs7T0FJRztJQUNJLHNCQUFPLEdBQWQ7UUFDRSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFO1lBQ3RCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDdEI7SUFDSCxDQUFDO0lBRU0scUJBQU0sR0FBYjtRQUNFLE9BQU87WUFDTCxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07WUFDbkIsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHO1lBQ2IsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1lBQ25CLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVTtTQUM1QixDQUFDO0lBQ0osQ0FBQztJQUNILFdBQUM7QUFBRCxDQTdNQSxBQTZNQyxJQUFBO0FBN01ZLG9CQUFJIiwiZmlsZSI6ImxpYi9hcGkvdXBsb2FkL2ZpbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgbWQ1LCBzYW5pdGl6ZU5hbWUsIFNhbml0aXplT3B0aW9ucyB9IGZyb20gJy4vLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVwbG9hZFRhZ3Mge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUluc3RhbmNlIHtcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG4gIHNpemU6IG51bWJlcjtcbiAgc2xpY2U6IChzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikgPT4gUHJvbWlzZTxBcnJheUJ1ZmZlcj47XG4gIHJlbGVhc2U/OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgZW51bSBGaWxlU3RhdGUge1xuICBJTklUID0gJ0luaXRpYWxpemVkJyxcbiAgUFJPR1JFU1MgPSAnUHJvZ3Jlc3MnLFxuICBTVE9SRUQgPSAnU3RvcmVkJyxcbiAgSU5UUkFOU0lUID0gJ0luVHJhbnNpdCcsXG4gIEZBSUxFRCA9ICdGYWlsZWQnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVQYXJ0TWV0YWRhdGEge1xuICBzdGFydEJ5dGU6IG51bWJlcjtcbiAgZW5kQnl0ZTogbnVtYmVyO1xuICBwYXJ0TnVtYmVyOiBudW1iZXI7XG4gIHNpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlUGFydCBleHRlbmRzIEZpbGVQYXJ0TWV0YWRhdGEge1xuICBidWZmZXI6IEJ1ZmZlciB8IEFycmF5QnVmZmVyO1xuICBtZDU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUNodW5rIGV4dGVuZHMgRmlsZVBhcnQge1xuICBvZmZzZXQ6IG51bWJlcjsgLy8gb2Zmc2V0IGZvciBjaHVuayAtIGZyb20gcGFydCBzdGFydFxufVxuXG4vKipcbiAqIEZpbGUgcmVwcmVzZW50YXRpb24gdG8gdW5pZnkgZmlsZSBvYmplY3QgaW4gbm9kZWpzIGFuZCBicm93c2VyXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIEZpbGVcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGUge1xuXG4gIHB1YmxpYyBzdGF0dXM6IEZpbGVTdGF0ZTtcblxuICBwdWJsaWMgaGFuZGxlOiBzdHJpbmc7XG5cbiAgcHVibGljIHVybDogc3RyaW5nO1xuXG4gIHB1YmxpYyBjb250YWluZXI6IHN0cmluZztcblxuICBwdWJsaWMga2V5OiBzdHJpbmc7XG5cbiAgcHVibGljIHdvcmtmbG93czogYW55W107XG5cbiAgcHVibGljIHVwbG9hZFRhZ3M6IFVwbG9hZFRhZ3M7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBfZmlsZTogRmlsZUluc3RhbmNlLCBwcml2YXRlIHJlYWRvbmx5IF9zYW5pdGl6ZU9wdGlvbnM/OiBTYW5pdGl6ZU9wdGlvbnMpIHtcbiAgICB0aGlzLl9maWxlLm5hbWUgPSBzYW5pdGl6ZU5hbWUodGhpcy5fZmlsZS5uYW1lLCB0aGlzLl9zYW5pdGl6ZU9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsZSBuYW1lXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZS5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBuYW1lIGdldHRlclxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBnZXQgZmlsZW5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgbmV3IGZpbGUgbmFtZSAgYW5kIGNsZWFudXAgZXh0cmEgY2hhcnNcbiAgICpcbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBzZXQgbmFtZSh2YWw6IHN0cmluZykge1xuICAgIHRoaXMuX2ZpbGUubmFtZSA9IHNhbml0aXplTmFtZSh2YWwsIHRoaXMuX3Nhbml0aXplT3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBjdXN0b20gbmFtZSB1c2luZyBzdHJpbmcgb3IgZnVuY3Rpb25cbiAgICogTmFtZSB3aWxsIGJlIHNhbml0aXplZFxuICAgKlxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIHNldCBjdXN0b21OYW1lKHZhbDogKChmaWxlOiB0aGlzKSA9PiBzdHJpbmcpIHwgc3RyaW5nKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLm5hbWUgPSB2YWw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICBjb25zdCBuZXdOYW1lID0gdmFsKHRoaXMpO1xuICAgICAgICBpZiAodHlwZW9mIG5ld05hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOYW1lIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgc3RyaW5nLiBDdXJyZW50IHJldHVybiB0eXBlIGlzICR7dHlwZW9mIHZhbH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmFtZSA9IHZhbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsZSB0eXBlXG4gICAqXG4gICAqIEBkZWZhdWx0ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgZ2V0IHR5cGUoKTogc3RyaW5nIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLl9maWxlLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgZm9yIGZpbGUgdHlwZVxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBnZXQgbWltZXR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsZSBzaXplXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgZ2V0IHNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZS5zaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbnVtYmVyIG9mIHBhcnRzIGFjY29yZGluZyB0byBwYXJ0IHNpemVcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBwYXJ0IHNpemUgaW4gYnl0ZXNcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBnZXRQYXJ0c0NvdW50IChzaXplOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5fZmlsZS5zaXplIC8gc2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBwYXJ0IG1ldGFkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFydE51bT0wXVxuICAgKiBAcGFyYW0geyp9IHNpemVcbiAgICogQHJldHVybnMge0ZpbGVQYXJ0TWV0YWRhdGF9XG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgZ2V0UGFydE1ldGFkYXRhIChwYXJ0TnVtOiBudW1iZXIsIHNpemU6IG51bWJlcik6IEZpbGVQYXJ0TWV0YWRhdGEge1xuICAgIGNvbnN0IHN0YXJ0Qnl0ZSA9IHNpemUgKiBwYXJ0TnVtO1xuXG4gICAgaWYgKHN0YXJ0Qnl0ZSA+IHRoaXMuX2ZpbGUuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdGFydCBieXRlIG9mIHRoZSBwYXJ0IGlzIGhpZ2hlciB0aGFuIGJ1ZmZlciBzaXplYCk7XG4gICAgfVxuXG4gICAgY29uc3QgZW5kQnl0ZSA9IE1hdGgubWluKHN0YXJ0Qnl0ZSArIHNpemUsIHRoaXMuX2ZpbGUuc2l6ZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFydE51bWJlcjogcGFydE51bSxcbiAgICAgIHN0YXJ0Qnl0ZSxcbiAgICAgIGVuZEJ5dGUsXG4gICAgICBzaXplOiBlbmRCeXRlIC0gc3RhcnRCeXRlLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBwYXJ0IG1ldGFkYXRhICsgYnVmZmVyXG4gICAqXG4gICAqIEBwYXJhbSB7RmlsZVBhcnRNZXRhZGF0YX0gbWV0YVxuICAgKiBAcmV0dXJucyB7RmlsZVBhcnR9XG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0UGFydEJ5TWV0YWRhdGEobWV0YTogRmlsZVBhcnRNZXRhZGF0YSwgbWQ1RW5hYmxlZDogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPEZpbGVQYXJ0PiB7XG4gICAgbGV0IHNsaWNlID0gYXdhaXQgdGhpcy5fZmlsZS5zbGljZShtZXRhLnN0YXJ0Qnl0ZSwgbWV0YS5lbmRCeXRlKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgLi4ubWV0YSxcbiAgICAgIGJ1ZmZlcjogc2xpY2UsXG4gICAgICBtZDU6IG1kNUVuYWJsZWQgPyBtZDUoc2xpY2UpIDogdW5kZWZpbmVkLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcGFydCBjaHVua1xuICAgKlxuICAgKiBAcGFyYW0ge0ZpbGVQYXJ0TWV0YWRhdGF9IG1ldGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcGFyYW0ge251bWJlcn0gY2h1bmtTaXplXG4gICAqIEByZXR1cm5zIHtGaWxlUGFydH1cbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRDaHVua0J5TWV0YWRhdGEobWV0YTogRmlsZVBhcnRNZXRhZGF0YSwgb2Zmc2V0OiBudW1iZXIsIGNodW5rU2l6ZTogbnVtYmVyLCBtZDVFbmFibGVkOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8RmlsZUNodW5rPiB7XG4gICAgY29uc3Qgc3RhcnRCeXRlID0gbWV0YS5zdGFydEJ5dGUgKyBvZmZzZXQ7XG4gICAgY29uc3QgZW5kQnl0ZSA9IE1hdGgubWluKHN0YXJ0Qnl0ZSArIGNodW5rU2l6ZSwgbWV0YS5lbmRCeXRlKTtcblxuICAgIGxldCBzbGljZSA9IGF3YWl0IHRoaXMuX2ZpbGUuc2xpY2Uoc3RhcnRCeXRlLCBlbmRCeXRlKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgLi4ubWV0YSxcbiAgICAgIGJ1ZmZlcjogc2xpY2UsXG4gICAgICBtZDU6IG1kNUVuYWJsZWQgPyBtZDUoc2xpY2UpIDogdW5kZWZpbmVkLFxuICAgICAgc2l6ZTogc2xpY2UuYnl0ZUxlbmd0aCxcbiAgICAgIHN0YXJ0Qnl0ZSxcbiAgICAgIGVuZEJ5dGUsXG4gICAgICBvZmZzZXQsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFudXAgZmlsZSBidWZmZXIgdG8gcmVsZWFzZSBtZW1vcnlcbiAgICpcbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyByZWxlYXNlKCkge1xuICAgIGlmICh0aGlzLl9maWxlLnJlbGVhc2UpIHtcbiAgICAgIHRoaXMuX2ZpbGUucmVsZWFzZSgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgaGFuZGxlOiB0aGlzLmhhbmRsZSxcbiAgICAgIHVwbG9hZFRhZ3M6IHRoaXMudXBsb2FkVGFncyxcbiAgICB9O1xuICB9XG59XG4iXX0=


/***/ }),

/***/ 3373:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
exports.base64Regexp = /data:([a-zA-Z]*\/[a-zA-Z+]*);base64,([^\"]*)/i;
/**
 * Check if file is blob
 * @param input
 */
exports.isFileBlob = function (input) { return input.toString() === '[object Blob]'; };
/**
 * Check if file is instance of named interface
 *
 * @param input
 */
exports.isFileNamed = function (input) { return input && input['file'] && input['name']; };
tslib_1.__exportStar(__nccwpck_require__(7571), exports);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC9maWxlX3Rvb2xzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQXdCYSxRQUFBLFlBQVksR0FBRywrQ0FBK0MsQ0FBQztBQUU1RTs7O0dBR0c7QUFDVSxRQUFBLFVBQVUsR0FBRyxVQUFDLEtBQWdCLElBQW9CLE9BQUEsS0FBSyxDQUFDLFFBQVEsRUFBRSxLQUFLLGVBQWUsRUFBcEMsQ0FBb0MsQ0FBQztBQUVwRzs7OztHQUlHO0FBQ1UsUUFBQSxXQUFXLEdBQUcsVUFBQyxLQUFnQixJQUE4QixPQUFBLEtBQUssSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUF2QyxDQUF1QyxDQUFDO0FBRWxILDREQUFrQyIsImZpbGUiOiJsaWIvYXBpL3VwbG9hZC9maWxlX3Rvb2xzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBieSBGaWxlc3RhY2suXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCB0eXBlIFJhd0ZpbGUgPSBCbG9iIHwgQnVmZmVyIHwgRmlsZSB8IHN0cmluZztcbmV4cG9ydCB0eXBlIE5hbWVkSW5wdXRGaWxlID0ge1xuICBuYW1lPzogc3RyaW5nO1xuICBmaWxlOiBSYXdGaWxlO1xufTtcblxuZXhwb3J0IHR5cGUgSW5wdXRGaWxlID0gUmF3RmlsZSB8IE5hbWVkSW5wdXRGaWxlO1xuXG5leHBvcnQgY29uc3QgYmFzZTY0UmVnZXhwID0gL2RhdGE6KFthLXpBLVpdKlxcL1thLXpBLVorXSopO2Jhc2U2NCwoW15cXFwiXSopL2k7XG5cbi8qKlxuICogQ2hlY2sgaWYgZmlsZSBpcyBibG9iXG4gKiBAcGFyYW0gaW5wdXRcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRmlsZUJsb2IgPSAoaW5wdXQ6IElucHV0RmlsZSk6IGlucHV0IGlzIEJsb2IgPT4gaW5wdXQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xuXG4vKipcbiAqIENoZWNrIGlmIGZpbGUgaXMgaW5zdGFuY2Ugb2YgbmFtZWQgaW50ZXJmYWNlXG4gKlxuICogQHBhcmFtIGlucHV0XG4gKi9cbmV4cG9ydCBjb25zdCBpc0ZpbGVOYW1lZCA9IChpbnB1dDogSW5wdXRGaWxlKTogaW5wdXQgaXMgTmFtZWRJbnB1dEZpbGUgPT4gaW5wdXQgJiYgaW5wdXRbJ2ZpbGUnXSAmJiBpbnB1dFsnbmFtZSddO1xuXG5leHBvcnQgKiBmcm9tICcuL2ZpbGVfdG9vbHMubm9kZSc7XG4iXX0=


/***/ }),

/***/ 7571:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var file_1 = __nccwpck_require__(6669);
var utils_1 = __nccwpck_require__(8123);
var filestack_error_1 = __nccwpck_require__(4257);
var file_tools_1 = __nccwpck_require__(3373);
/**
 * Check if file is buffer
 *
 * @node
 * @param input
 */
var isFileBuffer = function (input) { return Buffer.isBuffer(input); };
/**
 * Check if input is a valid file path
 *
 * @node
 * @param input
 */
var isFilePath = function (input) { return __nccwpck_require__(5747).existsSync(input); };
/**
 * Check if file is base64 string
 *
 * @param input
 */
var isFileBase = function (input) {
    if (typeof input !== 'string') {
        return false;
    }
    if (input.indexOf('base64') > -1 && file_tools_1.base64Regexp.test(input)) {
        input = input.match(file_tools_1.base64Regexp).pop();
    }
    if (Buffer.from(input, 'base64').toString('base64') === input) {
        return true;
    }
    return false;
};
/**
 * Accepts Buffer or filepath or base64 string
 *
 * @node
 * @param {*} inputFile
 * @returns {Promise<File>}
 */
exports.getFile = function (input, sanitizeOptions) {
    var filename;
    if (file_tools_1.isFileNamed(input)) {
        filename = input.name;
        input = input.file;
    }
    if (isFilePath(input)) {
        var path_1 = input;
        return new Promise(function (resolve, reject) {
            __nccwpck_require__(5747).readFile(path_1, function (err, buffer) {
                if (err) {
                    return reject(err);
                }
                if (!filename) {
                    filename = require && __nccwpck_require__(5622).basename(path_1);
                }
                return resolve(new file_1.File({
                    name: filename,
                    size: buffer.byteLength,
                    type: utils_1.getMimetype(buffer, filename),
                    slice: function (start, end) { return Promise.resolve(buffer.slice(start, end)); },
                }, sanitizeOptions));
            });
        });
    }
    if (isFileBase(input)) {
        var matches = input.match(file_tools_1.base64Regexp);
        if (matches && matches.length === 2) {
            input = Buffer.from(matches[2], 'base64');
        }
        else {
            input = Buffer.from(input, 'base64');
        }
    }
    if (isFileBuffer(input)) {
        return Promise.resolve(new file_1.File({
            name: filename,
            size: input.byteLength,
            type: utils_1.getMimetype(input, filename),
            // @ts-ignore
            slice: function (start, end) { return Promise.resolve(input.slice(start, end)); },
        }, sanitizeOptions));
    }
    return Promise.reject(new filestack_error_1.FilestackError('Unsupported input file type'));
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC9maWxlX3Rvb2xzLm5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCwrQkFBd0M7QUFDeEMsdUNBQTZEO0FBQzdELDhEQUE0RDtBQUM1RCwyQ0FBb0U7QUFFcEU7Ozs7O0dBS0c7QUFDSCxJQUFNLFlBQVksR0FBRyxVQUFDLEtBQWdCLElBQXNCLE9BQUEsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBdEIsQ0FBc0IsQ0FBQztBQUVuRjs7Ozs7R0FLRztBQUNILElBQU0sVUFBVSxHQUFHLFVBQUMsS0FBZ0IsSUFBc0IsT0FBQSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUEvQixDQUErQixDQUFDO0FBRTFGOzs7O0dBSUc7QUFDSCxJQUFNLFVBQVUsR0FBRyxVQUFDLEtBQWdCO0lBQ2xDLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO1FBQzdCLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFFRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUkseUJBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDNUQsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMseUJBQVksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ3pDO0lBRUQsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEtBQUssS0FBSyxFQUFFO1FBQzdELE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUMsQ0FBQztBQUVGOzs7Ozs7R0FNRztBQUNVLFFBQUEsT0FBTyxHQUFHLFVBQUMsS0FBZ0IsRUFBRSxlQUFpQztJQUN6RSxJQUFJLFFBQVEsQ0FBQztJQUViLElBQUksd0JBQVcsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUN0QixRQUFRLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQztRQUN0QixLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQztLQUNwQjtJQUVELElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLElBQUksTUFBSSxHQUFHLEtBQUssQ0FBQztRQUNqQixPQUFPLElBQUksT0FBTyxDQUFDLFVBQUMsT0FBTyxFQUFFLE1BQU07WUFDakMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFJLEVBQUUsVUFBQyxHQUFHLEVBQUUsTUFBTTtnQkFDdkMsSUFBSSxHQUFHLEVBQUU7b0JBQ1AsT0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQ3BCO2dCQUVELElBQUksQ0FBQyxRQUFRLEVBQUU7b0JBQ2IsUUFBUSxHQUFHLE9BQU8sSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQUksQ0FBQyxDQUFDO2lCQUN0RDtnQkFFRCxPQUFPLE9BQU8sQ0FDWixJQUFJLFdBQU0sQ0FDUjtvQkFDRSxJQUFJLEVBQUUsUUFBUTtvQkFDZCxJQUFJLEVBQUUsTUFBTSxDQUFDLFVBQVU7b0JBQ3ZCLElBQUksRUFBRSxtQkFBVyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUM7b0JBQ25DLEtBQUssRUFBRSxVQUFDLEtBQUssRUFBRSxHQUFHLElBQUssT0FBQSxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQXpDLENBQXlDO2lCQUNqRSxFQUNELGVBQWUsQ0FDaEIsQ0FDRixDQUFDO1lBQ0osQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztLQUNKO0lBRUQsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDckIsSUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyx5QkFBWSxDQUFDLENBQUM7UUFDMUMsSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDbkMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQzNDO2FBQU07WUFDTCxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDdEM7S0FDRjtJQUVELElBQUksWUFBWSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3ZCLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FDcEIsSUFBSSxXQUFNLENBQ1I7WUFDRSxJQUFJLEVBQUUsUUFBUTtZQUNkLElBQUksRUFBRSxLQUFLLENBQUMsVUFBVTtZQUN0QixJQUFJLEVBQUUsbUJBQVcsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDO1lBQ2xDLGFBQWE7WUFDYixLQUFLLEVBQUUsVUFBQyxLQUFLLEVBQUUsR0FBRyxJQUFLLE9BQUEsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUF4QyxDQUF3QztTQUNoRSxFQUNELGVBQWUsQ0FDaEIsQ0FDRixDQUFDO0tBQ0g7SUFFRCxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxnQ0FBYyxDQUFDLDZCQUE2QixDQUFDLENBQUMsQ0FBQztBQUMzRSxDQUFDLENBQUMiLCJmaWxlIjoibGliL2FwaS91cGxvYWQvZmlsZV90b29scy5ub2RlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBieSBGaWxlc3RhY2suXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEZpbGUgYXMgRnNGaWxlIH0gZnJvbSAnLi9maWxlJztcbmltcG9ydCB7IFNhbml0aXplT3B0aW9ucywgZ2V0TWltZXR5cGUgfSBmcm9tICcuLy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IEZpbGVzdGFja0Vycm9yIH0gZnJvbSAnLi8uLi8uLi8uLi9maWxlc3RhY2tfZXJyb3InO1xuaW1wb3J0IHsgSW5wdXRGaWxlLCBiYXNlNjRSZWdleHAsIGlzRmlsZU5hbWVkIH0gZnJvbSAnLi9maWxlX3Rvb2xzJztcblxuLyoqXG4gKiBDaGVjayBpZiBmaWxlIGlzIGJ1ZmZlclxuICpcbiAqIEBub2RlXG4gKiBAcGFyYW0gaW5wdXRcbiAqL1xuY29uc3QgaXNGaWxlQnVmZmVyID0gKGlucHV0OiBJbnB1dEZpbGUpOiBpbnB1dCBpcyBCdWZmZXIgPT4gQnVmZmVyLmlzQnVmZmVyKGlucHV0KTtcblxuLyoqXG4gKiBDaGVjayBpZiBpbnB1dCBpcyBhIHZhbGlkIGZpbGUgcGF0aFxuICpcbiAqIEBub2RlXG4gKiBAcGFyYW0gaW5wdXRcbiAqL1xuY29uc3QgaXNGaWxlUGF0aCA9IChpbnB1dDogSW5wdXRGaWxlKTogaW5wdXQgaXMgc3RyaW5nID0+IHJlcXVpcmUoJ2ZzJykuZXhpc3RzU3luYyhpbnB1dCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgZmlsZSBpcyBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIGlucHV0XG4gKi9cbmNvbnN0IGlzRmlsZUJhc2UgPSAoaW5wdXQ6IElucHV0RmlsZSk6IGlucHV0IGlzIHN0cmluZyA9PiB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlucHV0LmluZGV4T2YoJ2Jhc2U2NCcpID4gLTEgJiYgYmFzZTY0UmVnZXhwLnRlc3QoaW5wdXQpKSB7XG4gICAgaW5wdXQgPSBpbnB1dC5tYXRjaChiYXNlNjRSZWdleHApLnBvcCgpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5mcm9tKGlucHV0LCAnYmFzZTY0JykudG9TdHJpbmcoJ2Jhc2U2NCcpID09PSBpbnB1dCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBBY2NlcHRzIEJ1ZmZlciBvciBmaWxlcGF0aCBvciBiYXNlNjQgc3RyaW5nXG4gKlxuICogQG5vZGVcbiAqIEBwYXJhbSB7Kn0gaW5wdXRGaWxlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGaWxlPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEZpbGUgPSAoaW5wdXQ6IElucHV0RmlsZSwgc2FuaXRpemVPcHRpb25zPzogU2FuaXRpemVPcHRpb25zKTogUHJvbWlzZTxGc0ZpbGU+ID0+IHtcbiAgbGV0IGZpbGVuYW1lO1xuXG4gIGlmIChpc0ZpbGVOYW1lZChpbnB1dCkpIHtcbiAgICBmaWxlbmFtZSA9IGlucHV0Lm5hbWU7XG4gICAgaW5wdXQgPSBpbnB1dC5maWxlO1xuICB9XG5cbiAgaWYgKGlzRmlsZVBhdGgoaW5wdXQpKSB7XG4gICAgbGV0IHBhdGggPSBpbnB1dDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVxdWlyZSgnZnMnKS5yZWFkRmlsZShwYXRoLCAoZXJyLCBidWZmZXIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgICAgICBmaWxlbmFtZSA9IHJlcXVpcmUgJiYgcmVxdWlyZSgncGF0aCcpLmJhc2VuYW1lKHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoXG4gICAgICAgICAgbmV3IEZzRmlsZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogZmlsZW5hbWUsXG4gICAgICAgICAgICAgIHNpemU6IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICB0eXBlOiBnZXRNaW1ldHlwZShidWZmZXIsIGZpbGVuYW1lKSxcbiAgICAgICAgICAgICAgc2xpY2U6IChzdGFydCwgZW5kKSA9PiBQcm9taXNlLnJlc29sdmUoYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW5pdGl6ZU9wdGlvbnNcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc0ZpbGVCYXNlKGlucHV0KSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBpbnB1dC5tYXRjaChiYXNlNjRSZWdleHApO1xuICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICBpbnB1dCA9IEJ1ZmZlci5mcm9tKG1hdGNoZXNbMl0sICdiYXNlNjQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQgPSBCdWZmZXIuZnJvbShpbnB1dCwgJ2Jhc2U2NCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0ZpbGVCdWZmZXIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgIG5ldyBGc0ZpbGUoXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICBzaXplOiBpbnB1dC5ieXRlTGVuZ3RoLFxuICAgICAgICAgIHR5cGU6IGdldE1pbWV0eXBlKGlucHV0LCBmaWxlbmFtZSksXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHNsaWNlOiAoc3RhcnQsIGVuZCkgPT4gUHJvbWlzZS5yZXNvbHZlKGlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpKSxcbiAgICAgICAgfSxcbiAgICAgICAgc2FuaXRpemVPcHRpb25zXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRmlsZXN0YWNrRXJyb3IoJ1Vuc3VwcG9ydGVkIGlucHV0IGZpbGUgdHlwZScpKTtcbn07XG4iXX0=


/***/ }),

/***/ 2427:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(3373), exports);
tslib_1.__exportStar(__nccwpck_require__(7992), exports);
tslib_1.__exportStar(__nccwpck_require__(6669), exports);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHOzs7QUFFSCx1REFBNkI7QUFDN0IsbURBQXlCO0FBQ3pCLGlEQUF1QiIsImZpbGUiOiJsaWIvYXBpL3VwbG9hZC9pbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCAqIGZyb20gJy4vZmlsZV90b29scyc7XG5leHBvcnQgKiBmcm9tICcuL3VwbG9hZCc7XG5leHBvcnQgKiBmcm9tICcuL2ZpbGUnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG4iXX0=


/***/ }),

/***/ 7992:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var eventemitter3_1 = __nccwpck_require__(1848);
var s3_1 = __nccwpck_require__(6524);
var filestack_error_1 = __nccwpck_require__(4257);
var file_tools_1 = __nccwpck_require__(3373);
var schema_1 = __nccwpck_require__(2782);
var DEFAULT_PROGRESS_INTERVAL = 1000;
var normalizeProgress = function (current, last) {
    current.totalBytes = Math.max(current.totalBytes, last.totalBytes);
    current.totalPercent = Math.max(current.totalPercent, last.totalPercent);
    return current;
};
/**
 * Uploader main class for now its supporting only s3 upload type
 *
 * @export
 * @class Upload
 */
var Upload = /** @class */ (function (_super) {
    tslib_1.__extends(Upload, _super);
    function Upload(options, storeOptions) {
        if (options === void 0) { options = {}; }
        if (storeOptions === void 0) { storeOptions = {}; }
        var _this = _super.call(this) || this;
        _this.options = options;
        _this.storeOptions = storeOptions;
        _this.lastProgress = {
            totalBytes: 0,
            totalPercent: 0,
        };
        // do not delete filename from original options reference - copy it first
        _this.storeOptions = Object.assign({}, storeOptions);
        var validateRes = schema_1.getValidator(schema_1.UploadParamsSchema)(options);
        if (validateRes.errors.length) {
            throw new filestack_error_1.FilestackError("Invalid upload params", validateRes.errors, filestack_error_1.FilestackErrorType.VALIDATION);
        }
        var storeValidateRes = schema_1.getValidator(schema_1.StoreParamsSchema)(storeOptions);
        if (storeValidateRes.errors.length) {
            throw new filestack_error_1.FilestackError("Invalid store upload params", storeValidateRes.errors, filestack_error_1.FilestackErrorType.VALIDATION);
        }
        if (storeOptions.filename) {
            _this.overrideFileName = storeOptions.filename;
            delete _this.storeOptions.filename;
        }
        if (_this.storeOptions.sanitizer) {
            _this.sanitizerOptions = _this.storeOptions.sanitizer;
            delete _this.storeOptions.sanitizer;
        }
        _this.uploader = new s3_1.S3Uploader(_this.storeOptions, options.concurrency);
        _this.uploader.setRetryConfig({
            retry: options.retry || 10,
            onRetry: options.onRetry,
            retryFactor: options.retryFactor || 2,
            retryMaxTime: options.retryMaxTime || 15000,
        });
        _this.uploader.setTimeout(options.timeout || 120000);
        if (options.partSize) {
            _this.uploader.setPartSize(options.partSize);
        }
        if (options.intelligentChunkSize) {
            _this.uploader.setIntelligentChunkSize(options.intelligentChunkSize);
        }
        if (options.disableIntegrityCheck) {
            _this.uploader.setIntegrityCheck(false);
        }
        if (options.intelligent) {
            _this.uploader.setUploadMode(options.intelligent === 'fallback' ? "fallback" /* FALLBACK */ : "intelligent" /* INTELLIGENT */);
        }
        _this.uploader.setUploadTags(options.tags);
        _this.uploader.on('start', function () { return _this.emit('start'); });
        _this.uploader.on('error', function (e) { return _this.emit('error', e); });
        _this.uploader.on('progress', _this.handleProgress.bind(_this));
        return _this;
    }
    /**
     * Set session object to uploader
     *
     * @deprecated
     * @param {Session} session
     * @memberof Upload
     */
    Upload.prototype.setSession = function (session) {
        this.uploader.setApikey(session.apikey);
        if (session.policy && session.signature) {
            this.uploader.setSecurity({
                policy: session.policy,
                signature: session.signature,
            });
        }
        this.uploader.setUrl(session.urls.uploadApiUrl);
    };
    /**
     * Set cancel token to controll upload flow
     *
     * @param {*} token
     * @returns
     * @memberof Upload
     */
    Upload.prototype.setToken = function (token) {
        var _this = this;
        if (!token || token !== Object(token)) {
            throw new Error('Incorrect upload token. Must be instance of object');
        }
        token.pause = function () { return _this.uploader.pause(); };
        token.resume = function () { return _this.uploader.resume(); };
        token.cancel = function () { return _this.uploader.abort(); };
        return token;
    };
    /**
     * Sets security to uploader instance
     *
     * @param {Security} security
     * @memberof Upload
     */
    Upload.prototype.setSecurity = function (security) {
        this.uploader.setSecurity(security);
    };
    /**
     * Set upload tags
     *
     * @param {Tags} tags
     * @memberof Upload
     */
    Upload.prototype.setUploadTags = function (tags) {
        this.uploader.setUploadTags(tags);
    };
    /**
     * Upload single file
     *
     * @param {(InputFile)} file
     * @returns {Promise<any>}
     * @memberof Upload
     */
    Upload.prototype.upload = function (input) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var f, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, file_tools_1.getFile(input, this.sanitizerOptions)];
                    case 1:
                        f = _a.sent();
                        f.customName = this.overrideFileName;
                        this.uploader.addFile(f);
                        this.startProgressInterval();
                        return [4 /*yield*/, this.uploader.execute()];
                    case 2:
                        res = (_a.sent()).shift();
                        this.stopProgressInterval();
                        this.uploader.removeAllListeners();
                        if (res.status === "Failed" /* FAILED */) {
                            return [2 /*return*/, Promise.reject(res)];
                        }
                        return [2 /*return*/, Promise.resolve(res)];
                }
            });
        });
    };
    /**
     * Upload multiple files at once
     *
     * @param {(InputFile[])} input
     * @returns {Promise<any>}
     * @memberof Upload
     */
    Upload.prototype.multiupload = function (input) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, _b, _i, i, f, res;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = [];
                        for (_b in input)
                            _a.push(_b);
                        _i = 0;
                        _c.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 4];
                        i = _a[_i];
                        /* istanbul ignore next */
                        if (!input.hasOwnProperty(i)) {
                            return [3 /*break*/, 3];
                        }
                        return [4 /*yield*/, file_tools_1.getFile(input[i], this.sanitizerOptions)];
                    case 2:
                        f = _c.sent();
                        f.customName = this.overrideFileName;
                        this.uploader.addFile(f);
                        _c.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        this.startProgressInterval();
                        return [4 /*yield*/, this.uploader.execute()];
                    case 5:
                        res = _c.sent();
                        this.stopProgressInterval();
                        this.uploader.removeAllListeners();
                        return [2 /*return*/, Promise.resolve(res)];
                }
            });
        });
    };
    /**
     * RUn progress with userdefined interval
     *
     * @private
     * @returns
     * @memberof Upload
     */
    Upload.prototype.startProgressInterval = function () {
        var _this = this;
        if (typeof this.options.onProgress !== 'function') {
            return;
        }
        this.progressIntervalHandler = setInterval(function () {
            _this.options.onProgress(_this.lastProgress);
        }, this.options.progressInterval || DEFAULT_PROGRESS_INTERVAL);
        this.options.onProgress(this.lastProgress);
    };
    /**
     * Stop progress interval after upload
     *
     * @private
     * @memberof Upload
     */
    Upload.prototype.stopProgressInterval = function () {
        clearInterval(this.progressIntervalHandler);
    };
    /**
     * Handle upload interval and normalize values
     *
     * @private
     * @param {ProgressEvent} progress
     * @memberof Upload
     */
    Upload.prototype.handleProgress = function (progress) {
        // get max progress data to avoid progress jumps on any part error
        progress = normalizeProgress(progress, this.lastProgress);
        if (this.lastProgress.files) {
            for (var i in progress.files) {
                if (this.lastProgress.files[i]) {
                    progress.files[i] = normalizeProgress(progress.files[i], this.lastProgress.files[i]);
                }
            }
        }
        this.lastProgress = progress;
    };
    return Upload;
}(eventemitter3_1.EventEmitter));
exports.Upload = Upload;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC91cGxvYWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRzs7O0FBRUgsK0NBQTZDO0FBRTdDLHFDQUE0QztBQUM1Qyw4REFBZ0Y7QUFJaEYsMkNBQWtEO0FBR2xELDRDQUF3RjtBQVF4RixJQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQztBQUV2QyxJQUFNLGlCQUFpQixHQUFHLFVBQUMsT0FBTyxFQUFFLElBQUk7SUFDdEMsT0FBTyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ25FLE9BQU8sQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUV6RSxPQUFPLE9BQU8sQ0FBQztBQUNqQixDQUFDLENBQUM7QUFFRjs7Ozs7R0FLRztBQUNIO0lBQTRCLGtDQUFZO0lBMkJ0QyxnQkFBNkIsT0FBMkIsRUFBVSxZQUFxQztRQUExRSx3QkFBQSxFQUFBLFlBQTJCO1FBQVUsNkJBQUEsRUFBQSxpQkFBcUM7UUFBdkcsWUFDRSxpQkFBTyxTQTBEUjtRQTNENEIsYUFBTyxHQUFQLE9BQU8sQ0FBb0I7UUFBVSxrQkFBWSxHQUFaLFlBQVksQ0FBeUI7UUFSL0Ysa0JBQVksR0FBa0I7WUFDcEMsVUFBVSxFQUFFLENBQUM7WUFDYixZQUFZLEVBQUUsQ0FBQztTQUNoQixDQUFDO1FBUUEseUVBQXlFO1FBQ3pFLEtBQUksQ0FBQyxZQUFZLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFFcEQsSUFBTSxXQUFXLEdBQUcscUJBQVksQ0FBQywyQkFBa0IsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRTlELElBQUksV0FBVyxDQUFDLE1BQU0s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SUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRTFELElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUU7WUFDM0IsS0FBSyxJQUFJLENBQUMsSUFBSSxRQUFRLENBQUMsS0FBSyxFQUFFO2dCQUM1QixJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO29CQUM5QixRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDdEY7YUFDRjtTQUNGO1FBRUQsSUFBSSxDQUFDLFlBQVksR0FBRyxRQUFRLENBQUM7SUFDL0IsQ0FBQztJQUNILGFBQUM7QUFBRCxDQTNQQSxBQTJQQyxDQTNQMkIsNEJBQVksR0EyUHZDO0FBM1BZLHdCQUFNIiwiZmlsZSI6ImxpYi9hcGkvdXBsb2FkL3VwbG9hZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgU2Vzc2lvbiwgU2VjdXJpdHkgfSBmcm9tICcuLi8uLi9jbGllbnQnO1xuaW1wb3J0IHsgUzNVcGxvYWRlciB9IGZyb20gJy4vdXBsb2FkZXJzL3MzJztcbmltcG9ydCB7IEZpbGVzdGFja0Vycm9yLCBGaWxlc3RhY2tFcnJvclR5cGUgfSBmcm9tICcuLy4uLy4uLy4uL2ZpbGVzdGFja19lcnJvcic7XG5pbXBvcnQgeyBTYW5pdGl6ZU9wdGlvbnMgfSBmcm9tICcuLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IHsgVXBsb2FkT3B0aW9ucywgU3RvcmVVcGxvYWRPcHRpb25zIH0gZnJvbSAnLi4vdXBsb2FkL3R5cGVzJztcbmltcG9ydCB7IGdldEZpbGUsIElucHV0RmlsZSB9IGZyb20gJy4vZmlsZV90b29scyc7XG5pbXBvcnQgeyBGaWxlU3RhdGUsIFVwbG9hZFRhZ3MgfSBmcm9tICcuL2ZpbGUnO1xuaW1wb3J0IHsgVXBsb2FkTW9kZSB9IGZyb20gJy4vdXBsb2FkZXJzL2Fic3RyYWN0JztcbmltcG9ydCB7IGdldFZhbGlkYXRvciwgVXBsb2FkUGFyYW1zU2NoZW1hLCBTdG9yZVBhcmFtc1NjaGVtYSB9IGZyb20gJy4vLi4vLi4vLi4vc2NoZW1hJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9ncmVzc0V2ZW50IHtcbiAgdG90YWxQZXJjZW50OiBudW1iZXI7XG4gIHRvdGFsQnl0ZXM6IG51bWJlcjtcbiAgZmlsZXM/OiB7IChrZXk6IHN0cmluZyk6IFByb2dyZXNzRXZlbnQgfTtcbn1cblxuY29uc3QgREVGQVVMVF9QUk9HUkVTU19JTlRFUlZBTCA9IDEwMDA7XG5cbmNvbnN0IG5vcm1hbGl6ZVByb2dyZXNzID0gKGN1cnJlbnQsIGxhc3QpID0+IHtcbiAgY3VycmVudC50b3RhbEJ5dGVzID0gTWF0aC5tYXgoY3VycmVudC50b3RhbEJ5dGVzLCBsYXN0LnRvdGFsQnl0ZXMpO1xuICBjdXJyZW50LnRvdGFsUGVyY2VudCA9IE1hdGgubWF4KGN1cnJlbnQudG90YWxQZXJjZW50LCBsYXN0LnRvdGFsUGVyY2VudCk7XG5cbiAgcmV0dXJuIGN1cnJlbnQ7XG59O1xuXG4vKipcbiAqIFVwbG9hZGVyIG1haW4gY2xhc3MgZm9yIG5vdyBpdHMgc3VwcG9ydGluZyBvbmx5IHMzIHVwbG9hZCB0eXBlXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIFVwbG9hZFxuICovXG5leHBvcnQgY2xhc3MgVXBsb2FkIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICAvKipcbiAgICogVXBsb2FkZXIgaW5zdGFuY2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge1MzVXBsb2FkZXJ9XG4gICAqIEBtZW1iZXJvZiBVcGxvYWRcbiAgICovXG4gIHByaXZhdGUgdXBsb2FkZXI6IFMzVXBsb2FkZXI7XG5cbiAgLyoqXG4gICAqIFNob3VsZCB3ZSBvdmVyd3JpdGUgZmlsZSBuYW1lXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZW1iZXJvZiBVcGxvYWRcbiAgICovXG4gIHByaXZhdGUgb3ZlcnJpZGVGaWxlTmFtZTtcblxuICBwcml2YXRlIGxhc3RQcm9ncmVzczogUHJvZ3Jlc3NFdmVudCA9IHtcbiAgICB0b3RhbEJ5dGVzOiAwLFxuICAgIHRvdGFsUGVyY2VudDogMCxcbiAgfTtcblxuICBwcml2YXRlIHByb2dyZXNzSW50ZXJ2YWxIYW5kbGVyO1xuICBwcml2YXRlIHNhbml0aXplck9wdGlvbnM6IFNhbml0aXplT3B0aW9ucztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IFVwbG9hZE9wdGlvbnMgPSB7fSwgcHJpdmF0ZSBzdG9yZU9wdGlvbnM6IFN0b3JlVXBsb2FkT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8vIGRvIG5vdCBkZWxldGUgZmlsZW5hbWUgZnJvbSBvcmlnaW5hbCBvcHRpb25zIHJlZmVyZW5jZSAtIGNvcHkgaXQgZmlyc3RcbiAgICB0aGlzLnN0b3JlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHN0b3JlT3B0aW9ucyk7XG5cbiAgICBjb25zdCB2YWxpZGF0ZVJlcyA9IGdldFZhbGlkYXRvcihVcGxvYWRQYXJhbXNTY2hlbWEpKG9wdGlvbnMpO1xuXG4gICAgaWYgKHZhbGlkYXRlUmVzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBGaWxlc3RhY2tFcnJvcihgSW52YWxpZCB1cGxvYWQgcGFyYW1zYCwgdmFsaWRhdGVSZXMuZXJyb3JzLCBGaWxlc3RhY2tFcnJvclR5cGUuVkFMSURBVElPTik7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmVWYWxpZGF0ZVJlcyA9IGdldFZhbGlkYXRvcihTdG9yZVBhcmFtc1NjaGVtYSkoc3RvcmVPcHRpb25zKTtcbiAgICBpZiAoc3RvcmVWYWxpZGF0ZVJlcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRmlsZXN0YWNrRXJyb3IoYEludmFsaWQgc3RvcmUgdXBsb2FkIHBhcmFtc2AsIHN0b3JlVmFsaWRhdGVSZXMuZXJyb3JzLCBGaWxlc3RhY2tFcnJvclR5cGUuVkFMSURBVElPTik7XG4gICAgfVxuXG4gICAgaWYgKHN0b3JlT3B0aW9ucy5maWxlbmFtZSkge1xuICAgICAgdGhpcy5vdmVycmlkZUZpbGVOYW1lID0gc3RvcmVPcHRpb25zLmZpbGVuYW1lO1xuICAgICAgZGVsZXRlIHRoaXMuc3RvcmVPcHRpb25zLmZpbGVuYW1lO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0b3JlT3B0aW9ucy5zYW5pdGl6ZXIpIHtcbiAgICAgIHRoaXMuc2FuaXRpemVyT3B0aW9ucyA9IHRoaXMuc3RvcmVPcHRpb25zLnNhbml0aXplcjtcbiAgICAgIGRlbGV0ZSB0aGlzLnN0b3JlT3B0aW9ucy5zYW5pdGl6ZXI7XG4gICAgfVxuXG4gICAgdGhpcy51cGxvYWRlciA9IG5ldyBTM1VwbG9hZGVyKHRoaXMuc3RvcmVPcHRpb25zLCBvcHRpb25zLmNvbmN1cnJlbmN5KTtcblxuICAgIHRoaXMudXBsb2FkZXIuc2V0UmV0cnlDb25maWcoe1xuICAgICAgcmV0cnk6IG9wdGlvbnMucmV0cnkgfHwgMTAsXG4gICAgICBvblJldHJ5OiBvcHRpb25zLm9uUmV0cnksIC8vIEB0b2RvIGJpbmQgZmlsZSB0byByZXRyeSBpbiBzMyB1cGxvYWRlclxuICAgICAgcmV0cnlGYWN0b3I6IG9wdGlvbnMucmV0cnlGYWN0b3IgfHwgMixcbiAgICAgIHJldHJ5TWF4VGltZTogb3B0aW9ucy5yZXRyeU1heFRpbWUgfHwgMTUwMDAsXG4gICAgfSk7XG5cbiAgICB0aGlzLnVwbG9hZGVyLnNldFRpbWVvdXQob3B0aW9ucy50aW1lb3V0IHx8IDEyMDAwMCk7XG5cbiAgICBpZiAob3B0aW9ucy5wYXJ0U2l6ZSkge1xuICAgICAgdGhpcy51cGxvYWRlci5zZXRQYXJ0U2l6ZShvcHRpb25zLnBhcnRTaXplKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbnRlbGxpZ2VudENodW5rU2l6ZSkge1xuICAgICAgdGhpcy51cGxvYWRlci5zZXRJbnRlbGxpZ2VudENodW5rU2l6ZShvcHRpb25zLmludGVsbGlnZW50Q2h1bmtTaXplKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5kaXNhYmxlSW50ZWdyaXR5Q2hlY2spIHtcbiAgICAgIHRoaXMudXBsb2FkZXIuc2V0SW50ZWdyaXR5Q2hlY2soZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmludGVsbGlnZW50KSB7XG4gICAgICB0aGlzLnVwbG9hZGVyLnNldFVwbG9hZE1vZGUob3B0aW9ucy5pbnRlbGxpZ2VudCA9PT0gJ2ZhbGxiYWNrJyA/IFVwbG9hZE1vZGUuRkFMTEJBQ0sgOiBVcGxvYWRNb2RlLklOVEVMTElHRU5UKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwbG9hZGVyLnNldFVwbG9hZFRhZ3Mob3B0aW9ucy50YWdzKTtcblxuICAgIHRoaXMudXBsb2FkZXIub24oJ3N0YXJ0JywgKCkgPT4gdGhpcy5lbWl0KCdzdGFydCcpKTtcbiAgICB0aGlzLnVwbG9hZGVyLm9uKCdlcnJvcicsIChlKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZSkpO1xuICAgIHRoaXMudXBsb2FkZXIub24oJ3Byb2dyZXNzJywgdGhpcy5oYW5kbGVQcm9ncmVzcy5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgc2Vzc2lvbiBvYmplY3QgdG8gdXBsb2FkZXJcbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIHtTZXNzaW9ufSBzZXNzaW9uXG4gICAqIEBtZW1iZXJvZiBVcGxvYWRcbiAgICovXG4gIHNldFNlc3Npb24oc2Vzc2lvbjogU2Vzc2lvbikge1xuICAgIHRoaXMudXBsb2FkZXIuc2V0QXBpa2V5KHNlc3Npb24uYXBpa2V5KTtcblxuICAgIGlmIChzZXNzaW9uLnBvbGljeSAmJiBzZXNzaW9uLnNpZ25hdHVyZSkge1xuICAgICAgdGhpcy51cGxvYWRlci5zZXRTZWN1cml0eSh7XG4gICAgICAgIHBvbGljeTogc2Vzc2lvbi5wb2xpY3ksXG4gICAgICAgIHNpZ25hdHVyZTogc2Vzc2lvbi5zaWduYXR1cmUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnVwbG9hZGVyLnNldFVybChzZXNzaW9uLnVybHMudXBsb2FkQXBpVXJsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgY2FuY2VsIHRva2VuIHRvIGNvbnRyb2xsIHVwbG9hZCBmbG93XG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdG9rZW5cbiAgICogQHJldHVybnNcbiAgICogQG1lbWJlcm9mIFVwbG9hZFxuICAgKi9cbiAgcHVibGljIHNldFRva2VuKHRva2VuOiBhbnkpIHtcbiAgICBpZiAoIXRva2VuIHx8IHRva2VuICE9PSBPYmplY3QodG9rZW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCB1cGxvYWQgdG9rZW4uIE11c3QgYmUgaW5zdGFuY2Ugb2Ygb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgdG9rZW4ucGF1c2UgPSAoKSA9PiB0aGlzLnVwbG9hZGVyLnBhdXNlKCk7XG4gICAgdG9rZW4ucmVzdW1lID0gKCkgPT4gdGhpcy51cGxvYWRlci5yZXN1bWUoKTtcbiAgICB0b2tlbi5jYW5jZWwgPSAoKSA9PiB0aGlzLnVwbG9hZGVyLmFib3J0KCk7XG5cbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBzZWN1cml0eSB0byB1cGxvYWRlciBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge1NlY3VyaXR5fSBzZWN1cml0eVxuICAgKiBAbWVtYmVyb2YgVXBsb2FkXG4gICAqL1xuICBwdWJsaWMgc2V0U2VjdXJpdHkoc2VjdXJpdHk6IFNlY3VyaXR5KSB7XG4gICAgdGhpcy51cGxvYWRlci5zZXRTZWN1cml0eShzZWN1cml0eSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwbG9hZCB0YWdzXG4gICAqXG4gICAqIEBwYXJhbSB7VGFnc30gdGFnc1xuICAgKiBAbWVtYmVyb2YgVXBsb2FkXG4gICAqL1xuICBwdWJsaWMgc2V0VXBsb2FkVGFncyh0YWdzOiBVcGxvYWRUYWdzKSB7XG4gICAgdGhpcy51cGxvYWRlci5zZXRVcGxvYWRUYWdzKHRhZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwbG9hZCBzaW5nbGUgZmlsZVxuICAgKlxuICAgKiBAcGFyYW0geyhJbnB1dEZpbGUpfSBmaWxlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAqIEBtZW1iZXJvZiBVcGxvYWRcbiAgICovXG4gIGFzeW5jIHVwbG9hZChpbnB1dDogSW5wdXRGaWxlKTogUHJvbWlzZTxhbnk+IHtcblxuICAgIGNvbnN0IGYgPSBhd2FpdCBnZXRGaWxlKGlucHV0LCB0aGlzLnNhbml0aXplck9wdGlvbnMpO1xuICAgIGYuY3VzdG9tTmFtZSA9IHRoaXMub3ZlcnJpZGVGaWxlTmFtZTtcbiAgICB0aGlzLnVwbG9hZGVyLmFkZEZpbGUoZik7XG5cbiAgICB0aGlzLnN0YXJ0UHJvZ3Jlc3NJbnRlcnZhbCgpO1xuICAgIGNvbnN0IHJlcyA9IChhd2FpdCB0aGlzLnVwbG9hZGVyLmV4ZWN1dGUoKSkuc2hpZnQoKTtcbiAgICB0aGlzLnN0b3BQcm9ncmVzc0ludGVydmFsKCk7XG5cbiAgICB0aGlzLnVwbG9hZGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IEZpbGVTdGF0ZS5GQUlMRUQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWQgbXVsdGlwbGUgZmlsZXMgYXQgb25jZVxuICAgKlxuICAgKiBAcGFyYW0geyhJbnB1dEZpbGVbXSl9IGlucHV0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAqIEBtZW1iZXJvZiBVcGxvYWRcbiAgICovXG4gIGFzeW5jIG11bHRpdXBsb2FkKGlucHV0OiBJbnB1dEZpbGVbXSk6IFByb21pc2U8YW55PiB7XG4gICAgZm9yIChsZXQgaSBpbiBpbnB1dCkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGlmICghaW5wdXQuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGYgPSBhd2FpdCBnZXRGaWxlKGlucHV0W2ldLCB0aGlzLnNhbml0aXplck9wdGlvbnMpO1xuICAgICAgZi5jdXN0b21OYW1lID0gdGhpcy5vdmVycmlkZUZpbGVOYW1lO1xuICAgICAgdGhpcy51cGxvYWRlci5hZGRGaWxlKGYpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhcnRQcm9ncmVzc0ludGVydmFsKCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy51cGxvYWRlci5leGVjdXRlKCk7XG4gICAgdGhpcy5zdG9wUHJvZ3Jlc3NJbnRlcnZhbCgpO1xuXG4gICAgdGhpcy51cGxvYWRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSVW4gcHJvZ3Jlc3Mgd2l0aCB1c2VyZGVmaW5lZCBpbnRlcnZhbFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuc1xuICAgKiBAbWVtYmVyb2YgVXBsb2FkXG4gICAqL1xuICBwcml2YXRlIHN0YXJ0UHJvZ3Jlc3NJbnRlcnZhbCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vblByb2dyZXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcm9ncmVzc0ludGVydmFsSGFuZGxlciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMub3B0aW9ucy5vblByb2dyZXNzKHRoaXMubGFzdFByb2dyZXNzKTtcbiAgICB9LCB0aGlzLm9wdGlvbnMucHJvZ3Jlc3NJbnRlcnZhbCB8fCBERUZBVUxUX1BST0dSRVNTX0lOVEVSVkFMKTtcblxuICAgIHRoaXMub3B0aW9ucy5vblByb2dyZXNzKHRoaXMubGFzdFByb2dyZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHByb2dyZXNzIGludGVydmFsIGFmdGVyIHVwbG9hZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWVtYmVyb2YgVXBsb2FkXG4gICAqL1xuICBwcml2YXRlIHN0b3BQcm9ncmVzc0ludGVydmFsKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5wcm9ncmVzc0ludGVydmFsSGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHVwbG9hZCBpbnRlcnZhbCBhbmQgbm9ybWFsaXplIHZhbHVlc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1Byb2dyZXNzRXZlbnR9IHByb2dyZXNzXG4gICAqIEBtZW1iZXJvZiBVcGxvYWRcbiAgICovXG4gIHByaXZhdGUgaGFuZGxlUHJvZ3Jlc3MocHJvZ3Jlc3M6IFByb2dyZXNzRXZlbnQpIHtcbiAgICAvLyBnZXQgbWF4IHByb2dyZXNzIGRhdGEgdG8gYXZvaWQgcHJvZ3Jlc3MganVtcHMgb24gYW55IHBhcnQgZXJyb3JcbiAgICBwcm9ncmVzcyA9IG5vcm1hbGl6ZVByb2dyZXNzKHByb2dyZXNzLCB0aGlzLmxhc3RQcm9ncmVzcyk7XG5cbiAgICBpZiAodGhpcy5sYXN0UHJvZ3Jlc3MuZmlsZXMpIHtcbiAgICAgIGZvciAobGV0IGkgaW4gcHJvZ3Jlc3MuZmlsZXMpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdFByb2dyZXNzLmZpbGVzW2ldKSB7XG4gICAgICAgICAgcHJvZ3Jlc3MuZmlsZXNbaV0gPSBub3JtYWxpemVQcm9ncmVzcyhwcm9ncmVzcy5maWxlc1tpXSwgdGhpcy5sYXN0UHJvZ3Jlc3MuZmlsZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0UHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgfVxufVxuIl19


/***/ }),

/***/ 647:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var debug_1 = __nccwpck_require__(8237);
var EventEmitter = __nccwpck_require__(1848);
var utils_1 = __nccwpck_require__(8123);
var filestack_error_1 = __nccwpck_require__(4257);
// regular part size
exports.DEFAULT_PART_SIZE = 6 * 1024 * 1024;
// Minimum part size for upload by multipart
exports.MIN_PART_SIZE = 5 * 1024 * 1024;
// when mode is set to fallback or intelligent, this part size is required
exports.INTELLIGENT_CHUNK_SIZE = 8 * 1024 * 1024;
// Mobile Chunk size for ii
exports.INTELLIGENT_MOBILE_CHUNK_SIZE = 1024 * 1024;
// minimum intelligent chunk size
exports.MIN_CHUNK_SIZE = 32 * 1024;
exports.DEFAULT_STORE_LOCATION = 's3';
var debug = debug_1.default('fs:upload:abstract');
var UploaderAbstract = /** @class */ (function (_super) {
    tslib_1.__extends(UploaderAbstract, _super);
    function UploaderAbstract(storeOptions, concurrency) {
        if (concurrency === void 0) { concurrency = 3; }
        var _this = _super.call(this) || this;
        _this.storeOptions = storeOptions;
        _this.concurrency = concurrency;
        // Parts size options
        _this.partSize = exports.DEFAULT_PART_SIZE;
        // chunk size for ii uploads
        _this.intelligentChunkSize = utils_1.isMobile() ? exports.INTELLIGENT_MOBILE_CHUNK_SIZE : exports.INTELLIGENT_CHUNK_SIZE;
        _this.timeout = 30 * 1000;
        _this.uploadMode = "default" /* DEFAULT */;
        _this.isModeLocked = false; // if account does not support ii in fallback mode we should abort
        _this.integrityCheck = true;
        _this.uploadTags = null;
        return _this;
    }
    UploaderAbstract.prototype.setSecurity = function (security) {
        debug('Set security %O', security);
        this.security = security;
    };
    UploaderAbstract.prototype.setApikey = function (apikey) {
        debug("Set apikey to " + apikey);
        this.apikey = apikey;
    };
    UploaderAbstract.prototype.setTimeout = function (timeout) {
        debug("Set request timeout to " + timeout);
        this.timeout = timeout;
    };
    UploaderAbstract.prototype.setRetryConfig = function (cfg) {
        debug("Set retry config to " + cfg);
        this.retryConfig = cfg;
    };
    UploaderAbstract.prototype.setUrl = function (url) {
        debug("Set upload url to " + url);
        this.url = url;
    };
    UploaderAbstract.prototype.setUploadTags = function (tags) {
        debug("Set tags to %O", tags);
        this.uploadTags = tags;
    };
    /**
     * Set state of checking file integrity
     * @param state
     */
    UploaderAbstract.prototype.setIntegrityCheck = function (state) {
        this.integrityCheck = state;
    };
    /**
     * Sets upload mode
     *
     * @param {UploadMode} mode
     * @param {boolean} [lock=false]
     * @returns
     * @memberof MultipartUploader
     */
    UploaderAbstract.prototype.setUploadMode = function (mode, lock) {
        if (lock === void 0) { lock = false; }
        // this shouldnt happend but for safety reasons if will stay
        /* istanbul ignore next */
        if (this.isModeLocked === true) {
            debug("Cannot switch mode to " + mode + ". Locked! Probably mode is not supported at this apikey");
            return;
        }
        this.isModeLocked = lock;
        debug("Set upload mode to " + mode);
        this.uploadMode = mode;
    };
    /**
     * Set upload part size
     * if part size is smaller than minimum 5mb it will throw error
     *
     * @param {number} size
     * @returns {void}
     * @memberof S3Uploader
     */
    UploaderAbstract.prototype.setPartSize = function (size) {
        if (this.uploadMode !== "default" /* DEFAULT */) {
            debug('Cannot set part size because upload mode is other than default. ');
            return;
        }
        debug("Set part size to " + size);
        if (size < exports.MIN_PART_SIZE) {
            throw new filestack_error_1.FilestackError('Minimum part size is 5MB');
        }
        this.partSize = size;
    };
    /**
     * Returns current part size
     */
    UploaderAbstract.prototype.getPartSize = function () {
        return this.partSize;
    };
    /**
     * Set start part size for ii
     *
     * @param {number} size
     * @memberof S3Uploader
     */
    UploaderAbstract.prototype.setIntelligentChunkSize = function (size) {
        debug("Set inteligent chunk size to " + size);
        if (size < exports.MIN_CHUNK_SIZE) {
            throw new filestack_error_1.FilestackError("Minimum intelligent chunk size is " + exports.MIN_CHUNK_SIZE);
        }
        this.intelligentChunkSize = size;
    };
    /**
     * Returns intelligent chunk size
     */
    UploaderAbstract.prototype.getIntelligentChunkSize = function () {
        return this.intelligentChunkSize;
    };
    /**
     * Returns filestack upload url
     *
     * @private
     * @returns
     * @memberof MultipartUploader
     */
    UploaderAbstract.prototype.getUrl = function () {
        if (!this.url) {
            throw new filestack_error_1.FilestackError('Upload url not set');
        }
        return this.url;
    };
    return UploaderAbstract;
}(EventEmitter));
exports.UploaderAbstract = UploaderAbstract;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC91cGxvYWRlcnMvYWJzdHJhY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsK0JBQTBCO0FBQzFCLDRDQUE4QztBQU05QywwQ0FBNEM7QUFDNUMsaUVBQStEO0FBRS9ELG9CQUFvQjtBQUNQLFFBQUEsaUJBQWlCLEdBQUcsQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7QUFFakQsNENBQTRDO0FBQy9CLFFBQUEsYUFBYSxHQUFHLENBQUMsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBRTdDLDBFQUEwRTtBQUM3RCxRQUFBLHNCQUFzQixHQUFHLENBQUMsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBRXRELDJCQUEyQjtBQUNkLFFBQUEsNkJBQTZCLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQztBQUV6RCxpQ0FBaUM7QUFDcEIsUUFBQSxjQUFjLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQztBQUUzQixRQUFBLHNCQUFzQixHQUFHLElBQUksQ0FBQztBQUUzQyxJQUFNLEtBQUssR0FBRyxlQUFLLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQVExQztJQUErQyw0Q0FBWTtJQXNCekQsMEJBQStCLFlBQWdDLEVBQXFCLFdBQXVCO1FBQXZCLDRCQUFBLEVBQUEsZUFBdUI7UUFBM0csWUFDRSxpQkFBTyxTQUNSO1FBRjhCLGtCQUFZLEdBQVosWUFBWSxDQUFvQjtRQUFxQixpQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQXJCM0cscUJBQXFCO1FBQ1gsY0FBUSxHQUFXLHlCQUFpQixDQUFDO1FBRS9DLDRCQUE0QjtRQUNsQiwwQkFBb0IsR0FBVyxnQkFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLHFDQUE2QixDQUFDLENBQUMsQ0FBQyw4QkFBc0IsQ0FBQztRQUluRyxhQUFPLEdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQztRQUM1QixnQkFBVSwyQkFBa0M7UUFN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SUFDSSxrREFBdUIsR0FBOUI7UUFDRSxPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQztJQUNuQyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksaUNBQU0sR0FBYjtRQUNFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ2IsTUFBTSxJQUFJLGdDQUFjLENBQUMsb0JBQW9CLENBQUMsQ0FBQztTQUNoRDtRQUVELE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUNsQixDQUFDO0lBeUJILHVCQUFDO0FBQUQsQ0FoTEEsQUFnTEMsQ0FoTDhDLFlBQVksR0FnTDFEO0FBaExxQiw0Q0FBZ0IiLCJmaWxlIjoibGliL2FwaS91cGxvYWQvdXBsb2FkZXJzL2Fic3RyYWN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBieSBGaWxlc3RhY2suXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCBEZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgKiBhcyBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5cbmltcG9ydCB7IEZpbGUsIFVwbG9hZFRhZ3MgfSBmcm9tICcuLy4uL2ZpbGUnO1xuaW1wb3J0IHsgU3RvcmVVcGxvYWRPcHRpb25zIH0gZnJvbSAnLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBTZWN1cml0eSB9IGZyb20gJy4vLi4vLi4vLi4vY2xpZW50JztcbmltcG9ydCB7IEZzUmV0cnlDb25maWcgfSBmcm9tICcuLy4uLy4uLy4uL3JlcXVlc3QnO1xuaW1wb3J0IHsgaXNNb2JpbGUgfSBmcm9tICcuLy4uLy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IEZpbGVzdGFja0Vycm9yIH0gZnJvbSAnLi8uLi8uLi8uLi8uLi9maWxlc3RhY2tfZXJyb3InO1xuXG4vLyByZWd1bGFyIHBhcnQgc2l6ZVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUEFSVF9TSVpFID0gNiAqIDEwMjQgKiAxMDI0O1xuXG4vLyBNaW5pbXVtIHBhcnQgc2l6ZSBmb3IgdXBsb2FkIGJ5IG11bHRpcGFydFxuZXhwb3J0IGNvbnN0IE1JTl9QQVJUX1NJWkUgPSA1ICogMTAyNCAqIDEwMjQ7XG5cbi8vIHdoZW4gbW9kZSBpcyBzZXQgdG8gZmFsbGJhY2sgb3IgaW50ZWxsaWdlbnQsIHRoaXMgcGFydCBzaXplIGlzIHJlcXVpcmVkXG5leHBvcnQgY29uc3QgSU5URUxMSUdFTlRfQ0hVTktfU0laRSA9IDggKiAxMDI0ICogMTAyNDtcblxuLy8gTW9iaWxlIENodW5rIHNpemUgZm9yIGlpXG5leHBvcnQgY29uc3QgSU5URUxMSUdFTlRfTU9CSUxFX0NIVU5LX1NJWkUgPSAxMDI0ICogMTAyNDtcblxuLy8gbWluaW11bSBpbnRlbGxpZ2VudCBjaHVuayBzaXplXG5leHBvcnQgY29uc3QgTUlOX0NIVU5LX1NJWkUgPSAzMiAqIDEwMjQ7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NUT1JFX0xPQ0FUSU9OID0gJ3MzJztcblxuY29uc3QgZGVidWcgPSBEZWJ1ZygnZnM6dXBsb2FkOmFic3RyYWN0Jyk7XG5cbmV4cG9ydCBjb25zdCBlbnVtIFVwbG9hZE1vZGUge1xuICBERUZBVUxUID0gJ2RlZmF1bHQnLFxuICBJTlRFTExJR0VOVCA9ICdpbnRlbGxpZ2VudCcsXG4gIEZBTExCQUNLID0gJ2ZhbGxiYWNrJyxcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFVwbG9hZGVyQWJzdHJhY3QgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvLyBQYXJ0cyBzaXplIG9wdGlvbnNcbiAgcHJvdGVjdGVkIHBhcnRTaXplOiBudW1iZXIgPSBERUZBVUxUX1BBUlRfU0laRTtcblxuICAvLyBjaHVuayBzaXplIGZvciBpaSB1cGxvYWRzXG4gIHByb3RlY3RlZCBpbnRlbGxpZ2VudENodW5rU2l6ZTogbnVtYmVyID0gaXNNb2JpbGUoKSA/IElOVEVMTElHRU5UX01PQklMRV9DSFVOS19TSVpFIDogSU5URUxMSUdFTlRfQ0hVTktfU0laRTtcblxuICAvLyB1cGxvYWQgb3B0aW9uc1xuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmc7XG4gIHByb3RlY3RlZCB0aW1lb3V0OiBudW1iZXIgPSAzMCAqIDEwMDA7XG4gIHByb3RlY3RlZCB1cGxvYWRNb2RlOiBVcGxvYWRNb2RlID0gVXBsb2FkTW9kZS5ERUZBVUxUO1xuXG4gIC8vIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gIHByb3RlY3RlZCBhcGlrZXk6IHN0cmluZztcbiAgcHJvdGVjdGVkIHNlY3VyaXR5OiBTZWN1cml0eTtcblxuICBwcm90ZWN0ZWQgaXNNb2RlTG9ja2VkOiBib29sZWFuID0gZmFsc2U7IC8vIGlmIGFjY291bnQgZG9lcyBub3Qgc3VwcG9ydCBpaSBpbiBmYWxsYmFjayBtb2RlIHdlIHNob3VsZCBhYm9ydFxuICBwcm90ZWN0ZWQgcmV0cnlDb25maWc6IEZzUmV0cnlDb25maWc7XG4gIHByb3RlY3RlZCBpbnRlZ3JpdHlDaGVjazogYm9vbGVhbiA9IHRydWU7XG5cbiAgcHJvdGVjdGVkIHVwbG9hZFRhZ3M6IFVwbG9hZFRhZ3MgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBzdG9yZU9wdGlvbnM6IFN0b3JlVXBsb2FkT3B0aW9ucywgcHJvdGVjdGVkIHJlYWRvbmx5IGNvbmN1cnJlbmN5OiBudW1iZXIgPSAzKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTZWN1cml0eShzZWN1cml0eTogU2VjdXJpdHkpOiB2b2lkIHtcbiAgICBkZWJ1ZygnU2V0IHNlY3VyaXR5ICVPJywgc2VjdXJpdHkpO1xuICAgIHRoaXMuc2VjdXJpdHkgPSBzZWN1cml0eTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRBcGlrZXkoYXBpa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBkZWJ1ZyhgU2V0IGFwaWtleSB0byAke2FwaWtleX1gKTtcbiAgICB0aGlzLmFwaWtleSA9IGFwaWtleTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRUaW1lb3V0KHRpbWVvdXQ6IG51bWJlcik6IHZvaWQge1xuICAgIGRlYnVnKGBTZXQgcmVxdWVzdCB0aW1lb3V0IHRvICR7dGltZW91dH1gKTtcbiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICB9XG5cbiAgcHVibGljIHNldFJldHJ5Q29uZmlnKGNmZzogRnNSZXRyeUNvbmZpZykge1xuICAgIGRlYnVnKGBTZXQgcmV0cnkgY29uZmlnIHRvICR7Y2ZnfWApO1xuICAgIHRoaXMucmV0cnlDb25maWcgPSBjZmc7XG4gIH1cblxuICBwdWJsaWMgc2V0VXJsKHVybDogc3RyaW5nKTogdm9pZCB7XG4gICAgZGVidWcoYFNldCB1cGxvYWQgdXJsIHRvICR7dXJsfWApO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICB9XG5cbiAgcHVibGljIHNldFVwbG9hZFRhZ3ModGFnczogVXBsb2FkVGFncykge1xuICAgIGRlYnVnKGBTZXQgdGFncyB0byAlT2AsIHRhZ3MpO1xuICAgIHRoaXMudXBsb2FkVGFncyA9IHRhZ3M7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHN0YXRlIG9mIGNoZWNraW5nIGZpbGUgaW50ZWdyaXR5XG4gICAqIEBwYXJhbSBzdGF0ZVxuICAgKi9cbiAgcHVibGljIHNldEludGVncml0eUNoZWNrKHN0YXRlKSB7XG4gICAgdGhpcy5pbnRlZ3JpdHlDaGVjayA9IHN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXBsb2FkIG1vZGVcbiAgICpcbiAgICogQHBhcmFtIHtVcGxvYWRNb2RlfSBtb2RlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xvY2s9ZmFsc2VdXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBNdWx0aXBhcnRVcGxvYWRlclxuICAgKi9cbiAgcHVibGljIHNldFVwbG9hZE1vZGUobW9kZTogVXBsb2FkTW9kZSwgbG9jazogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgLy8gdGhpcyBzaG91bGRudCBoYXBwZW5kIGJ1dCBmb3Igc2FmZXR5IHJlYXNvbnMgaWYgd2lsbCBzdGF5XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodGhpcy5pc01vZGVMb2NrZWQgPT09IHRydWUpIHtcbiAgICAgIGRlYnVnKGBDYW5ub3Qgc3dpdGNoIG1vZGUgdG8gJHttb2RlfS4gTG9ja2VkISBQcm9iYWJseSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgYXQgdGhpcyBhcGlrZXlgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzTW9kZUxvY2tlZCA9IGxvY2s7XG5cbiAgICBkZWJ1ZyhgU2V0IHVwbG9hZCBtb2RlIHRvICR7bW9kZX1gKTtcblxuICAgIHRoaXMudXBsb2FkTW9kZSA9IG1vZGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwbG9hZCBwYXJ0IHNpemVcbiAgICogaWYgcGFydCBzaXplIGlzIHNtYWxsZXIgdGhhbiBtaW5pbXVtIDVtYiBpdCB3aWxsIHRocm93IGVycm9yXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKiBAbWVtYmVyb2YgUzNVcGxvYWRlclxuICAgKi9cbiAgcHVibGljIHNldFBhcnRTaXplKHNpemU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLnVwbG9hZE1vZGUgIT09IFVwbG9hZE1vZGUuREVGQVVMVCkge1xuICAgICAgZGVidWcoJ0Nhbm5vdCBzZXQgcGFydCBzaXplIGJlY2F1c2UgdXBsb2FkIG1vZGUgaXMgb3RoZXIgdGhhbiBkZWZhdWx0LiAnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWJ1ZyhgU2V0IHBhcnQgc2l6ZSB0byAke3NpemV9YCk7XG5cbiAgICBpZiAoc2l6ZSA8IE1JTl9QQVJUX1NJWkUpIHtcbiAgICAgIHRocm93IG5ldyBGaWxlc3RhY2tFcnJvcignTWluaW11bSBwYXJ0IHNpemUgaXMgNU1CJyk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJ0U2l6ZSA9IHNpemU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IHBhcnQgc2l6ZVxuICAgKi9cbiAgcHVibGljIGdldFBhcnRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnRTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBzdGFydCBwYXJ0IHNpemUgZm9yIGlpXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAqIEBtZW1iZXJvZiBTM1VwbG9hZGVyXG4gICAqL1xuICBwdWJsaWMgc2V0SW50ZWxsaWdlbnRDaHVua1NpemUoc2l6ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgZGVidWcoYFNldCBpbnRlbGlnZW50IGNodW5rIHNpemUgdG8gJHtzaXplfWApO1xuICAgIGlmIChzaXplIDwgTUlOX0NIVU5LX1NJWkUpIHtcbiAgICAgIHRocm93IG5ldyBGaWxlc3RhY2tFcnJvcihgTWluaW11bSBpbnRlbGxpZ2VudCBjaHVuayBzaXplIGlzICR7TUlOX0NIVU5LX1NJWkV9YCk7XG4gICAgfVxuICAgIHRoaXMuaW50ZWxsaWdlbnRDaHVua1NpemUgPSBzaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaW50ZWxsaWdlbnQgY2h1bmsgc2l6ZVxuICAgKi9cbiAgcHVibGljIGdldEludGVsbGlnZW50Q2h1bmtTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZWxsaWdlbnRDaHVua1NpemU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmaWxlc3RhY2sgdXBsb2FkIHVybFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuc1xuICAgKiBAbWVtYmVyb2YgTXVsdGlwYXJ0VXBsb2FkZXJcbiAgICovXG4gIHB1YmxpYyBnZXRVcmwoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMudXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRmlsZXN0YWNrRXJyb3IoJ1VwbG9hZCB1cmwgbm90IHNldCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnVybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSB1cGxvYWQgcXVldWVcbiAgICpcbiAgICogQG1lbWJlcm9mIE11bHRpcGFydFVwbG9hZGVyXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgcGF1c2UoKTogdm9pZDtcbiAgLyoqXG4gICAqIHJlc3VtZSB1cGxvYWQgcXVldWUgaWYgaXRzIHBhdXNlZFxuICAgKlxuICAgKiBAbWVtYmVyb2YgTXVsdGlwYXJ0VXBsb2FkZXJcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCByZXN1bWUoKTogdm9pZDtcblxuICAvKipcbiAgICogQWJvcnRzIHF1ZXVlIChhbGwgcGVuZGluZyByZXF1ZXN0cyB3aXRoIHdpbGwgYmUgYWJvcnRlZClcbiAgICpcbiAgICogQG1lbWJlcm9mIE11bHRpcGFydFVwbG9hZGVyXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgYWJvcnQobXNnPzogc3RyaW5nKTogdm9pZDtcblxuICBwdWJsaWMgYWJzdHJhY3QgYWRkRmlsZShmaWxlOiBGaWxlKTogc3RyaW5nO1xuXG4gIHB1YmxpYyBhYnN0cmFjdCBhc3luYyBleGVjdXRlKCk6IFByb21pc2U8YW55Pjtcbn1cbiJdfQ==


/***/ }),

/***/ 6524:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var debug_1 = __nccwpck_require__(8237);
var p_queue_1 = __nccwpck_require__(8938);
var filestack_error_1 = __nccwpck_require__(4257);
var request_1 = __nccwpck_require__(5606);
var helpers_1 = __nccwpck_require__(9083);
var utils_1 = __nccwpck_require__(8123);
var abstract_1 = __nccwpck_require__(647);
var debug = debug_1.default('fs:upload:s3');
var COMPLETE_TIMEOUT = 1000 * 1;
var S3Uploader = /** @class */ (function (_super) {
    tslib_1.__extends(S3Uploader, _super);
    function S3Uploader(storeOptions, concurrency) {
        var _this = _super.call(this, storeOptions, concurrency) || this;
        _this.payloads = {};
        _this.partsQueue = new p_queue_1.default({
            autoStart: false,
            concurrency: _this.concurrency,
        });
        _this.cancelToken = new request_1.FsCancelToken();
        return _this;
    }
    /**
     * Pause upload queue
     *
     * @memberof S3Uploader
     */
    S3Uploader.prototype.pause = function () {
        this.partsQueue.pause();
    };
    /**
     * resume upload queue if its paused
     *
     * @memberof S3Uploader
     */
    S3Uploader.prototype.resume = function () {
        /* istanbul ignore next */
        if (this.partsQueue.isPaused) {
            this.partsQueue.start();
        }
    };
    /**
     * Aborts queue (all pending requests with will be aborted)
     *
     * @memberof S3Uploader
     */
    S3Uploader.prototype.abort = function (msg) {
        this.partsQueue.pause();
        this.partsQueue.clear();
        this.cancelToken.cancel(msg || 'Aborted by user');
    };
    /**
     * Execute all queued files
     *
     * @returns {Promise<any>}
     * @memberof S3Uploader
     */
    S3Uploader.prototype.execute = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tasks;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                tasks = Object.keys(this.payloads).map(function (id) {
                    return new Promise(function (resolve) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        var e_1, file;
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 5, , 6]);
                                    return [4 /*yield*/, this.startRequest(id)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.prepareParts(id)];
                                case 2:
                                    _a.sent();
                                    return [4 /*yield*/, this.startPartsQueue(id)];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/, this.completeRequest(id)];
                                case 4:
                                    _a.sent();
                                    return [3 /*break*/, 6];
                                case 5:
                                    e_1 = _a.sent();
                                    /* istanbul ignore next */
                                    this.emit('error', e_1);
                                    debug("[" + id + "] File upload failed. %O, \nDetails: %O ", e_1.message, e_1.details);
                                    return [3 /*break*/, 6];
                                case 6:
                                    file = this.getPayloadById(id).file;
                                    // release file buffer
                                    file.release();
                                    // cleanup payloads
                                    delete this.payloads[id];
                                    resolve(file);
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                });
                return [2 /*return*/, Promise.all(tasks)];
            });
        });
    };
    /**
     * Add file to upload queue
     *
     * @param {File} file
     * @returns
     * @memberof S3Uploader
     */
    S3Uploader.prototype.addFile = function (file) {
        debug('Add file to queue: \n %o', file);
        var id = utils_1.uniqueId(15) + "_" + utils_1.uniqueTime();
        file.status = "Initialized" /* INIT */;
        // split file into parts and set it as waiting
        this.payloads[id] = {
            file: file,
            parts: [],
        };
        return id;
    };
    /**
     * Returns host for upload (region based)
     *
     * @private
     * @returns
     * @memberof S3Uploader
     */
    S3Uploader.prototype.getUploadUrl = function (id) {
        var location_url = this.getDefaultFields(id, ['location_url']).location_url;
        return location_url.indexOf('http') === 0 ? location_url : "https://" + location_url;
    };
    /**
     * Returns formatted store options
     *
     * @private
     * @returns
     * @memberof S3Uploader
     */
    S3Uploader.prototype.getStoreOptions = function (id) {
        var options = tslib_1.__assign({ location: abstract_1.DEFAULT_STORE_LOCATION }, this.storeOptions);
        if (this.storeOptions.disableStorageKey) {
            var payload = this.getPayloadById(id);
            if (options.path && options.path.substr(-1) !== '/') {
                options.path = options.path + "/";
            }
            options.path = "" + (options.path ? options.path : '/') + payload.file.name;
            delete options.disableStorageKey;
        }
        return options;
    };
    /**
     * Returns all default fields for filestack requests
     *
     * @private
     * @returns
     * @memberof S3Uploader
     */
    S3Uploader.prototype.getDefaultFields = function (id, requiredFields, fiiFallback) {
        if (fiiFallback === void 0) { fiiFallback = false; }
        var payload = this.getPayloadById(id);
        var fields = tslib_1.__assign(tslib_1.__assign({}, this.security), { apikey: this.apikey, uri: payload.uri, location_url: payload.location_url, upload_id: payload.upload_id, region: payload.region });
        if (this.uploadMode === "intelligent" /* INTELLIGENT */ || (this.uploadMode === "fallback" /* FALLBACK */ && fiiFallback)) {
            fields['fii'] = true;
        }
        return tslib_1.__assign(tslib_1.__assign({}, utils_1.filterObject(fields, requiredFields)), { store: this.getStoreOptions(id) });
    };
    /**
     * Returns default headers needed for filestack request
     *
     * @private
     * @returns
     * @memberof S3Uploader
     */
    S3Uploader.prototype.getDefaultHeaders = function (id) {
        var headers = {};
        var file = this.getPayloadById(id);
        if (file.location_region) {
            headers['Filestack-Upload-Region'] = file.location_region;
        }
        return headers;
    };
    S3Uploader.prototype.getPayloadById = function (id) {
        return this.payloads[id];
    };
    /**
     * Split file onto parts for uploading with multipart mechanism and setup start
     *
     * @private
     * @memberof S3Uploader
     */
    S3Uploader.prototype.prepareParts = function (id) {
        var file = this.getPayloadById(id).file;
        // for intelligent or fallback mode we cant overwrite part size - requires 8MB
        if (["intelligent" /* INTELLIGENT */, "fallback" /* FALLBACK */].indexOf(this.uploadMode) > -1) {
            this.partSize = abstract_1.INTELLIGENT_CHUNK_SIZE;
        }
        var partsCount = file.getPartsCount(this.partSize);
        var parts = [];
        for (var i = 0; i < partsCount; i++) {
            parts[i] = tslib_1.__assign(tslib_1.__assign({}, file.getPartMetadata(i, this.partSize)), { offset: 0 });
        }
        // split file into parts and set it as waiting
        this.payloads[id].parts = parts;
        return Promise.resolve();
    };
    /**
     * Make start request for getting needed upload fields
     *
     * @private
     * @returns {Promise<any>}
     * @memberof S3Uploader
     */
    S3Uploader.prototype.startRequest = function (id) {
        var _this = this;
        var payload = this.getPayloadById(id);
        if (payload.file.size === 0) {
            this.setPayloadStatus(id, "Failed" /* FAILED */);
            return Promise.reject(new filestack_error_1.FilestackError("Invalid file \"" + payload.file.name + "\" size - 0", {}, filestack_error_1.FilestackErrorType.VALIDATION));
        }
        debug("[" + id + "] Make start request");
        return request_1.FsRequest.post(this.getUrl() + "/multipart/start", tslib_1.__assign({ filename: payload.file.name, mimetype: payload.file.type, size: payload.file.size }, this.getDefaultFields(id, ['apikey', 'policy', 'signature', 'fii'], true)), {
            timeout: this.timeout,
            cancelToken: this.cancelToken,
            headers: this.getDefaultHeaders(id),
            retry: this.retryConfig,
        })
            .then(function (_a) {
            var data = _a.data;
            if (!data || !data.location_url || !data.region || !data.upload_id || !data.uri) {
                debug("[" + id + "] Incorrect start response: \n%O\n", data);
                _this.setPayloadStatus(id, "Failed" /* FAILED */);
                return Promise.reject(new filestack_error_1.FilestackError('Incorrect start response', data, filestack_error_1.FilestackErrorType.REQUEST));
            }
            debug("[" + id + "] Assign payload data: \n%O\n", data);
            _this.updatePayload(id, data);
            // ii is not enabled in backend switch back to default upload mode
            if (["intelligent" /* INTELLIGENT */, "fallback" /* FALLBACK */].indexOf(_this.uploadMode) > -1 && (!data.upload_type || data.upload_type !== 'intelligent_ingestion')) {
                debug("[" + id + "] Intelligent Ingestion is not enabled on account, switch back to regular upload and lock mode change");
                _this.setUploadMode("default" /* DEFAULT */, true);
            }
            return data;
        })
            .catch(function (err) {
            debug("[" + id + "] Start request error %O", err);
            _this.setPayloadStatus(id, "Failed" /* FAILED */);
            return _this.rejectUpload('Cannot upload file. Start request failed', err);
        });
    };
    /**
     * Enqueue file parts to upload
     *
     * @private
     * @returns
     * @memberof S3Uploader
     */
    S3Uploader.prototype.startPartsQueue = function (id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var payload, parts, waitingLength;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                payload = this.getPayloadById(id);
                parts = payload.parts;
                waitingLength = parts.length;
                debug("[" + id + "] Create uploading queue from file. parts count - %d", waitingLength);
                return [2 /*return*/, new Promise(function (resolve, reject) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        var _a;
                        var _this = this;
                        return tslib_1.__generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    parts.forEach(function (part) {
                                        return _this.partsQueue
                                            .add(function () { return _this.startPart(id, part.partNumber); })
                                            .catch(function (e) {
                                            _this.setPayloadStatus(id, "Failed" /* FAILED */);
                                            debug("[" + id + "] Failed to upload part %s", e.message);
                                            _this.partsQueue.pause();
                                            _this.partsQueue.clear();
                                            return reject(e);
                                        });
                                    });
                                    debug("[" + id + "] All tasks for %s enqueued. Start processing main upload queue", id);
                                    this.emit('start');
                                    this.partsQueue.start();
                                    _a = resolve;
                                    return [4 /*yield*/, this.partsQueue.onIdle()];
                                case 1:
                                    _a.apply(void 0, [_b.sent()]);
                                    return [2 /*return*/];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Decide if upload should be made using ii or regular upload
     * It allows change upload mode during upload queue
     *
     * @private
     * @param {number} partNumber
     * @returns {Promise<any>}
     * @memberof S3Uploader
     */
    S3Uploader.prototype.startPart = function (id, partNumber) {
        debug("[" + id + "] Start processing part " + partNumber + " with mode " + this.uploadMode);
        var payload = this.getPayloadById(id);
        payload.file.status = "Progress" /* PROGRESS */;
        return (this.uploadMode !== "intelligent" /* INTELLIGENT */ ? this.uploadRegular : this.uploadIntelligent).apply(this, [id, partNumber]);
    };
    /**
     * Returns part data needed for upload
     *
     * @private
     * @param {string} id - id of a currently uploading file
     * @param {FilePart} part
     * @returns
     * @memberof S3Uploader
     */
    S3Uploader.prototype.getS3PartMetadata = function (id, part, offset) {
        var _this = this;
        var url = this.getUploadUrl(id);
        debug("[" + id + "] Get data for part " + part.partNumber + ", url " + url + ", Md5: " + part.md5 + ", Size: " + part.size);
        var data = tslib_1.__assign(tslib_1.__assign({}, this.getDefaultFields(id, ['apikey', 'uri', 'region', 'signature', 'policy', 'upload_id', 'fii'])), { 
            // method specific keys
            part: part.partNumber + 1, size: part.size, offset: offset });
        if (this.integrityCheck && part.md5) {
            data.md5 = part.md5;
        }
        return request_1.FsRequest.post(url + "/multipart/upload", data, {
            headers: this.getDefaultHeaders(id),
            cancelToken: this.cancelToken,
            timeout: this.timeout,
            retry: this.retryConfig,
        }).catch(function (err) {
            _this.setPayloadStatus(id, "Failed" /* FAILED */);
            return _this.rejectUpload('Cannot get part metadata', err);
        });
    };
    /**
     * Regular multipart request to amazon
     *
     * @private
     * @param {number} partNumber
     * @returns {Promise<any>}
     * @memberof S3Uploader
     */
    S3Uploader.prototype.uploadRegular = function (id, partNumber) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var payload, partMetadata, part, _a, data, headers;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        payload = this.getPayloadById(id);
                        partMetadata = payload.parts[partNumber];
                        return [4 /*yield*/, payload.file.getPartByMetadata(partMetadata, this.integrityCheck)];
                    case 1:
                        part = _b.sent();
                        return [4 /*yield*/, this.getS3PartMetadata(id, part)];
                    case 2:
                        _a = _b.sent(), data = _a.data, headers = _a.headers;
                        debug("[" + id + "] Received part " + partNumber + " info body: \n%O\n headers: \n%O\n", data, headers);
                        return [2 /*return*/, request_1.FsRequest.put(data.url, part.buffer, {
                                cancelToken: this.cancelToken,
                                timeout: this.timeout,
                                headers: data.headers,
                                filestackHeaders: false,
                                // for now we cant test progress callback from upload
                                /* istanbul ignore next */
                                onProgress: function (pr) { return _this.onProgressUpdate(id, partNumber, pr.loaded); },
                                retry: this.retryConfig && this.uploadMode !== "fallback" /* FALLBACK */ ? this.retryConfig : undefined,
                            })
                                .then(function (res) {
                                if (res.headers.etag) {
                                    _this.setPartETag(id, partNumber, res.headers.etag);
                                }
                                else {
                                    // release memory
                                    part = null;
                                    throw new filestack_error_1.FilestackError('Cannot upload file, check S3 bucket settings', 'Etag header is not exposed in CORS settings', filestack_error_1.FilestackErrorType.REQUEST);
                                }
                                debug("[" + id + "] S3 Upload response headers for " + partNumber + ": \n%O\n", res.headers);
                                _this.onProgressUpdate(id, partNumber, part.size);
                                // release memory
                                part = null;
                                return res;
                            })
                                .catch(function (err) {
                                var resp = err && err.response ? err.response : null;
                                /* istanbul ignore next */
                                if (resp && resp.status === 403) {
                                    if (resp.data && resp.data.Error && resp.data.Error.code) {
                                        var code = resp.data.Error.code;
                                        if (Array.isArray(code)) {
                                            code = code.pop();
                                        }
                                        switch (code) {
                                            case 'RequestTimeTooSkewed':
                                                return _this.startPart(id, partNumber);
                                            default:
                                                return Promise.reject(new filestack_error_1.FilestackError('Cannot upload file', resp.data.Error, filestack_error_1.FilestackErrorType.REQUEST));
                                        }
                                    }
                                }
                                // release memory
                                part = null;
                                if (err instanceof filestack_error_1.FilestackError) {
                                    return Promise.reject(err);
                                }
                                // reset upload progress on failed part
                                _this.onProgressUpdate(id, partNumber, 0);
                                // if fallback, set upload mode to intelligent and restart current part
                                if ((_this.uploadMode === "fallback" /* FALLBACK */ && !_this.isModeLocked) || _this.uploadMode === "intelligent" /* INTELLIGENT */) {
                                    debug("[" + id + "] Regular upload failed. Switching to intelligent ingestion mode");
                                    _this.setUploadMode("intelligent" /* INTELLIGENT */);
                                    // restart part
                                    return _this.startPart(id, partNumber);
                                }
                                return _this.rejectUpload('Cannot upload file part', err);
                            })];
                }
            });
        });
    };
    /**
     * Upload file using intelligent mechanism
     *
     * @private
     * @param {string} id
     * @param {number} partNumber
     * @returns {Promise<any>}
     * @memberof S3Uploader
     */
    S3Uploader.prototype.uploadIntelligent = function (id, partNumber) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.uploadNextChunk(id, partNumber).then(function () { return _this.commitPart(id, partNumber); })];
            });
        });
    };
    /**
     * Recursively upload file in chunk mode (intelligent ingession)
     *
     * @private
     * @param {string} id
     * @param {number} partNumber
     * @param {number} chunkSize
     * @returns
     * @memberof S3Uploader
     */
    S3Uploader.prototype.uploadNextChunk = function (id, partNumber, chunkSize) {
        if (chunkSize === void 0) { chunkSize = this.intelligentChunkSize; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var payload, part, chunk, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        payload = this.getPayloadById(id);
                        part = payload.parts[partNumber];
                        chunkSize = Math.min(chunkSize, part.size - part.offset);
                        return [4 /*yield*/, payload.file.getChunkByMetadata(part, part.offset, chunkSize, this.integrityCheck)];
                    case 1:
                        chunk = _a.sent();
                        debug("[" + id + "] PartNum: " + partNumber + ", PartSize: " + part.size + ", StartByte: " + part.startByte + ", Offset: " + part.offset + ", ChunkSize: " + chunk.size + ",\n       Left: " + (part.size - part.offset - chunk.size));
                        return [4 /*yield*/, this.getS3PartMetadata(id, chunk, part.offset).catch(function (err) {
                                debug("[" + id + "] Getting chunk data for ii failed %O, Chunk size: " + chunkSize + ", offset " + part.offset + ", part " + partNumber, err);
                                return Promise.reject(err);
                            })];
                    case 2:
                        data = (_a.sent()).data;
                        return [2 /*return*/, request_1.FsRequest.put(data.url, chunk.buffer, {
                                cancelToken: this.cancelToken,
                                timeout: this.timeout,
                                headers: data.headers,
                                filestackHeaders: false,
                                // for now we cant test progress callback from upload
                                /* istanbul ignore next */
                                onProgress: function (pr) { return part ? _this.onProgressUpdate(id, partNumber, part.offset + pr.loaded) : null; },
                            })
                                .then(function (res) {
                                _this.onProgressUpdate(id, partNumber, part.offset + chunk.size);
                                var newOffset = Math.min(part.offset + chunkSize, part.size);
                                debug("[" + id + "] S3 Chunk uploaded! offset: " + part.offset + ", part " + partNumber + "! response headers for " + partNumber + ": \n%O\n", res.headers);
                                _this.setPartData(id, partNumber, 'offset', newOffset);
                                // if all chunks was uploaded then return resolve
                                if (newOffset === part.size) {
                                    return Promise.resolve(res);
                                }
                                // release memory
                                part = null;
                                chunk = null;
                                return _this.uploadNextChunk(id, partNumber, chunkSize);
                            })
                                .catch(function (err) {
                                var resp = err && err.response ? err.response : null;
                                /* istanbul ignore next */
                                if (resp && resp.status === 403) {
                                    if (resp.data && resp.data.Error && resp.data.Error.code) {
                                        var code = resp.data.Error.code;
                                        if (Array.isArray(code)) {
                                            code = code.pop();
                                        }
                                        switch (code) {
                                            case 'RequestTimeTooSkewed':
                                                return _this.startPart(id, partNumber);
                                            default:
                                                return Promise.reject(new filestack_error_1.FilestackError('Cannot upload file', resp.data.Error, filestack_error_1.FilestackErrorType.REQUEST));
                                        }
                                    }
                                }
                                // reset progress on failed upload
                                _this.onProgressUpdate(id, partNumber, part.offset);
                                var nextChunkSize = Math.ceil(chunkSize / 2);
                                if (nextChunkSize < abstract_1.MIN_CHUNK_SIZE) {
                                    debug("[" + id + "] Minimal chunk size limit. Upload file failed!");
                                    return Promise.reject(new filestack_error_1.FilestackError('Min chunk size reached', err.data, filestack_error_1.FilestackErrorType.REQUEST));
                                }
                                if (helpers_1.shouldRetry(err)) {
                                    debug("[" + id + "] Request network error. Retry with new chunk size: " + nextChunkSize);
                                    return _this.uploadNextChunk(id, partNumber, nextChunkSize);
                                }
                                // release memory
                                part = null;
                                chunk = null;
                                return _this.rejectUpload('Cannot upload file part (FII)', err);
                            })];
                }
            });
        });
    };
    /**
     * Commit after upload all chunks of the part in ii mode
     *
     * @private
     * @param {string} id
     * @param {FilePart} part
     * @returns
     * @memberof S3Uploader
     */
    S3Uploader.prototype.commitPart = function (id, partNumber) {
        var _this = this;
        var payload = this.getPayloadById(id);
        var part = payload.parts[partNumber];
        return request_1.FsRequest.post(this.getUploadUrl(id) + "/multipart/commit", tslib_1.__assign(tslib_1.__assign({}, this.getDefaultFields(id, ['apikey', 'region', 'upload_id', 'policy', 'signature', 'uri'])), { size: payload.file.size, part: part.partNumber + 1 }), {
            cancelToken: this.cancelToken,
            timeout: this.timeout,
            headers: this.getDefaultHeaders(id),
            retry: this.retryConfig,
        })
            .then(function (res) {
            debug("[" + id + "] Commit Part number " + part.partNumber + ". Response: %O", res.data);
            return res;
        })
            .catch(function (err) {
            return _this.rejectUpload('Cannot commit file part metadata', err);
        });
    };
    /**
     * Complete request to merge all parts and get file handle etc
     *
     * @private
     * @returns
     * @memberof S3Uploader
     */
    S3Uploader.prototype.completeRequest = function (id) {
        var _this = this;
        var payload = this.getPayloadById(id);
        var parts = [];
        debug("[" + id + "] Run complete request");
        var partsHandle = payload.parts;
        var partLen = partsHandle.length;
        for (var i = 0; i < partLen; i++) {
            if (partsHandle[i].etag) {
                parts.push({ part_number: i + 1, etag: partsHandle[i].etag });
            }
        }
        debug("[" + id + "] Etags %O", parts);
        return request_1.FsRequest.post(this.getUploadUrl(id) + "/multipart/complete", tslib_1.__assign(tslib_1.__assign({}, this.getDefaultFields(id, ['apikey', 'policy', 'signature', 'uri', 'region', 'upload_id', 'fii'], true)), { 
            // method specific keys
            filename: payload.file.name, mimetype: payload.file.type, size: payload.file.size, upload_tags: this.uploadTags && Object.keys(this.uploadTags).length ? this.uploadTags : undefined, parts: parts.length ? parts : undefined }), {
            timeout: this.timeout,
            cancelToken: this.cancelToken,
            headers: this.getDefaultHeaders(id),
            retry: this.retryConfig,
        })
            .then(function (res) {
            // if parts hasnt been merged, retry complete request again
            if (res.status === 202) {
                return new Promise(function (resolve, reject) {
                    setTimeout(function () {
                        return _this.completeRequest(id)
                            .then(resolve)
                            .catch(reject);
                    }, COMPLETE_TIMEOUT);
                });
            }
            // update file object
            var file = _this.getPayloadById(id).file;
            file.handle = res.data.handle;
            file.url = res.data.url;
            file.container = res.data.container;
            file.key = res.data.key;
            file.uploadTags = res.data.upload_tags;
            file.workflows = res.data.workflows;
            file.status = res.data.status;
            return file;
        })
            .catch(function (err) {
            _this.setPayloadStatus(id, "Failed" /* FAILED */);
            return _this.rejectUpload('Cannot complete file', err);
        });
    };
    /**
     * UUpgrade upload progress and run progress event
     *
     * @private
     * @param {string} id
     * @param {number} partNumber
     * @param {number} loaded
     * @memberof S3Uploader
     */
    S3Uploader.prototype.onProgressUpdate = function (id, partNumber, loaded) {
        this.setPartData(id, partNumber, 'progress', loaded);
        this.emitProgress();
    };
    /**
     * Emits normalized progress event
     *
     * @private
     * @memberof S3Uploader
     */
    S3Uploader.prototype.emitProgress = function () {
        var totalSize = 0;
        var totalBytes = 0;
        var filesProgress = {};
        for (var i in this.payloads) {
            var payload = this.payloads[i];
            // omit all failed files in progress event
            // this shouldn't happend because of promises rejection in execute. Left to be sure
            /* istanbul ignore next */
            if (payload.file.status === "Failed" /* FAILED */) {
                continue;
            }
            var totalParts = payload.parts.map(function (p) { return p.progress || 0; }).reduce(function (a, b) { return a + b; }, 0);
            totalBytes = totalBytes + totalParts;
            filesProgress[i] = {
                totalBytes: totalParts,
                totalPercent: Math.round((totalParts * 100) / payload.file.size) || 0,
            };
            totalSize = totalSize + payload.file.size;
        }
        var res = {
            totalBytes: totalBytes || 0,
            totalPercent: Math.round((totalBytes * 100) / totalSize) || 0,
            files: filesProgress,
        };
        debug("Upload progress %O", res);
        this.emit('progress', res);
    };
    /**
     * Apply provided data to given payload
     *
     * @private
     * @param {string} id
     * @param {*} data
     * @memberof S3Uploader
     */
    S3Uploader.prototype.updatePayload = function (id, data) {
        this.payloads[id] = tslib_1.__assign(tslib_1.__assign({}, this.payloads[id]), data);
    };
    /**
     * Sets etag for part
     *
     * @private
     * @param {number} partNumber
     * @param {string} etag
     * @memberof S3Uploader
     */
    S3Uploader.prototype.setPartETag = function (id, partNumber, etag) {
        debug("[" + id + "] Set " + etag + " etag for part " + partNumber);
        this.getPayloadById(id).parts[partNumber].etag = etag;
    };
    /**
     * Sets part value for a key
     *
     * @private
     * @param {number} partNumber
     * @param {string} etag
     * @memberof S3Uploader
     */
    S3Uploader.prototype.setPartData = function (id, partNumber, key, value) {
        debug("[" + id + "] Set " + key + " = " + value + " for part " + partNumber);
        var payload = this.getPayloadById(id);
        /* istanbul ignore next */
        if (!payload) {
            debug("[" + id + "] Cannot set " + key + " = " + value + " for part " + partNumber);
            return;
        }
        payload.parts[partNumber][key] = value;
    };
    /**
     * Set payload file state
     *
     * @param id
     * @param status
     */
    S3Uploader.prototype.setPayloadStatus = function (id, status) {
        debug("[" + id + "] Set payload status to " + status);
        /* istanbul ignore next: additional check in case if file will be deleted before setting status */
        if (!this.payloads[id]) {
            return;
        }
        this.payloads[id].file.status = status;
    };
    /**
     * Returns error details if response exists
     *
     * @param err
     */
    S3Uploader.prototype.parseError = function (err) {
        if (!err.response) {
            return {};
        }
        return {
            code: err.response.status,
            data: err.response.data,
            headers: err.response.headers,
        };
    };
    S3Uploader.prototype.rejectUpload = function (message, err) {
        if (err instanceof request_1.FsRequestError && err.code === request_1.FsRequestErrorCode.ABORTED) {
            return Promise.reject(new filestack_error_1.FilestackError(message, { reason: err.message }, filestack_error_1.FilestackErrorType.ABORTED));
        }
        return Promise.reject(new filestack_error_1.FilestackError(message, this.parseError(err), filestack_error_1.FilestackErrorType.REQUEST));
    };
    return S3Uploader;
}(abstract_1.UploaderAbstract));
exports.S3Uploader = S3Uploader;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC91cGxvYWRlcnMvczMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsK0JBQTBCO0FBQzFCLG1DQUE2QjtBQUU3QixpRUFBbUY7QUFDbkYsOENBQThHO0FBQzlHLHNEQUF5RDtBQUN6RCwwQ0FBc0U7QUFHdEUsdUNBQTBIO0FBRTFILElBQU0sS0FBSyxHQUFHLGVBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUVwQyxJQUFNLGdCQUFnQixHQUFHLElBQUksR0FBRyxDQUFDLENBQUM7QUFtQmxDO0lBQWdDLHNDQUFnQjtJQU05QyxvQkFBWSxZQUFnQyxFQUFFLFdBQVk7UUFBMUQsWUFDRSxrQkFBTSxZQUFZLEVBQUUsV0FBVyxDQUFDLFNBUWpDO1FBWE8sY0FBUSxHQUFxQyxFQUFFLENBQUM7UUFLdEQsS0FBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLGlCQUFNLENBQUM7WUFDM0IsU0FBUyxFQUFFLEtBQUs7WUFDaEIsV0FBVyxFQUFFLEtBQUksQ0FBQyxXQUFXO1NBQzlCLENBQUMsQ0FBQztRQUVILEtBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSx1QkFBYSxFQUFFLENBQUM7O0lBQ3pDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksMEJBQUssR0FBWjtRQUNFLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSwyQkFBTSxHQUFiO1FBQ0UsMEJBQTBCO1FBQzFCLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUU7WUFDNUIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUN6QjtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksMEJBQUssR0FBWixVQUFhLEdBQVk7UUFDdkIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUN4QixJQUFJLENBQUMsVUFB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RSxFQUFFLG9DQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7U0FDekc7UUFDRCxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxnQ0FBYyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFLG9DQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDdkcsQ0FBQztJQUNILGlCQUFDO0FBQUQsQ0FqMEJBLEFBaTBCQyxDQWowQitCLDJCQUFnQixHQWkwQi9DO0FBajBCWSxnQ0FBVSIsImZpbGUiOiJsaWIvYXBpL3VwbG9hZC91cGxvYWRlcnMvczMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IERlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBQUXVldWUgZnJvbSAncC1xdWV1ZSc7XG5cbmltcG9ydCB7IEZpbGVzdGFja0Vycm9yLCBGaWxlc3RhY2tFcnJvclR5cGUgfSBmcm9tICcuLy4uLy4uLy4uLy4uL2ZpbGVzdGFja19lcnJvcic7XG5pbXBvcnQgeyBGc0NhbmNlbFRva2VuLCBGc1JlcXVlc3QsIEZzUmVxdWVzdEVycm9yLCBGc1JlcXVlc3RFcnJvckNvZGUsIEZzUmVzcG9uc2UgfSBmcm9tICcuLy4uLy4uLy4uL3JlcXVlc3QnO1xuaW1wb3J0IHsgc2hvdWxkUmV0cnkgfSBmcm9tICcuLy4uLy4uLy4uL3JlcXVlc3QvaGVscGVycyc7XG5pbXBvcnQgeyBmaWx0ZXJPYmplY3QsIHVuaXF1ZUlkLCB1bmlxdWVUaW1lIH0gZnJvbSAnLi8uLi8uLi8uLi91dGlscyc7XG5pbXBvcnQgeyBGaWxlLCBGaWxlUGFydCwgRmlsZVBhcnRNZXRhZGF0YSwgRmlsZVN0YXRlIH0gZnJvbSAnLi8uLi9maWxlJztcbmltcG9ydCB7IFN0b3JlVXBsb2FkT3B0aW9ucyB9IGZyb20gJy4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgREVGQVVMVF9TVE9SRV9MT0NBVElPTiwgSU5URUxMSUdFTlRfQ0hVTktfU0laRSwgTUlOX0NIVU5LX1NJWkUsIFVwbG9hZGVyQWJzdHJhY3QsIFVwbG9hZE1vZGUgfSBmcm9tICcuL2Fic3RyYWN0JztcblxuY29uc3QgZGVidWcgPSBEZWJ1ZygnZnM6dXBsb2FkOnMzJyk7XG5cbmNvbnN0IENPTVBMRVRFX1RJTUVPVVQgPSAxMDAwICogMTtcblxuZXhwb3J0IGludGVyZmFjZSBVcGxvYWRQYXJ0IGV4dGVuZHMgRmlsZVBhcnRNZXRhZGF0YSB7XG4gIGV0YWc/OiBzdHJpbmc7XG4gIG9mZnNldD86IG51bWJlcjtcbiAgcHJvZ3Jlc3M/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBsb2FkUGF5bG9hZCB7XG4gIGZpbGU6IEZpbGU7XG4gIHBhcnRzOiBVcGxvYWRQYXJ0W107XG4gIGhhbmRsZT86IHN0cmluZztcbiAgdXJpPzogc3RyaW5nO1xuICByZWdpb24/OiBzdHJpbmc7XG4gIHVwbG9hZF9pZD86IG51bWJlcjtcbiAgbG9jYXRpb25fdXJsPzogc3RyaW5nO1xuICBsb2NhdGlvbl9yZWdpb24/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBTM1VwbG9hZGVyIGV4dGVuZHMgVXBsb2FkZXJBYnN0cmFjdCB7XG4gIHByaXZhdGUgcGFydHNRdWV1ZTtcbiAgcHJpdmF0ZSBjYW5jZWxUb2tlbjogRnNDYW5jZWxUb2tlbjsgLy8gZ2xvYmFsIGNhbmNlbCB0b2tlbiBmb3IgYWxsIHJlcXVlc3RzXG5cbiAgcHJpdmF0ZSBwYXlsb2FkczogeyBba2V5OiBzdHJpbmddOiBVcGxvYWRQYXlsb2FkIH0gPSB7fTtcblxuICBjb25zdHJ1Y3RvcihzdG9yZU9wdGlvbnM6IFN0b3JlVXBsb2FkT3B0aW9ucywgY29uY3VycmVuY3k/KSB7XG4gICAgc3VwZXIoc3RvcmVPcHRpb25zLCBjb25jdXJyZW5jeSk7XG5cbiAgICB0aGlzLnBhcnRzUXVldWUgPSBuZXcgUFF1ZXVlKHtcbiAgICAgIGF1dG9TdGFydDogZmFsc2UsXG4gICAgICBjb25jdXJyZW5jeTogdGhpcy5jb25jdXJyZW5jeSxcbiAgICB9KTtcblxuICAgIHRoaXMuY2FuY2VsVG9rZW4gPSBuZXcgRnNDYW5jZWxUb2tlbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHVwbG9hZCBxdWV1ZVxuICAgKlxuICAgKiBAbWVtYmVyb2YgUzNVcGxvYWRlclxuICAgKi9cbiAgcHVibGljIHBhdXNlKCk6IHZvaWQge1xuICAgIHRoaXMucGFydHNRdWV1ZS5wYXVzZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlc3VtZSB1cGxvYWQgcXVldWUgaWYgaXRzIHBhdXNlZFxuICAgKlxuICAgKiBAbWVtYmVyb2YgUzNVcGxvYWRlclxuICAgKi9cbiAgcHVibGljIHJlc3VtZSgpOiB2b2lkIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0aGlzLnBhcnRzUXVldWUuaXNQYXVzZWQpIHtcbiAgICAgIHRoaXMucGFydHNRdWV1ZS5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBYm9ydHMgcXVldWUgKGFsbCBwZW5kaW5nIHJlcXVlc3RzIHdpdGggd2lsbCBiZSBhYm9ydGVkKVxuICAgKlxuICAgKiBAbWVtYmVyb2YgUzNVcGxvYWRlclxuICAgKi9cbiAgcHVibGljIGFib3J0KG1zZz86IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMucGFydHNRdWV1ZS5wYXVzZSgpO1xuICAgIHRoaXMucGFydHNRdWV1ZS5jbGVhcigpO1xuXG4gICAgdGhpcy5jYW5jZWxUb2tlbi5jYW5jZWwobXNnIHx8ICdBYm9ydGVkIGJ5IHVzZXInKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGFsbCBxdWV1ZWQgZmlsZXNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICogQG1lbWJlcm9mIFMzVXBsb2FkZXJcbiAgICovXG4gIHB1YmxpYyBhc3luYyBleGVjdXRlKCk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgdGFza3MgPSBPYmplY3Qua2V5cyh0aGlzLnBheWxvYWRzKS5tYXAoXG4gICAgICBpZCA9PlxuICAgICAgICBuZXcgUHJvbWlzZShhc3luYyByZXNvbHZlID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFydFJlcXVlc3QoaWQpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wcmVwYXJlUGFydHMoaWQpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFydFBhcnRzUXVldWUoaWQpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jb21wbGV0ZVJlcXVlc3QoaWQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICAgICAgICBkZWJ1ZyhgWyR7aWR9XSBGaWxlIHVwbG9hZCBmYWlsZWQuICVPLCBcXG5EZXRhaWxzOiAlTyBgLCBlLm1lc3NhZ2UsIGUuZGV0YWlscyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0UGF5bG9hZEJ5SWQoaWQpLmZpbGU7XG5cbiAgICAgICAgICAvLyByZWxlYXNlIGZpbGUgYnVmZmVyXG4gICAgICAgICAgZmlsZS5yZWxlYXNlKCk7XG5cbiAgICAgICAgICAvLyBjbGVhbnVwIHBheWxvYWRzXG4gICAgICAgICAgZGVsZXRlIHRoaXMucGF5bG9hZHNbaWRdO1xuXG4gICAgICAgICAgcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRhc2tzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZmlsZSB0byB1cGxvYWQgcXVldWVcbiAgICpcbiAgICogQHBhcmFtIHtGaWxlfSBmaWxlXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBTM1VwbG9hZGVyXG4gICAqL1xuICBwdWJsaWMgYWRkRmlsZShmaWxlOiBGaWxlKTogc3RyaW5nIHtcbiAgICBkZWJ1ZygnQWRkIGZpbGUgdG8gcXVldWU6IFxcbiAlbycsIGZpbGUpO1xuXG4gICAgY29uc3QgaWQgPSBgJHt1bmlxdWVJZCgxNSl9XyR7dW5pcXVlVGltZSgpfWA7XG5cbiAgICBmaWxlLnN0YXR1cyA9IEZpbGVTdGF0ZS5JTklUO1xuXG4gICAgLy8gc3BsaXQgZmlsZSBpbnRvIHBhcnRzIGFuZCBzZXQgaXQgYXMgd2FpdGluZ1xuICAgIHRoaXMucGF5bG9hZHNbaWRdID0ge1xuICAgICAgZmlsZSxcbiAgICAgIHBhcnRzOiBbXSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaG9zdCBmb3IgdXBsb2FkIChyZWdpb24gYmFzZWQpXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBTM1VwbG9hZGVyXG4gICAqL1xuICBwcml2YXRlIGdldFVwbG9hZFVybChpZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCB7IGxvY2F0aW9uX3VybCB9ID0gdGhpcy5nZXREZWZhdWx0RmllbGRzKGlkLCBbJ2xvY2F0aW9uX3VybCddKTtcbiAgICByZXR1cm4gbG9jYXRpb25fdXJsLmluZGV4T2YoJ2h0dHAnKSA9PT0gMCA/IGxvY2F0aW9uX3VybCA6IGBodHRwczovLyR7bG9jYXRpb25fdXJsfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmb3JtYXR0ZWQgc3RvcmUgb3B0aW9uc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuc1xuICAgKiBAbWVtYmVyb2YgUzNVcGxvYWRlclxuICAgKi9cbiAgcHJpdmF0ZSBnZXRTdG9yZU9wdGlvbnMoaWQ6IHN0cmluZyk6IFN0b3JlVXBsb2FkT3B0aW9ucyB7XG4gICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICBsb2NhdGlvbjogREVGQVVMVF9TVE9SRV9MT0NBVElPTiwgLy8gdGhpcyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQsIGlmIG5vdCBzZXQgdXNlIGRlZmF1bHQgb25lXG4gICAgICAuLi50aGlzLnN0b3JlT3B0aW9ucyxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuc3RvcmVPcHRpb25zLmRpc2FibGVTdG9yYWdlS2V5KSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5nZXRQYXlsb2FkQnlJZChpZCk7XG5cbiAgICAgIGlmIChvcHRpb25zLnBhdGggJiYgb3B0aW9ucy5wYXRoLnN1YnN0cigtMSkgIT09ICcvJykge1xuICAgICAgICBvcHRpb25zLnBhdGggPSBgJHtvcHRpb25zLnBhdGh9L2A7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMucGF0aCA9IGAke29wdGlvbnMucGF0aCA/IG9wdGlvbnMucGF0aCA6ICcvJ30ke3BheWxvYWQuZmlsZS5uYW1lfWA7XG5cbiAgICAgIGRlbGV0ZSBvcHRpb25zLmRpc2FibGVTdG9yYWdlS2V5O1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGRlZmF1bHQgZmllbGRzIGZvciBmaWxlc3RhY2sgcmVxdWVzdHNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnNcbiAgICogQG1lbWJlcm9mIFMzVXBsb2FkZXJcbiAgICovXG4gIHByaXZhdGUgZ2V0RGVmYXVsdEZpZWxkcyhpZDogc3RyaW5nLCByZXF1aXJlZEZpZWxkczogc3RyaW5nW10sIGZpaUZhbGxiYWNrOiBib29sZWFuID0gZmFsc2UpIHtcbiAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5nZXRQYXlsb2FkQnlJZChpZCk7XG5cbiAgICBsZXQgZmllbGRzID0ge1xuICAgICAgLi4udGhpcy5zZWN1cml0eSxcbiAgICAgIGFwaWtleTogdGhpcy5hcGlrZXksXG4gICAgICB1cmk6IHBheWxvYWQudXJpLFxuICAgICAgbG9jYXRpb25fdXJsOiBwYXlsb2FkLmxvY2F0aW9uX3VybCxcbiAgICAgIHVwbG9hZF9pZDogcGF5bG9hZC51cGxvYWRfaWQsXG4gICAgICByZWdpb246IHBheWxvYWQucmVnaW9uLFxuICAgIH07XG5cbiAgICBpZiAodGhpcy51cGxvYWRNb2RlID09PSBVcGxvYWRNb2RlLklOVEVMTElHRU5UIHx8ICh0aGlzLnVwbG9hZE1vZGUgPT09IFVwbG9hZE1vZGUuRkFMTEJBQ0sgJiYgZmlpRmFsbGJhY2spKSB7XG4gICAgICBmaWVsZHNbJ2ZpaSddID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZmlsdGVyT2JqZWN0KGZpZWxkcywgcmVxdWlyZWRGaWVsZHMpLFxuICAgICAgc3RvcmU6IHRoaXMuZ2V0U3RvcmVPcHRpb25zKGlkKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZGVmYXVsdCBoZWFkZXJzIG5lZWRlZCBmb3IgZmlsZXN0YWNrIHJlcXVlc3RcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnNcbiAgICogQG1lbWJlcm9mIFMzVXBsb2FkZXJcbiAgICovXG4gIHByaXZhdGUgZ2V0RGVmYXVsdEhlYWRlcnMoaWQ6IHN0cmluZykge1xuICAgIGxldCBoZWFkZXJzID0ge307XG4gICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0UGF5bG9hZEJ5SWQoaWQpO1xuXG4gICAgaWYgKGZpbGUubG9jYXRpb25fcmVnaW9uKSB7XG4gICAgICBoZWFkZXJzWydGaWxlc3RhY2stVXBsb2FkLVJlZ2lvbiddID0gZmlsZS5sb2NhdGlvbl9yZWdpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cblxuICBwcml2YXRlIGdldFBheWxvYWRCeUlkKGlkOiBzdHJpbmcpOiBVcGxvYWRQYXlsb2FkIHtcbiAgICByZXR1cm4gdGhpcy5wYXlsb2Fkc1tpZF07XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgZmlsZSBvbnRvIHBhcnRzIGZvciB1cGxvYWRpbmcgd2l0aCBtdWx0aXBhcnQgbWVjaGFuaXNtIGFuZCBzZXR1cCBzdGFydFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWVtYmVyb2YgUzNVcGxvYWRlclxuICAgKi9cbiAgcHJpdmF0ZSBwcmVwYXJlUGFydHMoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldFBheWxvYWRCeUlkKGlkKS5maWxlO1xuXG4gICAgLy8gZm9yIGludGVsbGlnZW50IG9yIGZhbGxiYWNrIG1vZGUgd2UgY2FudCBvdmVyd3JpdGUgcGFydCBzaXplIC0gcmVxdWlyZXMgOE1CXG4gICAgaWYgKFtVcGxvYWRNb2RlLklOVEVMTElHRU5ULCBVcGxvYWRNb2RlLkZBTExCQUNLXS5pbmRleE9mKHRoaXMudXBsb2FkTW9kZSkgPiAtMSkge1xuICAgICAgdGhpcy5wYXJ0U2l6ZSA9IElOVEVMTElHRU5UX0NIVU5LX1NJWkU7XG4gICAgfVxuXG4gICAgY29uc3QgcGFydHNDb3VudCA9IGZpbGUuZ2V0UGFydHNDb3VudCh0aGlzLnBhcnRTaXplKTtcblxuICAgIGNvbnN0IHBhcnRzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzQ291bnQ7IGkrKykge1xuICAgICAgcGFydHNbaV0gPSB7XG4gICAgICAgIC4uLmZpbGUuZ2V0UGFydE1ldGFkYXRhKGksIHRoaXMucGFydFNpemUpLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHNwbGl0IGZpbGUgaW50byBwYXJ0cyBhbmQgc2V0IGl0IGFzIHdhaXRpbmdcbiAgICB0aGlzLnBheWxvYWRzW2lkXS5wYXJ0cyA9IHBhcnRzO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2Ugc3RhcnQgcmVxdWVzdCBmb3IgZ2V0dGluZyBuZWVkZWQgdXBsb2FkIGZpZWxkc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgKiBAbWVtYmVyb2YgUzNVcGxvYWRlclxuICAgKi9cbiAgcHJpdmF0ZSBzdGFydFJlcXVlc3QoaWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuZ2V0UGF5bG9hZEJ5SWQoaWQpO1xuXG4gICAgaWYgKHBheWxvYWQuZmlsZS5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLnNldFBheWxvYWRTdGF0dXMoaWQsIEZpbGVTdGF0ZS5GQUlMRUQpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGaWxlc3RhY2tFcnJvcihgSW52YWxpZCBmaWxlIFwiJHtwYXlsb2FkLmZpbGUubmFtZX1cIiBzaXplIC0gMGAsIHt9LCBGaWxlc3RhY2tFcnJvclR5cGUuVkFMSURBVElPTikpO1xuICAgIH1cblxuICAgIGRlYnVnKGBbJHtpZH1dIE1ha2Ugc3RhcnQgcmVxdWVzdGApO1xuICAgIHJldHVybiBGc1JlcXVlc3QucG9zdChcbiAgICAgIGAke3RoaXMuZ2V0VXJsKCl9L211bHRpcGFydC9zdGFydGAsXG4gICAgICB7XG4gICAgICAgIGZpbGVuYW1lOiBwYXlsb2FkLmZpbGUubmFtZSxcbiAgICAgICAgbWltZXR5cGU6IHBheWxvYWQuZmlsZS50eXBlLFxuICAgICAgICBzaXplOiBwYXlsb2FkLmZpbGUuc2l6ZSxcbiAgICAgICAgLi4udGhpcy5nZXREZWZhdWx0RmllbGRzKGlkLCBbJ2FwaWtleScsICdwb2xpY3knLCAnc2lnbmF0dXJlJywgJ2ZpaSddLCB0cnVlKSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRpbWVvdXQ6IHRoaXMudGltZW91dCxcbiAgICAgICAgY2FuY2VsVG9rZW46IHRoaXMuY2FuY2VsVG9rZW4sXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0RGVmYXVsdEhlYWRlcnMoaWQpLFxuICAgICAgICByZXRyeTogdGhpcy5yZXRyeUNvbmZpZyxcbiAgICAgIH1cbiAgICApXG4gICAgICAudGhlbigoeyBkYXRhIH0pID0+IHtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxvY2F0aW9uX3VybCB8fCAhZGF0YS5yZWdpb24gfHwgIWRhdGEudXBsb2FkX2lkIHx8ICFkYXRhLnVyaSkge1xuICAgICAgICAgIGRlYnVnKGBbJHtpZH1dIEluY29ycmVjdCBzdGFydCByZXNwb25zZTogXFxuJU9cXG5gLCBkYXRhKTtcbiAgICAgICAgICB0aGlzLnNldFBheWxvYWRTdGF0dXMoaWQsIEZpbGVTdGF0ZS5GQUlMRUQpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRmlsZXN0YWNrRXJyb3IoJ0luY29ycmVjdCBzdGFydCByZXNwb25zZScsIGRhdGEsIEZpbGVzdGFja0Vycm9yVHlwZS5SRVFVRVNUKSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZyhgWyR7aWR9XSBBc3NpZ24gcGF5bG9hZCBkYXRhOiBcXG4lT1xcbmAsIGRhdGEpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlUGF5bG9hZChpZCwgZGF0YSk7XG5cbiAgICAgICAgLy8gaWkgaXMgbm90IGVuYWJsZWQgaW4gYmFja2VuZCBzd2l0Y2ggYmFjayB0byBkZWZhdWx0IHVwbG9hZCBtb2RlXG4gICAgICAgIGlmIChbVXBsb2FkTW9kZS5JTlRFTExJR0VOVCwgVXBsb2FkTW9kZS5GQUxMQkFDS10uaW5kZXhPZih0aGlzLnVwbG9hZE1vZGUpID4gLTEgJiYgKCFkYXRhLnVwbG9hZF90eXBlIHx8IGRhdGEudXBsb2FkX3R5cGUgIT09ICdpbnRlbGxpZ2VudF9pbmdlc3Rpb24nKSkge1xuICAgICAgICAgIGRlYnVnKGBbJHtpZH1dIEludGVsbGlnZW50IEluZ2VzdGlvbiBpcyBub3QgZW5hYmxlZCBvbiBhY2NvdW50LCBzd2l0Y2ggYmFjayB0byByZWd1bGFyIHVwbG9hZCBhbmQgbG9jayBtb2RlIGNoYW5nZWApO1xuICAgICAgICAgIHRoaXMuc2V0VXBsb2FkTW9kZShVcGxvYWRNb2RlLkRFRkFVTFQsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGRlYnVnKGBbJHtpZH1dIFN0YXJ0IHJlcXVlc3QgZXJyb3IgJU9gLCBlcnIpO1xuICAgICAgICB0aGlzLnNldFBheWxvYWRTdGF0dXMoaWQsIEZpbGVTdGF0ZS5GQUlMRUQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlamVjdFVwbG9hZCgnQ2Fubm90IHVwbG9hZCBmaWxlLiBTdGFydCByZXF1ZXN0IGZhaWxlZCcsIGVycik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGZpbGUgcGFydHMgdG8gdXBsb2FkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBTM1VwbG9hZGVyXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHN0YXJ0UGFydHNRdWV1ZShpZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5nZXRQYXlsb2FkQnlJZChpZCk7XG4gICAgY29uc3QgcGFydHMgPSBwYXlsb2FkLnBhcnRzO1xuICAgIGNvbnN0IHdhaXRpbmdMZW5ndGggPSBwYXJ0cy5sZW5ndGg7XG5cbiAgICBkZWJ1ZyhgWyR7aWR9XSBDcmVhdGUgdXBsb2FkaW5nIHF1ZXVlIGZyb20gZmlsZS4gcGFydHMgY291bnQgLSAlZGAsIHdhaXRpbmdMZW5ndGgpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHBhcnRzLmZvckVhY2gocGFydCA9PlxuICAgICAgICB0aGlzLnBhcnRzUXVldWVcbiAgICAgICAgICAuYWRkKCgpID0+IHRoaXMuc3RhcnRQYXJ0KGlkLCBwYXJ0LnBhcnROdW1iZXIpKVxuICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGF5bG9hZFN0YXR1cyhpZCwgRmlsZVN0YXRlLkZBSUxFRCk7XG4gICAgICAgICAgICBkZWJ1ZyhgWyR7aWR9XSBGYWlsZWQgdG8gdXBsb2FkIHBhcnQgJXNgLCBlLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgICB0aGlzLnBhcnRzUXVldWUucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMucGFydHNRdWV1ZS5jbGVhcigpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgZGVidWcoYFske2lkfV0gQWxsIHRhc2tzIGZvciAlcyBlbnF1ZXVlZC4gU3RhcnQgcHJvY2Vzc2luZyBtYWluIHVwbG9hZCBxdWV1ZWAsIGlkKTtcbiAgICAgIHRoaXMuZW1pdCgnc3RhcnQnKTtcbiAgICAgIHRoaXMucGFydHNRdWV1ZS5zdGFydCgpO1xuXG4gICAgICByZXNvbHZlKGF3YWl0IHRoaXMucGFydHNRdWV1ZS5vbklkbGUoKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjaWRlIGlmIHVwbG9hZCBzaG91bGQgYmUgbWFkZSB1c2luZyBpaSBvciByZWd1bGFyIHVwbG9hZFxuICAgKiBJdCBhbGxvd3MgY2hhbmdlIHVwbG9hZCBtb2RlIGR1cmluZyB1cGxvYWQgcXVldWVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhcnROdW1iZXJcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICogQG1lbWJlcm9mIFMzVXBsb2FkZXJcbiAgICovXG4gIHByaXZhdGUgc3RhcnRQYXJ0KGlkOiBzdHJpbmcsIHBhcnROdW1iZXI6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgZGVidWcoYFske2lkfV0gU3RhcnQgcHJvY2Vzc2luZyBwYXJ0ICR7cGFydE51bWJlcn0gd2l0aCBtb2RlICR7dGhpcy51cGxvYWRNb2RlfWApO1xuXG4gICAgbGV0IHBheWxvYWQgPSB0aGlzLmdldFBheWxvYWRCeUlkKGlkKTtcblxuICAgIHBheWxvYWQuZmlsZS5zdGF0dXMgPSBGaWxlU3RhdGUuUFJPR1JFU1M7XG4gICAgcmV0dXJuICh0aGlzLnVwbG9hZE1vZGUgIT09IFVwbG9hZE1vZGUuSU5URUxMSUdFTlQgPyB0aGlzLnVwbG9hZFJlZ3VsYXIgOiB0aGlzLnVwbG9hZEludGVsbGlnZW50KS5hcHBseSh0aGlzLCBbaWQsIHBhcnROdW1iZXJdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBhcnQgZGF0YSBuZWVkZWQgZm9yIHVwbG9hZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBpZCBvZiBhIGN1cnJlbnRseSB1cGxvYWRpbmcgZmlsZVxuICAgKiBAcGFyYW0ge0ZpbGVQYXJ0fSBwYXJ0XG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBTM1VwbG9hZGVyXG4gICAqL1xuICBwcml2YXRlIGdldFMzUGFydE1ldGFkYXRhKGlkOiBzdHJpbmcsIHBhcnQ6IEZpbGVQYXJ0LCBvZmZzZXQ/OiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0VXBsb2FkVXJsKGlkKTtcblxuICAgIGRlYnVnKGBbJHtpZH1dIEdldCBkYXRhIGZvciBwYXJ0ICR7cGFydC5wYXJ0TnVtYmVyfSwgdXJsICR7dXJsfSwgTWQ1OiAke3BhcnQubWQ1fSwgU2l6ZTogJHtwYXJ0LnNpemV9YCk7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgLi4udGhpcy5nZXREZWZhdWx0RmllbGRzKGlkLCBbJ2FwaWtleScsICd1cmknLCAncmVnaW9uJywgJ3NpZ25hdHVyZScsICdwb2xpY3knLCAndXBsb2FkX2lkJywgJ2ZpaSddKSxcbiAgICAgIC8vIG1ldGhvZCBzcGVjaWZpYyBrZXlzXG4gICAgICBwYXJ0OiBwYXJ0LnBhcnROdW1iZXIgKyAxLFxuICAgICAgc2l6ZTogcGFydC5zaXplLFxuICAgICAgb2Zmc2V0LFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5pbnRlZ3JpdHlDaGVjayAmJiBwYXJ0Lm1kNSkge1xuICAgICAgZGF0YS5tZDUgPSBwYXJ0Lm1kNTtcbiAgICB9XG5cbiAgICByZXR1cm4gRnNSZXF1ZXN0LnBvc3QoYCR7dXJsfS9tdWx0aXBhcnQvdXBsb2FkYCwgZGF0YSwge1xuICAgICAgaGVhZGVyczogdGhpcy5nZXREZWZhdWx0SGVhZGVycyhpZCksXG4gICAgICBjYW5jZWxUb2tlbjogdGhpcy5jYW5jZWxUb2tlbixcbiAgICAgIHRpbWVvdXQ6IHRoaXMudGltZW91dCxcbiAgICAgIHJldHJ5OiB0aGlzLnJldHJ5Q29uZmlnLFxuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICB0aGlzLnNldFBheWxvYWRTdGF0dXMoaWQsIEZpbGVTdGF0ZS5GQUlMRUQpO1xuXG4gICAgICByZXR1cm4gdGhpcy5yZWplY3RVcGxvYWQoJ0Nhbm5vdCBnZXQgcGFydCBtZXRhZGF0YScsIGVycik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVndWxhciBtdWx0aXBhcnQgcmVxdWVzdCB0byBhbWF6b25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhcnROdW1iZXJcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICogQG1lbWJlcm9mIFMzVXBsb2FkZXJcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgdXBsb2FkUmVndWxhcihpZDogc3RyaW5nLCBwYXJ0TnVtYmVyOiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgIGxldCBwYXlsb2FkID0gdGhpcy5nZXRQYXlsb2FkQnlJZChpZCk7XG4gICAgY29uc3QgcGFydE1ldGFkYXRhID0gcGF5bG9hZC5wYXJ0c1twYXJ0TnVtYmVyXTtcbiAgICBsZXQgcGFydCA9IGF3YWl0IHBheWxvYWQuZmlsZS5nZXRQYXJ0QnlNZXRhZGF0YShwYXJ0TWV0YWRhdGEsIHRoaXMuaW50ZWdyaXR5Q2hlY2spO1xuXG4gICAgY29uc3QgeyBkYXRhLCBoZWFkZXJzIH0gPSBhd2FpdCB0aGlzLmdldFMzUGFydE1ldGFkYXRhKGlkLCBwYXJ0KTtcbiAgICBkZWJ1ZyhgWyR7aWR9XSBSZWNlaXZlZCBwYXJ0ICR7cGFydE51bWJlcn0gaW5mbyBib2R5OiBcXG4lT1xcbiBoZWFkZXJzOiBcXG4lT1xcbmAsIGRhdGEsIGhlYWRlcnMpO1xuICAgIHJldHVybiBGc1JlcXVlc3QucHV0KGRhdGEudXJsLCBwYXJ0LmJ1ZmZlciwge1xuICAgICAgY2FuY2VsVG9rZW46IHRoaXMuY2FuY2VsVG9rZW4sXG4gICAgICB0aW1lb3V0OiB0aGlzLnRpbWVvdXQsXG4gICAgICBoZWFkZXJzOiBkYXRhLmhlYWRlcnMsXG4gICAgICBmaWxlc3RhY2tIZWFkZXJzOiBmYWxzZSxcbiAgICAgIC8vIGZvciBub3cgd2UgY2FudCB0ZXN0IHByb2dyZXNzIGNhbGxiYWNrIGZyb20gdXBsb2FkXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgb25Qcm9ncmVzczogKHByOiBQcm9ncmVzc0V2ZW50KSA9PiB0aGlzLm9uUHJvZ3Jlc3NVcGRhdGUoaWQsIHBhcnROdW1iZXIsIHByLmxvYWRlZCksXG4gICAgICByZXRyeTogdGhpcy5yZXRyeUNvbmZpZyAmJiB0aGlzLnVwbG9hZE1vZGUgIT09IFVwbG9hZE1vZGUuRkFMTEJBQ0sgPyB0aGlzLnJldHJ5Q29uZmlnIDogdW5kZWZpbmVkLFxuICAgIH0pXG4gICAgLnRoZW4ocmVzID0+IHtcbiAgICAgIGlmIChyZXMuaGVhZGVycy5ldGFnKSB7XG4gICAgICAgIHRoaXMuc2V0UGFydEVUYWcoaWQsIHBhcnROdW1iZXIsIHJlcy5oZWFkZXJzLmV0YWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVsZWFzZSBtZW1vcnlcbiAgICAgICAgcGFydCA9IG51bGw7XG4gICAgICAgIHRocm93IG5ldyBGaWxlc3RhY2tFcnJvcignQ2Fubm90IHVwbG9hZCBmaWxlLCBjaGVjayBTMyBidWNrZXQgc2V0dGluZ3MnLCAnRXRhZyBoZWFkZXIgaXMgbm90IGV4cG9zZWQgaW4gQ09SUyBzZXR0aW5ncycsIEZpbGVzdGFja0Vycm9yVHlwZS5SRVFVRVNUKTtcbiAgICAgIH1cblxuICAgICAgZGVidWcoYFske2lkfV0gUzMgVXBsb2FkIHJlc3BvbnNlIGhlYWRlcnMgZm9yICR7cGFydE51bWJlcn06IFxcbiVPXFxuYCwgcmVzLmhlYWRlcnMpO1xuXG4gICAgICB0aGlzLm9uUHJvZ3Jlc3NVcGRhdGUoaWQsIHBhcnROdW1iZXIsIHBhcnQuc2l6ZSk7XG5cbiAgICAgIC8vIHJlbGVhc2UgbWVtb3J5XG4gICAgICBwYXJ0ID0gbnVsbDtcblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KVxuICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgY29uc3QgcmVzcCA9IGVyciAmJiBlcnIucmVzcG9uc2UgPyBlcnIucmVzcG9uc2UgOiBudWxsO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKHJlc3AgJiYgcmVzcC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICBpZiAocmVzcC5kYXRhICYmIHJlc3AuZGF0YS5FcnJvciAmJiByZXNwLmRhdGEuRXJyb3IuY29kZSkge1xuICAgICAgICAgIGxldCBjb2RlID0gcmVzcC5kYXRhLkVycm9yLmNvZGU7XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2RlKSkge1xuICAgICAgICAgICAgY29kZSA9IGNvZGUucG9wKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdSZXF1ZXN0VGltZVRvb1NrZXdlZCc6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UGFydChpZCwgcGFydE51bWJlcik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEZpbGVzdGFja0Vycm9yKCdDYW5ub3QgdXBsb2FkIGZpbGUnLCByZXNwLmRhdGEuRXJyb3IsIEZpbGVzdGFja0Vycm9yVHlwZS5SRVFVRVNUKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbGVhc2UgbWVtb3J5XG4gICAgICBwYXJ0ID0gbnVsbDtcblxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEZpbGVzdGFja0Vycm9yKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgLy8gcmVzZXQgdXBsb2FkIHByb2dyZXNzIG9uIGZhaWxlZCBwYXJ0XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3NVcGRhdGUoaWQsIHBhcnROdW1iZXIsIDApO1xuXG4gICAgICAvLyBpZiBmYWxsYmFjaywgc2V0IHVwbG9hZCBtb2RlIHRvIGludGVsbGlnZW50IGFuZCByZXN0YXJ0IGN1cnJlbnQgcGFydFxuICAgICAgaWYgKCh0aGlzLnVwbG9hZE1vZGUgPT09IFVwbG9hZE1vZGUuRkFMTEJBQ0sgJiYgIXRoaXMuaXNNb2RlTG9ja2VkKSB8fCB0aGlzLnVwbG9hZE1vZGUgPT09IFVwbG9hZE1vZGUuSU5URUxMSUdFTlQpIHtcbiAgICAgICAgZGVidWcoYFske2lkfV0gUmVndWxhciB1cGxvYWQgZmFpbGVkLiBTd2l0Y2hpbmcgdG8gaW50ZWxsaWdlbnQgaW5nZXN0aW9uIG1vZGVgKTtcbiAgICAgICAgdGhpcy5zZXRVcGxvYWRNb2RlKFVwbG9hZE1vZGUuSU5URUxMSUdFTlQpO1xuICAgICAgICAvLyByZXN0YXJ0IHBhcnRcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQYXJ0KGlkLCBwYXJ0TnVtYmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVqZWN0VXBsb2FkKCdDYW5ub3QgdXBsb2FkIGZpbGUgcGFydCcsIGVycik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkIGZpbGUgdXNpbmcgaW50ZWxsaWdlbnQgbWVjaGFuaXNtXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFydE51bWJlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgKiBAbWVtYmVyb2YgUzNVcGxvYWRlclxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB1cGxvYWRJbnRlbGxpZ2VudChpZDogc3RyaW5nLCBwYXJ0TnVtYmVyOiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnVwbG9hZE5leHRDaHVuayhpZCwgcGFydE51bWJlcikudGhlbigoKSA9PiB0aGlzLmNvbW1pdFBhcnQoaWQsIHBhcnROdW1iZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSB1cGxvYWQgZmlsZSBpbiBjaHVuayBtb2RlIChpbnRlbGxpZ2VudCBpbmdlc3Npb24pXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFydE51bWJlclxuICAgKiBAcGFyYW0ge251bWJlcn0gY2h1bmtTaXplXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBTM1VwbG9hZGVyXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHVwbG9hZE5leHRDaHVuayhpZDogc3RyaW5nLCBwYXJ0TnVtYmVyOiBudW1iZXIsIGNodW5rU2l6ZTogbnVtYmVyID0gdGhpcy5pbnRlbGxpZ2VudENodW5rU2l6ZSkge1xuICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLmdldFBheWxvYWRCeUlkKGlkKTtcbiAgICBsZXQgcGFydCA9IHBheWxvYWQucGFydHNbcGFydE51bWJlcl07XG4gICAgY2h1bmtTaXplID0gTWF0aC5taW4oY2h1bmtTaXplLCBwYXJ0LnNpemUgLSBwYXJ0Lm9mZnNldCk7XG5cbiAgICBsZXQgY2h1bmsgPSBhd2FpdCBwYXlsb2FkLmZpbGUuZ2V0Q2h1bmtCeU1ldGFkYXRhKHBhcnQsIHBhcnQub2Zmc2V0LCBjaHVua1NpemUsIHRoaXMuaW50ZWdyaXR5Q2hlY2spO1xuXG4gICAgZGVidWcoXG4gICAgICBgWyR7aWR9XSBQYXJ0TnVtOiAke3BhcnROdW1iZXJ9LCBQYXJ0U2l6ZTogJHtwYXJ0LnNpemV9LCBTdGFydEJ5dGU6ICR7cGFydC5zdGFydEJ5dGV9LCBPZmZzZXQ6ICR7cGFydC5vZmZzZXR9LCBDaHVua1NpemU6ICR7Y2h1bmsuc2l6ZX0sXG4gICAgICAgTGVmdDogJHtwYXJ0LnNpemUgLSBwYXJ0Lm9mZnNldCAtIGNodW5rLnNpemV9YFxuICAgICk7XG5cbiAgICAvLyBjYXRjaCBlcnJvciBmb3IgZGVidWcgcHVycG9zZXNcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMuZ2V0UzNQYXJ0TWV0YWRhdGEoaWQsIGNodW5rLCBwYXJ0Lm9mZnNldCkuY2F0Y2goZXJyID0+IHtcbiAgICAgIGRlYnVnKGBbJHtpZH1dIEdldHRpbmcgY2h1bmsgZGF0YSBmb3IgaWkgZmFpbGVkICVPLCBDaHVuayBzaXplOiAke2NodW5rU2l6ZX0sIG9mZnNldCAke3BhcnQub2Zmc2V0fSwgcGFydCAke3BhcnROdW1iZXJ9YCwgZXJyKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIEZzUmVxdWVzdC5wdXQoZGF0YS51cmwsIGNodW5rLmJ1ZmZlciwge1xuICAgICAgY2FuY2VsVG9rZW46IHRoaXMuY2FuY2VsVG9rZW4sXG4gICAgICB0aW1lb3V0OiB0aGlzLnRpbWVvdXQsXG4gICAgICBoZWFkZXJzOiBkYXRhLmhlYWRlcnMsXG4gICAgICBmaWxlc3RhY2tIZWFkZXJzOiBmYWxzZSxcbiAgICAgIC8vIGZvciBub3cgd2UgY2FudCB0ZXN0IHByb2dyZXNzIGNhbGxiYWNrIGZyb20gdXBsb2FkXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgb25Qcm9ncmVzczogKHByOiBQcm9ncmVzc0V2ZW50KSA9PiBwYXJ0ID8gdGhpcy5vblByb2dyZXNzVXBkYXRlKGlkLCBwYXJ0TnVtYmVyLCBwYXJ0Lm9mZnNldCArIHByLmxvYWRlZCkgOiBudWxsLFxuICAgIH0pXG4gICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3NVcGRhdGUoaWQsIHBhcnROdW1iZXIsIHBhcnQub2Zmc2V0ICsgY2h1bmsuc2l6ZSk7XG4gICAgICAgIGNvbnN0IG5ld09mZnNldCA9IE1hdGgubWluKHBhcnQub2Zmc2V0ICsgY2h1bmtTaXplLCBwYXJ0LnNpemUpO1xuICAgICAgICBkZWJ1ZyhgWyR7aWR9XSBTMyBDaHVuayB1cGxvYWRlZCEgb2Zmc2V0OiAke3BhcnQub2Zmc2V0fSwgcGFydCAke3BhcnROdW1iZXJ9ISByZXNwb25zZSBoZWFkZXJzIGZvciAke3BhcnROdW1iZXJ9OiBcXG4lT1xcbmAsIHJlcy5oZWFkZXJzKTtcbiAgICAgICAgdGhpcy5zZXRQYXJ0RGF0YShpZCwgcGFydE51bWJlciwgJ29mZnNldCcsIG5ld09mZnNldCk7XG5cbiAgICAgICAgLy8gaWYgYWxsIGNodW5rcyB3YXMgdXBsb2FkZWQgdGhlbiByZXR1cm4gcmVzb2x2ZVxuICAgICAgICBpZiAobmV3T2Zmc2V0ID09PSBwYXJ0LnNpemUpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWxlYXNlIG1lbW9yeVxuICAgICAgICBwYXJ0ID0gbnVsbDtcbiAgICAgICAgY2h1bmsgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnVwbG9hZE5leHRDaHVuayhpZCwgcGFydE51bWJlciwgY2h1bmtTaXplKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGVyciAmJiBlcnIucmVzcG9uc2UgPyBlcnIucmVzcG9uc2UgOiBudWxsO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAocmVzcCAmJiByZXNwLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgaWYgKHJlc3AuZGF0YSAmJiByZXNwLmRhdGEuRXJyb3IgJiYgcmVzcC5kYXRhLkVycm9yLmNvZGUpIHtcbiAgICAgICAgICAgIGxldCBjb2RlID0gcmVzcC5kYXRhLkVycm9yLmNvZGU7XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvZGUpKSB7XG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnBvcCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnUmVxdWVzdFRpbWVUb29Ta2V3ZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UGFydChpZCwgcGFydE51bWJlcik7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGaWxlc3RhY2tFcnJvcignQ2Fubm90IHVwbG9hZCBmaWxlJywgcmVzcC5kYXRhLkVycm9yLCBGaWxlc3RhY2tFcnJvclR5cGUuUkVRVUVTVCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IHByb2dyZXNzIG9uIGZhaWxlZCB1cGxvYWRcbiAgICAgICAgdGhpcy5vblByb2dyZXNzVXBkYXRlKGlkLCBwYXJ0TnVtYmVyLCBwYXJ0Lm9mZnNldCk7XG4gICAgICAgIGNvbnN0IG5leHRDaHVua1NpemUgPSBNYXRoLmNlaWwoY2h1bmtTaXplIC8gMik7XG5cbiAgICAgICAgaWYgKG5leHRDaHVua1NpemUgPCBNSU5fQ0hVTktfU0laRSkge1xuICAgICAgICAgIGRlYnVnKGBbJHtpZH1dIE1pbmltYWwgY2h1bmsgc2l6ZSBsaW1pdC4gVXBsb2FkIGZpbGUgZmFpbGVkIWApO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRmlsZXN0YWNrRXJyb3IoJ01pbiBjaHVuayBzaXplIHJlYWNoZWQnLCBlcnIuZGF0YSwgRmlsZXN0YWNrRXJyb3JUeXBlLlJFUVVFU1QpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRSZXRyeShlcnIpKSB7XG4gICAgICAgICAgZGVidWcoYFske2lkfV0gUmVxdWVzdCBuZXR3b3JrIGVycm9yLiBSZXRyeSB3aXRoIG5ldyBjaHVuayBzaXplOiAke25leHRDaHVua1NpemV9YCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudXBsb2FkTmV4dENodW5rKGlkLCBwYXJ0TnVtYmVyLCBuZXh0Q2h1bmtTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbGVhc2UgbWVtb3J5XG4gICAgICAgIHBhcnQgPSBudWxsO1xuICAgICAgICBjaHVuayA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVqZWN0VXBsb2FkKCdDYW5ub3QgdXBsb2FkIGZpbGUgcGFydCAoRklJKScsIGVycik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21taXQgYWZ0ZXIgdXBsb2FkIGFsbCBjaHVua3Mgb2YgdGhlIHBhcnQgaW4gaWkgbW9kZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICogQHBhcmFtIHtGaWxlUGFydH0gcGFydFxuICAgKiBAcmV0dXJuc1xuICAgKiBAbWVtYmVyb2YgUzNVcGxvYWRlclxuICAgKi9cbiAgcHJpdmF0ZSBjb21taXRQYXJ0KGlkOiBzdHJpbmcsIHBhcnROdW1iZXI6IG51bWJlcikge1xuICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLmdldFBheWxvYWRCeUlkKGlkKTtcbiAgICBjb25zdCBwYXJ0ID0gcGF5bG9hZC5wYXJ0c1twYXJ0TnVtYmVyXTtcblxuICAgIHJldHVybiBGc1JlcXVlc3QucG9zdChcbiAgICAgIGAke3RoaXMuZ2V0VXBsb2FkVXJsKGlkKX0vbXVsdGlwYXJ0L2NvbW1pdGAsXG4gICAgICB7XG4gICAgICAgIC4uLnRoaXMuZ2V0RGVmYXVsdEZpZWxkcyhpZCwgWydhcGlrZXknLCAncmVnaW9uJywgJ3VwbG9hZF9pZCcsICdwb2xpY3knLCAnc2lnbmF0dXJlJywgJ3VyaSddKSxcbiAgICAgICAgc2l6ZTogcGF5bG9hZC5maWxlLnNpemUsXG4gICAgICAgIHBhcnQ6IHBhcnQucGFydE51bWJlciArIDEsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjYW5jZWxUb2tlbjogdGhpcy5jYW5jZWxUb2tlbixcbiAgICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0LFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmdldERlZmF1bHRIZWFkZXJzKGlkKSxcbiAgICAgICAgcmV0cnk6IHRoaXMucmV0cnlDb25maWcsXG4gICAgICB9XG4gICAgKVxuICAgICAgLnRoZW4oKHJlczogRnNSZXNwb25zZSkgPT4ge1xuICAgICAgICBkZWJ1ZyhgWyR7aWR9XSBDb21taXQgUGFydCBudW1iZXIgJHtwYXJ0LnBhcnROdW1iZXJ9LiBSZXNwb25zZTogJU9gLCByZXMuZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVqZWN0VXBsb2FkKCdDYW5ub3QgY29tbWl0IGZpbGUgcGFydCBtZXRhZGF0YScsIGVycik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZSByZXF1ZXN0IHRvIG1lcmdlIGFsbCBwYXJ0cyBhbmQgZ2V0IGZpbGUgaGFuZGxlIGV0Y1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuc1xuICAgKiBAbWVtYmVyb2YgUzNVcGxvYWRlclxuICAgKi9cbiAgcHJpdmF0ZSBjb21wbGV0ZVJlcXVlc3QoaWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuZ2V0UGF5bG9hZEJ5SWQoaWQpO1xuICAgIGxldCBwYXJ0cyA9IFtdO1xuXG4gICAgZGVidWcoYFske2lkfV0gUnVuIGNvbXBsZXRlIHJlcXVlc3RgKTtcblxuICAgIGNvbnN0IHBhcnRzSGFuZGxlID0gcGF5bG9hZC5wYXJ0cztcbiAgICBjb25zdCBwYXJ0TGVuID0gcGFydHNIYW5kbGUubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0TGVuOyBpKyspIHtcbiAgICAgIGlmIChwYXJ0c0hhbmRsZVtpXS5ldGFnKSB7XG4gICAgICAgIHBhcnRzLnB1c2goeyBwYXJ0X251bWJlcjogaSArIDEsIGV0YWc6IHBhcnRzSGFuZGxlW2ldLmV0YWcgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoYFske2lkfV0gRXRhZ3MgJU9gLCBwYXJ0cyk7XG5cbiAgICByZXR1cm4gRnNSZXF1ZXN0LnBvc3QoXG4gICAgICBgJHt0aGlzLmdldFVwbG9hZFVybChpZCl9L211bHRpcGFydC9jb21wbGV0ZWAsXG4gICAgICB7XG4gICAgICAgIC4uLnRoaXMuZ2V0RGVmYXVsdEZpZWxkcyhpZCwgWydhcGlrZXknLCAncG9saWN5JywgJ3NpZ25hdHVyZScsICd1cmknLCAncmVnaW9uJywgJ3VwbG9hZF9pZCcsICdmaWknXSwgdHJ1ZSksXG4gICAgICAgIC8vIG1ldGhvZCBzcGVjaWZpYyBrZXlzXG4gICAgICAgIGZpbGVuYW1lOiBwYXlsb2FkLmZpbGUubmFtZSxcbiAgICAgICAgbWltZXR5cGU6IHBheWxvYWQuZmlsZS50eXBlLFxuICAgICAgICBzaXplOiBwYXlsb2FkLmZpbGUuc2l6ZSxcbiAgICAgICAgdXBsb2FkX3RhZ3M6IHRoaXMudXBsb2FkVGFncyAmJiBPYmplY3Qua2V5cyh0aGlzLnVwbG9hZFRhZ3MpLmxlbmd0aCA/IHRoaXMudXBsb2FkVGFncyA6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFydHM6IHBhcnRzLmxlbmd0aCA/IHBhcnRzIDogdW5kZWZpbmVkLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0LFxuICAgICAgICBjYW5jZWxUb2tlbjogdGhpcy5jYW5jZWxUb2tlbixcbiAgICAgICAgaGVhZGVyczogdGhpcy5nZXREZWZhdWx0SGVhZGVycyhpZCksXG4gICAgICAgIHJldHJ5OiB0aGlzLnJldHJ5Q29uZmlnLFxuICAgICAgfVxuICAgIClcbiAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgIC8vIGlmIHBhcnRzIGhhc250IGJlZW4gbWVyZ2VkLCByZXRyeSBjb21wbGV0ZSByZXF1ZXN0IGFnYWluXG4gICAgICAgIGlmIChyZXMuc3RhdHVzID09PSAyMDIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgICAgKCkgPT5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlUmVxdWVzdChpZClcbiAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KSxcbiAgICAgICAgICAgICAgQ09NUExFVEVfVElNRU9VVFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBmaWxlIG9iamVjdFxuICAgICAgICBsZXQgZmlsZSA9IHRoaXMuZ2V0UGF5bG9hZEJ5SWQoaWQpLmZpbGU7XG5cbiAgICAgICAgZmlsZS5oYW5kbGUgPSByZXMuZGF0YS5oYW5kbGU7XG4gICAgICAgIGZpbGUudXJsID0gcmVzLmRhdGEudXJsO1xuICAgICAgICBmaWxlLmNvbnRhaW5lciA9IHJlcy5kYXRhLmNvbnRhaW5lcjtcbiAgICAgICAgZmlsZS5rZXkgPSByZXMuZGF0YS5rZXk7XG4gICAgICAgIGZpbGUudXBsb2FkVGFncyA9IHJlcy5kYXRhLnVwbG9hZF90YWdzO1xuICAgICAgICBmaWxlLndvcmtmbG93cyA9IHJlcy5kYXRhLndvcmtmbG93cztcbiAgICAgICAgZmlsZS5zdGF0dXMgPSByZXMuZGF0YS5zdGF0dXM7XG5cbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHRoaXMuc2V0UGF5bG9hZFN0YXR1cyhpZCwgRmlsZVN0YXRlLkZBSUxFRCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVqZWN0VXBsb2FkKCdDYW5ub3QgY29tcGxldGUgZmlsZScsIGVycik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVVXBncmFkZSB1cGxvYWQgcHJvZ3Jlc3MgYW5kIHJ1biBwcm9ncmVzcyBldmVudFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhcnROdW1iZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxvYWRlZFxuICAgKiBAbWVtYmVyb2YgUzNVcGxvYWRlclxuICAgKi9cbiAgcHJpdmF0ZSBvblByb2dyZXNzVXBkYXRlKGlkOiBzdHJpbmcsIHBhcnROdW1iZXI6IG51bWJlciwgbG9hZGVkOiBudW1iZXIpIHtcbiAgICB0aGlzLnNldFBhcnREYXRhKGlkLCBwYXJ0TnVtYmVyLCAncHJvZ3Jlc3MnLCBsb2FkZWQpO1xuICAgIHRoaXMuZW1pdFByb2dyZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgbm9ybWFsaXplZCBwcm9ncmVzcyBldmVudFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWVtYmVyb2YgUzNVcGxvYWRlclxuICAgKi9cbiAgcHJpdmF0ZSBlbWl0UHJvZ3Jlc3MoKSB7XG4gICAgbGV0IHRvdGFsU2l6ZSA9IDA7XG4gICAgbGV0IHRvdGFsQnl0ZXMgPSAwO1xuXG4gICAgbGV0IGZpbGVzUHJvZ3Jlc3MgPSB7fTtcbiAgICBmb3IgKGxldCBpIGluIHRoaXMucGF5bG9hZHMpIHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLnBheWxvYWRzW2ldO1xuICAgICAgLy8gb21pdCBhbGwgZmFpbGVkIGZpbGVzIGluIHByb2dyZXNzIGV2ZW50XG4gICAgICAvLyB0aGlzIHNob3VsZG4ndCBoYXBwZW5kIGJlY2F1c2Ugb2YgcHJvbWlzZXMgcmVqZWN0aW9uIGluIGV4ZWN1dGUuIExlZnQgdG8gYmUgc3VyZVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGlmIChwYXlsb2FkLmZpbGUuc3RhdHVzID09PSBGaWxlU3RhdGUuRkFJTEVEKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b3RhbFBhcnRzID0gcGF5bG9hZC5wYXJ0cy5tYXAocCA9PiBwLnByb2dyZXNzIHx8IDApLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuXG4gICAgICB0b3RhbEJ5dGVzID0gdG90YWxCeXRlcyArIHRvdGFsUGFydHM7XG5cbiAgICAgIGZpbGVzUHJvZ3Jlc3NbaV0gPSB7XG4gICAgICAgIHRvdGFsQnl0ZXM6IHRvdGFsUGFydHMsXG4gICAgICAgIHRvdGFsUGVyY2VudDogTWF0aC5yb3VuZCgodG90YWxQYXJ0cyAqIDEwMCkgLyBwYXlsb2FkLmZpbGUuc2l6ZSkgfHwgMCxcbiAgICAgIH07XG5cbiAgICAgIHRvdGFsU2l6ZSA9IHRvdGFsU2l6ZSArIHBheWxvYWQuZmlsZS5zaXplO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgIHRvdGFsQnl0ZXM6IHRvdGFsQnl0ZXMgfHwgMCxcbiAgICAgIHRvdGFsUGVyY2VudDogTWF0aC5yb3VuZCgodG90YWxCeXRlcyAqIDEwMCkgLyB0b3RhbFNpemUpIHx8IDAsXG4gICAgICBmaWxlczogZmlsZXNQcm9ncmVzcyxcbiAgICB9O1xuXG4gICAgZGVidWcoYFVwbG9hZCBwcm9ncmVzcyAlT2AsIHJlcyk7XG4gICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgcHJvdmlkZWQgZGF0YSB0byBnaXZlbiBwYXlsb2FkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICogQG1lbWJlcm9mIFMzVXBsb2FkZXJcbiAgICovXG4gIHByaXZhdGUgdXBkYXRlUGF5bG9hZChpZDogc3RyaW5nLCBkYXRhOiBhbnkpIHtcbiAgICB0aGlzLnBheWxvYWRzW2lkXSA9IHtcbiAgICAgIC4uLnRoaXMucGF5bG9hZHNbaWRdLFxuICAgICAgLi4uZGF0YSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgZXRhZyBmb3IgcGFydFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFydE51bWJlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXRhZ1xuICAgKiBAbWVtYmVyb2YgUzNVcGxvYWRlclxuICAgKi9cbiAgcHJpdmF0ZSBzZXRQYXJ0RVRhZyhpZDogc3RyaW5nLCBwYXJ0TnVtYmVyOiBudW1iZXIsIGV0YWc6IHN0cmluZykge1xuICAgIGRlYnVnKGBbJHtpZH1dIFNldCAke2V0YWd9IGV0YWcgZm9yIHBhcnQgJHtwYXJ0TnVtYmVyfWApO1xuICAgIHRoaXMuZ2V0UGF5bG9hZEJ5SWQoaWQpLnBhcnRzW3BhcnROdW1iZXJdLmV0YWcgPSBldGFnO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgcGFydCB2YWx1ZSBmb3IgYSBrZXlcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhcnROdW1iZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV0YWdcbiAgICogQG1lbWJlcm9mIFMzVXBsb2FkZXJcbiAgICovXG4gIHByaXZhdGUgc2V0UGFydERhdGEoaWQ6IHN0cmluZywgcGFydE51bWJlcjogbnVtYmVyLCBrZXk6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIGRlYnVnKGBbJHtpZH1dIFNldCAke2tleX0gPSAke3ZhbHVlfSBmb3IgcGFydCAke3BhcnROdW1iZXJ9YCk7XG5cbiAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5nZXRQYXlsb2FkQnlJZChpZCk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghcGF5bG9hZCkge1xuICAgICAgZGVidWcoYFske2lkfV0gQ2Fubm90IHNldCAke2tleX0gPSAke3ZhbHVlfSBmb3IgcGFydCAke3BhcnROdW1iZXJ9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGF5bG9hZC5wYXJ0c1twYXJ0TnVtYmVyXVtrZXldID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHBheWxvYWQgZmlsZSBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gaWRcbiAgICogQHBhcmFtIHN0YXR1c1xuICAgKi9cbiAgcHJpdmF0ZSBzZXRQYXlsb2FkU3RhdHVzKGlkOiBzdHJpbmcsIHN0YXR1czogRmlsZVN0YXRlKSB7XG4gICAgZGVidWcoYFske2lkfV0gU2V0IHBheWxvYWQgc3RhdHVzIHRvICR7c3RhdHVzfWApO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBhZGRpdGlvbmFsIGNoZWNrIGluIGNhc2UgaWYgZmlsZSB3aWxsIGJlIGRlbGV0ZWQgYmVmb3JlIHNldHRpbmcgc3RhdHVzICovXG4gICAgaWYgKCF0aGlzLnBheWxvYWRzW2lkXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGF5bG9hZHNbaWRdLmZpbGUuc3RhdHVzID0gc3RhdHVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZXJyb3IgZGV0YWlscyBpZiByZXNwb25zZSBleGlzdHNcbiAgICpcbiAgICogQHBhcmFtIGVyclxuICAgKi9cbiAgcHJpdmF0ZSBwYXJzZUVycm9yKGVycjogRnNSZXF1ZXN0RXJyb3IpIHtcbiAgICBpZiAoIWVyci5yZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb2RlOiBlcnIucmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgZGF0YTogZXJyLnJlc3BvbnNlLmRhdGEsXG4gICAgICBoZWFkZXJzOiBlcnIucmVzcG9uc2UuaGVhZGVycyxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSByZWplY3RVcGxvYWQobWVzc2FnZTogc3RyaW5nLCBlcnI6IEZzUmVxdWVzdEVycm9yKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIEZzUmVxdWVzdEVycm9yICYmIGVyci5jb2RlID09PSBGc1JlcXVlc3RFcnJvckNvZGUuQUJPUlRFRCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGaWxlc3RhY2tFcnJvcihtZXNzYWdlLCB7IHJlYXNvbjogZXJyLm1lc3NhZ2UgfSwgRmlsZXN0YWNrRXJyb3JUeXBlLkFCT1JURUQpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGaWxlc3RhY2tFcnJvcihtZXNzYWdlLCB0aGlzLnBhcnNlRXJyb3IoZXJyKSwgRmlsZXN0YWNrRXJyb3JUeXBlLlJFUVVFU1QpKTtcbiAgfVxufVxuIl19


/***/ }),

/***/ 9725:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var eventemitter3_1 = __nccwpck_require__(1848);
var Sentry = __nccwpck_require__(8455);
var config_1 = __nccwpck_require__(9670);
var filestack_error_1 = __nccwpck_require__(4257);
var file_1 = __nccwpck_require__(9016);
var transform_1 = __nccwpck_require__(6110);
var store_1 = __nccwpck_require__(1989);
var Utils = __nccwpck_require__(8123);
var upload_1 = __nccwpck_require__(2427);
var preview_1 = __nccwpck_require__(5653);
var cloud_1 = __nccwpck_require__(8577);
var prefetch_1 = __nccwpck_require__(7953);
var picker_1 = __nccwpck_require__(291);
/* istanbul ignore next */
Sentry.addBreadcrumb({ category: 'sdk', message: 'filestack-js-sdk scope' });
/**
 * The Filestack client, the entry point for all public methods. Encapsulates session information.
 *
 * ### Example
 * ```js
 * // ES module
 * import * as filestack from 'filestack-js';
 * const client = filestack.init('apikey');
 * ```
 *
 * ```js
 * // UMD module in browser
 * <script src="https://static.filestackapi.com/filestack-js/3.x.x/filestack.min.js"></script>
 * const client = filestack.init('apikey');
 * ```
 */
var Client = /** @class */ (function (_super) {
    tslib_1.__extends(Client, _super);
    function Client(apikey, options) {
        var _this = _super.call(this) || this;
        _this.options = options;
        _this.forwardErrors = true;
        /* istanbul ignore if */
        if (options && options.forwardErrors) {
            _this.forwardErrors = options.forwardErrors;
        }
        if (!apikey || typeof apikey !== 'string' || apikey.length === 0) {
            throw new Error('An apikey is required to initialize the Filestack client');
        }
        var urls = config_1.config.urls;
        _this.session = { apikey: apikey, urls: urls };
        if (options) {
            var cname = options.cname, security = options.security;
            _this.setSecurity(security);
            _this.setCname(cname);
        }
        _this.prefetchInstance = new prefetch_1.Prefetch(_this.session);
        _this.cloud = new cloud_1.CloudClient(_this.session, options);
        return _this;
    }
    Object.defineProperty(Client.prototype, "utils", {
        /**
         * Returns filestack utils
         *
         * @readonly
         * @memberof Client
         */
        get: function () {
            return Utils;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Make basic prefetch request to check permissions
     *
     * @param params
     */
    Client.prototype.prefetch = function (params) {
        return this.prefetchInstance.getConfig(params);
    };
    /**
     * Set security object
     *
     * @param {Security} security
     * @memberof Client
     */
    Client.prototype.setSecurity = function (security) {
        if (security && !(security.policy && security.signature)) {
            throw new filestack_error_1.FilestackError('Both policy and signature are required for client security');
        }
        if (security && security.policy && security.signature) {
            this.session.policy = security.policy;
            this.session.signature = security.signature;
        }
    };
    /**
     * Set custom cname
     *
     * @param {string} cname
     * @returns
     * @memberof Client
     */
    Client.prototype.setCname = function (cname) {
        if (!cname || cname.length === 0) {
            return;
        }
        this.session.cname = cname;
        this.session.urls = Utils.resolveHost(this.session.urls, cname);
    };
    /**
     * Clear all current cloud sessions in the picker.
     * Optionally pass a cloud source name to only log out of that cloud source.
     * This essentially clears the OAuth authorization codes from the Filestack session.
     * @param name Optional cloud source name.
     */
    Client.prototype.logout = function (name) {
        return this.cloud.logout(name);
    };
    /**
     * Retrieve detailed data of stored files.
     *
     * ### Example
     *
     * ```js
     * client
     *   .metadata('DCL5K46FS3OIxb5iuKby')
     *   .then((res) => {
     *     console.log(res);
     *   })
     *   .catch((err) => {
     *     console.log(err);
     *   }));
     * ```
     * @see [File API - Metadata](https://www.filestack.com/docs/api/file#metadata).
     * @param handle Valid Filestack handle.
     * @param options Metadata fields to enable on response.
     * @param security Optional security override.
     */
    Client.prototype.metadata = function (handle, options, security) {
        /* istanbul ignore next */
        return file_1.metadata(this.session, handle, options, security);
    };
    /**
     * Construct a new picker instance.
     */
    Client.prototype.picker = function (options) {
        /* istanbul ignore next */
        return picker_1.picker(this, options);
    };
    /**
     * Used for viewing files via Filestack handles or storage aliases, __requires Document Viewer addon to your Filestack application__.
     * Opens document viewer in new window if id option is not provided.
     *
     * ### Example
     *
     * ```js
     * // <div id="preview"></div>
     *
     * client.preview('DCL5K46FS3OIxb5iuKby', { id: 'preview' });
     * ```
     * @param handle Valid Filestack handle.
     * @param options Preview options
     */
    Client.prototype.preview = function (handle, options) {
        /* istanbul ignore next */
        return preview_1.preview(this.session, handle, options);
    };
    /**
     * Remove a file from storage and the Filestack system.
     *
     * __Requires a valid security policy and signature__. The policy and signature will be pulled from the client session, or it can be overridden with the security parameter.
     *
     * ### Example
     *
     * ```js
     * client
     *   .remove('DCL5K46FS3OIxb5iuKby')
     *   .then((res) => {
     *     console.log(res);
     *   })
     *   .catch((err) => {
     *     console.log(err);
     *   }));
     * ```
     * @see [File API - Delete](https://www.filestack.com/docs/api/file#delete)
     * @param handle Valid Filestack handle.
     * @param security Optional security override.
     */
    Client.prototype.remove = function (handle, security) {
        /* istanbul ignore next */
        return file_1.remove(this.session, handle, false, security);
    };
    /**
     * Remove a file **only** from the Filestack system. The file remains in storage.
     *
     * __Requires a valid security policy and signature__. The policy and signature will be pulled from the client session, or it can be overridden with the security parameter.
     *
     * ### Example
     *
     * ```js
     * client
     *   .removeMetadata('DCL5K46FS3OIxb5iuKby')
     *   .then((res) => {
     *     console.log(res);
     *   })
     *   .catch((err) => {
     *     console.log(err);
     *   }));
     * ```
     * @see [File API - Delete](https://www.filestack.com/docs/api/file#delete)
     * @param handle Valid Filestack handle.
     * @param security Optional security override.
     */
    Client.prototype.removeMetadata = function (handle, security) {
        /* istanbul ignore next */
        return file_1.remove(this.session, handle, true, security);
    };
    /**
     * Store a file from its URL.
     *
     * ### Example
     *
     * ```js
     * client
     *   .storeURL('https://d1wtqaffaaj63z.cloudfront.net/images/NY_199_E_of_Hammertown_2014.jpg')
     *   .then(res => console.log(res));
     * ```
     * @see [File API - Store](https://www.filestack.com/docs/api/file#store)
     * @param url       Valid URL to a file.
     * @param options   Configure file storage.
     * @param token     Optional control token to call .cancel()
     * @param security  Optional security override.
     * @param uploadTags Optional tags visible in webhooks.
     * @param headers    Optional headers to send
     * @param workflowIds    Optional workflowIds to send
     */
    Client.prototype.storeURL = function (url, storeParams, token, security, uploadTags, headers, workflowIds) {
        return store_1.storeURL({
            session: this.session,
            url: url,
            storeParams: storeParams,
            token: token,
            security: security,
            uploadTags: uploadTags,
            headers: headers,
            workflowIds: workflowIds,
        });
    };
    /**
     * Access files via their Filestack handles.
     *
     * If head option is provided - request headers are returned in promise
     * If metadata option is provided - metadata object is returned in promise
     * Otherwise file blob is returned
     * Metadata and head options cannot be mixed
     *
     * ### Example
     *
     * ```js
     * client.retrieve('fileHandle', {
     *  metadata: true,
     * }).then((response) => {
     *  console.log(response);
     * }).catch((err) => {
     *  console.error(err);
     * })
     * ```
     *
     * @see [File API - Download](https://www.filestack.com/docs/api/file#download)
     * @deprecated use metadata or download methods instead
     * @param handle    Valid file handle
     * @param options   RetrieveOptions
     * @param security  Optional security override.
     * @throws          Error
     */
    Client.prototype.retrieve = function (handle, options, security) {
        /* istanbul ignore next */
        return file_1.retrieve(this.session, handle, options, security);
    };
    /**
     * Download file by handle
     *
     *
     * ### Browser Example
     *
     * ```js
     * client.download('fileHandle').then((response) => {
     * const img = new Image();
     * img.src = URL.createObjectURL(res.data)
     * document.body.appendChild(img);
     * }).catch((err) => {
     *  console.error(err);
     * })
     * ```
     *
     * @see [File API - Download](https://www.filestack.com/docs/api/file#download)
     * @param handle    Valid file handle
     * @throws          Error
     */
    Client.prototype.download = function (handle, security) {
        /* istanbul ignore next */
        return file_1.download(this.session, handle, security);
    };
    /**
     * Interface to the Filestack [Processing API](https://www.filestack.com/docs/api/processing).
     * Convert a URL, handle, or storage alias to another URL which links to the transformed file.
     * You can optionally store the returned URL with client.storeURL.
     *
     * Transform params can be provided in camelCase or snakeCase style ie: partial_pixelate or partialPixelate
     *
     * ### Example
     *
     * ```js
     * const transformedUrl = client.transform(url, {
     *   crop: {
     *     dim: [x, y, width, height],
     *   },
     *   vignette: {
     *     blurmode: 'gaussian',
     *     amount: 50,
     *   },
     *   flip: true,
     *   partial_pixelate: {
     *     objects: [[10, 20, 200, 250], [275, 91, 500, 557]],
     *   },
     * };
     *
     * // optionally store the new URL
     * client.storeURL(transformedUrl).then(res => console.log(res));
     * ```
     * @see [Filestack Processing API](https://www.filestack.com/docs/api/processing)
     * @param url     Single or multiple valid URLs (http(s)://), file handles, or storage aliases (src://) to an image.
     * @param options Transformations are applied in the order specified by this object.
     * @param b64     Use new more safe format for generating transforms url (default=false) Note: If there will be any issues with url please test it with enabled b64 support
     * @returns       A new URL that points to the transformed resource.
     */
    Client.prototype.transform = function (url, options, b64) {
        if (b64 === void 0) { b64 = false; }
        /* istanbul ignore next */
        return transform_1.transform(this.session, url, options, b64);
    };
    /**
     * Initiates a multi-part upload flow. Use this for Filestack CIN and FII uploads.
     *
     * In Node runtimes the file argument is treated as a file path.
     * Uploading from a Node buffer is not yet implemented.
     *
     * ### Example
     *
     * ```js
     * const token = {};
     * const onRetry = (obj) => {
     *   console.log(`Retrying ${obj.location} for ${obj.filename}. Attempt ${obj.attempt} of 10.`);
     * };
     *
     * client.upload(file, { onRetry }, { filename: 'foobar.jpg' }, token)
     *   .then(res => console.log(res));
     *
     * client.upload({file, name}, { onRetry }, { filename: 'foobar.jpg' }, token)
     *   .then(res => console.log(res));
     *
     * token.pause();  // Pause flow
     * token.resume(); // Resume flow
     * token.cancel(); // Cancel flow (rejects)
     * ```
     * @param {InputFile}    file           Must be a valid [File | Blob | Buffer | string]
     * @param uploadOptions  Uploader options.
     * @param storeOptions   Storage options.
     * @param token          A control token that can be used to call cancel(), pause(), and resume().
     * @param security       Optional security policy and signature override.
     *
     * @returns {Promise}
     */
    Client.prototype.upload = function (file, options, storeOptions, token, security) {
        var _this = this;
        var upload = new upload_1.Upload(options, storeOptions);
        upload.setSession(this.session);
        if (token) {
            upload.setToken(token);
        }
        if (security) {
            upload.setSecurity(security);
        }
        upload.on('start', function () { return _this.emit('upload.start'); });
        /* istanbul ignore next */
        upload.on('error', function (e) {
            if (_this.forwardErrors) {
                Sentry.withScope(function (scope) {
                    scope.setTag('filestack-apikey', _this.session.apikey);
                    scope.setTag('filestack-version', Utils.getVersion());
                    scope.setExtra('filestack-options', _this.options);
                    scope.setExtras({ uploadOptions: options, storeOptions: storeOptions, details: e.details });
                    e.message = "FS-" + e.message;
                    Sentry.captureException(e);
                });
            }
            _this.emit('upload.error', e);
        });
        return upload.upload(file);
    };
    /**
     * Initiates a multi-part upload flow. Use this for Filestack CIN and FII uploads.
     *
     * In Node runtimes the file argument is treated as a file path.
     * Uploading from a Node buffer is not yet implemented.
     *
     * ### Example
     *
     * ```js
     * const token = {};
     * const onRetry = (obj) => {
     *   console.log(`Retrying ${obj.location} for ${obj.filename}. Attempt ${obj.attempt} of 10.`);
     * };
     *
     * client.multiupload([file], { onRetry }, token)
     *   .then(res => console.log(res));
     *
     * client.multiupload([{file, name}], { onRetry }, token)
     *   .then(res => console.log(res));
     *
     * token.pause();  // Pause flow
     * token.resume(); // Resume flow
     * token.cancel(); // Cancel flow (rejects)
     * ```
     * @param {InputFile[]}  file           Must be a valid [File | Blob | Buffer | string (base64)]
     * @param uploadOptions  Upload options.
     * @param storeOptions   Storage options.
     * @param token          A control token that can be used to call cancel(), pause(), and resume().
     * @param security       Optional security policy and signature override.
     *
     * @returns {Promise}
     */
    Client.prototype.multiupload = function (file, options, storeOptions, token, security) {
        var _this = this;
        var upload = new upload_1.Upload(options, storeOptions);
        upload.setSession(this.session);
        if (token) {
            upload.setToken(token);
        }
        if (security) {
            upload.setSecurity(security);
        }
        upload.on('start', function () { return _this.emit('upload.start'); });
        /* istanbul ignore next */
        upload.on('error', function (e) {
            Sentry.withScope(function (scope) {
                scope.setTag('filestack-apikey', _this.session.apikey);
                scope.setTag('filestack-version', Utils.getVersion());
                scope.setExtra('filestack-options', _this.options);
                scope.setExtras(e.details);
                scope.setExtras({ uploadOptions: options, storeOptions: storeOptions });
                Sentry.captureException(e);
            });
            _this.emit('upload.error', e);
        });
        return upload.multiupload(file);
    };
    return Client;
}(eventemitter3_1.EventEmitter));
exports.Client = Client;

//# sourceMappingURL=data:application/json;charset=utf8;base64,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LEtBQUssQ0FBQyxNQUFNLENBQUMsa0JBQWtCLEVBQUUsS0FBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDdEQsS0FBSyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQztnQkFDdEQsS0FBSyxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsRUFBRSxLQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ2xELEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUMzQixLQUFLLENBQUMsU0FBUyxDQUFDLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxZQUFZLGNBQUEsRUFBRSxDQUFDLENBQUM7Z0JBQzFELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM3QixDQUFDLENBQUMsQ0FBQztZQUVILEtBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQy9CLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFDSCxhQUFDO0FBQUQsQ0E5YkEsQUE4YkMsQ0E5YjJCLDRCQUFZLEdBOGJ2QztBQTliWSx3QkFBTSIsImZpbGUiOiJsaWIvY2xpZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2tcbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCAqIGFzIFNlbnRyeSBmcm9tICdAc2VudHJ5L21pbmltYWwnO1xuaW1wb3J0IHsgY29uZmlnLCBIb3N0cyB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgeyBGaWxlc3RhY2tFcnJvciB9IGZyb20gJy4vLi4vZmlsZXN0YWNrX2Vycm9yJztcbmltcG9ydCB7IG1ldGFkYXRhLCBNZXRhZGF0YU9wdGlvbnMsIHJlbW92ZSwgcmV0cmlldmUsIFJldHJpZXZlT3B0aW9ucywgZG93bmxvYWQgfSBmcm9tICcuL2FwaS9maWxlJztcbmltcG9ydCB7IHRyYW5zZm9ybSwgVHJhbnNmb3JtT3B0aW9ucyB9IGZyb20gJy4vYXBpL3RyYW5zZm9ybSc7XG5pbXBvcnQgeyBzdG9yZVVSTCB9IGZyb20gJy4vYXBpL3N0b3JlJztcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgVXBsb2FkLCBJbnB1dEZpbGUsIFVwbG9hZE9wdGlvbnMsIFN0b3JlVXBsb2FkT3B0aW9ucywgVXBsb2FkVGFncyB9IGZyb20gJy4vYXBpL3VwbG9hZCc7XG5pbXBvcnQgeyBwcmV2aWV3LCBQcmV2aWV3T3B0aW9ucyB9IGZyb20gJy4vYXBpL3ByZXZpZXcnO1xuaW1wb3J0IHsgQ2xvdWRDbGllbnQgfSBmcm9tICcuL2FwaS9jbG91ZCc7XG5pbXBvcnQgeyBQcmVmZXRjaCwgUHJlZmV0Y2hSZXNwb25zZSwgUHJlZmV0Y2hPcHRpb25zIH0gZnJvbSAnLi9hcGkvcHJlZmV0Y2gnO1xuaW1wb3J0IHsgRnNSZXNwb25zZSB9IGZyb20gJy4vcmVxdWVzdC90eXBlcyc7XG5pbXBvcnQgeyBTdG9yZVBhcmFtcyB9IGZyb20gJy4vZmlsZWxpbmsnO1xuXG5pbXBvcnQgeyBwaWNrZXIsIFBpY2tlckluc3RhbmNlLCBQaWNrZXJPcHRpb25zIH0gZnJvbSAnLi9waWNrZXInO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuU2VudHJ5LmFkZEJyZWFkY3J1bWIoeyBjYXRlZ29yeTogJ3NkaycsIG1lc3NhZ2U6ICdmaWxlc3RhY2stanMtc2RrIHNjb3BlJyB9KTtcblxuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uIHtcbiAgYXBpa2V5OiBzdHJpbmc7XG4gIHVybHM6IEhvc3RzO1xuICBjbmFtZT86IHN0cmluZztcbiAgcG9saWN5Pzogc3RyaW5nO1xuICBzaWduYXR1cmU/OiBzdHJpbmc7XG4gIHByZWZldGNoPzogUHJlZmV0Y2hSZXNwb25zZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWN1cml0eSB7XG4gIHBvbGljeTogc3RyaW5nO1xuICBzaWduYXR1cmU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDbGllbnRPcHRpb25zIHtcbiAgW29wdGlvbjogc3RyaW5nXTogYW55O1xuICAvKipcbiAgICogU2VjdXJpdHkgb2JqZWN0IHdpdGggcG9saWN5IGFuZCBzaWduYXR1cmUga2V5cy5cbiAgICogQ2FuIGJlIHVzZWQgdG8gbGltaXQgY2xpZW50IGNhcGFiaWxpdGllcyBhbmQgcHJvdGVjdCBwdWJsaWMgVVJMcy5cbiAgICogSXQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoIHNlcnZlci1zaWRlIHBvbGljeSBhbmQgc2lnbmF0dXJlIGdlbmVyYXRpb24uXG4gICAqIFJlYWQgYWJvdXQgW3NlY3VyaXR5IHBvbGljaWVzXShodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvY29uY2VwdHMvc2VjdXJpdHkpLlxuICAgKi9cbiAgc2VjdXJpdHk/OiBTZWN1cml0eTtcbiAgLyoqXG4gICAqIERvbWFpbiB0byB1c2UgZm9yIGFsbCBVUkxzLiBfX1JlcXVpcmVzIHRoZSBjdXN0b20gQ05BTUUgYWRkb25fXy5cbiAgICogSWYgdGhpcyBpcyBlbmFibGVkIHRoZW4geW91IG11c3QgYWxzbyBzZXQgdXAgeW91ciBvd24gT0F1dGggYXBwbGljYXRpb25zXG4gICAqIGZvciBlYWNoIGNsb3VkIHNvdXJjZSB5b3Ugd2lzaCB0byB1c2UgaW4gdGhlIHBpY2tlci5cbiAgICovXG4gIGNuYW1lPzogc3RyaW5nO1xuICAvKipcbiAgICogRW5hYmxlL2Rpc2FibGUgY2FjaGluZyBvZiB0aGUgY2xvdWQgc2Vzc2lvbiB0b2tlbi4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICogVGhpcyBlbnN1cmVzIHRoYXQgdXNlcnMgd2lsbCBiZSByZW1lbWJlcmVkIG9uIHlvdXIgZG9tYWluIHdoZW4gY2FsbGluZyB0aGUgY2xvdWQgQVBJIGZyb20gdGhlIGJyb3dzZXIuXG4gICAqIFBsZWFzZSBiZSBhd2FyZSB0aGF0IHRva2VucyBzdG9yZWQgaW4gbG9jYWxTdG9yYWdlIGFyZSBhY2Nlc3NpYmxlIGJ5IG90aGVyIHNjcmlwdHMgb24gdGhlIHNhbWUgZG9tYWluLlxuICAgKi9cbiAgc2Vzc2lvbkNhY2hlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRW5hYmxlIGZvcndhcmRpbmcgZXJyb3IgbG9ncyB0byBzZW50cnlcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGZvcndhcmRFcnJvcnM/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFRoZSBGaWxlc3RhY2sgY2xpZW50LCB0aGUgZW50cnkgcG9pbnQgZm9yIGFsbCBwdWJsaWMgbWV0aG9kcy4gRW5jYXBzdWxhdGVzIHNlc3Npb24gaW5mb3JtYXRpb24uXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYGpzXG4gKiAvLyBFUyBtb2R1bGVcbiAqIGltcG9ydCAqIGFzIGZpbGVzdGFjayBmcm9tICdmaWxlc3RhY2stanMnO1xuICogY29uc3QgY2xpZW50ID0gZmlsZXN0YWNrLmluaXQoJ2FwaWtleScpO1xuICogYGBgXG4gKlxuICogYGBganNcbiAqIC8vIFVNRCBtb2R1bGUgaW4gYnJvd3NlclxuICogPHNjcmlwdCBzcmM9XCJodHRwczovL3N0YXRpYy5maWxlc3RhY2thcGkuY29tL2ZpbGVzdGFjay1qcy8zLngueC9maWxlc3RhY2subWluLmpzXCI+PC9zY3JpcHQ+XG4gKiBjb25zdCBjbGllbnQgPSBmaWxlc3RhY2suaW5pdCgnYXBpa2V5Jyk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIENsaWVudCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHB1YmxpYyBzZXNzaW9uOiBTZXNzaW9uO1xuICBwcml2YXRlIGNsb3VkOiBDbG91ZENsaWVudDtcbiAgcHJpdmF0ZSBwcmVmZXRjaEluc3RhbmNlOiBQcmVmZXRjaDtcblxuICBwcml2YXRlIGZvcndhcmRFcnJvcnM6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbGVzdGFjayB1dGlsc1xuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQG1lbWJlcm9mIENsaWVudFxuICAgKi9cbiAgZ2V0IHV0aWxzKCkge1xuICAgIHJldHVybiBVdGlscztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFwaWtleTogc3RyaW5nLCBwcml2YXRlIG9wdGlvbnM/OiBDbGllbnRPcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZm9yd2FyZEVycm9ycykge1xuICAgICAgdGhpcy5mb3J3YXJkRXJyb3JzID0gb3B0aW9ucy5mb3J3YXJkRXJyb3JzO1xuICAgIH1cblxuICAgIGlmICghYXBpa2V5IHx8IHR5cGVvZiBhcGlrZXkgIT09ICdzdHJpbmcnIHx8IGFwaWtleS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gYXBpa2V5IGlzIHJlcXVpcmVkIHRvIGluaXRpYWxpemUgdGhlIEZpbGVzdGFjayBjbGllbnQnKTtcbiAgICB9XG4gICAgY29uc3QgeyB1cmxzIH0gPSBjb25maWc7XG4gICAgdGhpcy5zZXNzaW9uID0geyBhcGlrZXksIHVybHMgfTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjb25zdCB7IGNuYW1lLCBzZWN1cml0eSB9ID0gb3B0aW9ucztcblxuICAgICAgdGhpcy5zZXRTZWN1cml0eShzZWN1cml0eSk7XG4gICAgICB0aGlzLnNldENuYW1lKGNuYW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLnByZWZldGNoSW5zdGFuY2UgPSBuZXcgUHJlZmV0Y2godGhpcy5zZXNzaW9uKTtcbiAgICB0aGlzLmNsb3VkID0gbmV3IENsb3VkQ2xpZW50KHRoaXMuc2Vzc2lvbiwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBiYXNpYyBwcmVmZXRjaCByZXF1ZXN0IHRvIGNoZWNrIHBlcm1pc3Npb25zXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIHByZWZldGNoKHBhcmFtczogUHJlZmV0Y2hPcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZmV0Y2hJbnN0YW5jZS5nZXRDb25maWcocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgc2VjdXJpdHkgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7U2VjdXJpdHl9IHNlY3VyaXR5XG4gICAqIEBtZW1iZXJvZiBDbGllbnRcbiAgICovXG4gIHNldFNlY3VyaXR5KHNlY3VyaXR5OiBTZWN1cml0eSkge1xuICAgIGlmIChzZWN1cml0eSAmJiAhKHNlY3VyaXR5LnBvbGljeSAmJiBzZWN1cml0eS5zaWduYXR1cmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRmlsZXN0YWNrRXJyb3IoJ0JvdGggcG9saWN5IGFuZCBzaWduYXR1cmUgYXJlIHJlcXVpcmVkIGZvciBjbGllbnQgc2VjdXJpdHknKTtcbiAgICB9XG5cbiAgICBpZiAoc2VjdXJpdHkgJiYgc2VjdXJpdHkucG9saWN5ICYmIHNlY3VyaXR5LnNpZ25hdHVyZSkge1xuICAgICAgdGhpcy5zZXNzaW9uLnBvbGljeSA9IHNlY3VyaXR5LnBvbGljeTtcbiAgICAgIHRoaXMuc2Vzc2lvbi5zaWduYXR1cmUgPSBzZWN1cml0eS5zaWduYXR1cmU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjdXN0b20gY25hbWVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNuYW1lXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBDbGllbnRcbiAgICovXG4gIHNldENuYW1lKGNuYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAoIWNuYW1lIHx8IGNuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2Vzc2lvbi5jbmFtZSA9IGNuYW1lO1xuICAgIHRoaXMuc2Vzc2lvbi51cmxzID0gVXRpbHMucmVzb2x2ZUhvc3QodGhpcy5zZXNzaW9uLnVybHMsIGNuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgY3VycmVudCBjbG91ZCBzZXNzaW9ucyBpbiB0aGUgcGlja2VyLlxuICAgKiBPcHRpb25hbGx5IHBhc3MgYSBjbG91ZCBzb3VyY2UgbmFtZSB0byBvbmx5IGxvZyBvdXQgb2YgdGhhdCBjbG91ZCBzb3VyY2UuXG4gICAqIFRoaXMgZXNzZW50aWFsbHkgY2xlYXJzIHRoZSBPQXV0aCBhdXRob3JpemF0aW9uIGNvZGVzIGZyb20gdGhlIEZpbGVzdGFjayBzZXNzaW9uLlxuICAgKiBAcGFyYW0gbmFtZSBPcHRpb25hbCBjbG91ZCBzb3VyY2UgbmFtZS5cbiAgICovXG4gIGxvZ291dChuYW1lPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvdWQubG9nb3V0KG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBkZXRhaWxlZCBkYXRhIG9mIHN0b3JlZCBmaWxlcy5cbiAgICpcbiAgICogIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogY2xpZW50XG4gICAqICAgLm1ldGFkYXRhKCdEQ0w1SzQ2RlMzT0l4YjVpdUtieScpXG4gICAqICAgLnRoZW4oKHJlcykgPT4ge1xuICAgKiAgICAgY29uc29sZS5sb2cocmVzKTtcbiAgICogICB9KVxuICAgKiAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgKiAgIH0pKTtcbiAgICogYGBgXG4gICAqIEBzZWUgW0ZpbGUgQVBJIC0gTWV0YWRhdGFdKGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvZmlsZSNtZXRhZGF0YSkuXG4gICAqIEBwYXJhbSBoYW5kbGUgVmFsaWQgRmlsZXN0YWNrIGhhbmRsZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgTWV0YWRhdGEgZmllbGRzIHRvIGVuYWJsZSBvbiByZXNwb25zZS5cbiAgICogQHBhcmFtIHNlY3VyaXR5IE9wdGlvbmFsIHNlY3VyaXR5IG92ZXJyaWRlLlxuICAgKi9cbiAgbWV0YWRhdGEoaGFuZGxlOiBzdHJpbmcsIG9wdGlvbnM/OiBNZXRhZGF0YU9wdGlvbnMsIHNlY3VyaXR5PzogU2VjdXJpdHkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBtZXRhZGF0YSh0aGlzLnNlc3Npb24sIGhhbmRsZSwgb3B0aW9ucywgc2VjdXJpdHkpO1xuICB9XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgcGlja2VyIGluc3RhbmNlLlxuICAgKi9cbiAgcGlja2VyKG9wdGlvbnM/OiBQaWNrZXJPcHRpb25zKTogUGlja2VySW5zdGFuY2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHBpY2tlcih0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogVXNlZCBmb3Igdmlld2luZyBmaWxlcyB2aWEgRmlsZXN0YWNrIGhhbmRsZXMgb3Igc3RvcmFnZSBhbGlhc2VzLCBfX3JlcXVpcmVzIERvY3VtZW50IFZpZXdlciBhZGRvbiB0byB5b3VyIEZpbGVzdGFjayBhcHBsaWNhdGlvbl9fLlxuICAgKiBPcGVucyBkb2N1bWVudCB2aWV3ZXIgaW4gbmV3IHdpbmRvdyBpZiBpZCBvcHRpb24gaXMgbm90IHByb3ZpZGVkLlxuICAgKlxuICAgKiAjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyA8ZGl2IGlkPVwicHJldmlld1wiPjwvZGl2PlxuICAgKlxuICAgKiBjbGllbnQucHJldmlldygnRENMNUs0NkZTM09JeGI1aXVLYnknLCB7IGlkOiAncHJldmlldycgfSk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gaGFuZGxlIFZhbGlkIEZpbGVzdGFjayBoYW5kbGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIFByZXZpZXcgb3B0aW9uc1xuICAgKi9cbiAgcHJldmlldyhoYW5kbGU6IHN0cmluZywgb3B0aW9ucz86IFByZXZpZXdPcHRpb25zKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gcHJldmlldyh0aGlzLnNlc3Npb24sIGhhbmRsZSwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZpbGUgZnJvbSBzdG9yYWdlIGFuZCB0aGUgRmlsZXN0YWNrIHN5c3RlbS5cbiAgICpcbiAgICogX19SZXF1aXJlcyBhIHZhbGlkIHNlY3VyaXR5IHBvbGljeSBhbmQgc2lnbmF0dXJlX18uIFRoZSBwb2xpY3kgYW5kIHNpZ25hdHVyZSB3aWxsIGJlIHB1bGxlZCBmcm9tIHRoZSBjbGllbnQgc2Vzc2lvbiwgb3IgaXQgY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCB0aGUgc2VjdXJpdHkgcGFyYW1ldGVyLlxuICAgKlxuICAgKiAjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjbGllbnRcbiAgICogICAucmVtb3ZlKCdEQ0w1SzQ2RlMzT0l4YjVpdUtieScpXG4gICAqICAgLnRoZW4oKHJlcykgPT4ge1xuICAgKiAgICAgY29uc29sZS5sb2cocmVzKTtcbiAgICogICB9KVxuICAgKiAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgKiAgIH0pKTtcbiAgICogYGBgXG4gICAqIEBzZWUgW0ZpbGUgQVBJIC0gRGVsZXRlXShodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL2ZpbGUjZGVsZXRlKVxuICAgKiBAcGFyYW0gaGFuZGxlIFZhbGlkIEZpbGVzdGFjayBoYW5kbGUuXG4gICAqIEBwYXJhbSBzZWN1cml0eSBPcHRpb25hbCBzZWN1cml0eSBvdmVycmlkZS5cbiAgICovXG4gIHJlbW92ZShoYW5kbGU6IHN0cmluZywgc2VjdXJpdHk/OiBTZWN1cml0eSk6IFByb21pc2U8YW55PiB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gcmVtb3ZlKHRoaXMuc2Vzc2lvbiwgaGFuZGxlLCBmYWxzZSwgc2VjdXJpdHkpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmaWxlICoqb25seSoqIGZyb20gdGhlIEZpbGVzdGFjayBzeXN0ZW0uIFRoZSBmaWxlIHJlbWFpbnMgaW4gc3RvcmFnZS5cbiAgICpcbiAgICogX19SZXF1aXJlcyBhIHZhbGlkIHNlY3VyaXR5IHBvbGljeSBhbmQgc2lnbmF0dXJlX18uIFRoZSBwb2xpY3kgYW5kIHNpZ25hdHVyZSB3aWxsIGJlIHB1bGxlZCBmcm9tIHRoZSBjbGllbnQgc2Vzc2lvbiwgb3IgaXQgY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCB0aGUgc2VjdXJpdHkgcGFyYW1ldGVyLlxuICAgKlxuICAgKiAjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjbGllbnRcbiAgICogICAucmVtb3ZlTWV0YWRhdGEoJ0RDTDVLNDZGUzNPSXhiNWl1S2J5JylcbiAgICogICAudGhlbigocmVzKSA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZyhyZXMpO1xuICAgKiAgIH0pXG4gICAqICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAqICAgfSkpO1xuICAgKiBgYGBcbiAgICogQHNlZSBbRmlsZSBBUEkgLSBEZWxldGVdKGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvZmlsZSNkZWxldGUpXG4gICAqIEBwYXJhbSBoYW5kbGUgVmFsaWQgRmlsZXN0YWNrIGhhbmRsZS5cbiAgICogQHBhcmFtIHNlY3VyaXR5IE9wdGlvbmFsIHNlY3VyaXR5IG92ZXJyaWRlLlxuICAgKi9cbiAgcmVtb3ZlTWV0YWRhdGEoaGFuZGxlOiBzdHJpbmcsIHNlY3VyaXR5PzogU2VjdXJpdHkpOiBQcm9taXNlPGFueT4ge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHJlbW92ZSh0aGlzLnNlc3Npb24sIGhhbmRsZSwgdHJ1ZSwgc2VjdXJpdHkpO1xuICB9XG4gIC8qKlxuICAgKiBTdG9yZSBhIGZpbGUgZnJvbSBpdHMgVVJMLlxuICAgKlxuICAgKiAjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjbGllbnRcbiAgICogICAuc3RvcmVVUkwoJ2h0dHBzOi8vZDF3dHFhZmZhYWo2M3ouY2xvdWRmcm9udC5uZXQvaW1hZ2VzL05ZXzE5OV9FX29mX0hhbW1lcnRvd25fMjAxNC5qcGcnKVxuICAgKiAgIC50aGVuKHJlcyA9PiBjb25zb2xlLmxvZyhyZXMpKTtcbiAgICogYGBgXG4gICAqIEBzZWUgW0ZpbGUgQVBJIC0gU3RvcmVdKGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvZmlsZSNzdG9yZSlcbiAgICogQHBhcmFtIHVybCAgICAgICBWYWxpZCBVUkwgdG8gYSBmaWxlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAgIENvbmZpZ3VyZSBmaWxlIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB0b2tlbiAgICAgT3B0aW9uYWwgY29udHJvbCB0b2tlbiB0byBjYWxsIC5jYW5jZWwoKVxuICAgKiBAcGFyYW0gc2VjdXJpdHkgIE9wdGlvbmFsIHNlY3VyaXR5IG92ZXJyaWRlLlxuICAgKiBAcGFyYW0gdXBsb2FkVGFncyBPcHRpb25hbCB0YWdzIHZpc2libGUgaW4gd2ViaG9va3MuXG4gICAqIEBwYXJhbSBoZWFkZXJzICAgIE9wdGlvbmFsIGhlYWRlcnMgdG8gc2VuZFxuICAgKiBAcGFyYW0gd29ya2Zsb3dJZHMgICAgT3B0aW9uYWwgd29ya2Zsb3dJZHMgdG8gc2VuZFxuICAgKi9cbiAgc3RvcmVVUkwodXJsOiBzdHJpbmcsIHN0b3JlUGFyYW1zPzogU3RvcmVQYXJhbXMsIHRva2VuPzogYW55LCBzZWN1cml0eT86IFNlY3VyaXR5LCB1cGxvYWRUYWdzPzogVXBsb2FkVGFncywgaGVhZGVycz86IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9LCB3b3JrZmxvd0lkcz86IHN0cmluZ1tdKTogUHJvbWlzZTxPYmplY3Q+IHtcbiAgICByZXR1cm4gc3RvcmVVUkwoe1xuICAgICAgc2Vzc2lvbjogdGhpcy5zZXNzaW9uLFxuICAgICAgdXJsLFxuICAgICAgc3RvcmVQYXJhbXMsXG4gICAgICB0b2tlbixcbiAgICAgIHNlY3VyaXR5LFxuICAgICAgdXBsb2FkVGFncyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICB3b3JrZmxvd0lkcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2Nlc3MgZmlsZXMgdmlhIHRoZWlyIEZpbGVzdGFjayBoYW5kbGVzLlxuICAgKlxuICAgKiBJZiBoZWFkIG9wdGlvbiBpcyBwcm92aWRlZCAtIHJlcXVlc3QgaGVhZGVycyBhcmUgcmV0dXJuZWQgaW4gcHJvbWlzZVxuICAgKiBJZiBtZXRhZGF0YSBvcHRpb24gaXMgcHJvdmlkZWQgLSBtZXRhZGF0YSBvYmplY3QgaXMgcmV0dXJuZWQgaW4gcHJvbWlzZVxuICAgKiBPdGhlcndpc2UgZmlsZSBibG9iIGlzIHJldHVybmVkXG4gICAqIE1ldGFkYXRhIGFuZCBoZWFkIG9wdGlvbnMgY2Fubm90IGJlIG1peGVkXG4gICAqXG4gICAqICMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNsaWVudC5yZXRyaWV2ZSgnZmlsZUhhbmRsZScsIHtcbiAgICogIG1ldGFkYXRhOiB0cnVlLFxuICAgKiB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgKiAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgKiB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAqICBjb25zb2xlLmVycm9yKGVycik7XG4gICAqIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VlIFtGaWxlIEFQSSAtIERvd25sb2FkXShodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL2ZpbGUjZG93bmxvYWQpXG4gICAqIEBkZXByZWNhdGVkIHVzZSBtZXRhZGF0YSBvciBkb3dubG9hZCBtZXRob2RzIGluc3RlYWRcbiAgICogQHBhcmFtIGhhbmRsZSAgICBWYWxpZCBmaWxlIGhhbmRsZVxuICAgKiBAcGFyYW0gb3B0aW9ucyAgIFJldHJpZXZlT3B0aW9uc1xuICAgKiBAcGFyYW0gc2VjdXJpdHkgIE9wdGlvbmFsIHNlY3VyaXR5IG92ZXJyaWRlLlxuICAgKiBAdGhyb3dzICAgICAgICAgIEVycm9yXG4gICAqL1xuICByZXRyaWV2ZShoYW5kbGU6IHN0cmluZywgb3B0aW9ucz86IFJldHJpZXZlT3B0aW9ucywgc2VjdXJpdHk/OiBTZWN1cml0eSk6IFByb21pc2U8T2JqZWN0IHwgQmxvYj4ge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHJldHJpZXZlKHRoaXMuc2Vzc2lvbiwgaGFuZGxlLCBvcHRpb25zLCBzZWN1cml0eSk7XG4gIH1cblxuICAvKipcbiAgICogRG93bmxvYWQgZmlsZSBieSBoYW5kbGVcbiAgICpcbiAgICpcbiAgICogIyMjIEJyb3dzZXIgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjbGllbnQuZG93bmxvYWQoJ2ZpbGVIYW5kbGUnKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgKiBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICogaW1nLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwocmVzLmRhdGEpXG4gICAqIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICogfSkuY2F0Y2goKGVycikgPT4ge1xuICAgKiAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgKiB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogQHNlZSBbRmlsZSBBUEkgLSBEb3dubG9hZF0oaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9maWxlI2Rvd25sb2FkKVxuICAgKiBAcGFyYW0gaGFuZGxlICAgIFZhbGlkIGZpbGUgaGFuZGxlXG4gICAqIEB0aHJvd3MgICAgICAgICAgRXJyb3JcbiAgICovXG4gIGRvd25sb2FkKGhhbmRsZTogc3RyaW5nLCBzZWN1cml0eT86IFNlY3VyaXR5KTogUHJvbWlzZTxGc1Jlc3BvbnNlPiB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gZG93bmxvYWQodGhpcy5zZXNzaW9uLCBoYW5kbGUsIHNlY3VyaXR5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2UgdG8gdGhlIEZpbGVzdGFjayBbUHJvY2Vzc2luZyBBUEldKGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZykuXG4gICAqIENvbnZlcnQgYSBVUkwsIGhhbmRsZSwgb3Igc3RvcmFnZSBhbGlhcyB0byBhbm90aGVyIFVSTCB3aGljaCBsaW5rcyB0byB0aGUgdHJhbnNmb3JtZWQgZmlsZS5cbiAgICogWW91IGNhbiBvcHRpb25hbGx5IHN0b3JlIHRoZSByZXR1cm5lZCBVUkwgd2l0aCBjbGllbnQuc3RvcmVVUkwuXG4gICAqXG4gICAqIFRyYW5zZm9ybSBwYXJhbXMgY2FuIGJlIHByb3ZpZGVkIGluIGNhbWVsQ2FzZSBvciBzbmFrZUNhc2Ugc3R5bGUgaWU6IHBhcnRpYWxfcGl4ZWxhdGUgb3IgcGFydGlhbFBpeGVsYXRlXG4gICAqXG4gICAqICMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHRyYW5zZm9ybWVkVXJsID0gY2xpZW50LnRyYW5zZm9ybSh1cmwsIHtcbiAgICogICBjcm9wOiB7XG4gICAqICAgICBkaW06IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSxcbiAgICogICB9LFxuICAgKiAgIHZpZ25ldHRlOiB7XG4gICAqICAgICBibHVybW9kZTogJ2dhdXNzaWFuJyxcbiAgICogICAgIGFtb3VudDogNTAsXG4gICAqICAgfSxcbiAgICogICBmbGlwOiB0cnVlLFxuICAgKiAgIHBhcnRpYWxfcGl4ZWxhdGU6IHtcbiAgICogICAgIG9iamVjdHM6IFtbMTAsIDIwLCAyMDAsIDI1MF0sIFsyNzUsIDkxLCA1MDAsIDU1N11dLFxuICAgKiAgIH0sXG4gICAqIH07XG4gICAqXG4gICAqIC8vIG9wdGlvbmFsbHkgc3RvcmUgdGhlIG5ldyBVUkxcbiAgICogY2xpZW50LnN0b3JlVVJMKHRyYW5zZm9ybWVkVXJsKS50aGVuKHJlcyA9PiBjb25zb2xlLmxvZyhyZXMpKTtcbiAgICogYGBgXG4gICAqIEBzZWUgW0ZpbGVzdGFjayBQcm9jZXNzaW5nIEFQSV0oaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nKVxuICAgKiBAcGFyYW0gdXJsICAgICBTaW5nbGUgb3IgbXVsdGlwbGUgdmFsaWQgVVJMcyAoaHR0cChzKTovLyksIGZpbGUgaGFuZGxlcywgb3Igc3RvcmFnZSBhbGlhc2VzIChzcmM6Ly8pIHRvIGFuIGltYWdlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUcmFuc2Zvcm1hdGlvbnMgYXJlIGFwcGxpZWQgaW4gdGhlIG9yZGVyIHNwZWNpZmllZCBieSB0aGlzIG9iamVjdC5cbiAgICogQHBhcmFtIGI2NCAgICAgVXNlIG5ldyBtb3JlIHNhZmUgZm9ybWF0IGZvciBnZW5lcmF0aW5nIHRyYW5zZm9ybXMgdXJsIChkZWZhdWx0PWZhbHNlKSBOb3RlOiBJZiB0aGVyZSB3aWxsIGJlIGFueSBpc3N1ZXMgd2l0aCB1cmwgcGxlYXNlIHRlc3QgaXQgd2l0aCBlbmFibGVkIGI2NCBzdXBwb3J0XG4gICAqIEByZXR1cm5zICAgICAgIEEgbmV3IFVSTCB0aGF0IHBvaW50cyB0byB0aGUgdHJhbnNmb3JtZWQgcmVzb3VyY2UuXG4gICAqL1xuICB0cmFuc2Zvcm0odXJsOiBzdHJpbmcgfCBzdHJpbmdbXSwgb3B0aW9uczogVHJhbnNmb3JtT3B0aW9ucywgYjY0OiBib29sZWFuID0gZmFsc2UpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0cmFuc2Zvcm0odGhpcy5zZXNzaW9uLCB1cmwsIG9wdGlvbnMsIGI2NCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgbXVsdGktcGFydCB1cGxvYWQgZmxvdy4gVXNlIHRoaXMgZm9yIEZpbGVzdGFjayBDSU4gYW5kIEZJSSB1cGxvYWRzLlxuICAgKlxuICAgKiBJbiBOb2RlIHJ1bnRpbWVzIHRoZSBmaWxlIGFyZ3VtZW50IGlzIHRyZWF0ZWQgYXMgYSBmaWxlIHBhdGguXG4gICAqIFVwbG9hZGluZyBmcm9tIGEgTm9kZSBidWZmZXIgaXMgbm90IHlldCBpbXBsZW1lbnRlZC5cbiAgICpcbiAgICogIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgdG9rZW4gPSB7fTtcbiAgICogY29uc3Qgb25SZXRyeSA9IChvYmopID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhgUmV0cnlpbmcgJHtvYmoubG9jYXRpb259IGZvciAke29iai5maWxlbmFtZX0uIEF0dGVtcHQgJHtvYmouYXR0ZW1wdH0gb2YgMTAuYCk7XG4gICAqIH07XG4gICAqXG4gICAqIGNsaWVudC51cGxvYWQoZmlsZSwgeyBvblJldHJ5IH0sIHsgZmlsZW5hbWU6ICdmb29iYXIuanBnJyB9LCB0b2tlbilcbiAgICogICAudGhlbihyZXMgPT4gY29uc29sZS5sb2cocmVzKSk7XG4gICAqXG4gICAqIGNsaWVudC51cGxvYWQoe2ZpbGUsIG5hbWV9LCB7IG9uUmV0cnkgfSwgeyBmaWxlbmFtZTogJ2Zvb2Jhci5qcGcnIH0sIHRva2VuKVxuICAgKiAgIC50aGVuKHJlcyA9PiBjb25zb2xlLmxvZyhyZXMpKTtcbiAgICpcbiAgICogdG9rZW4ucGF1c2UoKTsgIC8vIFBhdXNlIGZsb3dcbiAgICogdG9rZW4ucmVzdW1lKCk7IC8vIFJlc3VtZSBmbG93XG4gICAqIHRva2VuLmNhbmNlbCgpOyAvLyBDYW5jZWwgZmxvdyAocmVqZWN0cylcbiAgICogYGBgXG4gICAqIEBwYXJhbSB7SW5wdXRGaWxlfSAgICBmaWxlICAgICAgICAgICBNdXN0IGJlIGEgdmFsaWQgW0ZpbGUgfCBCbG9iIHwgQnVmZmVyIHwgc3RyaW5nXVxuICAgKiBAcGFyYW0gdXBsb2FkT3B0aW9ucyAgVXBsb2FkZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHN0b3JlT3B0aW9ucyAgIFN0b3JhZ2Ugb3B0aW9ucy5cbiAgICogQHBhcmFtIHRva2VuICAgICAgICAgIEEgY29udHJvbCB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbGwgY2FuY2VsKCksIHBhdXNlKCksIGFuZCByZXN1bWUoKS5cbiAgICogQHBhcmFtIHNlY3VyaXR5ICAgICAgIE9wdGlvbmFsIHNlY3VyaXR5IHBvbGljeSBhbmQgc2lnbmF0dXJlIG92ZXJyaWRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIHVwbG9hZChmaWxlOiBJbnB1dEZpbGUsIG9wdGlvbnM/OiBVcGxvYWRPcHRpb25zLCBzdG9yZU9wdGlvbnM/OiBTdG9yZVVwbG9hZE9wdGlvbnMsIHRva2VuPzogYW55LCBzZWN1cml0eT86IFNlY3VyaXR5KSB7XG4gICAgbGV0IHVwbG9hZCA9IG5ldyBVcGxvYWQob3B0aW9ucywgc3RvcmVPcHRpb25zKTtcbiAgICB1cGxvYWQuc2V0U2Vzc2lvbih0aGlzLnNlc3Npb24pO1xuXG4gICAgaWYgKHRva2VuKSB7XG4gICAgICB1cGxvYWQuc2V0VG9rZW4odG9rZW4pO1xuICAgIH1cblxuICAgIGlmIChzZWN1cml0eSkge1xuICAgICAgdXBsb2FkLnNldFNlY3VyaXR5KHNlY3VyaXR5KTtcbiAgICB9XG5cbiAgICB1cGxvYWQub24oJ3N0YXJ0JywgKCkgPT4gdGhpcy5lbWl0KCd1cGxvYWQuc3RhcnQnKSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB1cGxvYWQub24oJ2Vycm9yJywgZSA9PiB7XG4gICAgICBpZiAodGhpcy5mb3J3YXJkRXJyb3JzKSB7XG4gICAgICAgIFNlbnRyeS53aXRoU2NvcGUoc2NvcGUgPT4ge1xuICAgICAgICAgIHNjb3BlLnNldFRhZygnZmlsZXN0YWNrLWFwaWtleScsIHRoaXMuc2Vzc2lvbi5hcGlrZXkpO1xuICAgICAgICAgIHNjb3BlLnNldFRhZygnZmlsZXN0YWNrLXZlcnNpb24nLCBVdGlscy5nZXRWZXJzaW9uKCkpO1xuICAgICAgICAgIHNjb3BlLnNldEV4dHJhKCdmaWxlc3RhY2stb3B0aW9ucycsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgc2NvcGUuc2V0RXh0cmFzKHsgdXBsb2FkT3B0aW9uczogb3B0aW9ucywgc3RvcmVPcHRpb25zLCBkZXRhaWxzOiBlLmRldGFpbHMgfSk7XG4gICAgICAgICAgZS5tZXNzYWdlID0gYEZTLSR7ZS5tZXNzYWdlfWA7XG5cbiAgICAgICAgICBTZW50cnkuY2FwdHVyZUV4Y2VwdGlvbihlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdCgndXBsb2FkLmVycm9yJywgZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXBsb2FkLnVwbG9hZChmaWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgYSBtdWx0aS1wYXJ0IHVwbG9hZCBmbG93LiBVc2UgdGhpcyBmb3IgRmlsZXN0YWNrIENJTiBhbmQgRklJIHVwbG9hZHMuXG4gICAqXG4gICAqIEluIE5vZGUgcnVudGltZXMgdGhlIGZpbGUgYXJndW1lbnQgaXMgdHJlYXRlZCBhcyBhIGZpbGUgcGF0aC5cbiAgICogVXBsb2FkaW5nIGZyb20gYSBOb2RlIGJ1ZmZlciBpcyBub3QgeWV0IGltcGxlbWVudGVkLlxuICAgKlxuICAgKiAjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCB0b2tlbiA9IHt9O1xuICAgKiBjb25zdCBvblJldHJ5ID0gKG9iaikgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKGBSZXRyeWluZyAke29iai5sb2NhdGlvbn0gZm9yICR7b2JqLmZpbGVuYW1lfS4gQXR0ZW1wdCAke29iai5hdHRlbXB0fSBvZiAxMC5gKTtcbiAgICogfTtcbiAgICpcbiAgICogY2xpZW50Lm11bHRpdXBsb2FkKFtmaWxlXSwgeyBvblJldHJ5IH0sIHRva2VuKVxuICAgKiAgIC50aGVuKHJlcyA9PiBjb25zb2xlLmxvZyhyZXMpKTtcbiAgICpcbiAgICogY2xpZW50Lm11bHRpdXBsb2FkKFt7ZmlsZSwgbmFtZX1dLCB7IG9uUmV0cnkgfSwgdG9rZW4pXG4gICAqICAgLnRoZW4ocmVzID0+IGNvbnNvbGUubG9nKHJlcykpO1xuICAgKlxuICAgKiB0b2tlbi5wYXVzZSgpOyAgLy8gUGF1c2UgZmxvd1xuICAgKiB0b2tlbi5yZXN1bWUoKTsgLy8gUmVzdW1lIGZsb3dcbiAgICogdG9rZW4uY2FuY2VsKCk7IC8vIENhbmNlbCBmbG93IChyZWplY3RzKVxuICAgKiBgYGBcbiAgICogQHBhcmFtIHtJbnB1dEZpbGVbXX0gIGZpbGUgICAgICAgICAgIE11c3QgYmUgYSB2YWxpZCBbRmlsZSB8IEJsb2IgfCBCdWZmZXIgfCBzdHJpbmcgKGJhc2U2NCldXG4gICAqIEBwYXJhbSB1cGxvYWRPcHRpb25zICBVcGxvYWQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHN0b3JlT3B0aW9ucyAgIFN0b3JhZ2Ugb3B0aW9ucy5cbiAgICogQHBhcmFtIHRva2VuICAgICAgICAgIEEgY29udHJvbCB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbGwgY2FuY2VsKCksIHBhdXNlKCksIGFuZCByZXN1bWUoKS5cbiAgICogQHBhcmFtIHNlY3VyaXR5ICAgICAgIE9wdGlvbmFsIHNlY3VyaXR5IHBvbGljeSBhbmQgc2lnbmF0dXJlIG92ZXJyaWRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIG11bHRpdXBsb2FkKGZpbGU6IElucHV0RmlsZVtdLCBvcHRpb25zPzogVXBsb2FkT3B0aW9ucywgc3RvcmVPcHRpb25zPzogU3RvcmVVcGxvYWRPcHRpb25zLCB0b2tlbj86IGFueSwgc2VjdXJpdHk/OiBTZWN1cml0eSkge1xuICAgIGxldCB1cGxvYWQgPSBuZXcgVXBsb2FkKG9wdGlvbnMsIHN0b3JlT3B0aW9ucyk7XG5cbiAgICB1cGxvYWQuc2V0U2Vzc2lvbih0aGlzLnNlc3Npb24pO1xuXG4gICAgaWYgKHRva2VuKSB7XG4gICAgICB1cGxvYWQuc2V0VG9rZW4odG9rZW4pO1xuICAgIH1cblxuICAgIGlmIChzZWN1cml0eSkge1xuICAgICAgdXBsb2FkLnNldFNlY3VyaXR5KHNlY3VyaXR5KTtcbiAgICB9XG5cbiAgICB1cGxvYWQub24oJ3N0YXJ0JywgKCkgPT4gdGhpcy5lbWl0KCd1cGxvYWQuc3RhcnQnKSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB1cGxvYWQub24oJ2Vycm9yJywgZSA9PiB7XG4gICAgICBTZW50cnkud2l0aFNjb3BlKHNjb3BlID0+IHtcbiAgICAgICAgc2NvcGUuc2V0VGFnKCdmaWxlc3RhY2stYXBpa2V5JywgdGhpcy5zZXNzaW9uLmFwaWtleSk7XG4gICAgICAgIHNjb3BlLnNldFRhZygnZmlsZXN0YWNrLXZlcnNpb24nLCBVdGlscy5nZXRWZXJzaW9uKCkpO1xuICAgICAgICBzY29wZS5zZXRFeHRyYSgnZmlsZXN0YWNrLW9wdGlvbnMnLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBzY29wZS5zZXRFeHRyYXMoZS5kZXRhaWxzKTtcbiAgICAgICAgc2NvcGUuc2V0RXh0cmFzKHsgdXBsb2FkT3B0aW9uczogb3B0aW9ucywgc3RvcmVPcHRpb25zIH0pO1xuICAgICAgICBTZW50cnkuY2FwdHVyZUV4Y2VwdGlvbihlKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmVtaXQoJ3VwbG9hZC5lcnJvcicsIGUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHVwbG9hZC5tdWx0aXVwbG9hZChmaWxlKTtcbiAgfVxufVxuIl19


/***/ }),

/***/ 4915:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var config_1 = __nccwpck_require__(9670);
var transforms_schema_1 = __nccwpck_require__(5037);
var validator_1 = __nccwpck_require__(2596);
var utils_1 = __nccwpck_require__(8123);
var filestack_error_1 = __nccwpck_require__(4257);
var debug_1 = __nccwpck_require__(8237);
var debug = debug_1.default('fs:filelink');
var Align;
(function (Align) {
    Align["left"] = "left";
    Align["right"] = "right";
    Align["center"] = "center";
    Align["bottom"] = "bottom";
    Align["top"] = "top";
    Align["faces"] = "faces";
    Align["middle"] = "middle";
})(Align = exports.Align || (exports.Align = {}));
/**
 * Fit enum
 */
var FitOptions;
(function (FitOptions) {
    FitOptions["clip"] = "clip";
    FitOptions["crop"] = "crop";
    FitOptions["scale"] = "scale";
    FitOptions["max"] = "max";
})(FitOptions = exports.FitOptions || (exports.FitOptions = {}));
/**
 * Blur enum
 */
var BlurMode;
(function (BlurMode) {
    BlurMode["linear"] = "linear";
    BlurMode["gaussian"] = "gaussian";
})(BlurMode = exports.BlurMode || (exports.BlurMode = {}));
/**
 * Shapes enum
 */
var ShapeType;
(function (ShapeType) {
    ShapeType["oval"] = "oval";
    ShapeType["rect"] = "rect";
})(ShapeType = exports.ShapeType || (exports.ShapeType = {}));
/**
 * Noise type enum
 */
var NoiseType;
(function (NoiseType) {
    NoiseType["none"] = "none";
    NoiseType["low"] = "low";
    NoiseType["medium"] = "medium";
    NoiseType["high"] = "high";
})(NoiseType = exports.NoiseType || (exports.NoiseType = {}));
/**
 * Style type enum
 */
var StyleType;
(function (StyleType) {
    StyleType["artwork"] = "artwork";
    StyleType["photo"] = "photo";
})(StyleType = exports.StyleType || (exports.StyleType = {}));
/**
 * Color space enum
 */
var ColorspaceType;
(function (ColorspaceType) {
    ColorspaceType["RGB"] = "RGB";
    ColorspaceType["CMYK"] = "CMYK";
    ColorspaceType["Input"] = "Input";
})(ColorspaceType = exports.ColorspaceType || (exports.ColorspaceType = {}));
/**
 * Crop faces options enum
 */
var CropfacesType;
(function (CropfacesType) {
    CropfacesType["thumb"] = "thumb";
    CropfacesType["crop"] = "crop";
    CropfacesType["fill"] = "fill";
})(CropfacesType = exports.CropfacesType || (exports.CropfacesType = {}));
/**
 * Watermark postion options enum
 */
var ImageWatermarkPosition;
(function (ImageWatermarkPosition) {
    ImageWatermarkPosition["top"] = "top";
    ImageWatermarkPosition["middle"] = "middle";
    ImageWatermarkPosition["bottom"] = "bottom";
    ImageWatermarkPosition["left"] = "left";
    ImageWatermarkPosition["center"] = "center";
    ImageWatermarkPosition["right"] = "right";
})(ImageWatermarkPosition = exports.ImageWatermarkPosition || (exports.ImageWatermarkPosition = {}));
/**
 * SmartCrop options enum
 */
var SmartCropMode;
(function (SmartCropMode) {
    SmartCropMode["face"] = "face";
    SmartCropMode["auto"] = "auto";
})(SmartCropMode = exports.SmartCropMode || (exports.SmartCropMode = {}));
/**
 * Convert to format
 */
var VideoTypes;
(function (VideoTypes) {
    VideoTypes["h264"] = "h264";
    VideoTypes["h264_hi"] = "h264.hi";
    VideoTypes["webm"] = "webm";
    VideoTypes["webm-hi"] = "webm.hi";
    VideoTypes["ogg"] = "ogg";
    VideoTypes["ogg-hi"] = "ogg.hi";
    VideoTypes["hls-variant"] = "hls.variant";
    VideoTypes["mp3"] = "mp3";
    VideoTypes["oga"] = "oga";
    VideoTypes["m4a"] = "m4a";
    VideoTypes["aac"] = "aac";
    VideoTypes["hls"] = "hls.variant.audio";
})(VideoTypes = exports.VideoTypes || (exports.VideoTypes = {}));
var URLScreenshotAgent;
(function (URLScreenshotAgent) {
    URLScreenshotAgent["desktop"] = "desktop";
    URLScreenshotAgent["mobile"] = "mobile";
})(URLScreenshotAgent = exports.URLScreenshotAgent || (exports.URLScreenshotAgent = {}));
var URLScreenshotMode;
(function (URLScreenshotMode) {
    URLScreenshotMode["all"] = "all";
    URLScreenshotMode["window"] = "window";
})(URLScreenshotMode = exports.URLScreenshotMode || (exports.URLScreenshotMode = {}));
var URLScreenshotOrientation;
(function (URLScreenshotOrientation) {
    URLScreenshotOrientation["portrait"] = "portrait";
    URLScreenshotOrientation["landscape"] = "landscape";
})(URLScreenshotOrientation = exports.URLScreenshotOrientation || (exports.URLScreenshotOrientation = {}));
/**
 * Video storage location
 */
var Locations;
(function (Locations) {
    Locations["s3"] = "s3";
    Locations["azure"] = "azure";
    Locations["gcs"] = "gcs";
    Locations["rackspace"] = "rackspace";
    Locations["dropbox"] = "dropbox";
})(Locations = exports.Locations || (exports.Locations = {}));
var VideoAccess;
(function (VideoAccess) {
    VideoAccess["private"] = "private";
    VideoAccess["public"] = "public";
})(VideoAccess = exports.VideoAccess || (exports.VideoAccess = {}));
var VideoAccessMode;
(function (VideoAccessMode) {
    VideoAccessMode["preserve"] = "preserve";
    VideoAccessMode["constrain"] = "constrain";
    VideoAccessMode["letterbox"] = "letterbox";
    VideoAccessMode["pad"] = "pad";
    VideoAccessMode["crop"] = "crop";
})(VideoAccessMode = exports.VideoAccessMode || (exports.VideoAccessMode = {}));
var EnhancePreset;
(function (EnhancePreset) {
    EnhancePreset["auto"] = "auto";
    EnhancePreset["vivid"] = "vivid";
    EnhancePreset["beautify"] = "beautify";
    EnhancePreset["beautifyPlus"] = "beautify_plus";
    EnhancePreset["fixDark"] = "fix_dark";
    EnhancePreset["fixNoise"] = "fix_noise";
    EnhancePreset["fixTint"] = "fix_tint";
    EnhancePreset["outdor"] = "outdoor";
    EnhancePreset["fireworks"] = "fireworks";
})(EnhancePreset = exports.EnhancePreset || (exports.EnhancePreset = {}));
var handleRegexp = /^[\w\-]{20}|wf:\/\/[\w\-\/]{106}$/;
/**
 * Class for handling filelinks. For now its supports all filestack transforms.
 * It outputs transform url or array of transforms
 * @example
 * const link = new Filelink('handle or externalUrl', 'apikey');
 * link.flip().flop().store();
 *
 * console.log(link.toString());
 * // enable base64 support
 * link.setBase64(true)
 *
 * console.log(link.toString());
 *
 * @export
 * @class Filelink
 */
var Filelink = /** @class */ (function () {
    /**
     * Class for generating tranformation urls
     * @param {(string | string[])} source - handle or multiple handles (i.e. for collage)
     * @param {string} [apikey] - your apikey - required for all external sources
     *
     * @memberof Filelink
     */
    function Filelink(source, apikey) {
        /**
         * Applied transforms array
         *
         * @private
         * @memberof Filelink
         */
        this.transforms = [];
        /**
         * Is base64 support is enabled
         *
         * @private
         * @type {boolean}
         * @memberof Filelink
         */
        this.b64 = false;
        /**
         * should use a validator to check params of every task
         * @private
         * @type {boolean}
         * @memberof Filelink
         */
        this.useValidator = true;
        /**
         * Converts array of objects to object
         *
         * @private
         * @example [{name: 'resize', params: {height: 125}}] => {resize: {height: 125}}
         * @param arr - any array
         */
        this.arrayToObject = function (array, nameKey, dataKey) {
            if (array === void 0) { array = []; }
            return array.reduce(function (obj, item) {
                obj[item[nameKey]] = item[dataKey];
                return obj;
            }, {});
        };
        this.apikey = apikey;
        this.setSource(source);
    }
    /**
     * Enable new base64 link support to avoid problems with special chars in link
     *
     * @param {boolean} flag
     * @returns
     * @memberof Filelink
     */
    Filelink.prototype.setBase64 = function (flag) {
        this.b64 = flag;
        return this;
    };
    /**
     * Switch the useValidator flag
     *
     * @param {boolean} flag
     * @returns
     * @memberof Filelink
     */
    Filelink.prototype.setUseValidator = function (flag) {
        this.useValidator = flag;
        return this;
    };
    /**
     * Set cname for transformation link
     *
     * @param {string} cname
     * @returns
     * @memberof Filelink
     */
    Filelink.prototype.setCname = function (cname) {
        this.cname = cname;
        return this;
    };
    /**
     * Set custom domain. Used for test purpose. It will be removed when after client.transform
     *
     * @param {string} domain
     * @returns
     * @memberof Filelink
     */
    Filelink.prototype.setCustomDomain = function (domain) {
        this.customDomain = domain;
        return this;
    };
    Filelink.prototype.setSource = function (source) {
        this.source = source;
        var isExternal = this.isSourceExternal();
        debug("Source " + source + " - isExternal? " + isExternal);
        if (isExternal && !this.apikey) {
            throw new filestack_error_1.FilestackError('External sources requires apikey to handle transforms');
        }
        if (!isExternal && typeof this.source === 'string' && !handleRegexp.test(this.source) && this.source.indexOf('filestackcontent') === -1) {
            throw new filestack_error_1.FilestackError('Invalid filestack source provided');
        }
    };
    /**
     * Returns JSONSchema form transformations params
     *
     * @returns
     * @memberof Filelink
     */
    Filelink.prototype.getValidationSchema = function () {
        return transforms_schema_1.TransformSchema;
    };
    /**
     * Returns transformations in JSON format
     *
     * @returns
     * @memberof Filelink
     */
    Filelink.prototype.getTransformations = function () {
        if (this.useValidator) {
            this.validateTasks(this.transforms);
        }
        return this.transforms;
    };
    /**
     * Returns transform url
     *
     * @returns
     * @memberof Filelink
     */
    Filelink.prototype.toString = function () {
        var returnUrl = [];
        returnUrl.push(this.getCdnHost());
        if (this.useValidator) {
            this.validateTasks(this.transforms);
        }
        if (this.apikey) {
            returnUrl.push(this.apikey);
        }
        var transformsString = this.generateTransformString();
        var source = this.source;
        if (this.b64) {
            if (this.transforms.length > 0) {
                transformsString = "b64/" + utils_1.b64(JSON.stringify(this.transforms), true);
            }
            if (Array.isArray(source)) {
                source = this.arrayToString(source);
            }
            source = "b64://" + utils_1.b64(source, true);
        }
        else {
            if (Array.isArray(source)) {
                source = this.arrayToString(source);
            }
            else {
                source = this.escapeValue(source);
            }
        }
        if (transformsString.length) {
            returnUrl.push(transformsString);
        }
        returnUrl.push(source);
        return returnUrl.join('/');
    };
    /**
     * Add task and validate
     *
     * @param {string} name
     * @param {*} [params]
     * @returns
     * @memberof Filelink
     */
    Filelink.prototype.addTask = function (name, params) {
        debug_1.default("Add task  " + name + " with params %O", params);
        if (name !== 'cache' && typeof params === 'boolean') {
            if (!params) {
                return this;
            }
            else {
                params = undefined;
            }
        }
        else if (typeof params === 'object' && !Object.keys(params).length) {
            params = undefined;
        }
        this.transforms.push({ name: name, params: params });
        return this;
    };
    /**
     * Returns all tasks added for transformation
     *
     * @memberof Filelink
     */
    Filelink.prototype.getTasks = function () {
        return this.transforms;
    };
    /**
     * Cleanup transformations on filelink
     *
     * @returns
     * @memberof Filelink
     */
    Filelink.prototype.reset = function () {
        this.transforms = [];
        return this;
    };
    /**
     * Transformations part
     */
    /**
     * Add autoimage transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#auto-image-conversion
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.autoImage = function () {
        return this.addTask('auto_image', true);
    };
    /**
     * Adds flip transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#flip
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.flip = function () {
        return this.addTask('flip', true);
    };
    /**
     * Adds flop transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#flop
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.flop = function () {
        return this.addTask('flop', true);
    };
    /**
     * Adds imagesize transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#image-size
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.imagesize = function () {
        return this.addTask('imagesize', true);
    };
    /**
     * Adds noMetadata transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#strip-metadata
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.noMetadata = function () {
        return this.addTask('no_metadata', true);
    };
    /**
     * Adds Progressive JPEG transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#progressive-jpeg
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.pjpg = function (params) {
        return this.addTask('pjpg', params);
    };
    /**
     * Adds imagesize transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#smart-crop
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.smartCrop = function (params) {
        return this.addTask('smart_crop', params);
    };
    /**
     * Adds watermart transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#watermark
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.watermark = function (params) {
        return this.addTask('watermark', params);
    };
    /**
     * Adds enhance transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#enhance
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.enhance = function (params) {
        return this.addTask('enhance', params || true);
    };
    /**
     * Add security to link
     *
     * @see https://www.filestack.com/docs/api/processing/#redeye
     * @returns
     * @memberof Filelink
     */
    Filelink.prototype.redeye = function () {
        return this.addTask('redeye', true);
    };
    /**
     * Add monochrome transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#monochrome
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.monochrome = function () {
        return this.addTask('monochrome', true);
    };
    /**
     * Add compress transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#compress
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.compress = function (params) {
        return this.addTask('compress', params || true);
    };
    /**
     * Adds negative transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#negative
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.negative = function () {
        return this.addTask('negative', true);
    };
    /**
     * Adds tags transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#tags
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.tags = function () {
        return this.addTask('tags', true);
    };
    /**
     * Adds sfw transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#sfw
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.sfw = function () {
        return this.addTask('sfw', true);
    };
    /**
     * Add animate transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#animate-images-to-gif
     * @param params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.animate = function (params) {
        return this.addTask('animate', params);
    };
    /**
     * Adds store transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#store
     * @param {(StoreParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.store = function (params) {
        return this.addTask('store', params);
    };
    /**
     * Adds cache transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#cache
     * @param {(CacheParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.cache = function (params) {
        return this.addTask('cache', params);
    };
    /**
     * Adds resize transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#resize
     * @param {ResizeParams} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.resize = function (params) {
        return this.addTask('resize', params);
    };
    /**
     * Adds crop transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#crop
     * @param {CropParams} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.crop = function (params) {
        return this.addTask('crop', params);
    };
    /**
     * Adds rotate transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#rotate
     * @param {RotateParams} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.rotate = function (params) {
        return this.addTask('rotate', params);
    };
    /**
     * Adds detect_faces transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#facial-detection
     * @param {(DetectFacesParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.detectFaces = function (params) {
        return this.addTask('detect_faces', params);
    };
    /**
     * Adds crop faces transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#crop-faces
     * @param {CropFacesParams} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.cropFaces = function (params) {
        return this.addTask('crop_faces', params);
    };
    /**
     * Adds pixelate faces transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#pixelate-faces
     * @param {PixelateFacesParams} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.pixelateFaces = function (params) {
        return this.addTask('pixelate_faces', params);
    };
    /**
     * Adds blur faces transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#blur-faces
     * @param {BlurFacesParams} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.blurFaces = function (params) {
        return this.addTask('blur_faces', params);
    };
    /**
     * Adds rounded corners transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#rounded-corners
     * @param {(RoundedCornersParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.roundedCorners = function (params) {
        return this.addTask('rounded_corners', params);
    };
    /**
     * Adds polaroid transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#polaroid
     * @param {(PolaroidParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.polaroid = function (params) {
        return this.addTask('polaroid', params);
    };
    /**
     * Adds vignette transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#vignette
     * @param {(VignetteParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.vignette = function (params) {
        return this.addTask('vignette', params);
    };
    /**
     * Adds torn edges transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#torn-edges
     * @param {(TornEdgesParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.tornEdges = function (params) {
        return this.addTask('torn_edges', params);
    };
    /**
     * Adds shadow transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#shadow
     * @param {(ShadowParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.shadow = function (params) {
        return this.addTask('shadow', params);
    };
    /**
     * Adds circle transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#circle
     * @param {(CircleParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.circle = function (params) {
        return this.addTask('circle', params);
    };
    /**
     * Adds border transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#border
     * @param {(BorderParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.border = function (params) {
        return this.addTask('border', params);
    };
    /**
     * Adds sharpen transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#sharpen
     * @param {(SharpenParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.sharpen = function (params) {
        return this.addTask('sharpen', params);
    };
    /**
     * Adds blur transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#blur
     * @param {(BlurParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.blur = function (params) {
        return this.addTask('blur', params);
    };
    /**
     * Adds blackwhite transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#blackwhite
     * @param {(BlackwhiteParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.blackwhite = function (params) {
        return this.addTask('blackwhite', params);
    };
    /**
     * Adds sepia transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#sepia
     * @param {(SepiaParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.sepia = function (params) {
        return this.addTask('sepia', params);
    };
    /**
     * Adds pixelate transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#pixelate
     * @param {(PixelateParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.pixelate = function (params) {
        return this.addTask('pixelate', params);
    };
    /**
     * Adds oilpaint transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#oil-paint
     * @param {(OilPaintParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.oilPaint = function (params) {
        return this.addTask('oil_paint', params);
    };
    /**
     * Adds modulate transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#modulate
     * @param {(ModulateParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.modulate = function (params) {
        return this.addTask('modulate', params);
    };
    /**
     * Adds partial pixelate transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#partial-pixelate
     * @param {PartialPixelateParams} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.partialPixelate = function (params) {
        return this.addTask('partial_pixelate', params);
    };
    /**
     * Adds partial blur transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#partial-blur
     * @param {PartialBlurParams} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.partialBlur = function (params) {
        return this.addTask('partial_blur', params);
    };
    /**
     * Adds collage transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#collage
     * @param {CollageParams} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.collage = function (params) {
        return this.addTask('collage', params);
    };
    /**
     * Adds upscale transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#upscale
     * @param {(UpscaleParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.upscale = function (params) {
        return this.addTask('upscale', params);
    };
    /**
     * Adds ascii transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#ascii
     * @param {(AsciiParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.ascii = function (params) {
        return this.addTask('ascii', params);
    };
    /**
     * Adds quality transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#quality
     * @param {QualityParams} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.quality = function (params) {
        return this.addTask('quality', params);
    };
    /**
     * Adds security transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#security
     * @param {SecurityParams} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.security = function (params) {
        return this.addTask('security', params);
    };
    /**
     * Adds output transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#output
     * @param {OutputParams} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.output = function (params) {
        return this.addTask('output', params);
    };
    /**
     * Adds video convert transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#video-convert
     * @param {VideoConvertParams} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.videoConvert = function (params) {
        return this.addTask('video_convert', params);
    };
    /**
     * Adds URLScreenshot transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#urlscreenshot
     * @param {(URLScreenshotParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.URLScreenshot = function (params) {
        return this.addTask('urlscreenshot', params);
    };
    /**
     * Adds pdfinfo transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#pdfinfo
     * @param {(PdfInfoParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.PDFInfo = function (params) {
        return this.addTask('pdfinfo', params);
    };
    /**
     * Adds pdfconvert transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#pdfconvert
     * @param {(PdfConvertParams | boolean)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.PDFConvert = function (params) {
        return this.addTask('pdfconvert', params);
    };
    /**
     * Adds fallback transformation
     *
     * @see https://www.filestack.com/docs/api/processing/#fallback
     * @param {(FallbackParams)} params
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.fallback = function (params) {
        return this.addTask('fallback', params);
    };
    /**
     * Add zip transformation which create a zip package on files
     * used on actual context
     *
     * @see https://www.filestack.com/docs/api/processing/#zip
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.zip = function () {
        return this.addTask('zip', true);
    };
    /**
     * Add task which minify a css file
     *
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.minifyCss = function (params) {
        return this.addTask('minify_css', params);
    };
    /**
     * Add task which minify a javascript file.
     * For better handling of 'targets' param, use with b64 flag enabled.
     *
     * @returns this
     * @memberof Filelink
     */
    Filelink.prototype.minifyJs = function (params) {
        return this.addTask('minify_js', params);
    };
    /**
     * Checks if source is external
     *
     * @private
     * @returns {boolean}
     * @memberof Filelink
     */
    Filelink.prototype.isSourceExternal = function () {
        if (!this.source) {
            throw new filestack_error_1.FilestackError('Source not Set');
        }
        var toTest = Array.isArray(this.source) ? this.source : [this.source];
        for (var i in toTest) {
            /* istanbul ignore next */
            if (!toTest.hasOwnProperty(i)) {
                continue;
            }
            if (toTest[i].indexOf('src:') === 0 || (toTest[i].indexOf('http') === 0 && toTest[i].indexOf('filestackcontent') === -1)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Validate every task against schema
     *
     * @private
     * @param {object[]} transformations - object which contain all transformations
     * @returns {void}
     * @memberof Filelink
     */
    Filelink.prototype.validateTasks = function (transformations) {
        var res = Filelink.validator(this.arrayToObject(transformations, 'name', 'params'));
        if (res.errors.length) {
            throw new filestack_error_1.FilestackError("Params validation error", res.errors, filestack_error_1.FilestackErrorType.VALIDATION);
        }
        return;
    };
    /**
     * Returns correct cdn url with cname support
     *
     * @private
     * @returns {string}
     * @memberof Filelink
     */
    Filelink.prototype.getCdnHost = function () {
        var urls = Object.assign({}, config_1.config.urls);
        if (this.customDomain) {
            urls.cdnUrl = this.customDomain;
        }
        urls = utils_1.resolveHost(urls, this.cname);
        return urls.cdnUrl;
    };
    /**
     * Returns applied transformations as string
     *
     * @private
     * @returns {string}
     * @memberof Filelink
     */
    Filelink.prototype.generateTransformString = function () {
        var _this = this;
        var transforms = [];
        this.transforms.forEach(function (el) {
            transforms.push(_this.optionToString(el.name, el.params));
        });
        return transforms.join('/');
    };
    /**
     * Flatten transformation option to string
     *
     * @private
     * @example {resize:{width: 100,height: 200}} => resize=width:100,height:200
     * @param key - option key
     * @param values - option params
     */
    Filelink.prototype.optionToString = function (key, values) {
        var _this = this;
        var optionsString = [];
        if (typeof values === 'undefined') {
            return key;
        }
        // if we just want to enable feature
        if (typeof values === 'boolean') {
            if (!values && key === 'cache') {
                return 'cache=false';
            }
            return key;
        }
        Object.keys(values).forEach(function (i) {
            if (Array.isArray(values[i])) {
                optionsString.push(i + ":" + _this.arrayToString(values[i]));
                return;
            }
            optionsString.push(i + ":" + _this.escapeValue(values[i]));
        });
        return key + "=" + optionsString.join(',');
    };
    /**
     * Escape params values
     *
     * @private
     * @param {string} value
     * @returns {string}
     * @memberof Filelink
     */
    Filelink.prototype.escapeValue = function (value) {
        if (typeof value !== 'string') {
            return value;
        }
        if (value.indexOf('/') > -1 || value.indexOf(',') > -1) {
            return "\"" + value + "\"";
        }
        return value;
    };
    /**
     * Converts nested arrays to string
     *
     * @private
     * @example [1,2, [2,3]] => "[1,2, [2,3]]"
     * @param arr - any array
     */
    Filelink.prototype.arrayToString = function (arr) {
        var _this = this;
        var toReturn = arr.map(function (el) {
            if (Array.isArray(el)) {
                return _this.arrayToString(el);
            }
            return _this.escapeValue(el);
        });
        return "[" + toReturn + "]";
    };
    /**
     * Validator instance
     *
     * @private
     * @memberof Filelink
     */
    Filelink.validator = validator_1.getValidator(transforms_schema_1.TransformSchema);
    return Filelink;
}());
exports.Filelink = Filelink;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZmlsZWxpbmsudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRzs7QUFFSCxzQ0FBcUM7QUFDckMsbUVBQWdFO0FBQ2hFLG1EQUFxRDtBQUNyRCxpQ0FBMkM7QUFDM0Msd0RBQTBFO0FBQzFFLCtCQUEwQjtBQUUxQixJQUFNLEtBQUssR0FBRyxlQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7QUFFbkMsSUFBWSxLQVFYO0FBUkQsV0FBWSxLQUFLO0lBQ2Ysc0JBQWEsQ0FBQTtJQUNiLHdCQUFlLENBQUE7SUFDZiwwQkFBaUIsQ0FBQTtJQUNqQiwwQkFBaUIsQ0FBQTtJQUNqQixvQkFBVyxDQUFBO0lBQ1gsd0JBQWUsQ0FBQTtJQUNmLDBCQUFpQixDQUFBO0FBQ25CLENBQUMsRUFSVyxLQUFLLEdBQUwsYUFBSyxLQUFMLGFBQUssUUFRaEI7QUFPRDs7R0FFRztBQUNILElBQVksVUFLWDtBQUxELFdBQVksVUFBVTtJQUNwQiwyQkFBYSxDQUFBO0lBQ2IsMkJBQWEsQ0FBQTtJQUNiLDZCQUFlLENBQUE7SUFDZix5QkFBVyxDQUFBO0FBQ2IsQ0FBQyxFQUxXLFVBQVUsR0FBVixrQkFBVSxLQUFWLGtCQUFVLFFBS3JCO0FBRUQ7O0dBRUc7QUFDSCxJQUFZLFFBR1g7QUFIRCxXQUFZLFFBQVE7SUFDbEIsNkJBQWlCLENBQUE7SUFDakIsaUNBQXFCLENBQUE7QUFDdkIsQ0FBQyxFQUhXLFFBQVEsR0FBUixnQkFBUSxLQUFSLGdCQUFRLFFBR25CO0FBRUQ7O0dBRUc7QUFDSCxJQUFZLFNBR1g7QUFIRCxXQUFZLFNBQVM7SUFDbkIsMEJBQWEsQ0FBQTtJQUNiLDBCQUFhLENBQUE7QUFDZixDQUFDLEVBSFcsU0FBUyxHQUFULGlCQUFTLEtBQVQsaUJBQVMsUUFHcEI7QUFFRDs7R0FFRztBQUNILElBQVksU0FLWDtBQUxELFdBQVksU0FBUztJQUNuQiwwQkFBYSxDQUFBO0lBQ2Isd0JBQVcsQ0FBQTtJQUNY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QWxpQ0Q7Ozs7O09BS0c7SUFDWSxrQkFBUyxHQUFHLHdCQUFZLENBQUMsbUNBQWUsQ0FBQyxDQUFDO0lBMmlDM0QsZUFBQztDQWxqQ0QsQUFrakNDLElBQUE7QUFsakNZLDRCQUFRIiwiZmlsZSI6ImxpYi9maWxlbGluay5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi8uLi9jb25maWcnO1xuaW1wb3J0IHsgVHJhbnNmb3JtU2NoZW1hIH0gZnJvbSAnLi8uLi9zY2hlbWEvdHJhbnNmb3Jtcy5zY2hlbWEnO1xuaW1wb3J0IHsgZ2V0VmFsaWRhdG9yIH0gZnJvbSAnLi8uLi9zY2hlbWEvdmFsaWRhdG9yJztcbmltcG9ydCB7IHJlc29sdmVIb3N0LCBiNjQgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IEZpbGVzdGFja0Vycm9yLCBGaWxlc3RhY2tFcnJvclR5cGUgfSBmcm9tICcuLy4uL2ZpbGVzdGFja19lcnJvcic7XG5pbXBvcnQgRGVidWcgZnJvbSAnZGVidWcnO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKCdmczpmaWxlbGluaycpO1xuXG5leHBvcnQgZW51bSBBbGlnbiB7XG4gIGxlZnQgPSAnbGVmdCcsXG4gIHJpZ2h0ID0gJ3JpZ2h0JyxcbiAgY2VudGVyID0gJ2NlbnRlcicsXG4gIGJvdHRvbSA9ICdib3R0b20nLFxuICB0b3AgPSAndG9wJyxcbiAgZmFjZXMgPSAnZmFjZXMnLFxuICBtaWRkbGUgPSAnbWlkZGxlJyxcbn1cblxuLyoqXG4gKiBBbGlnblxuICovXG5leHBvcnQgdHlwZSBBbGlnbk9wdGlvbnMgPSBBbGlnbiB8IFtBbGlnbi50b3AgfCBBbGlnbi5taWRkbGUgfCBBbGlnbi5ib3R0b20sIEFsaWduLmxlZnQgfCBBbGlnbi5jZW50ZXIgfCBBbGlnbi5yaWdodF07XG5cbi8qKlxuICogRml0IGVudW1cbiAqL1xuZXhwb3J0IGVudW0gRml0T3B0aW9ucyB7XG4gIGNsaXAgPSAnY2xpcCcsXG4gIGNyb3AgPSAnY3JvcCcsXG4gIHNjYWxlID0gJ3NjYWxlJyxcbiAgbWF4ID0gJ21heCcsXG59XG5cbi8qKlxuICogQmx1ciBlbnVtXG4gKi9cbmV4cG9ydCBlbnVtIEJsdXJNb2RlIHtcbiAgbGluZWFyID0gJ2xpbmVhcicsXG4gIGdhdXNzaWFuID0gJ2dhdXNzaWFuJyxcbn1cblxuLyoqXG4gKiBTaGFwZXMgZW51bVxuICovXG5leHBvcnQgZW51bSBTaGFwZVR5cGUge1xuICBvdmFsID0gJ292YWwnLFxuICByZWN0ID0gJ3JlY3QnLFxufVxuXG4vKipcbiAqIE5vaXNlIHR5cGUgZW51bVxuICovXG5leHBvcnQgZW51bSBOb2lzZVR5cGUge1xuICBub25lID0gJ25vbmUnLFxuICBsb3cgPSAnbG93JyxcbiAgbWVkaXVtID0gJ21lZGl1bScsXG4gIGhpZ2ggPSAnaGlnaCcsXG59XG5cbi8qKlxuICogU3R5bGUgdHlwZSBlbnVtXG4gKi9cbmV4cG9ydCBlbnVtIFN0eWxlVHlwZSB7XG4gIGFydHdvcmsgPSAnYXJ0d29yaycsXG4gIHBob3RvID0gJ3Bob3RvJyxcbn1cblxuLyoqXG4gKiBDb2xvciBzcGFjZSBlbnVtXG4gKi9cbmV4cG9ydCBlbnVtIENvbG9yc3BhY2VUeXBlIHtcbiAgUkdCID0gJ1JHQicsXG4gIENNWUsgPSAnQ01ZSycsXG4gIElucHV0ID0gJ0lucHV0Jyxcbn1cblxuLyoqXG4gKiBDcm9wIGZhY2VzIG9wdGlvbnMgZW51bVxuICovXG5leHBvcnQgZW51bSBDcm9wZmFjZXNUeXBlIHtcbiAgdGh1bWIgPSAndGh1bWInLFxuICBjcm9wID0gJ2Nyb3AnLFxuICBmaWxsID0gJ2ZpbGwnLFxufVxuXG4vKipcbiAqIFdhdGVybWFyayBwb3N0aW9uIG9wdGlvbnMgZW51bVxuICovXG5leHBvcnQgZW51bSBJbWFnZVdhdGVybWFya1Bvc2l0aW9uIHtcbiAgdG9wID0gJ3RvcCcsXG4gIG1pZGRsZSA9ICdtaWRkbGUnLFxuICBib3R0b20gPSAnYm90dG9tJyxcbiAgbGVmdCA9ICdsZWZ0JyxcbiAgY2VudGVyID0gJ2NlbnRlcicsXG4gIHJpZ2h0ID0gJ3JpZ2h0Jyxcbn1cblxuLyoqXG4gKiBTbWFydENyb3Agb3B0aW9ucyBlbnVtXG4gKi9cbmV4cG9ydCBlbnVtIFNtYXJ0Q3JvcE1vZGUge1xuICBmYWNlID0gJ2ZhY2UnLFxuICBhdXRvID0gJ2F1dG8nLFxufVxuXG4vKipcbiAqIENvbnZlcnQgdG8gZm9ybWF0XG4gKi9cbmV4cG9ydCBlbnVtIFZpZGVvVHlwZXMge1xuICBoMjY0ID0gJ2gyNjQnLFxuICBoMjY0X2hpID0gJ2gyNjQuaGknLFxuICB3ZWJtID0gJ3dlYm0nLFxuICAnd2VibS1oaScgPSAnd2VibS5oaScsXG4gIG9nZyA9ICdvZ2cnLFxuICAnb2dnLWhpJyA9ICdvZ2cuaGknLFxuICAnaGxzLXZhcmlhbnQnID0gJ2hscy52YXJpYW50JyxcbiAgbXAzID0gJ21wMycsXG4gIG9nYSA9ICdvZ2EnLFxuICBtNGEgPSAnbTRhJyxcbiAgYWFjID0gJ2FhYycsXG4gIGhscyA9ICdobHMudmFyaWFudC5hdWRpbycsXG59XG5cbmV4cG9ydCBlbnVtIFVSTFNjcmVlbnNob3RBZ2VudCB7XG4gIGRlc2t0b3AgPSAnZGVza3RvcCcsXG4gIG1vYmlsZSA9ICdtb2JpbGUnLFxufVxuXG5leHBvcnQgZW51bSBVUkxTY3JlZW5zaG90TW9kZSB7XG4gIGFsbCA9ICdhbGwnLFxuICB3aW5kb3cgPSAnd2luZG93Jyxcbn1cblxuZXhwb3J0IGVudW0gVVJMU2NyZWVuc2hvdE9yaWVudGF0aW9uIHtcbiAgcG9ydHJhaXQgPSAncG9ydHJhaXQnLFxuICBsYW5kc2NhcGUgPSAnbGFuZHNjYXBlJyxcbn1cblxuLyoqXG4gKiBWaWRlbyBzdG9yYWdlIGxvY2F0aW9uXG4gKi9cbmV4cG9ydCBlbnVtIExvY2F0aW9ucyB7XG4gIHMzID0gJ3MzJyxcbiAgYXp1cmUgPSAnYXp1cmUnLFxuICBnY3MgPSAnZ2NzJyxcbiAgcmFja3NwYWNlID0gJ3JhY2tzcGFjZScsXG4gIGRyb3Bib3ggPSAnZHJvcGJveCcsXG59XG5cbmV4cG9ydCBlbnVtIFZpZGVvQWNjZXNzIHtcbiAgcHJpdmF0ZSA9ICdwcml2YXRlJyxcbiAgcHVibGljID0gJ3B1YmxpYycsXG59XG5cbmV4cG9ydCBlbnVtIFZpZGVvQWNjZXNzTW9kZSB7XG4gIHByZXNlcnZlID0gJ3ByZXNlcnZlJyxcbiAgY29uc3RyYWluID0gJ2NvbnN0cmFpbicsXG4gIGxldHRlcmJveCA9ICdsZXR0ZXJib3gnLFxuICBwYWQgPSAncGFkJyxcbiAgY3JvcCA9ICdjcm9wJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdG9yZUJhc2VQYXJhbXMge1xuICBsb2NhdGlvbj86IHN0cmluZztcbiAgcGF0aD86IHN0cmluZztcbiAgY29udGFpbmVyPzogc3RyaW5nO1xuICByZWdpb24/OiBzdHJpbmc7XG4gIGFjY2Vzcz86IHN0cmluZztcbiAgZGlzYWJsZVN0b3JhZ2VLZXk/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEF2YWlsYWJsZSBvcHRpb25zIGZvciBzdG9yZSB0cmFuc2Zvcm1hdGlvbnNcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFN0b3JlUGFyYW1zXG4gKi9cbmV4cG9ydCB0eXBlIFN0b3JlUGFyYW1zID0gU3RvcmVCYXNlUGFyYW1zICYge1xuICBmaWxlbmFtZT86IHN0cmluZztcbiAgYmFzZTY0ZGVjb2RlPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uUGFyYW1zIHtcbiAgZGVsYXk/OiBudW1iZXI7XG4gIGxvb3A/OiBudW1iZXI7XG4gIHdpZHRoPzogbnVtYmVyO1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIGZpdD86IEZpdE9wdGlvbnM7XG4gIGFsaWduPzogQWxpZ25PcHRpb25zO1xuICBiYWNrZ3JvdW5kPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc2l6ZVBhcmFtcyB7XG4gIHdpZHRoPzogbnVtYmVyO1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIGZpdD86IEZpdE9wdGlvbnM7XG4gIGFsaWduPzogQWxpZ25PcHRpb25zO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyb3BQYXJhbXMge1xuICBkaW06IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdGF0ZVBhcmFtcyB7XG4gIGRlZzogbnVtYmVyIHwgc3RyaW5nO1xuICBjb2xvcj86IHN0cmluZztcbiAgYmFja2dyb3VuZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZXRlY3RGYWNlc1BhcmFtcyB7XG4gIG1pbnNpemU/OiBudW1iZXI7XG4gIG1heHNpemU/OiBudW1iZXI7XG4gIGNvbG9yPzogc3RyaW5nO1xuICBleHBvcnQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyb3BGYWNlc1BhcmFtcyB7XG4gIG1vZGU/OiBDcm9wZmFjZXNUeXBlO1xuICB3aWR0aD86IG51bWJlcjtcbiAgaGVpZ2h0PzogbnVtYmVyO1xuICBmYWNlcz86IG51bWJlciB8IHN0cmluZztcbiAgYnVmZmVyPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBpeGVsYXRlRmFjZXNQYXJhbXMge1xuICBmYWNlcz86IG51bWJlciB8IHN0cmluZztcbiAgbWluc2l6ZT86IG51bWJlcjtcbiAgbWF4c2l6ZT86IG51bWJlcjtcbiAgYnVmZmVyPzogbnVtYmVyO1xuICBhbW91bnQ/OiBudW1iZXI7XG4gIGJsdXI/OiBudW1iZXI7XG4gIHR5cGU/OiBTaGFwZVR5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmx1ckZhY2VzUGFyYW1zIHtcbiAgZmFjZXM/OiBudW1iZXIgfCBzdHJpbmc7XG4gIG1pbnNpemU/OiBudW1iZXI7XG4gIG1heHNpemU/OiBudW1iZXI7XG4gIGJ1ZmZlcj86IG51bWJlcjtcbiAgYW1vdW50PzogbnVtYmVyO1xuICBibHVyPzogbnVtYmVyO1xuICB0eXBlPzogU2hhcGVUeXBlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdW5kZWRDb3JuZXJzUGFyYW1zIHtcbiAgcmFkaXVzPzogbnVtYmVyO1xuICBibHVyPzogbnVtYmVyO1xuICBiYWNrZ3JvdW5kPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZ25ldHRlUGFyYW1zIHtcbiAgYW1vdW50PzogbnVtYmVyO1xuICBibHVybW9kZT86IEJsdXJNb2RlO1xuICBiYWNrZ3JvdW5kPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBvbGFyb2lkUGFyYW1zIHtcbiAgY29sb3I/OiBzdHJpbmc7XG4gIHJvdGF0ZT86IG51bWJlcjtcbiAgYmFja2dyb3VuZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb3JuRWRnZXNQYXJhbXMge1xuICBzcHJlYWQ/OiBbbnVtYmVyLCBudW1iZXJdO1xuICBiYWNrZ3JvdW5kPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNoYWRvd1BhcmFtcyB7XG4gIGJsdXI/OiBudW1iZXI7XG4gIG9wYWNpdHk/OiBudW1iZXI7XG4gIHZlY3Rvcj86IFtudW1iZXIsIG51bWJlcl07XG4gIGNvbG9yPzogc3RyaW5nO1xuICBiYWNrZ3JvdW5kPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENpcmNsZVBhcmFtcyB7XG4gIGJhY2tncm91bmQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQm9yZGVyUGFyYW1zIHtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGNvbG9yPzogc3RyaW5nO1xuICBiYWNrZ3JvdW5kPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXByZXNzUGFyYW1zIHtcbiAgbWV0YWRhdGE/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdhdGVybWFya1BhcmFtcyB7XG4gIGZpbGU6IHN0cmluZztcbiAgc2l6ZT86IG51bWJlcjtcbiAgcG9zaXRpb24/OiBJbWFnZVdhdGVybWFya1Bvc2l0aW9uIHwgSW1hZ2VXYXRlcm1hcmtQb3NpdGlvbltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyZXNzaXZlSnBnUGFyYW1zIHtcbiAgcXVhbGl0eTogbnVtYmVyO1xuICBtZXRhZGF0YTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbWFydENyb3BQYXJhbXMge1xuICBtb2RlOiBTbWFydENyb3BNb2RlO1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaGFycGVuUGFyYW1zIHtcbiAgYW1vdW50OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmx1clBhcmFtcyB7XG4gIGFtb3VudDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJsYWNrd2hpdGVQYXJhbXMge1xuICB0aHJlc2hvbGQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXBpYVBhcmFtcyB7XG4gIHRvbmU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQaXhlbGF0ZVBhcmFtcyB7XG4gIGFtb3VudDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9pbFBhaW50UGFyYW1zIHtcbiAgYW1vdW50OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kdWxhdGVQYXJhbXMge1xuICBicmlnaHRuZXNzPzogbnVtYmVyO1xuICBodWU/OiBudW1iZXI7XG4gIHNhdHVyYXRpb24/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFydGlhbFBpeGVsYXRlUGFyYW1zIHtcbiAgYW1vdW50PzogbnVtYmVyO1xuICBibHVyPzogbnVtYmVyO1xuICB0eXBlPzogU2hhcGVUeXBlO1xuICBvYmplY3RzPzogW1tudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJ0aWFsQmx1clBhcmFtcyB7XG4gIGFtb3VudDogbnVtYmVyO1xuICBibHVyPzogbnVtYmVyO1xuICB0eXBlPzogU2hhcGVUeXBlO1xuICBvYmplY3RzPzogW1tudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2xsYWdlUGFyYW1zIHtcbiAgbWFyZ2luPzogbnVtYmVyO1xuICB3aWR0aD86IG51bWJlcjtcbiAgaGVpZ2h0PzogbnVtYmVyO1xuICBjb2xvcj86IHN0cmluZztcbiAgZml0PzogRml0T3B0aW9ucztcbiAgZmlsZXM6IFtzdHJpbmddO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwc2NhbGVQYXJhbXMge1xuICB1cHNjYWxlPzogYm9vbGVhbjtcbiAgbm9pc2U/OiBOb2lzZVR5cGU7XG4gIHN0eWxlPzogU3R5bGVUeXBlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzY2lpUGFyYW1zIHtcbiAgYmFja2dyb3VuZD86IHN0cmluZztcbiAgZm9yZWdyb3VuZD86IHN0cmluZztcbiAgY29sb3JlZD86IGJvb2xlYW47XG4gIHNpemU/OiBudW1iZXI7XG4gIHJldmVyc2U/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1YWxpdHlQYXJhbXMge1xuICB2YWx1ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlY3VyaXR5UGFyYW1zIHtcbiAgcG9saWN5OiBzdHJpbmc7XG4gIHNpZ25hdHVyZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPdXRwdXRQYXJhbXMge1xuICBmb3JtYXQ6IHN0cmluZztcbiAgY29sb3JzcGFjZT86IHN0cmluZztcbiAgc3RyaXA/OiBib29sZWFuO1xuICBxdWFsaXR5PzogbnVtYmVyO1xuICBwYWdlPzogbnVtYmVyO1xuICBjb21wcmVzcz86IGJvb2xlYW47XG4gIGRlbnNpdHk/OiBudW1iZXI7XG4gIGJhY2tncm91bmQ/OiBzdHJpbmc7XG4gIHNlY3VyZT86IGJvb2xlYW47XG4gIGRvY2luZm8/OiBib29sZWFuO1xuICBwYWdlZm9ybWF0Pzogc3RyaW5nO1xuICBwYWdlb3JpZW50YXRpb24/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVQYXJhbXMge1xuICBjYWNoZT86IGJvb2xlYW47XG4gIGV4cGlyeTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZGVvQ29udmVydFBhcmFtcyB7XG4gIGFzcGVjdF9tb2RlOiBWaWRlb0FjY2Vzc01vZGU7XG4gIHByZXNldD86IFZpZGVvVHlwZXM7XG4gIGZvcmNlPzogYm9vbGVhbjtcbiAgdGl0bGU/OiBzdHJpbmc7XG4gIGV4dG5hbWU/OiBzdHJpbmc7XG4gIGZpbGVuYW1lPzogc3RyaW5nO1xuICBsb2NhdGlvbj86IExvY2F0aW9ucztcbiAgcGF0aD86IHN0cmluZztcbiAgYWNjZXNzPzogVmlkZW9BY2Nlc3M7XG4gIGNvbnRhaW5lcj86IHN0cmluZztcbiAgYXVkaW9fYml0cmF0ZT86IG51bWJlcjtcbiAgdXBzY2FsZTogYm9vbGVhbjtcbiAgdmlkZW9fYml0cmF0ZT86IG51bWJlcjtcbiAgYXVkaW9fc2FtcGxlX3JhdGU/OiBudW1iZXI7XG4gIGF1ZGlvX2NoYW5uZWxzPzogbnVtYmVyO1xuICBjbGlwX2xlbmd0aD86IHN0cmluZztcbiAgY2xpcF9vZmZzZXQ/OiBzdHJpbmc7XG4gIHdpZHRoPzogbnVtYmVyO1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIHR3b19wYXNzPzogYm9vbGVhbjtcbiAgZnBzPzogbnVtYmVyO1xuICBrZXlmcmFtZV9pbnRlcnZhbD86IG51bWJlcjtcbiAgd2F0ZXJtYXJrX3VybD86IHN0cmluZztcbiAgd2F0ZXJtYXJrX3RvcD86IG51bWJlcjtcbiAgd2F0ZXJtYXJrX2JvdHRvbT86IG51bWJlcjtcbiAgd2F0ZXJtYXJrX3JpZ2h0PzogbnVtYmVyO1xuICB3YXRlcm1hcmtfbGVmdD86IG51bWJlcjtcbiAgd2F0ZXJtYXJrX3dpZHRoPzogbnVtYmVyO1xuICB3YXRlcm1hcmtfaGVpZ2h0PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVSTFNjcmVlbnNob3RQYXJhbXMge1xuICBhZ2VudD86IFVSTFNjcmVlbnNob3RBZ2VudDtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgbW9kZT86IFVSTFNjcmVlbnNob3RNb2RlO1xuICBkZWxheT86IG51bWJlcjtcbiAgb3JpZW50YXRpb24/OiBVUkxTY3JlZW5zaG90T3JpZW50YXRpb247XG4gIGRldmljZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGVudW0gRW5oYW5jZVByZXNldCB7XG4gIGF1dG8gPSAnYXV0bycsXG4gIHZpdmlkID0gJ3ZpdmlkJyxcbiAgYmVhdXRpZnkgPSAnYmVhdXRpZnknLFxuICBiZWF1dGlmeVBsdXMgPSAnYmVhdXRpZnlfcGx1cycsXG4gIGZpeERhcmsgPSAnZml4X2RhcmsnLFxuICBmaXhOb2lzZSA9ICdmaXhfbm9pc2UnLFxuICBmaXhUaW50ID0gJ2ZpeF90aW50JyxcbiAgb3V0ZG9yID0gJ291dGRvb3InLFxuICBmaXJld29ya3MgPSAnZmlyZXdvcmtzJyxcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRW5oYW5jZVBhcmFtcyB7XG4gIHByZXNldD86IEVuaGFuY2VQcmVzZXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGRmSW5mb1BhcmFtcyB7XG4gIGNvbG9yaW5mbz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGRmQ29udmVydFBhcmFtcyB7XG4gIHBhZ2VvcmllbnRhdGlvbj86IHN0cmluZztcbiAgcGFnZWZvcm1hdD86IHN0cmluZztcbiAgcGFnZXM/OiAoc3RyaW5nIHwgbnVtYmVyKVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZhbGxiYWNrUGFyYW1zIHtcbiAgaGFuZGxlOiBzdHJpbmc7XG4gIGNhY2hlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1pbmlmeUNzc1BhcmFtcyB7XG4gIGd6aXA/OiBib29sZWFuO1xuICBsZXZlbD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNaW5pZnlKc1BhcmFtcyB7XG4gIGd6aXA/OiBib29sZWFuO1xuICB1c2VfYmFiZWxfcG9seWZpbGw/OiBib29sZWFuO1xuICBrZWVwX2ZuX25hbWU/OiBib29sZWFuO1xuICBrZWVwX2NsYXNzX25hbWU/OiBib29sZWFuO1xuICBtYW5nbGU/OiBib29sZWFuO1xuICBtZXJnZV92YXJzPzogYm9vbGVhbjtcbiAgcmVtb3ZlX2NvbnNvbGU/OiBib29sZWFuO1xuICByZW1vdmVfdW5kZWZpbmVkPzogYm9vbGVhbjtcbiAgdGFyZ2V0cz86IG51bGwgfCBzdHJpbmc7XG59XG5cbmNvbnN0IGhhbmRsZVJlZ2V4cCA9IC9eW1xcd1xcLV17MjB9fHdmOlxcL1xcL1tcXHdcXC1cXC9dezEwNn0kLztcblxuLyoqXG4gKiBDbGFzcyBmb3IgaGFuZGxpbmcgZmlsZWxpbmtzLiBGb3Igbm93IGl0cyBzdXBwb3J0cyBhbGwgZmlsZXN0YWNrIHRyYW5zZm9ybXMuXG4gKiBJdCBvdXRwdXRzIHRyYW5zZm9ybSB1cmwgb3IgYXJyYXkgb2YgdHJhbnNmb3Jtc1xuICogQGV4YW1wbGVcbiAqIGNvbnN0IGxpbmsgPSBuZXcgRmlsZWxpbmsoJ2hhbmRsZSBvciBleHRlcm5hbFVybCcsICdhcGlrZXknKTtcbiAqIGxpbmsuZmxpcCgpLmZsb3AoKS5zdG9yZSgpO1xuICpcbiAqIGNvbnNvbGUubG9nKGxpbmsudG9TdHJpbmcoKSk7XG4gKiAvLyBlbmFibGUgYmFzZTY0IHN1cHBvcnRcbiAqIGxpbmsuc2V0QmFzZTY0KHRydWUpXG4gKlxuICogY29uc29sZS5sb2cobGluay50b1N0cmluZygpKTtcbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgRmlsZWxpbmtcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVsaW5rIHtcbiAgLyoqXG4gICAqIFZhbGlkYXRvciBpbnN0YW5jZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHZhbGlkYXRvciA9IGdldFZhbGlkYXRvcihUcmFuc2Zvcm1TY2hlbWEpO1xuXG4gIC8qKlxuICAgKiBBcHBsaWVkIHRyYW5zZm9ybXMgYXJyYXlcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBwcml2YXRlIHRyYW5zZm9ybXMgPSBbXTtcblxuICAvKipcbiAgICogSGFuZGxlIG9yIG11bHRpcGxlIGhhbmRsZXMgaW4gYXJyYXlcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBwcml2YXRlIHNvdXJjZTogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEFwcGxpY2F0aW9uIGtleVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIHByaXZhdGUgYXBpa2V5OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElzIGJhc2U2NCBzdXBwb3J0IGlzIGVuYWJsZWRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgcHJpdmF0ZSBiNjQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogc2hvdWxkIHVzZSBhIHZhbGlkYXRvciB0byBjaGVjayBwYXJhbXMgb2YgZXZlcnkgdGFza1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBwcml2YXRlIHVzZVZhbGlkYXRvcjogYm9vbGVhbiA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEN1c3RvbSBDTkFNRVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIHByaXZhdGUgY25hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogT3ZlcndyaXRlIGRvbWFpbiAodGVzdCBwdXJwb3NlcylcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBwcml2YXRlIGN1c3RvbURvbWFpbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBmb3IgZ2VuZXJhdGluZyB0cmFuZm9ybWF0aW9uIHVybHNcbiAgICogQHBhcmFtIHsoc3RyaW5nIHwgc3RyaW5nW10pfSBzb3VyY2UgLSBoYW5kbGUgb3IgbXVsdGlwbGUgaGFuZGxlcyAoaS5lLiBmb3IgY29sbGFnZSlcbiAgICogQHBhcmFtIHtzdHJpbmd9IFthcGlrZXldIC0geW91ciBhcGlrZXkgLSByZXF1aXJlZCBmb3IgYWxsIGV4dGVybmFsIHNvdXJjZXNcbiAgICpcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2U6IHN0cmluZyB8IHN0cmluZ1tdLCBhcGlrZXk/OiBzdHJpbmcpIHtcbiAgICB0aGlzLmFwaWtleSA9IGFwaWtleTtcbiAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBuZXcgYmFzZTY0IGxpbmsgc3VwcG9ydCB0byBhdm9pZCBwcm9ibGVtcyB3aXRoIHNwZWNpYWwgY2hhcnMgaW4gbGlua1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsYWdcbiAgICogQHJldHVybnNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBzZXRCYXNlNjQoZmxhZzogYm9vbGVhbikge1xuICAgIHRoaXMuYjY0ID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2l0Y2ggdGhlIHVzZVZhbGlkYXRvciBmbGFnXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZ1xuICAgKiBAcmV0dXJuc1xuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIHNldFVzZVZhbGlkYXRvcihmbGFnOiBib29sZWFuKSB7XG4gICAgdGhpcy51c2VWYWxpZGF0b3IgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjbmFtZSBmb3IgdHJhbnNmb3JtYXRpb24gbGlua1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY25hbWVcbiAgICogQHJldHVybnNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBzZXRDbmFtZShjbmFtZTogc3RyaW5nKSB7XG4gICAgdGhpcy5jbmFtZSA9IGNuYW1lO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjdXN0b20gZG9tYWluLiBVc2VkIGZvciB0ZXN0IHB1cnBvc2UuIEl0IHdpbGwgYmUgcmVtb3ZlZCB3aGVuIGFmdGVyIGNsaWVudC50cmFuc2Zvcm1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpblxuICAgKiBAcmV0dXJuc1xuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIHNldEN1c3RvbURvbWFpbihkb21haW46IHN0cmluZykge1xuICAgIHRoaXMuY3VzdG9tRG9tYWluID0gZG9tYWluO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0U291cmNlKHNvdXJjZTogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxuICAgIGNvbnN0IGlzRXh0ZXJuYWwgPSB0aGlzLmlzU291cmNlRXh0ZXJuYWwoKTtcblxuICAgIGRlYnVnKGBTb3VyY2UgJHtzb3VyY2V9IC0gaXNFeHRlcm5hbD8gJHtpc0V4dGVybmFsfWApO1xuXG4gICAgaWYgKGlzRXh0ZXJuYWwgJiYgIXRoaXMuYXBpa2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRmlsZXN0YWNrRXJyb3IoJ0V4dGVybmFsIHNvdXJjZXMgcmVxdWlyZXMgYXBpa2V5IHRvIGhhbmRsZSB0cmFuc2Zvcm1zJyk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0V4dGVybmFsICYmIHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ3N0cmluZycgJiYgIWhhbmRsZVJlZ2V4cC50ZXN0KHRoaXMuc291cmNlKSAmJiB0aGlzLnNvdXJjZS5pbmRleE9mKCdmaWxlc3RhY2tjb250ZW50JykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRmlsZXN0YWNrRXJyb3IoJ0ludmFsaWQgZmlsZXN0YWNrIHNvdXJjZSBwcm92aWRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIEpTT05TY2hlbWEgZm9ybSB0cmFuc2Zvcm1hdGlvbnMgcGFyYW1zXG4gICAqXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgZ2V0VmFsaWRhdGlvblNjaGVtYSgpIHtcbiAgICByZXR1cm4gVHJhbnNmb3JtU2NoZW1hO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJhbnNmb3JtYXRpb25zIGluIEpTT04gZm9ybWF0XG4gICAqXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgZ2V0VHJhbnNmb3JtYXRpb25zKCkge1xuICAgIGlmICh0aGlzLnVzZVZhbGlkYXRvcikge1xuICAgICAgdGhpcy52YWxpZGF0ZVRhc2tzKHRoaXMudHJhbnNmb3Jtcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cmFuc2Zvcm0gdXJsXG4gICAqXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgcmV0dXJuVXJsID0gW107XG4gICAgcmV0dXJuVXJsLnB1c2godGhpcy5nZXRDZG5Ib3N0KCkpO1xuXG4gICAgaWYgKHRoaXMudXNlVmFsaWRhdG9yKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlVGFza3ModGhpcy50cmFuc2Zvcm1zKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcGlrZXkpIHtcbiAgICAgIHJldHVyblVybC5wdXNoKHRoaXMuYXBpa2V5KTtcbiAgICB9XG5cbiAgICBsZXQgdHJhbnNmb3Jtc1N0cmluZyA9IHRoaXMuZ2VuZXJhdGVUcmFuc2Zvcm1TdHJpbmcoKTtcblxuICAgIGxldCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcblxuICAgIGlmICh0aGlzLmI2NCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNmb3Jtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRyYW5zZm9ybXNTdHJpbmcgPSBgYjY0LyR7YjY0KEpTT04uc3RyaW5naWZ5KHRoaXMudHJhbnNmb3JtcyksIHRydWUpfWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgc291cmNlID0gdGhpcy5hcnJheVRvU3RyaW5nKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZSA9IGBiNjQ6Ly8ke2I2NChzb3VyY2UsIHRydWUpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgc291cmNlID0gdGhpcy5hcnJheVRvU3RyaW5nKHNvdXJjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2UgPSB0aGlzLmVzY2FwZVZhbHVlKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgICByZXR1cm5VcmwucHVzaCh0cmFuc2Zvcm1zU3RyaW5nKTtcbiAgICB9XG5cbiAgICByZXR1cm5VcmwucHVzaChzb3VyY2UpO1xuICAgIHJldHVybiByZXR1cm5Vcmwuam9pbignLycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0YXNrIGFuZCB2YWxpZGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IFtwYXJhbXNdXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgYWRkVGFzayhuYW1lOiBzdHJpbmcsIHBhcmFtcz8pIHtcbiAgICBEZWJ1ZyhgQWRkIHRhc2sgICR7bmFtZX0gd2l0aCBwYXJhbXMgJU9gLCBwYXJhbXMpO1xuXG4gICAgaWYgKG5hbWUgIT09ICdjYWNoZScgJiYgdHlwZW9mIHBhcmFtcyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnICYmICFPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCkge1xuICAgICAgcGFyYW1zID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMudHJhbnNmb3Jtcy5wdXNoKHsgbmFtZSwgcGFyYW1zIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHRhc2tzIGFkZGVkIGZvciB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIGdldFRhc2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybXM7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW51cCB0cmFuc2Zvcm1hdGlvbnMgb24gZmlsZWxpbmtcbiAgICpcbiAgICogQHJldHVybnNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1hdGlvbnMgcGFydFxuICAgKi9cblxuICAvKipcbiAgICogQWRkIGF1dG9pbWFnZSB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jYXV0by1pbWFnZS1jb252ZXJzaW9uXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBhdXRvSW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGFzaygnYXV0b19pbWFnZScsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZmxpcCB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jZmxpcFxuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgZmxpcCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCdmbGlwJywgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBmbG9wIHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyNmbG9wXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBmbG9wKCkge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ2Zsb3AnLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGltYWdlc2l6ZSB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jaW1hZ2Utc2l6ZVxuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgaW1hZ2VzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ2ltYWdlc2l6ZScsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbm9NZXRhZGF0YSB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jc3RyaXAtbWV0YWRhdGFcbiAgICogQHJldHVybnMgdGhpc1xuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIG5vTWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGFzaygnbm9fbWV0YWRhdGEnLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIFByb2dyZXNzaXZlIEpQRUcgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI3Byb2dyZXNzaXZlLWpwZWdcbiAgICogQHJldHVybnMgdGhpc1xuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIHBqcGcocGFyYW1zOiBQcm9ncmVzc2l2ZUpwZ1BhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ3BqcGcnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgaW1hZ2VzaXplIHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyNzbWFydC1jcm9wXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBzbWFydENyb3AocGFyYW1zOiBTbWFydENyb3BQYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCdzbWFydF9jcm9wJywgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHdhdGVybWFydCB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jd2F0ZXJtYXJrXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICB3YXRlcm1hcmsocGFyYW1zOiBXYXRlcm1hcmtQYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCd3YXRlcm1hcmsnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZW5oYW5jZSB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jZW5oYW5jZVxuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgZW5oYW5jZShwYXJhbXM/OiBFbmhhbmNlUGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGFzaygnZW5oYW5jZScsIHBhcmFtcyB8fCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgc2VjdXJpdHkgdG8gbGlua1xuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jcmVkZXllXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgcmVkZXllKCkge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ3JlZGV5ZScsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBtb25vY2hyb21lIHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyNtb25vY2hyb21lXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBtb25vY2hyb21lKCkge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ21vbm9jaHJvbWUnLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgY29tcHJlc3MgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI2NvbXByZXNzXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBjb21wcmVzcyhwYXJhbXM/OiBDb21wcmVzc1BhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ2NvbXByZXNzJywgcGFyYW1zIHx8IHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbmVnYXRpdmUgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI25lZ2F0aXZlXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBuZWdhdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCduZWdhdGl2ZScsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGFncyB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jdGFnc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgdGFncygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCd0YWdzJywgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBzZncgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI3Nmd1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgc2Z3KCkge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ3NmdycsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbmltYXRlIHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyNhbmltYXRlLWltYWdlcy10by1naWZcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgYW5pbWF0ZShwYXJhbXM6IEFuaW1hdGlvblBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ2FuaW1hdGUnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgc3RvcmUgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI3N0b3JlXG4gICAqIEBwYXJhbSB7KFN0b3JlUGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgc3RvcmUocGFyYW1zPzogU3RvcmVQYXJhbXMgfCBib29sZWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGFzaygnc3RvcmUnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY2FjaGUgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI2NhY2hlXG4gICAqIEBwYXJhbSB7KENhY2hlUGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgY2FjaGUocGFyYW1zOiBDYWNoZVBhcmFtcyB8IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCdjYWNoZScsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyByZXNpemUgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI3Jlc2l6ZVxuICAgKiBAcGFyYW0ge1Jlc2l6ZVBhcmFtc30gcGFyYW1zXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICByZXNpemUocGFyYW1zOiBSZXNpemVQYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCdyZXNpemUnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY3JvcCB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jY3JvcFxuICAgKiBAcGFyYW0ge0Nyb3BQYXJhbXN9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgY3JvcChwYXJhbXM6IENyb3BQYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCdjcm9wJywgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHJvdGF0ZSB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jcm90YXRlXG4gICAqIEBwYXJhbSB7Um90YXRlUGFyYW1zfSBwYXJhbXNcbiAgICogQHJldHVybnMgdGhpc1xuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIHJvdGF0ZShwYXJhbXM6IFJvdGF0ZVBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ3JvdGF0ZScsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBkZXRlY3RfZmFjZXMgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI2ZhY2lhbC1kZXRlY3Rpb25cbiAgICogQHBhcmFtIHsoRGV0ZWN0RmFjZXNQYXJhbXMgfCBib29sZWFuKX0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBkZXRlY3RGYWNlcyhwYXJhbXM/OiBEZXRlY3RGYWNlc1BhcmFtcyB8IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCdkZXRlY3RfZmFjZXMnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY3JvcCBmYWNlcyB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jY3JvcC1mYWNlc1xuICAgKiBAcGFyYW0ge0Nyb3BGYWNlc1BhcmFtc30gcGFyYW1zXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBjcm9wRmFjZXMocGFyYW1zOiBDcm9wRmFjZXNQYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCdjcm9wX2ZhY2VzJywgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHBpeGVsYXRlIGZhY2VzIHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyNwaXhlbGF0ZS1mYWNlc1xuICAgKiBAcGFyYW0ge1BpeGVsYXRlRmFjZXNQYXJhbXN9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgcGl4ZWxhdGVGYWNlcyhwYXJhbXM6IFBpeGVsYXRlRmFjZXNQYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCdwaXhlbGF0ZV9mYWNlcycsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBibHVyIGZhY2VzIHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyNibHVyLWZhY2VzXG4gICAqIEBwYXJhbSB7Qmx1ckZhY2VzUGFyYW1zfSBwYXJhbXNcbiAgICogQHJldHVybnMgdGhpc1xuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIGJsdXJGYWNlcyhwYXJhbXM6IEJsdXJGYWNlc1BhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ2JsdXJfZmFjZXMnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcm91bmRlZCBjb3JuZXJzIHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyNyb3VuZGVkLWNvcm5lcnNcbiAgICogQHBhcmFtIHsoUm91bmRlZENvcm5lcnNQYXJhbXMgfCBib29sZWFuKX0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICByb3VuZGVkQ29ybmVycyhwYXJhbXM/OiBSb3VuZGVkQ29ybmVyc1BhcmFtcyB8IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCdyb3VuZGVkX2Nvcm5lcnMnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcG9sYXJvaWQgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI3BvbGFyb2lkXG4gICAqIEBwYXJhbSB7KFBvbGFyb2lkUGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgcG9sYXJvaWQocGFyYW1zPzogUG9sYXJvaWRQYXJhbXMgfCBib29sZWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGFzaygncG9sYXJvaWQnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdmlnbmV0dGUgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI3ZpZ25ldHRlXG4gICAqIEBwYXJhbSB7KFZpZ25ldHRlUGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgdmlnbmV0dGUocGFyYW1zPzogVmlnbmV0dGVQYXJhbXMgfCBib29sZWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGFzaygndmlnbmV0dGUnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdG9ybiBlZGdlcyB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jdG9ybi1lZGdlc1xuICAgKiBAcGFyYW0geyhUb3JuRWRnZXNQYXJhbXMgfCBib29sZWFuKX0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICB0b3JuRWRnZXMocGFyYW1zPzogVG9ybkVkZ2VzUGFyYW1zIHwgYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ3Rvcm5fZWRnZXMnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgc2hhZG93IHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyNzaGFkb3dcbiAgICogQHBhcmFtIHsoU2hhZG93UGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgc2hhZG93KHBhcmFtcz86IFNoYWRvd1BhcmFtcyB8IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCdzaGFkb3cnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY2lyY2xlIHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyNjaXJjbGVcbiAgICogQHBhcmFtIHsoQ2lyY2xlUGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgY2lyY2xlKHBhcmFtcz86IENpcmNsZVBhcmFtcyB8IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCdjaXJjbGUnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYm9yZGVyIHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyNib3JkZXJcbiAgICogQHBhcmFtIHsoQm9yZGVyUGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgYm9yZGVyKHBhcmFtcz86IEJvcmRlclBhcmFtcyB8IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCdib3JkZXInLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgc2hhcnBlbiB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jc2hhcnBlblxuICAgKiBAcGFyYW0geyhTaGFycGVuUGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgc2hhcnBlbihwYXJhbXM/OiBTaGFycGVuUGFyYW1zIHwgYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ3NoYXJwZW4nLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYmx1ciB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jYmx1clxuICAgKiBAcGFyYW0geyhCbHVyUGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgYmx1cihwYXJhbXM/OiBCbHVyUGFyYW1zIHwgYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ2JsdXInLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYmxhY2t3aGl0ZSB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jYmxhY2t3aGl0ZVxuICAgKiBAcGFyYW0geyhCbGFja3doaXRlUGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgYmxhY2t3aGl0ZShwYXJhbXM/OiBCbGFja3doaXRlUGFyYW1zIHwgYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ2JsYWNrd2hpdGUnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgc2VwaWEgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI3NlcGlhXG4gICAqIEBwYXJhbSB7KFNlcGlhUGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgc2VwaWEocGFyYW1zPzogU2VwaWFQYXJhbXMgfCBib29sZWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGFzaygnc2VwaWEnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcGl4ZWxhdGUgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI3BpeGVsYXRlXG4gICAqIEBwYXJhbSB7KFBpeGVsYXRlUGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgcGl4ZWxhdGUocGFyYW1zPzogUGl4ZWxhdGVQYXJhbXMgfCBib29sZWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGFzaygncGl4ZWxhdGUnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgb2lscGFpbnQgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI29pbC1wYWludFxuICAgKiBAcGFyYW0geyhPaWxQYWludFBhcmFtcyB8IGJvb2xlYW4pfSBwYXJhbXNcbiAgICogQHJldHVybnMgdGhpc1xuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIG9pbFBhaW50KHBhcmFtcz86IE9pbFBhaW50UGFyYW1zIHwgYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ29pbF9wYWludCcsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBtb2R1bGF0ZSB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jbW9kdWxhdGVcbiAgICogQHBhcmFtIHsoTW9kdWxhdGVQYXJhbXMgfCBib29sZWFuKX0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBtb2R1bGF0ZShwYXJhbXM/OiBNb2R1bGF0ZVBhcmFtcyB8IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCdtb2R1bGF0ZScsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBwYXJ0aWFsIHBpeGVsYXRlIHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyNwYXJ0aWFsLXBpeGVsYXRlXG4gICAqIEBwYXJhbSB7UGFydGlhbFBpeGVsYXRlUGFyYW1zfSBwYXJhbXNcbiAgICogQHJldHVybnMgdGhpc1xuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIHBhcnRpYWxQaXhlbGF0ZShwYXJhbXM6IFBhcnRpYWxQaXhlbGF0ZVBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ3BhcnRpYWxfcGl4ZWxhdGUnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcGFydGlhbCBibHVyIHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyNwYXJ0aWFsLWJsdXJcbiAgICogQHBhcmFtIHtQYXJ0aWFsQmx1clBhcmFtc30gcGFyYW1zXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBwYXJ0aWFsQmx1cihwYXJhbXM6IFBhcnRpYWxCbHVyUGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGFzaygncGFydGlhbF9ibHVyJywgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGNvbGxhZ2UgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI2NvbGxhZ2VcbiAgICogQHBhcmFtIHtDb2xsYWdlUGFyYW1zfSBwYXJhbXNcbiAgICogQHJldHVybnMgdGhpc1xuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIGNvbGxhZ2UocGFyYW1zOiBDb2xsYWdlUGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGFzaygnY29sbGFnZScsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB1cHNjYWxlIHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyN1cHNjYWxlXG4gICAqIEBwYXJhbSB7KFVwc2NhbGVQYXJhbXMgfCBib29sZWFuKX0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICB1cHNjYWxlKHBhcmFtcz86IFVwc2NhbGVQYXJhbXMgfCBib29sZWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGFzaygndXBzY2FsZScsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhc2NpaSB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jYXNjaWlcbiAgICogQHBhcmFtIHsoQXNjaWlQYXJhbXMgfCBib29sZWFuKX0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBhc2NpaShwYXJhbXM/OiBBc2NpaVBhcmFtcyB8IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5hZGRUYXNrKCdhc2NpaScsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBxdWFsaXR5IHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyNxdWFsaXR5XG4gICAqIEBwYXJhbSB7UXVhbGl0eVBhcmFtc30gcGFyYW1zXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBxdWFsaXR5KHBhcmFtczogUXVhbGl0eVBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ3F1YWxpdHknLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgc2VjdXJpdHkgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI3NlY3VyaXR5XG4gICAqIEBwYXJhbSB7U2VjdXJpdHlQYXJhbXN9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgc2VjdXJpdHkocGFyYW1zOiBTZWN1cml0eVBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ3NlY3VyaXR5JywgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG91dHB1dCB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jb3V0cHV0XG4gICAqIEBwYXJhbSB7T3V0cHV0UGFyYW1zfSBwYXJhbXNcbiAgICogQHJldHVybnMgdGhpc1xuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIG91dHB1dChwYXJhbXM6IE91dHB1dFBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ291dHB1dCcsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB2aWRlbyBjb252ZXJ0IHRyYW5zZm9ybWF0aW9uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuZmlsZXN0YWNrLmNvbS9kb2NzL2FwaS9wcm9jZXNzaW5nLyN2aWRlby1jb252ZXJ0XG4gICAqIEBwYXJhbSB7VmlkZW9Db252ZXJ0UGFyYW1zfSBwYXJhbXNcbiAgICogQHJldHVybnMgdGhpc1xuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIHZpZGVvQ29udmVydChwYXJhbXM6IFZpZGVvQ29udmVydFBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ3ZpZGVvX2NvbnZlcnQnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgVVJMU2NyZWVuc2hvdCB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jdXJsc2NyZWVuc2hvdFxuICAgKiBAcGFyYW0geyhVUkxTY3JlZW5zaG90UGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgVVJMU2NyZWVuc2hvdChwYXJhbXM/OiBVUkxTY3JlZW5zaG90UGFyYW1zIHwgYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ3VybHNjcmVlbnNob3QnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcGRmaW5mbyB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jcGRmaW5mb1xuICAgKiBAcGFyYW0geyhQZGZJbmZvUGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgUERGSW5mbyhwYXJhbXM/OiBQZGZJbmZvUGFyYW1zIHwgYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ3BkZmluZm8nLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcGRmY29udmVydCB0cmFuc2Zvcm1hdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jcGRmY29udmVydFxuICAgKiBAcGFyYW0geyhQZGZDb252ZXJ0UGFyYW1zIHwgYm9vbGVhbil9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqIEBtZW1iZXJvZiBGaWxlbGlua1xuICAgKi9cbiAgUERGQ29udmVydChwYXJhbXM/OiBQZGZDb252ZXJ0UGFyYW1zIHwgYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ3BkZmNvbnZlcnQnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZmFsbGJhY2sgdHJhbnNmb3JtYXRpb25cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5maWxlc3RhY2suY29tL2RvY3MvYXBpL3Byb2Nlc3NpbmcvI2ZhbGxiYWNrXG4gICAqIEBwYXJhbSB7KEZhbGxiYWNrUGFyYW1zKX0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBmYWxsYmFjayhwYXJhbXM6IEZhbGxiYWNrUGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGFzaygnZmFsbGJhY2snLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB6aXAgdHJhbnNmb3JtYXRpb24gd2hpY2ggY3JlYXRlIGEgemlwIHBhY2thZ2Ugb24gZmlsZXNcbiAgICogdXNlZCBvbiBhY3R1YWwgY29udGV4dFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmZpbGVzdGFjay5jb20vZG9jcy9hcGkvcHJvY2Vzc2luZy8jemlwXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICB6aXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGFzaygnemlwJywgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHRhc2sgd2hpY2ggbWluaWZ5IGEgY3NzIGZpbGVcbiAgICpcbiAgICogQHJldHVybnMgdGhpc1xuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIG1pbmlmeUNzcyhwYXJhbXM6IE1pbmlmeUNzc1BhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmFkZFRhc2soJ21pbmlmeV9jc3MnLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0YXNrIHdoaWNoIG1pbmlmeSBhIGphdmFzY3JpcHQgZmlsZS5cbiAgICogRm9yIGJldHRlciBoYW5kbGluZyBvZiAndGFyZ2V0cycgcGFyYW0sIHVzZSB3aXRoIGI2NCBmbGFnIGVuYWJsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICogQG1lbWJlcm9mIEZpbGVsaW5rXG4gICAqL1xuICBtaW5pZnlKcyhwYXJhbXM6IE1pbmlmeUpzUGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGFzaygnbWluaWZ5X2pzJywgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgc291cmNlIGlzIGV4dGVybmFsXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIHByaXZhdGUgaXNTb3VyY2VFeHRlcm5hbCgpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuc291cmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRmlsZXN0YWNrRXJyb3IoJ1NvdXJjZSBub3QgU2V0Jyk7XG4gICAgfVxuXG4gICAgbGV0IHRvVGVzdCA9IEFycmF5LmlzQXJyYXkodGhpcy5zb3VyY2UpID8gdGhpcy5zb3VyY2UgOiBbdGhpcy5zb3VyY2VdO1xuICAgIGZvciAobGV0IGkgaW4gdG9UZXN0KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKCF0b1Rlc3QuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b1Rlc3RbaV0uaW5kZXhPZignc3JjOicpID09PSAwIHx8ICh0b1Rlc3RbaV0uaW5kZXhPZignaHR0cCcpID09PSAwICYmIHRvVGVzdFtpXS5pbmRleE9mKCdmaWxlc3RhY2tjb250ZW50JykgPT09IC0xKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgZXZlcnkgdGFzayBhZ2FpbnN0IHNjaGVtYVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdFtdfSB0cmFuc2Zvcm1hdGlvbnMgLSBvYmplY3Qgd2hpY2ggY29udGFpbiBhbGwgdHJhbnNmb3JtYXRpb25zXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIHByaXZhdGUgdmFsaWRhdGVUYXNrcyh0cmFuc2Zvcm1hdGlvbnM6IG9iamVjdFtdKTogdm9pZCB7XG4gICAgY29uc3QgcmVzID0gRmlsZWxpbmsudmFsaWRhdG9yKHRoaXMuYXJyYXlUb09iamVjdCh0cmFuc2Zvcm1hdGlvbnMsICduYW1lJywgJ3BhcmFtcycpKTtcbiAgICBpZiAocmVzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBGaWxlc3RhY2tFcnJvcihgUGFyYW1zIHZhbGlkYXRpb24gZXJyb3JgLCByZXMuZXJyb3JzLCBGaWxlc3RhY2tFcnJvclR5cGUuVkFMSURBVElPTik7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29ycmVjdCBjZG4gdXJsIHdpdGggY25hbWUgc3VwcG9ydFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIHByaXZhdGUgZ2V0Q2RuSG9zdCgpOiBzdHJpbmcge1xuICAgIGxldCB1cmxzID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLnVybHMpO1xuXG4gICAgaWYgKHRoaXMuY3VzdG9tRG9tYWluKSB7XG4gICAgICB1cmxzLmNkblVybCA9IHRoaXMuY3VzdG9tRG9tYWluO1xuICAgIH1cblxuICAgIHVybHMgPSByZXNvbHZlSG9zdCh1cmxzLCB0aGlzLmNuYW1lKTtcblxuICAgIHJldHVybiB1cmxzLmNkblVybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFwcGxpZWQgdHJhbnNmb3JtYXRpb25zIGFzIHN0cmluZ1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVUcmFuc2Zvcm1TdHJpbmcoKTogc3RyaW5nIHtcbiAgICBsZXQgdHJhbnNmb3JtcyA9IFtdO1xuXG4gICAgdGhpcy50cmFuc2Zvcm1zLmZvckVhY2goZWwgPT4ge1xuICAgICAgdHJhbnNmb3Jtcy5wdXNoKHRoaXMub3B0aW9uVG9TdHJpbmcoZWwubmFtZSwgZWwucGFyYW1zKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJhbnNmb3Jtcy5qb2luKCcvJyk7XG4gIH1cblxuICAvKipcbiAgICogRmxhdHRlbiB0cmFuc2Zvcm1hdGlvbiBvcHRpb24gdG8gc3RyaW5nXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBleGFtcGxlIHtyZXNpemU6e3dpZHRoOiAxMDAsaGVpZ2h0OiAyMDB9fSA9PiByZXNpemU9d2lkdGg6MTAwLGhlaWdodDoyMDBcbiAgICogQHBhcmFtIGtleSAtIG9wdGlvbiBrZXlcbiAgICogQHBhcmFtIHZhbHVlcyAtIG9wdGlvbiBwYXJhbXNcbiAgICovXG4gIHByaXZhdGUgb3B0aW9uVG9TdHJpbmcoa2V5OiBzdHJpbmcsIHZhbHVlczogYW55KTogc3RyaW5nIHtcbiAgICBsZXQgb3B0aW9uc1N0cmluZzogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UganVzdCB3YW50IHRvIGVuYWJsZSBmZWF0dXJlXG4gICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICdib29sZWFuJykge1xuICAgICAgaWYgKCF2YWx1ZXMgJiYga2V5ID09PSAnY2FjaGUnKSB7XG4gICAgICAgIHJldHVybiAnY2FjaGU9ZmFsc2UnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChpID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlc1tpXSkpIHtcbiAgICAgICAgb3B0aW9uc1N0cmluZy5wdXNoKGAke2l9OiR7dGhpcy5hcnJheVRvU3RyaW5nKHZhbHVlc1tpXSl9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb3B0aW9uc1N0cmluZy5wdXNoKGAke2l9OiR7dGhpcy5lc2NhcGVWYWx1ZSh2YWx1ZXNbaV0pfWApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGAke2tleX09JHtvcHRpb25zU3RyaW5nLmpvaW4oJywnKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzY2FwZSBwYXJhbXMgdmFsdWVzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgRmlsZWxpbmtcbiAgICovXG4gIHByaXZhdGUgZXNjYXBlVmFsdWUodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUuaW5kZXhPZignLycpID4gLTEgfHwgdmFsdWUuaW5kZXhPZignLCcpID4gLTEpIHtcbiAgICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgbmVzdGVkIGFycmF5cyB0byBzdHJpbmdcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGV4YW1wbGUgWzEsMiwgWzIsM11dID0+IFwiWzEsMiwgWzIsM11dXCJcbiAgICogQHBhcmFtIGFyciAtIGFueSBhcnJheVxuICAgKi9cbiAgcHJpdmF0ZSBhcnJheVRvU3RyaW5nKGFycjogYW55W10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHRvUmV0dXJuID0gYXJyLm1hcChlbCA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXlUb1N0cmluZyhlbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVzY2FwZVZhbHVlKGVsKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBgWyR7dG9SZXR1cm59XWA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYXJyYXkgb2Ygb2JqZWN0cyB0byBvYmplY3RcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGV4YW1wbGUgW3tuYW1lOiAncmVzaXplJywgcGFyYW1zOiB7aGVpZ2h0OiAxMjV9fV0gPT4ge3Jlc2l6ZToge2hlaWdodDogMTI1fX1cbiAgICogQHBhcmFtIGFyciAtIGFueSBhcnJheVxuICAgKi9cbiAgcHJpdmF0ZSBhcnJheVRvT2JqZWN0ID0gKGFycmF5OiBvYmplY3RbXSA9IFtdLCBuYW1lS2V5OiBzdHJpbmcsIGRhdGFLZXk6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiBhcnJheS5yZWR1Y2UoKG9iaiwgaXRlbSkgPT4ge1xuICAgICAgb2JqW2l0ZW1bbmFtZUtleV1dID0gaXRlbVtkYXRhS2V5XTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xuICB9XG59XG4iXX0=


/***/ }),

/***/ 291:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var loader_1 = __nccwpck_require__(2995);
var filestack_error_1 = __nccwpck_require__(4257);
var schema_1 = __nccwpck_require__(2782);
var RotateDirection;
(function (RotateDirection) {
    RotateDirection["cw"] = "CW";
    RotateDirection["ccw"] = "CCW";
})(RotateDirection = exports.RotateDirection || (exports.RotateDirection = {}));
var PickerDisplayMode;
(function (PickerDisplayMode) {
    PickerDisplayMode["inline"] = "inline";
    PickerDisplayMode["overlay"] = "overlay";
    PickerDisplayMode["dropPane"] = "dropPane";
})(PickerDisplayMode = exports.PickerDisplayMode || (exports.PickerDisplayMode = {}));
/**
 * @private
 * A synchronous-looking wrapper for loading the picker and calling its methods.
 * This is currently needed because the picker module is loaded asynchronously.
 * Eventually we should offer a bundle with the picker module included.
 */
var PickerLoader = /** @class */ (function () {
    function PickerLoader(client, options) {
        var validateRes = schema_1.getValidator(schema_1.PickerParamsSchema)(options);
        if (validateRes.errors.length) {
            throw new filestack_error_1.FilestackError("Invalid picker params", validateRes.errors, filestack_error_1.FilestackErrorType.VALIDATION);
        }
        this._initialized = this.loadModule(client, options);
    }
    PickerLoader.prototype.open = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var picker;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._initialized];
                    case 1:
                        picker = _a.sent();
                        return [4 /*yield*/, picker.open()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    PickerLoader.prototype.crop = function (files) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var picker;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._initialized];
                    case 1:
                        picker = _a.sent();
                        return [4 /*yield*/, picker.crop(files)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    PickerLoader.prototype.close = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var picker;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._initialized];
                    case 1:
                        picker = _a.sent();
                        return [4 /*yield*/, picker.close()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    PickerLoader.prototype.cancel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var picker;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._initialized];
                    case 1:
                        picker = _a.sent();
                        return [4 /*yield*/, picker.cancel()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    PickerLoader.prototype.loadModule = function (client, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var url, Picker;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = client.session.urls.pickerUrl;
                        return [4 /*yield*/, loader_1.loadModule(loader_1.FILESTACK_MODULES.PICKER, url)];
                    case 1:
                        Picker = _a.sent();
                        return [2 /*return*/, new Picker(client, options)];
                }
            });
        });
    };
    return PickerLoader;
}());
/**
 * Loads and creates picker instance
 *
 * @private
 * @param client
 * @param options
 */
exports.picker = function (client, options) {
    return new PickerLoader(client, options);
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcGlja2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7OztBQUVILDRDQUFrRTtBQUNsRSx3REFBMEU7QUFHMUUsc0NBQStEO0FBK0QvRCxJQUFZLGVBR1g7QUFIRCxXQUFZLGVBQWU7SUFDekIsNEJBQVMsQ0FBQTtJQUNULDhCQUFVLENBQUE7QUFDWixDQUFDLEVBSFcsZUFBZSxHQUFmLHVCQUFlLEtBQWYsdUJBQWUsUUFHMUI7QUErR0QsSUFBWSxpQkFJWDtBQUpELFdBQVksaUJBQWlCO0lBQzNCLHNDQUFpQixDQUFBO0lBQ2pCLHdDQUFtQixDQUFBO0lBQ25CLDBDQUFxQixDQUFBO0FBQ3ZCLENBQUMsRUFKVyxpQkFBaUIsR0FBakIseUJBQWlCLEtBQWpCLHlCQUFpQixRQUk1QjtBQTZpQkQ7Ozs7O0dBS0c7QUFDSDtJQUdFLHNCQUFZLE1BQWMsRUFBRSxPQUF1QjtRQUNqRCxJQUFNLFdBQVcsR0FBRyxxQkFBWSxDQUFDLDJCQUFrQixDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFOUQsSUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTtZQUM3QixNQUFNLElBQUksZ0NBQWMsQ0FBQyx1QkFBdUIsRUFBRSxXQUFXLENBQUMsTUFBTSxFQUFFLG9DQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ3RHO1FBRUQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUssMkJBQUksR0FBVjs7Ozs7NEJBQ2lCLHFCQUFNLElBQUksQ0FBQyxZQUFZLEVBQUE7O3dCQUFoQyxNQUFNLEdBQUcsU0FBdUI7d0JBQ3RDLHFCQUFNLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBQTs7d0JBQW5CLFNBQW1CLENBQUM7Ozs7O0tBQ3JCO0lBRUssMkJBQUksR0FBVixVQUFXLEtBQVk7Ozs7OzRCQUNOLHFCQUFNLElBQUksQ0FBQyxZQUFZLEVBQUE7O3dCQUFoQyxNQUFNLEdBQUcsU0FBdUI7d0JBQ3RDLHFCQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUE7O3dCQUF4QixTQUF3QixDQUFDOzs7OztLQUMxQjtJQUVLLDRCQUFLLEdBQVg7Ozs7OzRCQUNpQixxQkFBTSxJQUFJLENBQUMsWUFBWSxFQUFBOzt3QkFBaEMsTUFBTSxHQUFHLFNBQXVCO3dCQUN0QyxxQkFBTSxNQUFNLENBQUMsS0FBSyxFQUFFLEVBQUE7O3dCQUFwQixTQUFvQixDQUFDOzs7OztLQUN0QjtJQUVLLDZCQUFNLEdBQVo7Ozs7OzRCQUNpQixxQkFBTSxJQUFJLENBQUMsWUFBWSxFQUFBOzt3QkFBaEMsTUFBTSxHQUFHLFNBQXVCO3dCQUN0QyxxQkFBTSxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUE7O3dCQUFyQixTQUFxQixDQUFDOzs7OztLQUN2QjtJQUVhLGlDQUFVLEdBQXhCLFVBQXlCLE1BQWMsRUFBRSxPQUF1Qjs7Ozs7O3dCQUN4QixHQUFHLEdBQVMsTUFBTSx1QkFBZixDQUFnQjt3QkFDMUMscUJBQU0sbUJBQVUsQ0FBQywwQkFBaUIsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEVBQUE7O3dCQUF4RCxNQUFNLEdBQUcsU0FBK0M7d0JBQzlELHNCQUFPLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsRUFBQzs7OztLQUNwQztJQUNILG1CQUFDO0FBQUQsQ0F0Q0EsQUFzQ0MsSUFBQTtBQUVEOzs7Ozs7R0FNRztBQUNVLFFBQUEsTUFBTSxHQUFHLFVBQUMsTUFBYyxFQUFFLE9BQXVCO0lBQzVELE9BQU8sSUFBSSxZQUFZLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQzNDLENBQUMsQ0FBQyIsImZpbGUiOiJsaWIvcGlja2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2tcbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBsb2FkTW9kdWxlLCBGSUxFU1RBQ0tfTU9EVUxFUyB9IGZyb20gJ0BmaWxlc3RhY2svbG9hZGVyJztcbmltcG9ydCB7IEZpbGVzdGFja0Vycm9yLCBGaWxlc3RhY2tFcnJvclR5cGUgfSBmcm9tICcuLy4uL2ZpbGVzdGFja19lcnJvcic7XG5pbXBvcnQgeyBDbGllbnQgfSBmcm9tICcuL2NsaWVudCc7XG5pbXBvcnQgeyBGU1Byb2dyZXNzRXZlbnQsIFVwbG9hZE9wdGlvbnMsIFdvcmtmbG93Q29uZmlnIH0gZnJvbSAnLi9hcGkvdXBsb2FkL3R5cGVzJztcbmltcG9ydCB7IGdldFZhbGlkYXRvciwgUGlja2VyUGFyYW1zU2NoZW1hIH0gZnJvbSAnLi8uLi9zY2hlbWEnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBpY2tlckluc3RhbmNlIHtcbiAgLyoqXG4gICAqIENsb3NlIHBpY2tlci4gVGhpcyBvcGVyYXRpb24gaXMgaWRlbXBvdGVudC5cbiAgICovXG4gIGNsb3NlOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBDYW5jZWwgcGlja2VyIHVwbG9hZHMuIFRoaXMgb3BlcmF0aW9uIGlzIGlkZW1wb3RlbnQuXG4gICAqL1xuICBjYW5jZWw6ICgpID0+IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIE9wZW4gcGlja2VyLiBUaGlzIG9wZXJhdGlvbiBpcyBpZGVtcG90ZW50LlxuICAgKi9cbiAgb3BlbjogKCkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogU3BlY2lmeSBhIGxpc3Qgb2YgZmlsZXMgdG8gb3BlbiBpbiB0aGUgcGlja2VyIGZvciBjcm9wcGluZ1xuICAgKlxuICAgKiAjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyA8aW5wdXQgaWQ9XCJmaWxlU2VsZWN0XCIgdHlwZT1cImZpbGVcIj5cbiAgICpcbiAgICogY29uc3QgaW5wdXRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWxlU2VsZWN0Jyk7XG4gICAqIGNvbnN0IHBpY2tlciA9IGNsaWVudC5waWNrZXIoe1xuICAgKiAgIG9uVXBsb2FkRG9uZTogcmVzID0+IGNvbnNvbGUubG9nKHJlcyksXG4gICAqIH0pO1xuICAgKlxuICAgKiBpbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAqICAgcGlja2VyLmNyb3AoZS50YXJnZXQuZmlsZXMpO1xuICAgKiB9KTtcbiAgICpcbiAgICogLy8gT3IgcGFzcyBhbiBhcnJheSBvZiBVUkwgc3RyaW5nc1xuICAgKiBjb25zdCB1cmxzID0gW1xuICAgKiAgICdodHRwczovL2Qxd3RxYWZmYWFqNjN6LmNsb3VkZnJvbnQubmV0L2ltYWdlcy9mb3hfaW5fZm9yZXN0MS5qcGcnLFxuICAgKiAgICdodHRwczovL2Qxd3RxYWZmYWFqNjN6LmNsb3VkZnJvbnQubmV0L2ltYWdlcy9zYWlsLmpwZycsXG4gICAqIF07XG4gICAqIHBpY2tlci5jcm9wKHVybHMpO1xuICAgKiBgYGBcbiAgICovXG4gIGNyb3A6IChmaWxlczogYW55W10pID0+IFByb21pc2U8dm9pZD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGlja2VyQ3JvcHBlZERhdGEge1xuICBjcm9wQXJlYToge1xuICAgIC8qKlxuICAgICAqIFt4LCB5XVxuICAgICAqL1xuICAgIHBvc2l0aW9uOiBbbnVtYmVyLCBudW1iZXJdO1xuICAgIC8qKlxuICAgICAqIFt3aWR0aCwgaGVpZ2h0XVxuICAgICAqL1xuICAgIHNpemU6IFtudW1iZXIsIG51bWJlcl07XG4gIH07XG4gICAgLyoqXG4gICAgICogW3dpZHRoLCBoZWlnaHRdXG4gICAgICovXG4gIG9yaWdpbmFsSW1hZ2VTaXplOiBbbnVtYmVyLCBudW1iZXJdO1xufVxuXG5leHBvcnQgZW51bSBSb3RhdGVEaXJlY3Rpb24ge1xuICBjdyA9ICdDVycsXG4gIGNjdz0gJ0NDVycsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGlja2VyUm90YXRlZERhdGEge1xuICAvKipcbiAgICogQW1vdW50IHJvdGF0ZWQgaW4gZGVncmVlcy5cbiAgICovXG4gIHZhbHVlOiBudW1iZXI7XG4gIC8qKlxuICAgKiBDYW4gYmUgQ1cgb3IgQ0NXIChjbG9ja3dpc2UgLyBjb3VudGVyLWNsb2Nrd2lzZSlcbiAgICovXG4gIGRpcmVjdGlvbjogUm90YXRlRGlyZWN0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBpY2tlckZpbGVNZXRhZGF0YSB7XG4gIC8qKlxuICAgKiBUaGUgY2xvdWQgY29udGFpbmVyIGZvciB0aGUgdXBsb2FkZWQgZmlsZS5cbiAgICovXG4gIGNvbnRhaW5lcj86IHN0cmluZztcbiAgLyoqXG4gICAqIFBvc2l0aW9uIGFuZCBzaXplIGluZm9ybWF0aW9uIGZvciBjcm9wcGVkIGltYWdlcy5cbiAgICovXG4gIGNyb3BwZWQ/OiBQaWNrZXJDcm9wcGVkRGF0YTtcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGZpbGUuXG4gICAqL1xuICBmaWxlbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogRmlsZXN0YWNrIGhhbmRsZSBmb3IgdGhlIHVwbG9hZGVkIGZpbGUuXG4gICAqL1xuICBoYW5kbGU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBoYXNoLXByZWZpeGVkIGNsb3VkIHN0b3JhZ2UgcGF0aC5cbiAgICovXG4gIGtleT86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBNSU1FIHR5cGUgb2YgdGhlIGZpbGUuXG4gICAqL1xuICBtaW1ldHlwZTogc3RyaW5nO1xuICAvKipcbiAgICogUHJvcGVydGllcyBvZiB0aGUgbG9jYWwgYmluYXJ5IGZpbGUuIEFsc28gc2VlIHRoZSBwaWNrIG9wdGlvbiBgZXhwb3NlT3JpZ2luYWxGaWxlYCBpZiB5b3Ugd2FudCB0aGUgdW5kZXJseWluZyBgRmlsZWAgb2JqZWN0LlxuICAgKi9cbiAgb3JpZ2luYWxGaWxlPzogb2JqZWN0IHwgRmlsZTtcbiAgLyoqXG4gICAqIFRoZSBvcmlnaW4gb2YgdGhlIGZpbGUsIGUuZy4gL0ZvbGRlci9maWxlLmpwZy5cbiAgICovXG4gIG9yaWdpbmFsUGF0aDogc3RyaW5nO1xuICAvKipcbiAgICogRGlyZWN0aW9uIGFuZCB2YWx1ZSBpbmZvcm1hdGlvbiBmb3Igcm90YXRlZCBpbWFnZXMuXG4gICAqL1xuICByb3RhdGVkPzogUGlja2VyUm90YXRlZERhdGE7XG4gIC8qKlxuICAgKiBTaXplIGluIGJ5dGVzIG9mIHRoZSB1cGxvYWRlZCBmaWxlLlxuICAgKi9cbiAgc2l6ZTogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIHNvdXJjZSBmcm9tIHdoZXJlIHRoZSBmaWxlIHdhcyBwaWNrZWQuXG4gICAqL1xuICBzb3VyY2U6IHN0cmluZztcbiAgLyoqXG4gICAqIEluZGljYXRlcyBGaWxlc3RhY2sgdHJhbnNpdCBzdGF0dXMuXG4gICAqL1xuICBzdGF0dXM/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBIHV1aWQgZm9yIHRyYWNraW5nIHRoaXMgZmlsZSBpbiBjYWxsYmFja3MuXG4gICAqL1xuICB1cGxvYWRJZDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIEZpbGVzdGFjayBDRE4gVVJMIGZvciB0aGUgdXBsb2FkZWQgZmlsZS5cbiAgICovXG4gIHVybDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbUF1dGhUZXh0T3B0aW9ucyB7XG4gIFtrZXk6IHN0cmluZ106IHtcbiAgICB0b3A/OiBzdHJpbmdbXSxcbiAgICBib3R0b20/OiBzdHJpbmdbXVxuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBpY2tlclJlc3BvbnNlIHtcbiAgZmlsZXNVcGxvYWRlZDogUGlja2VyRmlsZU1ldGFkYXRhW107XG4gIGZpbGVzRmFpbGVkOiBQaWNrZXJGaWxlTWV0YWRhdGFbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQaWNrZXJGaWxlQ2FsbGJhY2sge1xuICAoZmlsZTogUGlja2VyRmlsZU1ldGFkYXRhKTogdm9pZCB8IFByb21pc2U8YW55Pjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgUGlja2VyRmlsZVdpdGhUb2tlbkNhbGxiYWNrIHtcbiAgKGZpbGU6IFBpY2tlckZpbGVNZXRhZGF0YSwgdG9rZW4/OiB7cGF1c2U/OiAoKSA9PiB2b2lkLCByZXN1bWU/OiAoKSA9PiB2b2lkLCBjYW5jZWw/OiAoKSA9PiB2b2lkfSk6IHZvaWQgfCBQcm9taXNlPGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGlja2VyRmlsZUNhbmNlbENhbGxiYWNrIHtcbiAgKGZpbGU6IFBpY2tlckZpbGVNZXRhZGF0YSk6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGlja2VyRmlsZUVycm9yQ2FsbGJhY2sge1xuICAoZmlsZTogUGlja2VyRmlsZU1ldGFkYXRhLCBlcnJvcjogRXJyb3IpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBpY2tlckZpbGVQcm9ncmVzc0NhbGxiYWNrIHtcbiAgKGZpbGU6IFBpY2tlckZpbGVNZXRhZGF0YSwgZXZlbnQ6IEZTUHJvZ3Jlc3NFdmVudCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGlja2VyVXBsb2FkU3RhcnRlZENhbGxiYWNrIHtcbiAgKGZpbGVzOiBQaWNrZXJGaWxlTWV0YWRhdGFbXSk6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGlja2VyVXBsb2FkRG9uZUNhbGxiYWNrIHtcbiAgKGZpbGVzOiBQaWNrZXJSZXNwb25zZSk6IHZvaWQ7XG59XG5cbmV4cG9ydCBlbnVtIFBpY2tlckRpc3BsYXlNb2RlIHtcbiAgaW5saW5lID0gJ2lubGluZScsXG4gIG92ZXJsYXkgPSAnb3ZlcmxheScsXG4gIGRyb3BQYW5lID0gJ2Ryb3BQYW5lJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQaWNrZXJEcm9wUGFuZU9wdGlvbnMge1xuICAvKipcbiAgICogVG9nZ2xlIHRoZSBjcm9wIFVJIGZvciBkcm9wcGVkIGZpbGVzLlxuICAgKi9cbiAgY3JvcEZpbGVzPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEN1c3RvbWl6ZSB0aGUgdGV4dCBjb250ZW50IGluIHRoZSBkcm9wIHBhbmUuXG4gICAqL1xuICBjdXN0b21UZXh0Pzogc3RyaW5nO1xuICAvKipcbiAgICogRGlzYWJsZSB0aGUgZmlsZSBpbnB1dCBvbiBjbGljay4gVGhpcyBkb2VzIG5vdCBkaXNhYmxlIHRoZSBgb25DbGlja2AgY2FsbGJhY2suXG4gICAqL1xuICBkaXNhYmxlQ2xpY2s/OiBib29sZWFuO1xuICAvKipcbiAgICogVG9nZ2xlIHRoZSBmdWxsLXBhZ2UgZHJvcCB6b25lIG92ZXJsYXkuXG4gICAqL1xuICBvdmVybGF5PzogYm9vbGVhbjtcbiAgb25EcmFnRW50ZXI/OiAoZXZ0OiBEcmFnRXZlbnQpID0+IHZvaWQ7XG4gIG9uRHJhZ0xlYXZlPzogKCkgPT4gdm9pZDtcbiAgb25EcmFnT3Zlcj86IChldnQ6IERyYWdFdmVudCkgPT4gdm9pZDtcbiAgb25Ecm9wPzogKGV2dDogRHJhZ0V2ZW50KSA9PiB2b2lkO1xuICAvKipcbiAgICogYG9uU3VjY2Vzc2AgbXVzdCBiZSB1c2VkIGluc3RlYWQgb2YgYG9uVXBsb2FkRG9uZWAuIFRoZSBkcm9wIHBhbmUgdXNlcyBpdHMgb3duIGNhbGxiYWNrcyBmb3IgY29tcGF0aWJpbGl0eSBwdXJwb3Nlcy4gVGhpcyBtaWdodCBldmVudHVhbGx5IGNoYW5nZS5cbiAgICovXG4gIG9uU3VjY2Vzcz86IChmaWxlczogUGlja2VyRmlsZU1ldGFkYXRhW10pID0+IHZvaWQ7XG4gIG9uRXJyb3I/OiAoZmlsZXM6IFBpY2tlckZpbGVNZXRhZGF0YVtdKSA9PiB2b2lkO1xuICBvblByb2dyZXNzPzogKHBlcmNlbnQ6IG51bWJlcikgPT4gdm9pZDtcbiAgb25DbGljaz86IChldnQ6IGFueSkgPT4gdm9pZDtcbiAgLyoqXG4gICAqIFRvZ2dsZSBpY29uIGVsZW1lbnQgaW4gZHJvcCBwYW5lLlxuICAgKi9cbiAgc2hvd0ljb24/OiBib29sZWFuO1xuICAvKipcbiAgICogVG9nZ2xlIHVwbG9hZCBwcm9ncmVzcyBkaXNwbGF5LlxuICAgKi9cbiAgc2hvd1Byb2dyZXNzPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQaWNrZXJTdG9yZU9wdGlvbnMge1xuICAvKipcbiAgICogTG9jYXRpb24gZm9yIHN0b3JlZCBmaWxlLiBPbmUgb2YgJ3MzJywgJ2djcycsICdhenVyZScsICdyYWNrc3BhY2UnLCBvciAnZHJvcGJveCcuXG4gICAqL1xuICBsb2NhdGlvbj86IHN0cmluZztcbiAgLyoqXG4gICAqIFNwZWNpZnkgc3RvcmFnZSBjb250YWluZXIuXG4gICAqL1xuICBjb250YWluZXI/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBTZXQgY29udGFpbmVyIHBhdGguIEluZGljYXRlIGEgZm9sZGVyIGJ5IGFkZGluZyBhIHRyYWlsaW5nIHNsYXNoLiBXaXRob3V0IGEgdHJhaWxpbmcgc2xhc2ggYWxsIGZpbGVzIHdpbGwgYmUgc3RvcmVkIHRvIHRoZSBzYW1lIG9iamVjdC5cbiAgICovXG4gIHBhdGg/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IFMzIHJlZ2lvbi5cbiAgICovXG4gIHJlZ2lvbj86IHN0cmluZztcbiAgLyoqXG4gICAqIFMzIGNvbnRhaW5lciBhY2Nlc3MuICdwdWJsaWMnIG9yICdwcml2YXRlJy5cbiAgICovXG4gIGFjY2Vzcz86IHN0cmluZztcblxuICAvKipcbiAgICogV29ya2Zsb3dzIGlkcyB0byBydW4gYWZ0ZXIgdXBsb2FkXG4gICAqL1xuICB3b3JrZmxvd3M/OiBzdHJpbmdbXSB8IFdvcmtmbG93Q29uZmlnW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGlja2VyQ3VzdG9tVGV4dCB7XG4gIC8vIEFjdGlvbnNcbiAgVXBsb2FkPzogc3RyaW5nO1xuICAnVXBsb2FkIG1vcmUnPzogc3RyaW5nO1xuICAnRGVzZWxlY3QgQWxsJz86IHN0cmluZztcbiAgJ1ZpZXcvRWRpdCBTZWxlY3RlZCc/OiBzdHJpbmc7XG4gICdTaWduIE91dCc/OiBzdHJpbmc7XG5cbiAgLy8gU291cmNlIExhYmVsc1xuICAnTXkgRGV2aWNlJz86IHN0cmluZztcbiAgJ1dlYiBTZWFyY2gnPzogc3RyaW5nO1xuICAnVGFrZSBQaG90byc/OiBzdHJpbmc7XG4gICdMaW5rIChVUkwpJz86IHN0cmluZztcbiAgJ1JlY29yZCBWaWRlbyc/OiBzdHJpbmc7XG4gICdSZWNvcmQgQXVkaW8nPzogc3RyaW5nO1xuXG4gIC8vIEN1c3RvbSBTb3VyY2VcbiAgJ0N1c3RvbSBTb3VyY2UnPzogc3RyaW5nO1xuXG4gIC8vIEZvb3RlciBUZXh0XG4gIEFkZD86IHN0cmluZztcbiAgJ21vcmUgZmlsZSc/OiBzdHJpbmc7XG4gICdtb3JlIGZpbGVzJz86IHN0cmluZztcblxuICAvLyBDbG91ZFxuICAnQ29ubmVjdCB7cHJvdmlkZXJOYW1lfSc/OiBzdHJpbmc7XG4gICdTZWxlY3QgRmlsZXMgZnJvbSB7cHJvdmlkZXJOYW1lfSc/OiBzdHJpbmc7XG4gICdZb3UgbmVlZCB0byBhdXRoZW50aWNhdGUgd2l0aCB7cHJvdmlkZXJOYW1lfS4nPzogc3RyaW5nO1xuICAnQSBuZXcgcGFnZSB3aWxsIG9wZW4gdG8gY29ubmVjdCB5b3VyIGFjY291bnQuJz86IHN0cmluZztcbiAgJ1dlIG9ubHkgZXh0cmFjdCBpbWFnZXMgYW5kIG5ldmVyIG1vZGlmeSBvciBkZWxldGUgdGhlbS4nPzogc3RyaW5nO1xuICAnVG8gZGlzY29ubmVjdCBmcm9tIHtwcm92aWRlck5hbWV9IGNsaWNrIFwiU2lnbiBvdXRcIiBidXR0b24gaW4gdGhlIG1lbnUuJz86IHN0cmluZztcbiAgJ1NpZ24gaW4gd2l0aCBHb29nbGUnPzogc3RyaW5nO1xuICAnR28gYmFjayc/OiBzdHJpbmc7XG4gICdUaGlzIGZvbGRlciBpcyBlbXB0eS4nPzogc3RyaW5nO1xuXG4gIC8vIFN1bW1hcnlcbiAgRmlsZXM/OiBzdHJpbmc7XG4gIEltYWdlcz86IHN0cmluZztcbiAgVXBsb2FkZWQ/OiBzdHJpbmc7XG4gIFVwbG9hZGluZz86IHN0cmluZztcbiAgQ29tcGxldGVkPzogc3RyaW5nO1xuICBGaWx0ZXI/OiBzdHJpbmc7XG4gICdDcm9wcGVkIEltYWdlcyc/OiBzdHJpbmc7XG4gICdFZGl0ZWQgSW1hZ2VzJz86IHN0cmluZztcbiAgJ1NlbGVjdGVkIEZpbGVzJz86IHN0cmluZztcbiAgJ0Nyb3AgaXMgcmVxdWlyZWQgb24gaW1hZ2VzJz86IHN0cmluZztcblxuICAvLyBUcmFuc2Zvcm1cbiAgQ3JvcD86IHN0cmluZztcbiAgQ2lyY2xlPzogc3RyaW5nO1xuICBSb3RhdGU/OiBzdHJpbmc7XG4gIE1hc2s/OiBzdHJpbmc7XG4gIFJldmVydD86IHN0cmluZztcbiAgRWRpdD86IHN0cmluZztcbiAgUmVzZXQ/OiBzdHJpbmc7XG4gIERvbmU/OiBzdHJpbmc7XG4gIFNhdmU/OiBzdHJpbmc7XG4gIE5leHQ/OiBzdHJpbmc7XG4gICdFZGl0IEltYWdlJz86IHN0cmluZztcbiAgJ1RoaXMgaW1hZ2UgY2Fubm90IGJlIGVkaXRlZCc/OiBzdHJpbmc7XG5cbiAgLy8gUmV0cnkgbWVzc2FnaW5nXG4gICdDb25uZWN0aW9uIExvc3QnPzogc3RyaW5nO1xuICAnRmFpbGVkIFdoaWxlIFVwbG9hZGluZyc/OiBzdHJpbmc7XG4gICdSZXRyeWluZyBpbic/OiBzdHJpbmc7XG4gICdUcnkgYWdhaW4nPzogc3RyaW5nO1xuICAnVHJ5IG5vdyc/OiBzdHJpbmc7XG5cbiAgLy8gTG9jYWwgRmlsZSBTb3VyY2VcbiAgJ0RyYWcgYW5kIERyb3AsIENvcHkgYW5kIFBhc3RlIEZpbGVzJz86IHN0cmluZztcbiAgJ29yIERyYWcgYW5kIERyb3AsIENvcHkgYW5kIFBhc3RlIEZpbGVzJz86IHN0cmluZztcbiAgJ1NlbGVjdCBGaWxlcyB0byBVcGxvYWQnPzogc3RyaW5nO1xuICAnU2VsZWN0IEZyb20nPzogc3RyaW5nO1xuICAnRHJvcCB5b3VyIGZpbGVzIGFueXdoZXJlJz86IHN0cmluZztcblxuICAvLyBJbnB1dCBwbGFjZWhvbGRlcnNcbiAgJ0VudGVyIGEgVVJMJz86IHN0cmluZztcbiAgJ1NlYXJjaCBpbWFnZXMnPzogc3RyaW5nO1xuXG4gIC8vIFdlYmNhbSBTb3VyY2VcbiAgJ1dlYmNhbSBEaXNhYmxlZCc/OiBzdHJpbmc7XG4gICdXZWJjYW0gTm90IFN1cHBvcnRlZCc/OiBzdHJpbmc7XG4gICdQbGVhc2UgZW5hYmxlIHlvdXIgd2ViY2FtIHRvIHRha2UgYSBwaG90by4nPzogc3RyaW5nO1xuICAnWW91ciBjdXJyZW50IGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB3ZWJjYW0gZnVuY3Rpb25hbGl0eS4nPzogc3RyaW5nO1xuICAnV2Ugc3VnZ2VzdCB1c2luZyBDaHJvbWUgb3IgRmlyZWZveC4nPzogc3RyaW5nO1xuXG4gIC8vIEVycm9yIE5vdGlmaWNhdGlvbnNcbiAgJ0ZpbGUge2Rpc3BsYXlOYW1lfSBpcyBub3QgYW4gYWNjZXB0ZWQgZmlsZSB0eXBlLiBUaGUgYWNjZXB0ZWQgZmlsZSB0eXBlcyBhcmUge3R5cGVzfSc/OiBzdHJpbmc7XG4gICdGaWxlIHtkaXNwbGF5TmFtZX0gaXMgdG9vIGJpZy4gVGhlIGFjY2VwdGVkIGZpbGUgc2l6ZSBpcyBsZXNzIHRoYW4ge3JvdW5kRmlsZVNpemV9Jz86IHN0cmluZztcbiAgJ091ciBmaWxlIHVwbG9hZCBsaW1pdCBpcyB7bWF4RmlsZXN9IHtmaWxlc1RleHR9Jz86IHN0cmluZztcbiAgJ05vIHNlYXJjaCByZXN1bHRzIGZvdW5kIGZvciBcIntzZWFyY2h9XCInPzogc3RyaW5nO1xuICAnQW4gZXJyb3Igb2NjdXJyZWQuIFBsZWFzZSB0cnkgYWdhaW4uJz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQaWNrZXJPcHRpb25zIHtcbiAgLyoqXG4gICAqIFJlc3RyaWN0IGZpbGUgdHlwZXMgdGhhdCBhcmUgYWxsb3dlZCB0byBiZSBwaWNrZWQuIEZvcm1hdHMgYWNjZXB0ZWQ6XG4gICAqICAtIC5wZGYgPC0gYW55IGZpbGUgZXh0ZW5zaW9uXG4gICAqICAtIGltYWdlL2pwZWcgPC0gYW55IG1pbWUgdHlwZSBjb21tb25seSBrbm93biBieSBicm93c2Vyc1xuICAgKiAgLSBpbWFnZS8qIDwtIGFjY2VwdCBhbGwgdHlwZXMgb2YgaW1hZ2VzXG4gICAqICAtIHZpZGVvLyogPC0gYWNjZXB0IGFsbCB0eXBlcyBvZiB2aWRlbyBmaWxlc1xuICAgKiAgLSBhdWRpby8qIDwtIGFjY2VwdCBhbGwgdHlwZXMgb2YgYXVkaW8gZmlsZXNcbiAgICogIC0gYXBwbGljYXRpb24vKiA8LSBhY2NlcHQgYWxsIHR5cGVzIG9mIGFwcGxpY2F0aW9uIGZpbGVzXG4gICAqICAtIHRleHQvKiA8LSBhY2NlcHQgYWxsIHR5cGVzIG9mIHRleHQgZmlsZXNcbiAgICovXG4gIGFjY2VwdD86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAvKipcbiAgICogQ3VzdG9tIGFjY2VwdCBjaGVjayBmdW5jdGlvblxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGFjY2VwdEZuOiAoZmlsZSwgb3B0aW9ucykgPT4ge1xuICAgKiAgcmV0dXJuIG9wdGlvbnMubWltZUZyb21NYWdpY0J5dGVzKGZpbGUub3JpZ2luYWxGaWxlKS50aGVuKChyZXMpID0+IHsgLy8gd2UgY2FuIGNoZWNrIG1pbWV0eXBlIGZyb20gbWFnaWMgYnl0ZXNcbiAgICogICAgLy9jb25zb2xlLmxvZyhvcHRpb25zLm1pbWVGcm9tRXh0ZW5zaW9uKGZpbGUub3JpZ2luYWxGaWxlLm5hbWUpKTsgLy8gb3IgY2hlY2sgZXh0ZW5zaW9uIGZyb20gZmlsZXN0YWNrIGV4dGVuc2lvbnMgZGF0YWJhc2VcbiAgICogICAgLy8gdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWNjZXB0IHRoYXQgZmlsZScpIC8vIHdlIGNhbiB0aHJvdyBleGNlcHRpb24gdG8gYmxvY2sgZmlsZSB1cGxvYWRcbiAgICogICAgLy8gcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5ub3QgYWNjZXB0IHRoYXQgZmlsZScnKSAvLyBvciByZWplY3QgYSBwcm9taXNlXG4gICAqICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICogIH0pO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgYWNjZXB0Rm4/OiAoUGlja2VyRmlsZU1ldGFkYXRhLCBQaWNrZXJBY2NlcHRGbk9wdGlvbnMpID0+IFByb21pc2U8c3RyaW5nPjtcbiAgLyoqXG4gICAqIFByZXZlbnQgbW9kYWwgY2xvc2Ugb24gdXBsb2FkIGZhaWx1cmUgYW5kIGFsbG93IHVzZXJzIHRvIHJldHJ5LlxuICAgKi9cbiAgYWxsb3dNYW51YWxSZXRyeT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiAgVmFsaWQgc291cmNlcyBhcmU6XG4gICAqICAtIGxvY2FsX2ZpbGVfc3lzdGVtIC0gRGVmYXVsdFxuICAgKiAgLSB1cmwgLSBEZWZhdWx0XG4gICAqICAtIGltYWdlc2VhcmNoIC0gRGVmYXVsdFxuICAgKiAgLSBmYWNlYm9vayAtIERlZmF1bHRcbiAgICogIC0gaW5zdGFncmFtIC0gRGVmYXVsdFxuICAgKiAgLSBnb29nbGVkcml2ZSAtIERlZmF1bHRcbiAgICogIC0gZHJvcGJveCAtIERlZmF1bHRcbiAgICogIC0gd2ViY2FtIC0gVXNlcyBkZXZpY2UgbWVudSBvbiBtb2JpbGUuIE5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGluIFNhZmFyaSBhbmQgSUUuXG4gICAqICAtIHZpZGVvIC0gVXNlcyBkZXZpY2UgbWVudSBvbiBtb2JpbGUuIE5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGluIFNhZmFyaSBhbmQgSUUuXG4gICAqICAtIGF1ZGlvIC0gVXNlcyBkZXZpY2UgbWVudSBvbiBtb2JpbGUuIE5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGluIFNhZmFyaSBhbmQgSUUuXG4gICAqICAtIGJveFxuICAgKiAgLSBnaXRodWJcbiAgICogIC0gZ21haWxcbiAgICogIC0gZ29vZ2xlcGhvdG9zXG4gICAqICAtIG9uZWRyaXZlXG4gICAqICAtIG9uZWRyaXZlZm9yYnVzaW5lc3NcbiAgICogIC0gY3VzdG9tc291cmNlIC0gQ29uZmlndXJlIHRoaXMgaW4geW91ciBGaWxlc3RhY2sgRGV2IFBvcnRhbC5cbiAgICogIC0gdW5zcGxhc2hcbiAgICovXG4gIGZyb21Tb3VyY2VzPzogc3RyaW5nW107XG4gIC8qKlxuICAgKiBDb250YWluZXIgd2hlcmUgcGlja2VyIHNob3VsZCBiZSBhcHBlbmRlZC4gT25seSByZWxldmFudCBmb3IgYGlubGluZWAgYW5kIGBkcm9wUGFuZWAgZGlzcGxheSBtb2Rlcy5cbiAgICovXG4gIGNvbnRhaW5lcj86IHN0cmluZyB8IE5vZGU7XG5cbiAgLyoqXG4gICAqIFR1cm4gb24gY2xlYW5pbmcgSlBFRyBpbWFnZSBleGlmLiBNZXRob2QgY2FuIGtlZXAgaW1hZ2Ugb3JpZW50YXRpb24gb3IgY29sb3IgcHJvZmlsZXNcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjbGVhbnVwSW1hZ2VFeGlmOiB7XG4gICAqICAga2VlcE9yaWVudGF0aW9uOiB0cnVlXG4gICAqICAga2VlcElDQ2FuZEFQUDogdHJ1ZVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgY2xlYW51cEltYWdlRXhpZj86IGJvb2xlYW4gfCB7XG4gICAga2VlcE9yaWVudGF0aW9uPzogYm9vbGVhbixcbiAgICBrZWVwSUNDYW5kQVBQPzogYm9vbGVhblxuICB9O1xuICAvKipcbiAgICogQ3VzdG9taXplIHRoZSB0ZXh0IG9uIHRoZSBjbG91ZCBhdXRoZW50aWNhdGlvbiBzY3JlZW4gaW4gUGlja2VyLlxuICAgKiBVc2UgYSBjbG91ZCBzb3VyY2UgbmFtZSAoc2VlIFtbUGlja2VyT3B0aW9ucy5mcm9tU291cmNlc11dKVxuICAgKiBvciBhICdkZWZhdWx0JyBhcyBhIGtleSwgdGhlbiBwdXQgeW91ciBjdXN0b20gbm90aWNlIG9yIGNvbnNlbnRcbiAgICogdG8gdGhlICd0b3AnIG9yIHRoZSAnYm90dG9tJyBrZXkgdG8gc2hvdyBpdCByZXNwZWN0aXZseSBhYm92ZSBvciB1bmRlciAnQ29ubmVjdCBidXR0b24nLlxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGN1c3RvbUF1dGhUZXh0OiB7XG4gICAqICAgLy8gdXNlIGl0IGZvciBldmVyeSBjbG91ZCBhdXRoZW50aWNhdGlvbiBzY3JlZW5cbiAgICogICBkZWZhdWx0OiB7XG4gICAqICAgICB0b3A6IFtcbiAgICogICAgICAgJ2RlZmF1bHQgdG9wIGZpcnN0IGxpbmUnLFxuICAgKiAgICAgICAnZGVmYXVsdCB0b3Agc2Vjb25kIGxpbmUnXG4gICAqICAgICBdLFxuICAgKiAgICAgYm90dG9tOiBbXG4gICAqICAgICAgICdkZWZhdWx0IGJvdHRvbSBmaXJzdCBsaW5lJyxcbiAgICogICAgICAgJ2RlZmF1bHQgYm90dG9tIHNlY29uZCBsaW5lJ1xuICAgKiAgICAgXVxuICAgKiAgIH0sXG4gICAqICAgLy8gb3ZlcnJpZGUgYSBkZWZhdWx0IGJvdHRvbSB0ZXh0IGZvciBvbmx5IGdtYWlsXG4gICAqICAgZ21haWw6IHtcbiAgICogICAgIGJvdHRvbTogW1xuICAgKiAgICAgICAnV2UgbmVlZCB5b3VyIHBlcm1pc3Npb24gdG8gYWNjZXNzIHlvdXIgZGF0YSBhbmQnLFxuICAgKiAgICAgICAncHJvY2VzcyBpdCB3aXRoIG91ciBtYWNoaW5lIGxlYXJuaW5nIHN5c3RlbS4nXG4gICAqICAgICBdXG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgY3VzdG9tQXV0aFRleHQ/OiBDdXN0b21BdXRoVGV4dE9wdGlvbnM7XG4gIC8qKlxuICAgKiBQaWNrZXIgZGlzcGxheSBtb2RlLCBvbmUgb2YgYCdpbmxpbmUnYCwgYCdvdmVybGF5J2AsIGAnZHJvcFBhbmUnYCAtIGRlZmF1bHQgaXMgYCdvdmVybGF5J2AuXG4gICAqL1xuICBkaXNwbGF5TW9kZT86IFBpY2tlckRpc3BsYXlNb2RlO1xuICAvKipcbiAgICogTWF4IG51bWJlciBvZiBmaWxlcyB0byB1cGxvYWQgY29uY3VycmVudGx5LiBEZWZhdWx0IGlzIDQuXG4gICAqL1xuICBjb25jdXJyZW5jeT86IG51bWJlcjtcbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBjb250YWluZXIgZm9yIHlvdXIgY3VzdG9tIHNvdXJjZS5cbiAgICovXG4gIGN1c3RvbVNvdXJjZUNvbnRhaW5lcj86IHN0cmluZztcbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBwYXRoIGZvciB5b3VyIGN1c3RvbSBzb3VyY2UgY29udGFpbmVyLlxuICAgKi9cbiAgY3VzdG9tU291cmNlUGF0aD86IHN0cmluZztcbiAgLyoqXG4gICAqIFNldCB0aGUgZGlzcGxheSBuYW1lIGZvciB0aGUgY3VzdG9tIHNvdXJjZS5cbiAgICovXG4gIGN1c3RvbVNvdXJjZU5hbWU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBQcm92aWRlIGFuIG9iamVjdCBmb3IgbWFwcGluZyBwaWNrZXIgc3RyaW5ncyB0byB5b3VyIG93biBzdHJpbmdzLlxuICAgKiBTdHJpbmdzIHN1cnJvdW5kZWQgYnkgYnJhY2tldHMsIGB7IGZvb2JhciB9YCwgYXJlIGludGVycG9sYXRlZCB3aXRoIHJ1bnRpbWUgdmFsdWVzLlxuICAgKiBTb3VyY2UgbGFiZWxzIGFyZSBhbHNvIGF2YWlsYWJsZSB0byBvdmVycmlkZSwgZS5nLiBGYWNlYm9vaywgSW5zdGFncmFtLCBEcm9wYm94LCBldGMuXG4gICAqL1xuICBjdXN0b21UZXh0PzogUGlja2VyQ3VzdG9tVGV4dDtcbiAgLyoqXG4gICAqIHNldCBzdXBwb3J0IGVtYWlsIHRvIGRpc3BsYXkgaW4gY2FzZSBvZiBlcnJvclxuICAgKi9cbiAgc3VwcG9ydEVtYWlsPzogc3RyaW5nO1xuICAvKipcbiAgICogV2hlbiB0cnVlIHJlbW92ZXMgdGhlIGhhc2ggcHJlZml4IG9uIHN0b3JlZCBmaWxlcy5cbiAgICovXG4gIGRpc2FibGVTdG9yYWdlS2V5PzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSByZW1vdmVzIGFiaWxpdHkgdG8gZWRpdCBpbWFnZXMuXG4gICAqL1xuICBkaXNhYmxlVHJhbnNmb3JtZXI/OiBib29sZWFuO1xuICAvKipcbiAgICogRGlzYWJsZXMgbG9jYWwgaW1hZ2UgdGh1bWJuYWlsIHByZXZpZXdzIGluIHRoZSBzdW1tYXJ5IHNjcmVlbi5cbiAgICovXG4gIGRpc2FibGVUaHVtYm5haWxzPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIENvbmZpZ3VyZSB0aGUgZHJvcCBwYW5lIGJlaGF2aW9yLCBpLmUuIHdoZW4gYGRpc3BsYXlNb2RlYCBpcyBgZHJvcFBhbmVgLlxuICAgKi9cbiAgZHJvcFBhbmU/OiBQaWNrZXJEcm9wUGFuZU9wdGlvbnM7XG4gIC8qKlxuICAgKiBXaGVuIHRydWUgdGhlIGBvcmlnaW5hbEZpbGVgIG1ldGFkYXRhIHdpbGwgYmUgdGhlIGFjdHVhbCBgRmlsZWAgb2JqZWN0IGluc3RlYWQgb2YgYSBQT0pPXG4gICAqL1xuICBleHBvc2VPcmlnaW5hbEZpbGU/OiBib29sZWFuO1xuICAvKipcbiAgICogVG9nZ2xlIHRoZSBkcm9wIHpvbmUgdG8gYmUgYWN0aXZlIG9uIGFsbCB2aWV3cy4gRGVmYXVsdCBpcyBhY3RpdmUgb25seSBvbiBsb2NhbCBmaWxlIHNvdXJjZS5cbiAgICovXG4gIGdsb2JhbERyb3Bab25lPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEhpZGUgdGhlIHBpY2tlciBtb2RhbCBVSSBvbmNlIHVwbG9hZGluZyBiZWdpbnMuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqL1xuICBoaWRlTW9kYWxXaGVuVXBsb2FkaW5nPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU3BlY2lmeSBpbWFnZSBkaW1lbnNpb25zLiBlLmcuIFs4MDAsIDYwMF0uIE9ubHkgZm9yIEpQRUcsIFBORywgYW5kIEJNUCBmaWxlcy5cbiAgICogTG9jYWwgYW5kIGNyb3BwZWQgaW1hZ2VzIHdpbGwgYmUgcmVzaXplZCAodXBzY2FsZWQgb3IgZG93bnNjYWxlZCkgdG8gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25zIGJlZm9yZSB1cGxvYWRpbmcuXG4gICAqIFRoZSBvcmlnaW5hbCBoZWlnaHQgdG8gd2lkdGggcmF0aW8gaXMgbWFpbnRhaW5lZC4gVG8gcmVzaXplIGFsbCBpbWFnZXMgYmFzZWQgb24gdGhlIHdpZHRoLCBzZXQgW3dpZHRoLCBudWxsXSwgZS5nLiBbODAwLCBudWxsXS5cbiAgICogRm9yIHRoZSBoZWlnaHQgc2V0IFtudWxsLCBoZWlnaHRdLCBlLmcuIFtudWxsLCA2MDBdLlxuICAgKi9cbiAgaW1hZ2VEaW0/OiBbbnVtYmVyLCBudW1iZXJdO1xuICAvKipcbiAgICogU3BlY2lmeSBtYXhpbXVtIGltYWdlIGRpbWVuc2lvbnMuIGUuZy4gWzgwMCwgNjAwXS4gT25seSBmb3IgSlBFRywgUE5HLCBhbmQgQk1QIGZpbGVzLlxuICAgKiBJbWFnZXMgYmlnZ2VyIHRoYW4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25zIHdpbGwgYmUgcmVzaXplZCB0byB0aGUgbWF4aW11bSBzaXplIHdoaWxlIG1haW50YWluaW5nIHRoZSBvcmlnaW5hbCBhc3BlY3QgcmF0aW8uXG4gICAqIFRoZSBvdXRwdXQgd2lsbCBub3QgYmUgZXhhY3RseSA4MDB4NjAwIHVubGVzcyB0aGUgaW1hZ2VNYXggbWF0Y2hlcyB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBvcmlnaW5hbCBpbWFnZS5cbiAgICovXG4gIGltYWdlTWF4PzogW251bWJlciwgbnVtYmVyXTtcbiAgLyoqXG4gICAqIFNwZWNpZnkgbWluaW11bSBpbWFnZSBkaW1lbnNpb25zLiBlLmcuIFs4MDAsIDYwMF0uIE9ubHkgZm9yIEpQRUcsIFBORywgYW5kIEJNUCBmaWxlcy5cbiAgICogSW1hZ2VzIHNtYWxsZXIgdGhhbiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvbnMgd2lsbCBiZSB1cHNjYWxlZCB0byB0aGUgbWluaW11bSBzaXplIHdoaWxlIG1haW50YWluaW5nIHRoZSBvcmlnaW5hbCBhc3BlY3QgcmF0aW8uXG4gICAqIFRoZSBvdXRwdXQgd2lsbCBub3QgYmUgZXhhY3RseSA4MDB4NjAwIHVubGVzcyB0aGUgaW1hZ2VNaW4gbWF0Y2hlcyB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBvcmlnaW5hbCBpbWFnZS5cbiAgICovXG4gIGltYWdlTWluPzogW251bWJlciwgbnVtYmVyXTtcbiAgLyoqXG4gICAqIFNldHMgbG9jYWxlLiBBY2NlcHRzOiBjYSwgZGEsIGRlLCBlbiwgZXMsIGZyLCBoZSwgaXQsIGphLCBrbywgbmwsIG5vLCBwbCwgcHQsIHN2LCBydSwgdmksIHpoLCB0clxuICAgKi9cbiAgbGFuZz86IHN0cmluZztcbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIGZpbGVzIHJlcXVpcmVkIHRvIHN0YXJ0IHVwbG9hZGluZy4gRGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIG1pbkZpbGVzPzogbnVtYmVyO1xuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2YgZmlsZXMgYWxsb3dlZCB0byB1cGxvYWQuIERlZmF1bHRzIHRvIDEuXG4gICAqL1xuICBtYXhGaWxlcz86IG51bWJlcjtcbiAgLyoqXG4gICAqIFJlc3RyaWN0IHNlbGVjdGVkIGZpbGVzIHRvIGEgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMuIChlLmcuIDEwIFxcKiAxMDI0IFxcKiAxMDI0IGZvciAxME1CIGxpbWl0KS5cbiAgICovXG4gIG1heFNpemU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmlldyB0eXBlIG9wdGlvbiBmb3IgZmlsZSBicm93c2VyXG4gICAqL1xuICB2aWV3VHlwZT86ICdncmlkJyB8ICdsaXN0JztcblxuICAvKipcbiAgICogVGltZW91dCBmb3IgZXJyb3IgbWVzc2FnZXNcbiAgICovXG4gIGVycm9yc1RpbWVvdXQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IFt3aWR0aCwgaGVpZ2h0XSBpbiBwaXhlbHMgb2YgdGhlIGRlc2t0b3AgbW9kYWwuXG4gICAqL1xuICBtb2RhbFNpemU/OiBbbnVtYmVyLCBudW1iZXJdO1xuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYWxsIHVwbG9hZHMgaW4gYSBwaWNrIGFyZSBjYW5jZWxsZWQuXG4gICAqL1xuICBvbkNhbmNlbD86IFBpY2tlclVwbG9hZERvbmVDYWxsYmFjaztcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBVSSBpcyBleGl0ZWQuXG4gICAqL1xuICBvbkNsb3NlPzogKCkgPT4gdm9pZDtcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBVSSBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0gUGlja2VySW5zdGFuY2UgYXBwbGljYXRpb24gaGFuZGxlXG4gICAqL1xuICBvbk9wZW4/OiAoaGFuZGxlOiBQaWNrZXJJbnN0YW5jZSkgPT4gdm9pZDtcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuZXZlciB1c2VyIHNlbGVjdHMgYSBmaWxlLlxuICAgKiAjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBVc2luZyB0byB2ZXRvIGZpbGUgc2VsZWN0aW9uXG4gICAqIC8vIElmIHlvdSB0aHJvdyBhbnkgZXJyb3IgaW4gdGhpcyBmdW5jdGlvbiBpdCB3aWxsIHJlamVjdCB0aGUgZmlsZSBzZWxlY3Rpb24uXG4gICAqIC8vIFRoZSBlcnJvciBtZXNzYWdlIHdpbGwgYmUgZGlzcGxheWVkIHRvIHRoZSB1c2VyIGFzIGFuIGFsZXJ0LlxuICAgKiBvbkZpbGVTZWxlY3RlZChmaWxlKSB7XG4gICAqICAgaWYgKGZpbGUuc2l6ZSA+IDEwMDAgKiAxMDAwKSB7XG4gICAqICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgdG9vIGJpZywgc2VsZWN0IHNvbWV0aGluZyBzbWFsbGVyIHRoYW4gMU1CJyk7XG4gICAqICAgfVxuICAgKiB9XG4gICAqXG4gICAqIC8vIFVzaW5nIHRvIGNoYW5nZSBzZWxlY3RlZCBmaWxlIG5hbWVcbiAgICogLy8gTk9URTogVGhpcyBjdXJyZW50bHkgb25seSB3b3JrcyBmb3IgbG9jYWwgdXBsb2Fkc1xuICAgKiBvbkZpbGVTZWxlY3RlZChmaWxlKSB7XG4gICAqICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gcmV0dXJuIGEgbmV3IGZpbGUgYnkgdGhlIGVuZCBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgKiAgIHJldHVybiB7IC4uLmZpbGUsIG5hbWU6ICdmb28nIH07XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBjYW4gYWxzbyByZXR1cm4gYSBQcm9taXNlIHRvIGFsbG93IGFzeW5jaHJvbm91cyB2YWxpZGF0aW9uIGxvZ2ljLlxuICAgKiBZb3UgY2FuIHBhc3MgYSBmaWxlIG9iamVjdCB0byBgcmVzb2x2ZWAgZm9yIGNoYW5naW5nIHRoZSBmaWxlIG5hbWUsIGl0IHdpbGwgYmVoYXZlIHRoZSBzYW1lIGFzIHdoZW5cbiAgICogdGhlIGZpbGUgaXMgcmV0dXJuZWQgZnJvbSB0aGUgbm9uLWFzeW5jIGNhbGxiYWNrLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBvbkZpbGVTZWxlY3RlZChmaWxlKSB7XG4gICAqICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICogICAgIC8vIERvIHNvbWV0aGluZyBhc3luY1xuICAgKiAgICAgcmVzb2x2ZSgpO1xuICAgKiAgICAgLy8gT3IgcmVqZWN0IHRoZSBzZWxlY3Rpb24gd2l0aCByZWplY3QoKVxuICAgKiAgIH0pO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgb25GaWxlU2VsZWN0ZWQ/OiBQaWNrZXJGaWxlQ2FsbGJhY2s7XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGZpbGUgdXBsb2FkIGhhcyBiZWVuIGNhbmNlbGVkLlxuICAgKi9cbiAgb25GaWxlVXBsb2FkQ2FuY2VsPzogUGlja2VyRmlsZUNhbmNlbENhbGxiYWNrO1xuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBmaWxlIGJlZ2lucyB1cGxvYWRpbmcuXG4gICAqL1xuICBvbkZpbGVVcGxvYWRTdGFydGVkPzogUGlja2VyRmlsZVdpdGhUb2tlbkNhbGxiYWNrO1xuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBmaWxlIGlzIGRvbmUgdXBsb2FkaW5nLlxuICAgKi9cbiAgb25GaWxlVXBsb2FkRmluaXNoZWQ/OiBQaWNrZXJGaWxlQ2FsbGJhY2s7XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB1cGxvYWRpbmcgYSBmaWxlIGZhaWxzLlxuICAgKi9cbiAgb25GaWxlVXBsb2FkRmFpbGVkPzogUGlja2VyRmlsZUVycm9yQ2FsbGJhY2s7XG4gIC8qKlxuICAgKiBDYWxsZWQgZHVyaW5nIG11bHRpLXBhcnQgdXBsb2FkIHByb2dyZXNzIGV2ZW50cy4gTG9jYWwgZmlsZXMgb25seS5cbiAgICovXG4gIG9uRmlsZVVwbG9hZFByb2dyZXNzPzogUGlja2VyRmlsZVByb2dyZXNzQ2FsbGJhY2s7XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBmaWxlIGlzIGNyb3BwZWQgaW4gcGlja2VyXG4gICAqL1xuICBvbkZpbGVDcm9wcGVkPzogUGlja2VyRmlsZUNhbGxiYWNrO1xuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdXBsb2FkaW5nIHN0YXJ0cyAodXNlciBpbml0aWF0ZXMgdXBsb2FkaW5nKS5cbiAgICovXG4gIG9uVXBsb2FkU3RhcnRlZD86IFBpY2tlclVwbG9hZFN0YXJ0ZWRDYWxsYmFjaztcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGFsbCBmaWxlcyBoYXZlIGJlZW4gdXBsb2FkZWQuXG4gICAqL1xuICBvblVwbG9hZERvbmU/OiBQaWNrZXJVcGxvYWREb25lQ2FsbGJhY2s7XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHVuaXF1ZSBpZCBmb3IgdGhlIGFwcGxpY2F0aW9uIG1vdW50IHBvaW50LlxuICAgKiBNYXkgYmUgdXNlZnVsIGZvciBtb3JlIGFkdmFuY2VkIHVzZSBjYXNlcy5cbiAgICogRm9yIGV4YW1wbGUsIGlmIHlvdSB3aXNoIHRvIGhhdmUgbW9yZSB0aGFuIG9uZSBwaWNrZXIgaW5zdGFuY2Ugb3BlbiBhdCBvbmNlLFxuICAgKiB0aGVuIGVhY2ggd2lsbCBuZWVkIHRoZWlyIG93biB1bmlxdWUgcm9vdElkLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVGhpcyBvcHRpb24gaXMgaWdub3JlZCB3aGVuIGBkaXNwbGF5TW9kZWAgaXMgYGRyb3BQYW5lYC5cbiAgICovXG4gIHJvb3RJZD86IHN0cmluZztcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3RhcnQgdXBsb2FkaW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBtYXhGaWxlcyBpcyBoaXQuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqL1xuICBzdGFydFVwbG9hZGluZ1doZW5NYXhGaWxlc1JlYWNoZWQ/OiBib29sZWFuO1xuICAvKipcbiAgICogT3B0aW9ucyBmb3IgZmlsZSBzdG9yYWdlLlxuICAgKi9cbiAgc3RvcmVUbz86IFBpY2tlclN0b3JlT3B0aW9ucztcbiAgLyoqXG4gICAqIFNwZWNpZnkgb3B0aW9ucyBmb3IgaW1hZ2VzIHBhc3NlZCB0byB0aGUgY3JvcCBVSS5cbiAgICovXG4gIHRyYW5zZm9ybWF0aW9ucz86IFBpY2tlclRyYW5zZm9ybWF0aW9uT3B0aW9ucztcbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIGxvY2FsIGZpbGUgdXBsb2Fkcy5cbiAgICovXG4gIHVwbG9hZENvbmZpZz86IFVwbG9hZE9wdGlvbnM7XG4gIC8qKlxuICAgKiBTdGFydCB1cGxvYWRpbmcgaW1tZWRpYXRlbHkgb24gZmlsZSBzZWxlY3Rpb24uIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQGltcG9ydGFudCBUaGUgZmVhdHVyZSBpcyBjYW4gYmUgZW5hYmxlZCBvbmx5IGlmIGNyb3AgaXMgZGlzYWJsZWQgLSBkaXNhYmxlVHJhbnNmb3JtZXI6IHRydWVcbiAgICovXG4gIHVwbG9hZEluQmFja2dyb3VuZD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIG9mIHJlY29yZGVkIHZpZGVvLiBPbmUgb2YgXCIzMjB4MjQwXCIsIFwiNjQweDQ4MFwiIG9yIFwiMTI4MHg3MjBcIi4gRGVmYXVsdCBpcyBgXCI2NDB4NDgwXCJgLlxuICAgKi9cbiAgdmlkZW9SZXNvbHV0aW9uPzogc3RyaW5nO1xuICAvKipcbiAgICogVXNlIFNlbnRyeSBCcmVhZGNydW1icyBtZWNoYW5pc20gdG8gbG9nIGluZm9ybWF0aW9uIGFib3V0IG9jY3VyZWQgZXJyb3JzLlxuICAgKiBJdCBjYW4gb3ZlcnJpZGUgZ2xvYmFsIG9iamVjdHMgbGlrZSBjb25zb2xlLCBlcnJvciBldGMuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICovXG4gIHVzZVNlbnRyeUJyZWFkY3J1bWJzPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hpY2ggUGlja2VyIGluc3RhbmNlIHNob3VsZCByZXNwb25kIHRvIHBhc3RlIGV2ZW50LlxuICAgKiBCeSBkZWZhdWx0IG9ubHkgaG92ZXJlZCBpbnN0YW5jZSByZXNwb25kcyB0byBldmVudC5cbiAgICogQHBhcmFtIHtib29sZWFuID0gZmFsc2V9IHBhc3RlVG9GaXJzdEluVmlld1BvcnQgSWYgbm9uZSBpbnN0YW5jZSBpcyBob3ZlcmVkIHRha2UgZmlyc3QgcGlja2VyIGluc3RhbmNlIGZ1bGx5IHZpc2libGUgaW4gdmlld3BvcnRcbiAgICogQHBhcmFtIHtib29sZWFuID0gZmFsc2V9IHBhc3RlVG9GaXJzdEluc3RhbmNlIElmIG5vbmUgaW5zdGFuY2UgaXMgaG92ZXJlZCB0YWtlIGZpcnN0IHBpY2tlciBpbnN0YW5jZSB0aGF0IGlzIGluaXRpYWxpemVkXG4gICAqIEBwYXN0ZVRvRmlyc3RJblZpZXdQb3J0IGlzIGNoZWNrZWQgZmlyc3RcbiAgICovXG4gIHBhc3RlTW9kZT86IHtcbiAgICBwYXN0ZVRvRmlyc3RJblZpZXdQb3J0PzogYm9vbGVhbixcbiAgICBwYXN0ZVRvRmlyc3RJbnN0YW5jZT86IGJvb2xlYW5cbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQaWNrZXJDcm9wT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBNYWludGFpbiBhc3BlY3QgcmF0aW8gZm9yIGNyb3Agc2VsZWN0aW9uLiAoZS5nLiAxNi85LCA4MDAvNjAwKS5cbiAgICovXG4gIGFzcGVjdFJhdGlvPzogbnVtYmVyO1xuICAvKipcbiAgICogRm9yY2UgYWxsIGltYWdlcyB0byBiZSBjcm9wcGVkIGJlZm9yZSB1cGxvYWRpbmcuXG4gICAqL1xuICBmb3JjZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGlja2VyVHJhbnNmb3JtYXRpb25PcHRpb25zIHtcbiAgLyoqXG4gICAqIEVuYWJsZSBjcm9wLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqL1xuICBjcm9wPzogYm9vbGVhbiB8IFBpY2tlckNyb3BPcHRpb25zO1xuICAvKipcbiAgICogRW5hYmxlIGNpcmNsZSBjcm9wLiBEaXNhYmxlZCBpZiBjcm9wLmFzcGVjdFJhdGlvIGlzIGRlZmluZWQgYW5kIG5vdCAxLiBDb252ZXJ0cyB0byBQTkcuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICovXG4gIGNpcmNsZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBFbmFibGUgaW1hZ2Ugcm90YXRpb24uIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICovXG4gIHJvdGF0ZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEdsb2JhbCBmb3JjZSBjcm9wIG9wdGlvbi4gQ2FuIGJlIHVzZSBpZSB3aXRoIGNpcmNsZVxuICAgKi9cbiAgZm9yY2U/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBpY2tlckFjY2VwdEZuT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBQcm92aWRlZCBhY2NlcHQgc3RyaW5nXG4gICAqL1xuICBhY2NlcHQ6IHN0cmluZ1tdO1xuICAvKipcbiAgICogQWNjZXB0IHN0cmluZyBjb252ZXJ0ZWQgdG8gbWltZXR5cGVcbiAgICovXG4gIGFjY2VwdE1pbWU6IHN0cmluZ1tdO1xuICAvKipcbiAgICogTWltZXR5cGUgYmFzZWQgbWFnaWMgYnl0ZXNcbiAgICoge0BsaW5rIGh0dHBzOi8vZmlsZXN0YWNrLmdpdGh1Yi5pby9maWxlc3RhY2stanMvZ2xvYmFscy5odG1sI2dldG1pbWV0eXBlfVxuICAgKi9cbiAgbWltZUZyb21NYWdpY0J5dGVzOiBQcm9taXNlPHN0cmluZz47XG4gIC8qKlxuICAgKiBNaW1ldHlwZSBiYXNlZCBvbiBmaWxlIGV4dGVuc2lvblxuICAgKiB7QGxpbmsgaHR0cHM6Ly9maWxlc3RhY2suZ2l0aHViLmlvL2ZpbGVzdGFjay1qcy9nbG9iYWxzLmh0bWwjZXh0ZW5zaW9udG9taW1lfVxuICAgKi9cbiAgbWltZUZyb21FeHRlbnNpb246IHN0cmluZztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQSBzeW5jaHJvbm91cy1sb29raW5nIHdyYXBwZXIgZm9yIGxvYWRpbmcgdGhlIHBpY2tlciBhbmQgY2FsbGluZyBpdHMgbWV0aG9kcy5cbiAqIFRoaXMgaXMgY3VycmVudGx5IG5lZWRlZCBiZWNhdXNlIHRoZSBwaWNrZXIgbW9kdWxlIGlzIGxvYWRlZCBhc3luY2hyb25vdXNseS5cbiAqIEV2ZW50dWFsbHkgd2Ugc2hvdWxkIG9mZmVyIGEgYnVuZGxlIHdpdGggdGhlIHBpY2tlciBtb2R1bGUgaW5jbHVkZWQuXG4gKi9cbmNsYXNzIFBpY2tlckxvYWRlciB7XG5cbiAgcHJpdmF0ZSBfaW5pdGlhbGl6ZWQ6IFByb21pc2U8UGlja2VySW5zdGFuY2U+O1xuICBjb25zdHJ1Y3RvcihjbGllbnQ6IENsaWVudCwgb3B0aW9ucz86IFBpY2tlck9wdGlvbnMpIHtcbiAgICBjb25zdCB2YWxpZGF0ZVJlcyA9IGdldFZhbGlkYXRvcihQaWNrZXJQYXJhbXNTY2hlbWEpKG9wdGlvbnMpO1xuXG4gICAgaWYgKHZhbGlkYXRlUmVzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBGaWxlc3RhY2tFcnJvcihgSW52YWxpZCBwaWNrZXIgcGFyYW1zYCwgdmFsaWRhdGVSZXMuZXJyb3JzLCBGaWxlc3RhY2tFcnJvclR5cGUuVkFMSURBVElPTik7XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0aGlzLmxvYWRNb2R1bGUoY2xpZW50LCBvcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jIG9wZW4oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcGlja2VyID0gYXdhaXQgdGhpcy5faW5pdGlhbGl6ZWQ7XG4gICAgYXdhaXQgcGlja2VyLm9wZW4oKTtcbiAgfVxuXG4gIGFzeW5jIGNyb3AoZmlsZXM6IGFueVtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcGlja2VyID0gYXdhaXQgdGhpcy5faW5pdGlhbGl6ZWQ7XG4gICAgYXdhaXQgcGlja2VyLmNyb3AoZmlsZXMpO1xuICB9XG5cbiAgYXN5bmMgY2xvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcGlja2VyID0gYXdhaXQgdGhpcy5faW5pdGlhbGl6ZWQ7XG4gICAgYXdhaXQgcGlja2VyLmNsb3NlKCk7XG4gIH1cblxuICBhc3luYyBjYW5jZWwoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcGlja2VyID0gYXdhaXQgdGhpcy5faW5pdGlhbGl6ZWQ7XG4gICAgYXdhaXQgcGlja2VyLmNhbmNlbCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsb2FkTW9kdWxlKGNsaWVudDogQ2xpZW50LCBvcHRpb25zPzogUGlja2VyT3B0aW9ucyk6IFByb21pc2U8UGlja2VySW5zdGFuY2U+IHtcbiAgICBjb25zdCB7IHNlc3Npb246IHsgdXJsczogeyBwaWNrZXJVcmw6IHVybCB9IH0gfSA9IGNsaWVudDtcbiAgICBjb25zdCBQaWNrZXIgPSBhd2FpdCBsb2FkTW9kdWxlKEZJTEVTVEFDS19NT0RVTEVTLlBJQ0tFUiwgdXJsKTtcbiAgICByZXR1cm4gbmV3IFBpY2tlcihjbGllbnQsIG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogTG9hZHMgYW5kIGNyZWF0ZXMgcGlja2VyIGluc3RhbmNlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBjbGllbnRcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBwaWNrZXIgPSAoY2xpZW50OiBDbGllbnQsIG9wdGlvbnM/OiBQaWNrZXJPcHRpb25zKTogUGlja2VySW5zdGFuY2UgPT4ge1xuICByZXR1cm4gbmV3IFBpY2tlckxvYWRlcihjbGllbnQsIG9wdGlvbnMpO1xufTtcbiJdfQ==


/***/ }),

/***/ 9962:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
var __webpack_unused_export__;

/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
__webpack_unused_export__ = ({ value: true });
var tslib_1 = __nccwpck_require__(4351);
var url = __nccwpck_require__(8835);
var zlib = __nccwpck_require__(8761);
var debug_1 = __nccwpck_require__(8237);
var utils_1 = __nccwpck_require__(8123);
var Stream = __nccwpck_require__(2413);
var utils = __nccwpck_require__(2790);
var helpers_1 = __nccwpck_require__(9083);
var error_1 = __nccwpck_require__(8953);
var types_1 = __nccwpck_require__(6942);
var HTTPS_REGEXP = /https:?/;
var HTTP_CHUNK_SIZE = 16 * 1024;
var MAX_REDIRECTS = 10;
var CANCEL_CLEAR = "FsCleanMemory";
var debug = debug_1.default('fs:request:http');
/**
 * Writable stream thats overwrap http request for progress event
 *
 * @class HttpWritableStream
 * @extends {Stream.Writable}
 */
var HttpWritableStream = /** @class */ (function (_super) {
    tslib_1.__extends(HttpWritableStream, _super);
    function HttpWritableStream(req, opts) {
        if (opts === void 0) { opts = {}; }
        var _this = _super.call(this, opts) || this;
        _this.request = req;
        req.once('drain', function () { return _this.emit('drain'); });
        return _this;
    }
    HttpWritableStream.prototype._write = function (chunk, encoding, cb) {
        this.request.write(chunk, encoding, cb);
    };
    HttpWritableStream.prototype.end = function (chunk) {
        if (chunk) {
            this.request.write(chunk);
        }
        this.request.end();
    };
    return HttpWritableStream;
}(Stream.Writable));
/**
 * Node http request class
 *
 * @export
 * @class HttpAdapter
 * @implements {AdapterInterface}
 */
var HttpAdapter = /** @class */ (function () {
    function HttpAdapter() {
        this.redirectHoops = 0;
        this.redirectPaths = [];
        /**
         * Monitor and emit progress event if needed
         *
         * @private
         * @memberof HttpAdapter
         */
        this.getProgressMonitor = function (config, total) {
            var loaded = 0;
            var progress = new Stream.Transform();
            progress._transform = function (chunk, encoding, cb) {
                if (typeof config.onProgress === 'function' && [types_1.FsHttpMethod.POST, types_1.FsHttpMethod.PUT].indexOf(config.method) > -1) {
                    loaded += chunk.length;
                    config.onProgress({
                        lengthComputable: true,
                        loaded: loaded,
                        total: total,
                    });
                }
                cb(null, chunk);
            };
            return progress;
        };
    }
    /**
     * do request based on configuration
     *
     * @param {FsRequestOptions} config
     * @returns
     * @memberof HttpAdapter
     */
    HttpAdapter.prototype.request = function (config) {
        var _this = this;
        // if this option is unspecified set it by default
        if (typeof config.filestackHeaders === 'undefined') {
            config.filestackHeaders = true;
        }
        config.headers = helpers_1.normalizeHeaders(config.headers);
        var _a = helpers_1.prepareData(config), data = _a.data, headers = _a.headers;
        headers = helpers_1.set(headers, 'user-agent', "filestack-request/" + utils_1.getVersion());
        // for now we are not using streams
        if (data) {
            debug('Request data %O', data);
            if (!Buffer.isBuffer(data)) {
                if (!utils.isString(data)) {
                    return Promise.reject(new error_1.FsRequestError('Data must be a string, JSON or a Buffer', config));
                }
                data = Buffer.from(data, 'utf-8');
            }
            headers = helpers_1.set(headers, 'content-length', data.length, true);
        }
        // HTTP basic authentication
        var auth;
        if (config.auth) {
            if (!config.auth.username || config.auth.username.length === 0) {
                return Promise.reject(new error_1.FsRequestError("Basic auth: username is required " + config.auth, config));
            }
            auth = config.auth.username + ":" + config.auth.password;
        }
        // Parse url
        var parsed = url.parse(config.url);
        // try to add default https protocol
        if (!parsed.protocol) {
            parsed = url.parse("https://" + config.url);
        }
        /* istanbul ignore next: just be sure that the host is parsed correctly, not needed to test */
        if (!parsed.host) {
            return Promise.reject(new error_1.FsRequestError("Cannot parse provided url " + config.url, config));
        }
        // normalize auth header
        if (auth && headers.Authorization) {
            delete headers.Authorization;
        }
        var isHttpsRequest = HTTPS_REGEXP.test(parsed.protocol);
        var agent = isHttpsRequest ? __nccwpck_require__(7211) : __nccwpck_require__(8605);
        var options = {
            path: helpers_1.combineURL(parsed.path, config.params),
            host: parsed.host,
            port: parsed.port,
            protocol: parsed.protocol,
            method: config.method.toUpperCase(),
            headers: headers,
            agent: new agent.Agent(),
            auth: auth,
        };
        debug('Starting %s request with options %O', isHttpsRequest ? 'https' : 'http', options);
        return new Promise(function (resolve, reject) {
            var req;
            var cancelListener;
            if (config.cancelToken) {
                cancelListener = config.cancelToken.on('cancel', function (reason) {
                    // cleanup handler
                    cancelListener = null;
                    // do nothing if promise is resolved by system
                    if (reason && reason.message === CANCEL_CLEAR) {
                        return;
                    }
                    /* istanbul ignore next: if request is done cancel token should not throw any error */
                    if (req) {
                        req.abort();
                        req = null;
                    }
                    debug('Request canceled by user %s, config: %O', reason, config);
                    return reject(new error_1.FsRequestError("Request aborted. Reason: " + reason, config, null, error_1.FsRequestErrorCode.ABORTED));
                });
            }
            req = agent.request(options, function (res) {
                /* istanbul ignore next: just be sure that response will not be called after request is aborted */
                if (!req || req.aborted) {
                    return reject(new error_1.FsRequestError('Request aborted', config));
                }
                var stream = res;
                debug('Response statusCode: %d, Response Headers: %O', res.statusCode, res.headers);
                var compressHeaders = res.headers['content-encoding'];
                if (compressHeaders && compressHeaders.length && ['gzip', 'compress', 'deflate'].some(function (v) { return compressHeaders.indexOf(v) > -1; })) {
                    // add the unzipper to the body stream processing pipeline
                    stream = res.statusCode === 204 ? stream : stream.pipe(zlib.createUnzip());
                    // remove the content-encoding in order to not confuse downstream operations
                    delete res.headers['content-encoding'];
                }
                var response = {
                    status: res.statusCode,
                    statusText: res.statusMessage,
                    headers: res.headers,
                    config: config,
                    data: {},
                };
                // we need to follow redirect so make same request with new location
                if ([301, 302].indexOf(res.statusCode) > -1) {
                    debug('Redirect received %s', res.statusCode);
                    if (_this.redirectHoops >= MAX_REDIRECTS) {
                        return reject(new error_1.FsRequestError("Max redirects (" + _this.redirectHoops + ") reached. Exiting", config, response, error_1.FsRequestErrorCode.REDIRECT));
                    }
                    var url_1 = res.headers['location'];
                    if (!url_1 || url_1.length === 0) {
                        return reject(new error_1.FsRequestError("Redirect header location not found", config, response, error_1.FsRequestErrorCode.REDIRECT));
                    }
                    if (_this.redirectPaths.indexOf(url_1) > -1) {
                        return reject(new error_1.FsRequestError("Redirect loop detected at url " + url_1, config, response, error_1.FsRequestErrorCode.REDIRECT));
                    }
                    _this.redirectPaths.push(url_1);
                    _this.redirectHoops++;
                    // free resources
                    res = undefined;
                    req = undefined;
                    debug('Redirecting request to %s (hoop-count: %d)', url_1, _this.redirectHoops);
                    return resolve(_this.request(Object.assign({}, config, { url: url_1 })));
                }
                var responseBuffer = [];
                stream.on('data', function (chunk) { return responseBuffer.push(chunk); });
                /* istanbul ignore next: its hard to test socket events with jest and nock - tested manually */
                stream.on('error', function (err) {
                    res = undefined;
                    req = undefined;
                    responseBuffer = undefined;
                    debug('Request error: Aborted %O', err);
                    if (req.aborted) {
                        return;
                    }
                    // clear cancel token to avoid memory leak
                    if (cancelListener) {
                        config.cancelToken.removeListener(cancelListener);
                    }
                    return reject(new error_1.FsRequestError(err.message, config, null, error_1.FsRequestErrorCode.NETWORK));
                });
                stream.on('end', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                // clear cancel token to avoid memory leak
                                if (cancelListener) {
                                    config.cancelToken.removeListener(cancelListener);
                                }
                                if (!(res.statusCode !== 204)) return [3 /*break*/, 2];
                                // prepare response
                                response.data = Buffer.concat(responseBuffer);
                                return [4 /*yield*/, helpers_1.parseResponse(response)];
                            case 1:
                                response = _a.sent();
                                return [3 /*break*/, 3];
                            case 2:
                                response.data = null;
                                _a.label = 3;
                            case 3:
                                // free resources
                                res = undefined;
                                req = undefined;
                                responseBuffer = undefined;
                                if (500 <= response.status && response.status <= 599) {
                                    // server error throw
                                    debug('Server error(5xx) - %O', response);
                                    return [2 /*return*/, reject(new error_1.FsRequestError("Server error " + url, config, response, error_1.FsRequestErrorCode.SERVER))];
                                }
                                else if (400 <= response.status && response.status <= 499) {
                                    debug('Request error(4xx) - %O', response);
                                    return [2 /*return*/, reject(new error_1.FsRequestError("Request error " + url, config, response, error_1.FsRequestErrorCode.REQUEST))];
                                }
                                debug('Request ends: %O', response);
                                return [2 /*return*/, resolve(response)];
                        }
                    });
                }); });
            });
            if (config.timeout) {
                req.setTimeout(config.timeout, function () {
                    req.abort();
                    if (cancelListener) {
                        config.cancelToken.removeListener(cancelListener);
                    }
                    return reject(new error_1.FsRequestError('Request timeout', config, null, error_1.FsRequestErrorCode.TIMEOUT));
                });
            }
            req.on('error', function (err) {
                if (cancelListener) {
                    config.cancelToken.removeListener(cancelListener);
                }
                if (!req || req.aborted) {
                    return;
                }
                debug('Request error: %s - %O', err, err.code);
                return reject(new error_1.FsRequestError("Request error: " + err.code, config, null, error_1.FsRequestErrorCode.NETWORK));
            });
            if (Buffer.isBuffer(data) && ['POST', 'PUT'].indexOf(config.method) > -1) {
                return _this.bufferToChunks(data).pipe(_this.getProgressMonitor(config, data.length)).pipe(new HttpWritableStream(req));
            }
            req.end(data);
        });
    };
    /**
     * Convert buffer to stream
     *
     * @private
     * @param {*} buffer
     * @returns {Stream.Readable}
     * @memberof HttpAdapter
     */
    HttpAdapter.prototype.bufferToChunks = function (buffer) {
        var chunking = new Stream.Readable();
        var totalLength = buffer.length;
        var remainder = totalLength % HTTP_CHUNK_SIZE;
        var cutoff = totalLength - remainder;
        for (var i = 0; i < cutoff; i += HTTP_CHUNK_SIZE) {
            var chunk = buffer.slice(i, i + HTTP_CHUNK_SIZE);
            chunking.push(chunk);
        }
        if (remainder > 0) {
            var remainderBuffer = buffer.slice(-remainder);
            chunking.push(remainderBuffer);
        }
        chunking.push(null);
        return chunking;
    };
    return HttpAdapter;
}());
exports.HttpAdapter = HttpAdapter;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9hZGFwdGVycy9odHRwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7OztBQUVILHlCQUEyQjtBQUMzQiwyQkFBNkI7QUFDN0IsK0JBQTBCO0FBRzFCLHFDQUF5QztBQUN6QywrQkFBaUM7QUFFakMsZ0NBQWtDO0FBQ2xDLHdDQUEwRztBQUMxRyxrQ0FBOEQ7QUFDOUQsb0NBQTBDO0FBRTFDLElBQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQztBQUMvQixJQUFNLGVBQWUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO0FBQ2xDLElBQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQztBQUN6QixJQUFNLFlBQVksR0FBRyxlQUFlLENBQUM7QUFDckMsSUFBTSxLQUFLLEdBQUcsZUFBSyxDQUFDLGlCQUFpQixDQUFDLENBQUM7QUFFdkM7Ozs7O0dBS0c7QUFDSDtJQUFpQyw4Q0FBZTtJQUc5Qyw0QkFBWSxHQUFHLEVBQUUsSUFBUztRQUFULHFCQUFBLEVBQUEsU0FBUztRQUExQixZQUNFLGtCQUFNLElBQUksQ0FBQyxTQUlaO1FBRkMsS0FBSSxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7UUFDbkIsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsY0FBTSxPQUFBLEtBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQWxCLENBQWtCLENBQUMsQ0FBQzs7SUFDOUMsQ0FBQztJQUVELG1DQUFNLEdBQU4sVUFBTyxLQUFVLEVBQUUsUUFBaUIsRUFBRSxFQUE4QztRQUNsRixJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRCxnQ0FBRyxHQUFILFVBQUksS0FBSztRQUNQLElBQUksS0FBSyxFQUFFO1lBQ1QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDM0I7UUFFRCxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ3JCLENBQUM7SUFDSCx5QkFBQztBQUFELENBckJBLEFBcUJDLENBckJnQyxNQUFNLENBQUMsUUFBUSxHQXFCL0M7QUFFRDs7Ozs7O0dBTUc7QUFDSDtJQUFBO1FBQ1Usa0JBQWEsR0FBRyxDQUFDLENBQUM7UUFDbEIsa0JBQWEsR0FBRyxFQUFFLENBQUM7UUEyUDNCOzs7OztXQUtHO1FBQ0ssdUJBQWtCLEdBQUcsVUFBQyxNQUFNLEVBQUUsS0FBSztZQUN6QyxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7WUFFZixJQUFNLFFBQVEsR0FBRyxJQUFJLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUN4QyxRQUFRLENBQUMsVUFBVSxHQUFHLFVBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxFQUFFO2dCQUN4QyxJQUFJLE9BQU8sTUFBTSxDQUFDLFVBQVUsS0FBSyxVQUFVLElBQUksQ0FBQyxvQkFBWSxDQUFDLElBQUksRUFBRSxvQkFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7b0JBQ2hILE1BQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDO29CQUN2QixNQUFNLENBQUMsVUFBVSxDQUFDO3dCQUNoQixnQkFBZ0IsRUFBRSxJQUFJO3dCQUN0QixNQUFNLFFBQUE7d0JBQ04sS0FBSyxPQUFBO3FCQUNOLENBQUMsQ0FBQztpQkFDSjtnQkFDRCxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ2xCLENBQUMsQ0FBQztZQUVGLE9BQU8sUUFBUSxDQUFDO1FBQ2xCLENBQUMsQ0FBQTtJQThCSCxDQUFDO0lBOVNDOzs7Ozs7T0FNRztJQUNILDZCQUFPLEdBQVAsVUFBUSxNQUF3QjtRQUFoQyxpQkFnUEM7UUEvT0Msa0RBQWtEO1FBQ2xELElBQUksT0FBTyxNQUFNLENBQUMsZ0JBQWdCLEtBQUssV0FBVyxFQUFFO1lBQ2xELE1BQU0sQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7U0FDaEM7UUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLDBCQUFnQixDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUU5QyxJQUFBLGtDQUF1QyxFQUFyQyxjQUFJLEVBQUUsb0JBQStCLENBQUM7UUFFNUMsT0FBTyxHQUFHLGFBQVMsQ0FBQyxPQUFPLEVBQUUsWUFBWSxFQUFFLHVCQUFxQixrQkFBVSxFQUFJLENBQUMsQ0FBQztRQUVoRixtQ0FBbUM7UUFDbkMsSUFBSSxJQUFJLEVBQUU7WUFDUixLQUFLLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFFL0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQzFCLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFO29CQUN6QixPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxzQkFBYyxDQUFDLHlDQUF5QyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7aUJBQzlGO2dCQUVELElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQzthQUNuQztZQUVELE9BQU8sR0FBRyxhQUFTLENBQUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDbkU7UUFFRCw0QkFBNEI7UUFDNUIsSUFBSSxJQUFJLENBQUM7UUFDVCxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQkFDOUQsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksc0JBQWMsQ0FBQyxzQ0FBb0MsTUFBTSxDQUFDLElBQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO2FBQ3RHO1lBRUQsSUFBSSxHQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxTQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBVSxDQUFDO1NBQzFEO1FBRUQsWUFBWTtRQUNaLElBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRW5DLG9DQUFvQztRQUNwQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRTtZQUNwQixNQUFNLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxhQUFXLE1BQU0sQ0FBQyxHQUFLLENBQUMsQ0FBQztTQUM3QztRQUVELDhGQUE4RjtRQUM5RixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRTtZQUNoQixPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxzQkFBYyxDQUFDLCtCQUE2QixNQUFNLENBQUMsR0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7U0FDOUY7UUFFRCx3QkFBd0I7UUFDeEIsSUFBSSxJQUFJLElBQUksT0FBTyxDQUFDLGFBQWEsRUFBRTtZQUNqQyxPQUFPLE9BQU8sQ0FBQyxhQUFhLENBQUM7U0FDOUI7UUFFRCxJQUFNLGNBQWMsR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMxRCxJQUFNLEtBQUssR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRWxFLElBQU0sT0FBTyxHQUFHO1lBQ2QsSUFBSSxFQUFFLG9CQUFVLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDO1lBQzVDLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSTtZQUNqQixJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUk7WUFDakIsUUFBUSxFQUFFLE1BQU0sQ0FBQyxRQUFRO1lBQ3pCLE1BQU0sRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRTtZQUNuQyxPQUFPLEVBQUUsT0FBTztZQUNoQixLQUFLLEVBQUUsSUFBSSxLQUFLLENBQUMsS0FBSyxFQUFFO1lBQ3hCLElBQUksRUFBRSxJQUFJO1NBQ1gsQ0FBQztRQUVGLEtBQUssQ0FBQyxxQ0FBcUMsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRXpGLE9BQU8sSUFBSSxPQUFPLENBQWEsVUFBQyxPQUFPLEVBQUUsTUFBTTtZQUM3QyxJQUFJLEdBQUcsQ0FBQztZQUNSLElBQUksY0FBYyxDQUFDO1lBRW5CLElBQUksTUFBTSxDQUFDLFdBQVcsRUFBRTtnQkFDdEIsY0FBYyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxVQUFDLE1BQU07b0JBQ3RELGtCQUFrQjtvQkFDbEIsY0FBYyxHQUFHLElBQUksQ0FBQztvQkFFdEIsOENBQThDO29CQUM5QyxJQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsT0FBTyxLQUFLLFlBQVksRUFBRTt3QkFDN0MsT0FBTztxQkFDUjtvQkFFRCxzRkFBc0Y7b0JBQ3RGLElBQUksR0FBRyxFQUFFO3dCQUNQLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQzt3QkFDWixHQUFHLEdBQUcsSUFBSSxDQUFDO3FCQUNaO29CQUVELEtBQUssQ0FBQyx5Q0FBeUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7b0JBQ2pFLE9BQU8sTUFBTSxDQUFDLElBQUksc0JBQWMsQ0FBQyw4QkFBNEIsTUFBUSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsMEJBQWtCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztnQkFDcEgsQ0FBQyxDQUFDLENBQUM7YUFDSjtZQUVELEdBQUcsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxVQUFBLEdBQUc7Z0JBQzlCLGtHQUFrRztnQkFDbEcsSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsT0FBTyxFQUFFO29CQUN2QixPQUFPLE1BQU0sQ0FBQyxJQUFJLHNCQUFjLENBQUMsaUJBQWlCLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztpQkFDOUQ7Z0JBRUQsSUFBSSxNQUFNLEdBQUcsR0FBRyxDQUFDO2dCQUNqQixLQUFLLENBQUMsK0NBQStDLEVBQUUsR0FBRyxDQUFDLFVBQVUsRUFBRSxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBRXBGLElBQU0sZUFBZSxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztnQkFFeEQsSUFBSSxlQUFlLElBQUksZUFBZSxDQUFDLE1BQU0sSUFBSSxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQUMsQ0FBQyxJQUFLLE9BQUEsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBL0IsQ0FBK0IsQ0FBQyxFQUFFO29CQUM3SCwwREFBMEQ7b0JBQzFELE1BQU0sR0FBRyxHQUFHLENBQUMsVUFBVSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO29CQUMzRSw0RUFBNEU7b0JBQzVFLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2lCQUN4QztnQkFFRCxJQUFJLFFBQVEsR0FBZTtvQkFDekIsTUFBTSxFQUFFLEdBQUcsQ0FBQyxVQUFVO29CQUN0QixVQUFVLEVBQUUsR0FBRyxDQUFDLGFBQWE7b0JBQzdCLE9BQU8sRUFBRSxHQUFHLENBQUMsT0FBTztvQkFDcEIsTUFBTSxRQUFBO29CQUNOLElBQUksRUFBRSxFQUFFO2lCQUNULENBQUM7Z0JBRUYsb0VBQW9FO2dCQUNwRSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7b0JBQzNDLEtBQUssQ0FBQyxzQkFBc0IsRUFBRSxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7b0JBRTlDLElBQUksS0FBSSxDQUFDLGFBQWEsSUFBSSxhQUFhLEVBQUU7d0JBQ3ZDLE9BQU8sTUFBTSxDQUFDLElBQUksc0JBQWMsQ0FBQyxvQkFBa0IsS0FBSSxDQUFDLGFBQWEsdUJBQW9CLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSwwQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO3FCQUM1STtvQkFFRCxJQUFNLEtBQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO29CQUVwQyxJQUFJLENBQUMsS0FBRyxJQUFJLEtBQUcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO3dCQUM1QixPQUFPLE1BQU0sQ0FBQyxJQUFJLHNCQUFjLENBQUMsb0NBQW9DLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSwwQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO3FCQUN4SDtvQkFFRCxJQUFJLEtBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEtBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO3dCQUN4QyxPQUFPLE1BQU0sQ0FBQyxJQUFJLHNCQUFjLENBQUMsbUNBQWlDLEtBQUssRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLDBCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7cUJBQzFIO29CQUVELEtBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUcsQ0FBQyxDQUFDO29CQUM3QixLQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7b0JBRXJCLGlCQUFpQjtvQkFDakIsR0FBRyxHQUFHLFNBQVMsQ0FBQztvQkFDaEIsR0FBRyxHQUFHLFNBQVMsQ0FBQztvQkFFaEIsS0FBSyxDQUFDLDRDQUE0QyxFQUFFLEtBQUcsRUFBRSxLQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7b0JBRTdFLE9BQU8sT0FBTyxDQUFDLEtBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFLEVBQUUsR0FBRyxPQUFBLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDbEU7Z0JBRUQsSUFBSSxjQUFjLEdBQUcsRUFBRSxDQUFDO2dCQUN4QixNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxVQUFBLEtBQUssSUFBSSxPQUFBLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQTFCLENBQTBCLENBQUMsQ0FBQztnQkFFdkQsK0ZBQStGO2dCQUMvRixNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxVQUFBLEdBQUc7b0JBQ3BCLEdBQUcsR0FBRyxTQUFTLENBQUM7b0JBQ2hCLEdBQUcsR0FBRyxTQUFTLENBQUM7b0JBQ2hCLGNBQWMsR0FBRyxTQUFTLENBQUM7b0JBQzNCLEtBQUssQ0FBQywyQkFBMkIsRUFBRSxHQUFHLENBQUMsQ0FBQztvQkFFeEMsSUFBSSxHQUFHLENBQUMsT0FBTyxFQUFFO3dCQUNmLE9BQU87cUJBQ1I7b0JBRUQsMENBQTBDO29CQUMxQyxJQUFJLGNBQWMsRUFBRTt3QkFDbEIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLENBQUM7cUJBQ25EO29CQUVELE9BQU8sTUFBTSxDQUFDLElBQUksc0JBQWMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsMEJBQWtCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztnQkFDM0YsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUU7Ozs7Z0NBQ2YsMENBQTBDO2dDQUMxQyxJQUFJLGNBQWMsRUFBRTtvQ0FDbEIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLENBQUM7aUNBQ25EO3FDQUdHLENBQUEsR0FBRyxDQUFDLFVBQVUsS0FBSyxHQUFHLENBQUEsRUFBdEIsd0JBQXNCO2dDQUN4QixtQkFBbUI7Z0NBQ25CLFFBQVEsQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztnQ0FDbkMscUJBQU0sdUJBQWEsQ0FBQyxRQUFRLENBQUMsRUFBQTs7Z0NBQXhDLFFBQVEsR0FBRyxTQUE2QixDQUFDOzs7Z0NBRXpDLFFBQVEsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDOzs7Z0NBR3ZCLGlCQUFpQjtnQ0FDakIsR0FBRyxHQUFHLFNBQVMsQ0FBQztnQ0FDaEIsR0FBRyxHQUFHLFNBQVMsQ0FBQztnQ0FFaEIsY0FBYyxHQUFHLFNBQVMsQ0FBQztnQ0FFM0IsSUFBSSxHQUFHLElBQUksUUFBUSxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsTUFBTSxJQUFJLEdBQUcsRUFBRTtvQ0FDcEQscUJBQXFCO29DQUNyQixLQUFLLENBQUMsd0JBQXdCLEVBQUUsUUFBUSxDQUFDLENBQUM7b0NBQzFDLHNCQUFPLE1BQU0sQ0FBQyxJQUFJLHNCQUFjLENBQUMsa0JBQWdCLEdBQUssRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLDBCQUFrQixDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7aUNBQ3ZHO3FDQUFNLElBQUksR0FBRyxJQUFJLFFBQVEsQ0FBQyxNQUFNLElBQUksUUFBUSxDQUFDLE1BQU0sSUFBSSxHQUFHLEVBQUU7b0NBQzNELEtBQUssQ0FBQyx5QkFBeUIsRUFBRSxRQUFRLENBQUMsQ0FBQztvQ0FDM0Msc0JBQU8sTUFBTSxDQUFDLElBQUksc0JBQWMsQ0FBQyxtQkFBaUIsR0FBSyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsMEJBQWtCLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBQztpQ0FDekc7Z0NBRUQsS0FBSyxDQUFDLGtCQUFrQixFQUFFLFFBQVEsQ0FBQyxDQUFDO2dDQUNwQyxzQkFBTyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUM7OztxQkFDMUIsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUU7Z0JBQ2xCLEdBQUcsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRTtvQkFDN0IsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDO29CQUVaLElBQUksY0FBYyxFQUFFO3dCQUNsQixNQUFNLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQztxQkFDbkQ7b0JBRUQsT0FBTyxNQUFNLENBQUMsSUFBSSxzQkFBYyxDQUFDLGlCQUFpQixFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsMEJBQWtCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztnQkFDakcsQ0FBQyxDQUFDLENBQUM7YUFDSjtZQUVELEdBQUcsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLFVBQUEsR0FBRztnQkFDakIsSUFBSSxjQUFjLEVBQUU7b0JBQ2xCLE1BQU0sQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO2lCQUNuRDtnQkFFRCxJQUFJLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxPQUFPLEVBQUU7b0JBQ3ZCLE9BQU87aUJBQ1I7Z0JBRUQsS0FBSyxDQUFDLHdCQUF3QixFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQy9DLE9BQU8sTUFBTSxDQUFDLElBQUksc0JBQWMsQ0FBQyxvQkFBa0IsR0FBRyxDQUFDLElBQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLDBCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDNUcsQ0FBQyxDQUFDLENBQUM7WUFFSCxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtnQkFDeEUsT0FBTyxLQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDdkg7WUFFRCxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQTJCRDs7Ozs7OztPQU9HO0lBQ0ssb0NBQWMsR0FBdEIsVUFBdUIsTUFBTTtRQUMzQixJQUFNLFFBQVEsR0FBRyxJQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUN2QyxJQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ2xDLElBQU0sU0FBUyxHQUFHLFdBQVcsR0FBRyxlQUFlLENBQUM7UUFDaEQsSUFBTSxNQUFNLEdBQUcsV0FBVyxHQUFHLFNBQVMsQ0FBQztRQUV2QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsSUFBSSxlQUFlLEVBQUU7WUFDaEQsSUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGVBQWUsQ0FBQyxDQUFDO1lBQ25ELFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDdEI7UUFFRCxJQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUU7WUFDakIsSUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ2pELFFBQVEsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7U0FDaEM7UUFFRCxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXBCLE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFDSCxrQkFBQztBQUFELENBbFRBLEFBa1RDLElBQUE7QUFsVFksa0NBQVciLCJmaWxlIjoibGliL3JlcXVlc3QvYWRhcHRlcnMvaHR0cC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0ICogYXMgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgKiBhcyB6bGliIGZyb20gJ3psaWInO1xuaW1wb3J0IERlYnVnIGZyb20gJ2RlYnVnJztcblxuaW1wb3J0IHsgQWRhcHRlckludGVyZmFjZSB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IGdldFZlcnNpb24gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyBTdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCB7IEZzUmVxdWVzdE9wdGlvbnMsIEZzUmVzcG9uc2UgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBwcmVwYXJlRGF0YSwgcGFyc2VSZXNwb25zZSwgY29tYmluZVVSTCwgc2V0IGFzIHNldEhlYWRlciwgbm9ybWFsaXplSGVhZGVycyB9IGZyb20gJy4vLi4vaGVscGVycyc7XG5pbXBvcnQgeyBGc1JlcXVlc3RFcnJvckNvZGUsIEZzUmVxdWVzdEVycm9yIH0gZnJvbSAnLi4vZXJyb3InO1xuaW1wb3J0IHsgRnNIdHRwTWV0aG9kIH0gZnJvbSAnLi8uLi90eXBlcyc7XG5cbmNvbnN0IEhUVFBTX1JFR0VYUCA9IC9odHRwczo/LztcbmNvbnN0IEhUVFBfQ0hVTktfU0laRSA9IDE2ICogMTAyNDtcbmNvbnN0IE1BWF9SRURJUkVDVFMgPSAxMDtcbmNvbnN0IENBTkNFTF9DTEVBUiA9IGBGc0NsZWFuTWVtb3J5YDtcbmNvbnN0IGRlYnVnID0gRGVidWcoJ2ZzOnJlcXVlc3Q6aHR0cCcpO1xuXG4vKipcbiAqIFdyaXRhYmxlIHN0cmVhbSB0aGF0cyBvdmVyd3JhcCBodHRwIHJlcXVlc3QgZm9yIHByb2dyZXNzIGV2ZW50XG4gKlxuICogQGNsYXNzIEh0dHBXcml0YWJsZVN0cmVhbVxuICogQGV4dGVuZHMge1N0cmVhbS5Xcml0YWJsZX1cbiAqL1xuY2xhc3MgSHR0cFdyaXRhYmxlU3RyZWFtIGV4dGVuZHMgU3RyZWFtLldyaXRhYmxlIHtcbiAgcHJpdmF0ZSByZXF1ZXN0O1xuXG4gIGNvbnN0cnVjdG9yKHJlcSwgb3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICB0aGlzLnJlcXVlc3QgPSByZXE7XG4gICAgcmVxLm9uY2UoJ2RyYWluJywgKCkgPT4gdGhpcy5lbWl0KCdkcmFpbicpKTtcbiAgfVxuXG4gIF93cml0ZShjaHVuazogYW55LCBlbmNvZGluZz86IHN0cmluZywgY2I/OiAoZXJyb3I6IEVycm9yIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMucmVxdWVzdC53cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIGVuZChjaHVuaykge1xuICAgIGlmIChjaHVuaykge1xuICAgICAgdGhpcy5yZXF1ZXN0LndyaXRlKGNodW5rKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3QuZW5kKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb2RlIGh0dHAgcmVxdWVzdCBjbGFzc1xuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBIdHRwQWRhcHRlclxuICogQGltcGxlbWVudHMge0FkYXB0ZXJJbnRlcmZhY2V9XG4gKi9cbmV4cG9ydCBjbGFzcyBIdHRwQWRhcHRlciBpbXBsZW1lbnRzIEFkYXB0ZXJJbnRlcmZhY2Uge1xuICBwcml2YXRlIHJlZGlyZWN0SG9vcHMgPSAwO1xuICBwcml2YXRlIHJlZGlyZWN0UGF0aHMgPSBbXTtcblxuICAvKipcbiAgICogZG8gcmVxdWVzdCBiYXNlZCBvbiBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7RnNSZXF1ZXN0T3B0aW9uc30gY29uZmlnXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBIdHRwQWRhcHRlclxuICAgKi9cbiAgcmVxdWVzdChjb25maWc6IEZzUmVxdWVzdE9wdGlvbnMpIHtcbiAgICAvLyBpZiB0aGlzIG9wdGlvbiBpcyB1bnNwZWNpZmllZCBzZXQgaXQgYnkgZGVmYXVsdFxuICAgIGlmICh0eXBlb2YgY29uZmlnLmZpbGVzdGFja0hlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25maWcuZmlsZXN0YWNrSGVhZGVycyA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uZmlnLmhlYWRlcnMgPSBub3JtYWxpemVIZWFkZXJzKGNvbmZpZy5oZWFkZXJzKTtcblxuICAgIGxldCB7IGRhdGEsIGhlYWRlcnMgfSA9IHByZXBhcmVEYXRhKGNvbmZpZyk7XG5cbiAgICBoZWFkZXJzID0gc2V0SGVhZGVyKGhlYWRlcnMsICd1c2VyLWFnZW50JywgYGZpbGVzdGFjay1yZXF1ZXN0LyR7Z2V0VmVyc2lvbigpfWApO1xuXG4gICAgLy8gZm9yIG5vdyB3ZSBhcmUgbm90IHVzaW5nIHN0cmVhbXNcbiAgICBpZiAoZGF0YSkge1xuICAgICAgZGVidWcoJ1JlcXVlc3QgZGF0YSAlTycsIGRhdGEpO1xuXG4gICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcignRGF0YSBtdXN0IGJlIGEgc3RyaW5nLCBKU09OIG9yIGEgQnVmZmVyJywgY29uZmlnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ3V0Zi04Jyk7XG4gICAgICB9XG5cbiAgICAgIGhlYWRlcnMgPSBzZXRIZWFkZXIoaGVhZGVycywgJ2NvbnRlbnQtbGVuZ3RoJywgZGF0YS5sZW5ndGgsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBsZXQgYXV0aDtcbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIGlmICghY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgY29uZmlnLmF1dGgudXNlcm5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRnNSZXF1ZXN0RXJyb3IoYEJhc2ljIGF1dGg6IHVzZXJuYW1lIGlzIHJlcXVpcmVkICR7Y29uZmlnLmF1dGh9YCwgY29uZmlnKSk7XG4gICAgICB9XG5cbiAgICAgIGF1dGggPSBgJHtjb25maWcuYXV0aC51c2VybmFtZX06JHtjb25maWcuYXV0aC5wYXNzd29yZH1gO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHVybFxuICAgIGxldCBwYXJzZWQgPSB1cmwucGFyc2UoY29uZmlnLnVybCk7XG5cbiAgICAvLyB0cnkgdG8gYWRkIGRlZmF1bHQgaHR0cHMgcHJvdG9jb2xcbiAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCkge1xuICAgICAgcGFyc2VkID0gdXJsLnBhcnNlKGBodHRwczovLyR7Y29uZmlnLnVybH1gKTtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDoganVzdCBiZSBzdXJlIHRoYXQgdGhlIGhvc3QgaXMgcGFyc2VkIGNvcnJlY3RseSwgbm90IG5lZWRlZCB0byB0ZXN0ICovXG4gICAgaWYgKCFwYXJzZWQuaG9zdCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgQ2Fubm90IHBhcnNlIHByb3ZpZGVkIHVybCAke2NvbmZpZy51cmx9YCwgY29uZmlnKSk7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXplIGF1dGggaGVhZGVyXG4gICAgaWYgKGF1dGggJiYgaGVhZGVycy5BdXRob3JpemF0aW9uKSB7XG4gICAgICBkZWxldGUgaGVhZGVycy5BdXRob3JpemF0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGlzSHR0cHNSZXF1ZXN0ID0gSFRUUFNfUkVHRVhQLnRlc3QocGFyc2VkLnByb3RvY29sKTtcbiAgICBjb25zdCBhZ2VudCA9IGlzSHR0cHNSZXF1ZXN0ID8gcmVxdWlyZSgnaHR0cHMnKSA6IHJlcXVpcmUoJ2h0dHAnKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBwYXRoOiBjb21iaW5lVVJMKHBhcnNlZC5wYXRoLCBjb25maWcucGFyYW1zKSxcbiAgICAgIGhvc3Q6IHBhcnNlZC5ob3N0LFxuICAgICAgcG9ydDogcGFyc2VkLnBvcnQsXG4gICAgICBwcm90b2NvbDogcGFyc2VkLnByb3RvY29sLFxuICAgICAgbWV0aG9kOiBjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgYWdlbnQ6IG5ldyBhZ2VudC5BZ2VudCgpLFxuICAgICAgYXV0aDogYXV0aCxcbiAgICB9O1xuXG4gICAgZGVidWcoJ1N0YXJ0aW5nICVzIHJlcXVlc3Qgd2l0aCBvcHRpb25zICVPJywgaXNIdHRwc1JlcXVlc3QgPyAnaHR0cHMnIDogJ2h0dHAnLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxGc1Jlc3BvbnNlPigocmVzb2x2ZSwgcmVqZWN0KTogYW55ID0+IHtcbiAgICAgIGxldCByZXE7XG4gICAgICBsZXQgY2FuY2VsTGlzdGVuZXI7XG5cbiAgICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgY2FuY2VsTGlzdGVuZXIgPSBjb25maWcuY2FuY2VsVG9rZW4ub24oJ2NhbmNlbCcsIChyZWFzb24pID0+IHtcbiAgICAgICAgICAvLyBjbGVhbnVwIGhhbmRsZXJcbiAgICAgICAgICBjYW5jZWxMaXN0ZW5lciA9IG51bGw7XG5cbiAgICAgICAgICAvLyBkbyBub3RoaW5nIGlmIHByb21pc2UgaXMgcmVzb2x2ZWQgYnkgc3lzdGVtXG4gICAgICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ubWVzc2FnZSA9PT0gQ0FOQ0VMX0NMRUFSKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGlmIHJlcXVlc3QgaXMgZG9uZSBjYW5jZWwgdG9rZW4gc2hvdWxkIG5vdCB0aHJvdyBhbnkgZXJyb3IgKi9cbiAgICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgICByZXEuYWJvcnQoKTtcbiAgICAgICAgICAgIHJlcSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVidWcoJ1JlcXVlc3QgY2FuY2VsZWQgYnkgdXNlciAlcywgY29uZmlnOiAlTycsIHJlYXNvbiwgY29uZmlnKTtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgUmVxdWVzdCBhYm9ydGVkLiBSZWFzb246ICR7cmVhc29ufWAsIGNvbmZpZywgbnVsbCwgRnNSZXF1ZXN0RXJyb3JDb2RlLkFCT1JURUQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJlcSA9IGFnZW50LnJlcXVlc3Qob3B0aW9ucywgcmVzID0+IHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGp1c3QgYmUgc3VyZSB0aGF0IHJlc3BvbnNlIHdpbGwgbm90IGJlIGNhbGxlZCBhZnRlciByZXF1ZXN0IGlzIGFib3J0ZWQgKi9cbiAgICAgICAgaWYgKCFyZXEgfHwgcmVxLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgY29uZmlnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RyZWFtID0gcmVzO1xuICAgICAgICBkZWJ1ZygnUmVzcG9uc2Ugc3RhdHVzQ29kZTogJWQsIFJlc3BvbnNlIEhlYWRlcnM6ICVPJywgcmVzLnN0YXR1c0NvZGUsIHJlcy5oZWFkZXJzKTtcblxuICAgICAgICBjb25zdCBjb21wcmVzc0hlYWRlcnMgPSByZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xuXG4gICAgICAgIGlmIChjb21wcmVzc0hlYWRlcnMgJiYgY29tcHJlc3NIZWFkZXJzLmxlbmd0aCAmJiBbJ2d6aXAnLCAnY29tcHJlc3MnLCAnZGVmbGF0ZSddLnNvbWUoKHYpID0+IGNvbXByZXNzSGVhZGVycy5pbmRleE9mKHYpID4gLTEpKSB7XG4gICAgICAgICAgLy8gYWRkIHRoZSB1bnppcHBlciB0byB0aGUgYm9keSBzdHJlYW0gcHJvY2Vzc2luZyBwaXBlbGluZVxuICAgICAgICAgIHN0cmVhbSA9IHJlcy5zdGF0dXNDb2RlID09PSAyMDQgPyBzdHJlYW0gOiBzdHJlYW0ucGlwZSh6bGliLmNyZWF0ZVVuemlwKCkpO1xuICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY29udGVudC1lbmNvZGluZyBpbiBvcmRlciB0byBub3QgY29uZnVzZSBkb3duc3RyZWFtIG9wZXJhdGlvbnNcbiAgICAgICAgICBkZWxldGUgcmVzLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXNwb25zZTogRnNSZXNwb25zZSA9IHtcbiAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXNDb2RlLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlcy5zdGF0dXNNZXNzYWdlLFxuICAgICAgICAgIGhlYWRlcnM6IHJlcy5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGZvbGxvdyByZWRpcmVjdCBzbyBtYWtlIHNhbWUgcmVxdWVzdCB3aXRoIG5ldyBsb2NhdGlvblxuICAgICAgICBpZiAoWzMwMSwgMzAyXS5pbmRleE9mKHJlcy5zdGF0dXNDb2RlKSA+IC0xKSB7XG4gICAgICAgICAgZGVidWcoJ1JlZGlyZWN0IHJlY2VpdmVkICVzJywgcmVzLnN0YXR1c0NvZGUpO1xuXG4gICAgICAgICAgaWYgKHRoaXMucmVkaXJlY3RIb29wcyA+PSBNQVhfUkVESVJFQ1RTKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgTWF4IHJlZGlyZWN0cyAoJHt0aGlzLnJlZGlyZWN0SG9vcHN9KSByZWFjaGVkLiBFeGl0aW5nYCwgY29uZmlnLCByZXNwb25zZSwgRnNSZXF1ZXN0RXJyb3JDb2RlLlJFRElSRUNUKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdXJsID0gcmVzLmhlYWRlcnNbJ2xvY2F0aW9uJ107XG5cbiAgICAgICAgICBpZiAoIXVybCB8fCB1cmwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgUmVkaXJlY3QgaGVhZGVyIGxvY2F0aW9uIG5vdCBmb3VuZGAsIGNvbmZpZywgcmVzcG9uc2UsIEZzUmVxdWVzdEVycm9yQ29kZS5SRURJUkVDVCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnJlZGlyZWN0UGF0aHMuaW5kZXhPZih1cmwpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEZzUmVxdWVzdEVycm9yKGBSZWRpcmVjdCBsb29wIGRldGVjdGVkIGF0IHVybCAke3VybH1gLCBjb25maWcsIHJlc3BvbnNlLCBGc1JlcXVlc3RFcnJvckNvZGUuUkVESVJFQ1QpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnJlZGlyZWN0UGF0aHMucHVzaCh1cmwpO1xuICAgICAgICAgIHRoaXMucmVkaXJlY3RIb29wcysrO1xuXG4gICAgICAgICAgLy8gZnJlZSByZXNvdXJjZXNcbiAgICAgICAgICByZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVxID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgZGVidWcoJ1JlZGlyZWN0aW5nIHJlcXVlc3QgdG8gJXMgKGhvb3AtY291bnQ6ICVkKScsIHVybCwgdGhpcy5yZWRpcmVjdEhvb3BzKTtcblxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMucmVxdWVzdChPYmplY3QuYXNzaWduKHt9LCBjb25maWcsIHsgdXJsIH0pKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzcG9uc2VCdWZmZXIgPSBbXTtcbiAgICAgICAgc3RyZWFtLm9uKCdkYXRhJywgY2h1bmsgPT4gcmVzcG9uc2VCdWZmZXIucHVzaChjaHVuaykpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBpdHMgaGFyZCB0byB0ZXN0IHNvY2tldCBldmVudHMgd2l0aCBqZXN0IGFuZCBub2NrIC0gdGVzdGVkIG1hbnVhbGx5ICovXG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgIHJlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzcG9uc2VCdWZmZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVidWcoJ1JlcXVlc3QgZXJyb3I6IEFib3J0ZWQgJU8nLCBlcnIpO1xuXG4gICAgICAgICAgaWYgKHJlcS5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY2xlYXIgY2FuY2VsIHRva2VuIHRvIGF2b2lkIG1lbW9yeSBsZWFrXG4gICAgICAgICAgaWYgKGNhbmNlbExpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25maWcuY2FuY2VsVG9rZW4ucmVtb3ZlTGlzdGVuZXIoY2FuY2VsTGlzdGVuZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEZzUmVxdWVzdEVycm9yKGVyci5tZXNzYWdlLCBjb25maWcsIG51bGwsIEZzUmVxdWVzdEVycm9yQ29kZS5ORVRXT1JLKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIC8vIGNsZWFyIGNhbmNlbCB0b2tlbiB0byBhdm9pZCBtZW1vcnkgbGVha1xuICAgICAgICAgIGlmIChjYW5jZWxMaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnJlbW92ZUxpc3RlbmVyKGNhbmNlbExpc3RlbmVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhbnkgcmVzcG9uc2UgZGF0YSBpbnNpZGVcbiAgICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgIT09IDIwNCkge1xuICAgICAgICAgICAgLy8gcHJlcGFyZSByZXNwb25zZVxuICAgICAgICAgICAgcmVzcG9uc2UuZGF0YSA9IEJ1ZmZlci5jb25jYXQocmVzcG9uc2VCdWZmZXIpO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBwYXJzZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UuZGF0YSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZnJlZSByZXNvdXJjZXNcbiAgICAgICAgICByZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVxID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgcmVzcG9uc2VCdWZmZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoNTAwIDw9IHJlc3BvbnNlLnN0YXR1cyAmJiByZXNwb25zZS5zdGF0dXMgPD0gNTk5KSB7XG4gICAgICAgICAgICAvLyBzZXJ2ZXIgZXJyb3IgdGhyb3dcbiAgICAgICAgICAgIGRlYnVnKCdTZXJ2ZXIgZXJyb3IoNXh4KSAtICVPJywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRnNSZXF1ZXN0RXJyb3IoYFNlcnZlciBlcnJvciAke3VybH1gLCBjb25maWcsIHJlc3BvbnNlLCBGc1JlcXVlc3RFcnJvckNvZGUuU0VSVkVSKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICg0MDAgPD0gcmVzcG9uc2Uuc3RhdHVzICYmIHJlc3BvbnNlLnN0YXR1cyA8PSA0OTkpIHtcbiAgICAgICAgICAgIGRlYnVnKCdSZXF1ZXN0IGVycm9yKDR4eCkgLSAlTycsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEZzUmVxdWVzdEVycm9yKGBSZXF1ZXN0IGVycm9yICR7dXJsfWAsIGNvbmZpZywgcmVzcG9uc2UsIEZzUmVxdWVzdEVycm9yQ29kZS5SRVFVRVNUKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVidWcoJ1JlcXVlc3QgZW5kczogJU8nLCByZXNwb25zZSk7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXQpIHtcbiAgICAgICAgcmVxLnNldFRpbWVvdXQoY29uZmlnLnRpbWVvdXQsICgpID0+IHtcbiAgICAgICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgICAgIGlmIChjYW5jZWxMaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnJlbW92ZUxpc3RlbmVyKGNhbmNlbExpc3RlbmVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcignUmVxdWVzdCB0aW1lb3V0JywgY29uZmlnLCBudWxsLCBGc1JlcXVlc3RFcnJvckNvZGUuVElNRU9VVCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmVxLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgIGlmIChjYW5jZWxMaXN0ZW5lcikge1xuICAgICAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5yZW1vdmVMaXN0ZW5lcihjYW5jZWxMaXN0ZW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlcSB8fCByZXEuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnKCdSZXF1ZXN0IGVycm9yOiAlcyAtICVPJywgZXJyLCBlcnIuY29kZSk7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEZzUmVxdWVzdEVycm9yKGBSZXF1ZXN0IGVycm9yOiAke2Vyci5jb2RlfWAsIGNvbmZpZywgbnVsbCwgRnNSZXF1ZXN0RXJyb3JDb2RlLk5FVFdPUkspKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpICYmIFsnUE9TVCcsICdQVVQnXS5pbmRleE9mKGNvbmZpZy5tZXRob2QpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyVG9DaHVua3MoZGF0YSkucGlwZSh0aGlzLmdldFByb2dyZXNzTW9uaXRvcihjb25maWcsIGRhdGEubGVuZ3RoKSkucGlwZShuZXcgSHR0cFdyaXRhYmxlU3RyZWFtKHJlcSkpO1xuICAgICAgfVxuXG4gICAgICByZXEuZW5kKGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vbml0b3IgYW5kIGVtaXQgcHJvZ3Jlc3MgZXZlbnQgaWYgbmVlZGVkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZW1iZXJvZiBIdHRwQWRhcHRlclxuICAgKi9cbiAgcHJpdmF0ZSBnZXRQcm9ncmVzc01vbml0b3IgPSAoY29uZmlnLCB0b3RhbCkgPT4ge1xuICAgIGxldCBsb2FkZWQgPSAwO1xuXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBuZXcgU3RyZWFtLlRyYW5zZm9ybSgpO1xuICAgIHByb2dyZXNzLl90cmFuc2Zvcm0gPSAoY2h1bmssIGVuY29kaW5nLCBjYikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcub25Qcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiBbRnNIdHRwTWV0aG9kLlBPU1QsIEZzSHR0cE1ldGhvZC5QVVRdLmluZGV4T2YoY29uZmlnLm1ldGhvZCkgPiAtMSkge1xuICAgICAgICBsb2FkZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBjb25maWcub25Qcm9ncmVzcyh7XG4gICAgICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBsb2FkZWQsXG4gICAgICAgICAgdG90YWwsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2IobnVsbCwgY2h1bmspO1xuICAgIH07XG5cbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBidWZmZXIgdG8gc3RyZWFtXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gYnVmZmVyXG4gICAqIEByZXR1cm5zIHtTdHJlYW0uUmVhZGFibGV9XG4gICAqIEBtZW1iZXJvZiBIdHRwQWRhcHRlclxuICAgKi9cbiAgcHJpdmF0ZSBidWZmZXJUb0NodW5rcyhidWZmZXIpOiBTdHJlYW0uUmVhZGFibGUge1xuICAgIGNvbnN0IGNodW5raW5nID0gbmV3IFN0cmVhbS5SZWFkYWJsZSgpO1xuICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICBjb25zdCByZW1haW5kZXIgPSB0b3RhbExlbmd0aCAlIEhUVFBfQ0hVTktfU0laRTtcbiAgICBjb25zdCBjdXRvZmYgPSB0b3RhbExlbmd0aCAtIHJlbWFpbmRlcjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3V0b2ZmOyBpICs9IEhUVFBfQ0hVTktfU0laRSkge1xuICAgICAgY29uc3QgY2h1bmsgPSBidWZmZXIuc2xpY2UoaSwgaSArIEhUVFBfQ0hVTktfU0laRSk7XG4gICAgICBjaHVua2luZy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBpZiAocmVtYWluZGVyID4gMCkge1xuICAgICAgY29uc3QgcmVtYWluZGVyQnVmZmVyID0gYnVmZmVyLnNsaWNlKC1yZW1haW5kZXIpO1xuICAgICAgY2h1bmtpbmcucHVzaChyZW1haW5kZXJCdWZmZXIpO1xuICAgIH1cblxuICAgIGNodW5raW5nLnB1c2gobnVsbCk7XG5cbiAgICByZXR1cm4gY2h1bmtpbmc7XG4gIH1cbn1cbiJdfQ==


/***/ }),

/***/ 4055:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var shouldRetry_1 = __nccwpck_require__(1649);
var debug_1 = __nccwpck_require__(8237);
var debug = debug_1.default('fs:request:dispatch');
/**
 * Request dispatcher
 *
 * @export
 * @class Dispatch
 */
var Dispatch = /** @class */ (function () {
    /**
     * Creates an instance of Dispatch.
     *
     * @param {AdapterInterface} adapter http | XHR adapater
     * @memberof Dispatch
     */
    function Dispatch(adapter) {
        this.adapter = adapter;
    }
    /**
     * Dispatch request adding retry policy
     * @todo add data preprocesor
     *
     * @param {FsRequestOptions} config
     * @returns {Promise<FsResponse>}
     * @memberof Dispatch
     */
    Dispatch.prototype.request = function (config) {
        var _this = this;
        config.headers = config.headers || {};
        debug('Dispatching request %O', config);
        return this.adapter.request(config).catch(function (reason) {
            debug('Request error "%s": %O', reason, reason.response);
            return _this.retry(reason);
        });
    };
    /**
     * Request retrier
     *
     * @private
     * @param {FsRequestError} err
     * @returns
     * @memberof Dispatch
     */
    Dispatch.prototype.retry = function (err) {
        var _this = this;
        var config = err.config;
        if (!shouldRetry_1.shouldRetry(err)) {
            debug('[Retry] Request error is not retriable. Exiting');
            return Promise.reject(err);
        }
        if (!config.retry) {
            debug('[Retry] Retry config not found. Exiting');
            return Promise.reject(err);
        }
        var retryConfig = config.retry;
        var attempts = config.runtime && config.runtime.retryCount ? config.runtime.retryCount : 0;
        if (retryConfig.retry && retryConfig.retry <= attempts) {
            debug('[Retry] Retry attempts reached %d. Exiting', attempts);
            return Promise.reject(err);
        }
        var retryDelay = Math.max(Math.min(retryConfig.retryMaxTime, Math.pow(retryConfig.retryFactor, attempts) * 1000), 1);
        config.runtime = tslib_1.__assign(tslib_1.__assign({}, config.runtime), { retryCount: attempts + 1 });
        debug("[Retry] Retrying request to " + config.url + ", count " + attempts + " of " + retryConfig.retry + " - Delay: " + retryDelay);
        return new Promise(function (resolve) {
            setTimeout(function () { return resolve(_this.request(config)); }, retryDelay);
        });
    };
    return Dispatch;
}());
exports.Dispatch = Dispatch;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9kaXNwYXRjaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFtQkEscURBQW9EO0FBQ3BELCtCQUEwQjtBQUUxQixJQUFNLEtBQUssR0FBRyxlQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUUzQzs7Ozs7R0FLRztBQUNIO0lBR0U7Ozs7O09BS0c7SUFDSCxrQkFBWSxPQUF5QjtRQUNuQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztJQUN6QixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLDBCQUFPLEdBQWQsVUFBZSxNQUF3QjtRQUF2QyxpQkFPQztRQU5DLE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUM7UUFDdEMsS0FBSyxDQUFDLHdCQUF3QixFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLFVBQUMsTUFBc0I7WUFDL0QsS0FBSyxDQUFDLHdCQUF3QixFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDekQsT0FBTyxLQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzVCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSyx3QkFBSyxHQUFiLFVBQWMsR0FBbUI7UUFBakMsaUJBaUNDO1FBaENDLElBQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUM7UUFFMUIsSUFBSSxDQUFDLHlCQUFXLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDckIsS0FBSyxDQUFDLGlEQUFpRCxDQUFDLENBQUM7WUFDekQsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzVCO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUU7WUFDakIsS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7WUFDakQsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzVCO1FBRUQsSUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUNqQyxJQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsT0FBTyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTNGLElBQUksV0FBVyxDQUFDLEtBQUssSUFBSSxXQUFXLENBQUMsS0FBSyxJQUFJLFFBQVEsRUFBRTtZQUN0RCxLQUFLLENBQUMsNENBQTRDLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDOUQsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzVCO1FBRUQsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUUsU0FBQSxXQUFXLENBQUMsV0FBVyxFQUFJLFFBQVEsQ0FBQSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRS9HLE1BQU0sQ0FBQyxPQUFPLHlDQUNULE1BQU0sQ0FBQyxPQUFPLEtBQ2pCLFVBQVUsRUFBRSxRQUFRLEdBQUcsQ0FBQyxHQUN6QixDQUFDO1FBRUYsS0FBSyxDQUFDLGlDQUErQixNQUFNLENBQUMsR0FBRyxnQkFBVyxRQUFRLFlBQU8sV0FBVyxDQUFDLEtBQUssa0JBQWEsVUFBWSxDQUFDLENBQUM7UUFFckgsT0FBTyxJQUFJLE9BQU8sQ0FBYSxVQUFBLE9BQU87WUFDcEMsVUFBVSxDQUFDLGNBQU0sT0FBQSxPQUFPLENBQUMsS0FBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUE3QixDQUE2QixFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQzlELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUNILGVBQUM7QUFBRCxDQXhFQSxBQXdFQyxJQUFBO0FBeEVZLDRCQUFRIiwiZmlsZSI6ImxpYi9yZXF1ZXN0L2Rpc3BhdGNoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2tcbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgRnNSZXF1ZXN0T3B0aW9ucywgRnNSZXNwb25zZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgQWRhcHRlckludGVyZmFjZSB9IGZyb20gJy4vYWRhcHRlcnMvaW50ZXJmYWNlJztcbmltcG9ydCB7IEZzUmVxdWVzdEVycm9yIH0gZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgeyBzaG91bGRSZXRyeSB9IGZyb20gJy4vaGVscGVycy9zaG91bGRSZXRyeSc7XG5pbXBvcnQgRGVidWcgZnJvbSAnZGVidWcnO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKCdmczpyZXF1ZXN0OmRpc3BhdGNoJyk7XG5cbi8qKlxuICogUmVxdWVzdCBkaXNwYXRjaGVyXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIERpc3BhdGNoXG4gKi9cbmV4cG9ydCBjbGFzcyBEaXNwYXRjaCB7XG4gIGFkYXB0ZXI6IEFkYXB0ZXJJbnRlcmZhY2U7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgRGlzcGF0Y2guXG4gICAqXG4gICAqIEBwYXJhbSB7QWRhcHRlckludGVyZmFjZX0gYWRhcHRlciBodHRwIHwgWEhSIGFkYXBhdGVyXG4gICAqIEBtZW1iZXJvZiBEaXNwYXRjaFxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcjogQWRhcHRlckludGVyZmFjZSkge1xuICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXI7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2ggcmVxdWVzdCBhZGRpbmcgcmV0cnkgcG9saWN5XG4gICAqIEB0b2RvIGFkZCBkYXRhIHByZXByb2Nlc29yXG4gICAqXG4gICAqIEBwYXJhbSB7RnNSZXF1ZXN0T3B0aW9uc30gY29uZmlnXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEZzUmVzcG9uc2U+fVxuICAgKiBAbWVtYmVyb2YgRGlzcGF0Y2hcbiAgICovXG4gIHB1YmxpYyByZXF1ZXN0KGNvbmZpZzogRnNSZXF1ZXN0T3B0aW9ucyk6IFByb21pc2U8RnNSZXNwb25zZT4ge1xuICAgIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG4gICAgZGVidWcoJ0Rpc3BhdGNoaW5nIHJlcXVlc3QgJU8nLCBjb25maWcpO1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXIucmVxdWVzdChjb25maWcpLmNhdGNoKChyZWFzb246IEZzUmVxdWVzdEVycm9yKSA9PiB7XG4gICAgICBkZWJ1ZygnUmVxdWVzdCBlcnJvciBcIiVzXCI6ICVPJywgcmVhc29uLCByZWFzb24ucmVzcG9uc2UpO1xuICAgICAgcmV0dXJuIHRoaXMucmV0cnkocmVhc29uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHJldHJpZXJcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGc1JlcXVlc3RFcnJvcn0gZXJyXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBEaXNwYXRjaFxuICAgKi9cbiAgcHJpdmF0ZSByZXRyeShlcnI6IEZzUmVxdWVzdEVycm9yKSB7XG4gICAgY29uc3QgY29uZmlnID0gZXJyLmNvbmZpZztcblxuICAgIGlmICghc2hvdWxkUmV0cnkoZXJyKSkge1xuICAgICAgZGVidWcoJ1tSZXRyeV0gUmVxdWVzdCBlcnJvciBpcyBub3QgcmV0cmlhYmxlLiBFeGl0aW5nJyk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmZpZy5yZXRyeSkge1xuICAgICAgZGVidWcoJ1tSZXRyeV0gUmV0cnkgY29uZmlnIG5vdCBmb3VuZC4gRXhpdGluZycpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgY29uc3QgcmV0cnlDb25maWcgPSBjb25maWcucmV0cnk7XG4gICAgbGV0IGF0dGVtcHRzID0gY29uZmlnLnJ1bnRpbWUgJiYgY29uZmlnLnJ1bnRpbWUucmV0cnlDb3VudCA/IGNvbmZpZy5ydW50aW1lLnJldHJ5Q291bnQgOiAwO1xuXG4gICAgaWYgKHJldHJ5Q29uZmlnLnJldHJ5ICYmIHJldHJ5Q29uZmlnLnJldHJ5IDw9IGF0dGVtcHRzKSB7XG4gICAgICBkZWJ1ZygnW1JldHJ5XSBSZXRyeSBhdHRlbXB0cyByZWFjaGVkICVkLiBFeGl0aW5nJywgYXR0ZW1wdHMpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgY29uc3QgcmV0cnlEZWxheSA9IE1hdGgubWF4KE1hdGgubWluKHJldHJ5Q29uZmlnLnJldHJ5TWF4VGltZSwgcmV0cnlDb25maWcucmV0cnlGYWN0b3IgKiogYXR0ZW1wdHMgKiAxMDAwKSwgMSk7XG5cbiAgICBjb25maWcucnVudGltZSA9IHtcbiAgICAgIC4uLmNvbmZpZy5ydW50aW1lLFxuICAgICAgcmV0cnlDb3VudDogYXR0ZW1wdHMgKyAxLFxuICAgIH07XG5cbiAgICBkZWJ1ZyhgW1JldHJ5XSBSZXRyeWluZyByZXF1ZXN0IHRvICR7Y29uZmlnLnVybH0sIGNvdW50ICR7YXR0ZW1wdHN9IG9mICR7cmV0cnlDb25maWcucmV0cnl9IC0gRGVsYXk6ICR7cmV0cnlEZWxheX1gKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxGc1Jlc3BvbnNlPihyZXNvbHZlID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSh0aGlzLnJlcXVlc3QoY29uZmlnKSksIHJldHJ5RGVsYXkpO1xuICAgIH0pO1xuICB9XG59XG4iXX0=


/***/ }),

/***/ 8953:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
/**
 * Filestack error codes (common for browser and node)
 *
 * @export
 * @enum {number}
 */
var FsRequestErrorCode;
(function (FsRequestErrorCode) {
    FsRequestErrorCode["ABORTED"] = "ABORTED";
    FsRequestErrorCode["NETWORK"] = "NETWORK";
    FsRequestErrorCode["TIMEOUT"] = "TIMEDOUT";
    FsRequestErrorCode["SERVER"] = "SERVER";
    FsRequestErrorCode["REQUEST"] = "REQUEST";
    FsRequestErrorCode["OTHER"] = "OTHER";
    FsRequestErrorCode["REDIRECT"] = "REDIRECT";
})(FsRequestErrorCode = exports.FsRequestErrorCode || (exports.FsRequestErrorCode = {}));
/**
 * Custom Filestack Request error class
 *
 * @export
 * @class FsRequestError
 * @extends {Error}
 */
var FsRequestError = /** @class */ (function (_super) {
    tslib_1.__extends(FsRequestError, _super);
    /**
     * Creates an instance of FsRequestError.
     *
     * @param {string} message
     * @param {*} config
     * @param {FsResponse} [response]
     * @param {FsRequestErrorCode} [code]
     * @memberof FsRequestError
     */
    function FsRequestError(message, config, response, code) {
        var _newTarget = this.constructor;
        var _this = 
        /* istanbul ignore next */
        _super.call(this, message) || this;
        _this.config = config;
        _this.response = response;
        _this.code = code;
        // const captureStackTrace: Function = (Error as any).captureStackTrace;
        // captureStackTrace && captureStackTrace(this);
        fixProto(_this, _newTarget.prototype);
        return _this;
    }
    return FsRequestError;
}(Error));
exports.FsRequestError = FsRequestError;
function fixProto(target, prototype) {
    var setPrototypeOf = Object.setPrototypeOf;
    /* istanbul ignore next */
    setPrototypeOf ? setPrototypeOf(target, prototype) : (target.__proto__ = prototype);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9lcnJvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFrQkE7Ozs7O0dBS0c7QUFDSCxJQUFZLGtCQVFYO0FBUkQsV0FBWSxrQkFBa0I7SUFDNUIseUNBQW1CLENBQUE7SUFDbkIseUNBQW1CLENBQUE7SUFDbkIsMENBQW9CLENBQUE7SUFDcEIsdUNBQWlCLENBQUE7SUFDakIseUNBQW1CLENBQUE7SUFDbkIscUNBQWUsQ0FBQTtJQUNmLDJDQUFxQixDQUFBO0FBQ3ZCLENBQUMsRUFSVyxrQkFBa0IsR0FBbEIsMEJBQWtCLEtBQWxCLDBCQUFrQixRQVE3QjtBQUVEOzs7Ozs7R0FNRztBQUNIO0lBQW9DLDBDQUFLO0lBV3ZDOzs7Ozs7OztPQVFHO0lBQ0gsd0JBQVksT0FBZSxFQUFFLE1BQVcsRUFBRSxRQUFxQixFQUFFLElBQXlCOztRQUExRjtRQUNFLDBCQUEwQjtRQUMxQixrQkFBTSxPQUFPLENBQUMsU0FTZjtRQVBDLEtBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLEtBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBQ3pCLEtBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBRWpCLHdFQUF3RTtRQUN4RSxnREFBZ0Q7UUFDaEQsUUFBUSxDQUFDLEtBQUksRUFBRSxXQUFXLFNBQVMsQ0FBQyxDQUFDOztJQUN2QyxDQUFDO0lBQ0gscUJBQUM7QUFBRCxDQWhDQSxBQWdDQyxDQWhDbUMsS0FBSyxHQWdDeEM7QUFoQ1ksd0NBQWM7QUFrQzNCLFNBQVMsUUFBUSxDQUFDLE1BQWEsRUFBRSxTQUFhO0lBQzVDLElBQU0sY0FBYyxHQUFjLE1BQWMsQ0FBQyxjQUFjLENBQUM7SUFDaEUsMEJBQTBCO0lBQzFCLGNBQWMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBRSxNQUFjLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQyxDQUFDO0FBQy9GLENBQUMiLCJmaWxlIjoibGliL3JlcXVlc3QvZXJyb3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgRnNSZXF1ZXN0T3B0aW9ucywgRnNSZXNwb25zZSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIEZpbGVzdGFjayBlcnJvciBjb2RlcyAoY29tbW9uIGZvciBicm93c2VyIGFuZCBub2RlKVxuICpcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBlbnVtIEZzUmVxdWVzdEVycm9yQ29kZSB7XG4gIEFCT1JURUQgPSAnQUJPUlRFRCcsXG4gIE5FVFdPUksgPSAnTkVUV09SSycsXG4gIFRJTUVPVVQgPSAnVElNRURPVVQnLFxuICBTRVJWRVIgPSAnU0VSVkVSJyxcbiAgUkVRVUVTVCA9ICdSRVFVRVNUJyxcbiAgT1RIRVIgPSAnT1RIRVInLFxuICBSRURJUkVDVCA9ICdSRURJUkVDVCcsXG59XG5cbi8qKlxuICogQ3VzdG9tIEZpbGVzdGFjayBSZXF1ZXN0IGVycm9yIGNsYXNzXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIEZzUmVxdWVzdEVycm9yXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKi9cbmV4cG9ydCBjbGFzcyBGc1JlcXVlc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIEVycm9yIGRldGFpbHMsIGllIHZhbGlkYXRpb24gZXJyb3JzXG4gICAqXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAbWVtYmVyb2YgRmlsZXN0YWNrRXJyb3JcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBjb25maWc6IEZzUmVxdWVzdE9wdGlvbnM7XG4gIHB1YmxpYyByZWFkb25seSByZXNwb25zZTogRnNSZXNwb25zZTtcbiAgcHVibGljIHJlYWRvbmx5IGNvZGU6IEZzUmVxdWVzdEVycm9yQ29kZTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBGc1JlcXVlc3RFcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHsqfSBjb25maWdcbiAgICogQHBhcmFtIHtGc1Jlc3BvbnNlfSBbcmVzcG9uc2VdXG4gICAqIEBwYXJhbSB7RnNSZXF1ZXN0RXJyb3JDb2RlfSBbY29kZV1cbiAgICogQG1lbWJlcm9mIEZzUmVxdWVzdEVycm9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGNvbmZpZzogYW55LCByZXNwb25zZT86IEZzUmVzcG9uc2UsIGNvZGU/OiBGc1JlcXVlc3RFcnJvckNvZGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG5cbiAgICAvLyBjb25zdCBjYXB0dXJlU3RhY2tUcmFjZTogRnVuY3Rpb24gPSAoRXJyb3IgYXMgYW55KS5jYXB0dXJlU3RhY2tUcmFjZTtcbiAgICAvLyBjYXB0dXJlU3RhY2tUcmFjZSAmJiBjYXB0dXJlU3RhY2tUcmFjZSh0aGlzKTtcbiAgICBmaXhQcm90byh0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZml4UHJvdG8odGFyZ2V0OiBFcnJvciwgcHJvdG90eXBlOiB7fSkge1xuICBjb25zdCBzZXRQcm90b3R5cGVPZjogRnVuY3Rpb24gPSAoT2JqZWN0IGFzIGFueSkuc2V0UHJvdG90eXBlT2Y7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHNldFByb3RvdHlwZU9mID8gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90b3R5cGUpIDogKCh0YXJnZXQgYXMgYW55KS5fX3Byb3RvX18gPSBwcm90b3R5cGUpO1xufVxuIl19


/***/ }),

/***/ 6562:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Save cookie in browser
 *
 * @param name
 * @param value
 * @param expires
 * @param path
 * @param domain
 * @param secure
 */
exports.write = function (name, value, expires, path, domain, secure) {
    var cookie = [];
    cookie.push(name + '=' + encodeURIComponent(value));
    if (expires) {
        cookie.push('expires=' + new Date(expires).toUTCString());
    }
    if (path) {
        cookie.push('path=' + path);
    }
    if (domain) {
        cookie.push('domain=' + domain);
    }
    if (secure) {
        cookie.push('secure');
    }
    document.cookie = cookie.join('; ');
};
/**
 * Read cookie from browser with given name
 *
 * @param name
 */
exports.read = function (name) {
    var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
    return (match ? decodeURIComponent(match[3]) : null);
};
/**
 * Clear cookie by name
 *
 * @param name
 */
exports.remove = function (name) {
    exports.write(name, '', Date.now() - 86400000);
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9oZWxwZXJzL2Nvb2tpZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRzs7QUFFRjs7Ozs7Ozs7O0dBU0c7QUFDUyxRQUFBLEtBQUssR0FBRyxVQUFDLElBQVksRUFBRSxLQUFhLEVBQUUsT0FBZ0IsRUFBRSxJQUFhLEVBQUUsTUFBZSxFQUFFLE1BQWdCO0lBQ25ILElBQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQztJQUNsQixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUVwRCxJQUFJLE9BQU8sRUFBRTtRQUNYLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7S0FDM0Q7SUFFRCxJQUFJLElBQUksRUFBRTtRQUNSLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDO0tBQzdCO0lBRUQsSUFBSSxNQUFNLEVBQUU7UUFDVixNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsQ0FBQztLQUNqQztJQUVELElBQUksTUFBTSxFQUFFO1FBQ1YsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUN2QjtJQUVELFFBQVEsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN0QyxDQUFDLENBQUM7QUFFRjs7OztHQUlHO0FBQ1UsUUFBQSxJQUFJLEdBQUcsVUFBQyxJQUFZO0lBQy9CLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLFlBQVksR0FBRyxJQUFJLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQztJQUNuRixPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDdkQsQ0FBQyxDQUFDO0FBRUY7Ozs7R0FJRztBQUNVLFFBQUEsTUFBTSxHQUFHLFVBQUMsSUFBSTtJQUN6QixhQUFLLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsUUFBUSxDQUFDLENBQUM7QUFDekMsQ0FBQyxDQUFDIiwiZmlsZSI6ImxpYi9yZXF1ZXN0L2hlbHBlcnMvY29va2llcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuIC8qKlxuICAqIFNhdmUgY29va2llIGluIGJyb3dzZXJcbiAgKlxuICAqIEBwYXJhbSBuYW1lXG4gICogQHBhcmFtIHZhbHVlXG4gICogQHBhcmFtIGV4cGlyZXNcbiAgKiBAcGFyYW0gcGF0aFxuICAqIEBwYXJhbSBkb21haW5cbiAgKiBAcGFyYW0gc2VjdXJlXG4gICovXG5leHBvcnQgY29uc3Qgd3JpdGUgPSAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCBleHBpcmVzPzogbnVtYmVyLCBwYXRoPzogc3RyaW5nLCBkb21haW4/OiBzdHJpbmcsIHNlY3VyZT86IGJvb2xlYW4pID0+IHtcbiAgY29uc3QgY29va2llID0gW107XG4gIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICBpZiAoZXhwaXJlcykge1xuICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b1VUQ1N0cmluZygpKTtcbiAgfVxuXG4gIGlmIChwYXRoKSB7XG4gICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICB9XG5cbiAgaWYgKGRvbWFpbikge1xuICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gIH1cblxuICBpZiAoc2VjdXJlKSB7XG4gICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICB9XG5cbiAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG59O1xuXG4vKipcbiAqIFJlYWQgY29va2llIGZyb20gYnJvd3NlciB3aXRoIGdpdmVuIG5hbWVcbiAqXG4gKiBAcGFyYW0gbmFtZVxuICovXG5leHBvcnQgY29uc3QgcmVhZCA9IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xufTtcblxuLyoqXG4gKiBDbGVhciBjb29raWUgYnkgbmFtZVxuICpcbiAqIEBwYXJhbSBuYW1lXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmUgPSAobmFtZSkgPT4ge1xuICB3cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbn07XG4iXX0=


/***/ }),

/***/ 6164:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var utils_1 = __nccwpck_require__(2790);
var utils_2 = __nccwpck_require__(8123);
var headers_1 = __nccwpck_require__(4639);
var parser = __nccwpck_require__(7448);
var debug_1 = __nccwpck_require__(8237);
var debug = debug_1.default('fs:request:data');
/**
 * Prepare request and set content-type header based on data
 *
 * @param headers
 * @param data
 */
exports.prepareData = function (config) {
    // set filestack debug headers first
    config = exports.filestackHeaders(config);
    if (utils_1.isFormData(config.data) || utils_1.isBuffer(config.data) || utils_1.isStream(config.data) || utils_1.isFile(config.data) || utils_1.isBlob(config.data)) {
        return config;
    }
    // @todo convert it to ArrayBufferView for browser
    if (utils_1.isArrayBuffer(config.data)) {
        return config;
    }
    if (utils_1.isURLSearchParams(config.data)) {
        config.headers = headers_1.set(config.headers, 'content-type', 'application/x-www-form-urlencoded;charset=utf-8');
        config.data = config.data.toString();
    }
    else if (utils_1.isObject(config.data)) {
        config.headers = headers_1.set(config.headers, 'content-type', 'application/json', true);
        config.data = JSON.stringify(config.data);
    }
    return config;
};
/**
 * Add filestack debug headers to request
 *
 * @param config
 */
exports.filestackHeaders = function (config) {
    if (!config.filestackHeaders) {
        return config;
    }
    config.headers = headers_1.set(config.headers, 'filestack-source', utils_2.getVersion());
    config.headers = headers_1.set(config.headers, 'filestack-trace-id', Math.floor(Date.now() / 1000) + "-" + utils_2.uniqueId());
    config.headers = headers_1.set(config.headers, 'filestack-trace-span', "jssdk-" + utils_2.uniqueId());
    return config;
};
/**
 * Prepare response data based on content type
 *
 * @param response
 */
exports.parseResponse = function (response) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var contentType, data;
    return tslib_1.__generator(this, function (_a) {
        if (!response.headers || !response.headers['content-type']) {
            return [2 /*return*/, Promise.resolve(response)];
        }
        contentType = response.headers['content-type'];
        if (/application\/json/.test(contentType)) {
            try {
                response.data = JSON.parse(response.data);
            }
            catch (e) {
                debug('Cannot parse response %O - %O', response.data, response.headers);
            }
        }
        else if (/text\/(plain|html)/.test(contentType)) {
            if (utils_1.isBuffer(response.data)) {
                response.data = bufferToString(response.data);
            }
        }
        else if (/application\/xml/.test(contentType)) {
            data = response.data;
            if (utils_1.isBuffer(response.data)) {
                data = bufferToString(response.data);
            }
            if (parser.validate(data) === true) {
                response.data = parser.parse(data, {
                    ignoreAttributes: true,
                    trimValues: true,
                });
            }
        }
        return [2 /*return*/, Promise.resolve(response)];
    });
}); };
function bufferToString(buffer) {
    var bufView = new Uint16Array(buffer);
    var length = bufView.length;
    var result = '';
    var addition = Math.pow(2, 16) - 1;
    for (var i = 0; i < length; i += addition) {
        if (i + addition > length) {
            addition = length - i;
        }
        result += String.fromCharCode.apply(null, bufView.subarray(i, i + addition));
    }
    return result;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9oZWxwZXJzL2RhdGEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsb0NBQXdIO0FBQ3hILHVDQUFxRDtBQUVyRCxxQ0FBZ0M7QUFDaEMsd0NBQTBDO0FBQzFDLCtCQUEwQjtBQUUxQixJQUFNLEtBQUssR0FBRyxlQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUV2Qzs7Ozs7R0FLRztBQUNVLFFBQUEsV0FBVyxHQUFHLFVBQUMsTUFBd0I7SUFDbEQsb0NBQW9DO0lBQ3BDLE1BQU0sR0FBRyx3QkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUVsQyxJQUFJLGtCQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLGdCQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLGdCQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLGNBQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksY0FBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUMzSCxPQUFPLE1BQU0sQ0FBQztLQUNmO0lBRUQsa0RBQWtEO0lBQ2xELElBQUkscUJBQWEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDOUIsT0FBTyxNQUFNLENBQUM7S0FDZjtJQUVELElBQUkseUJBQWlCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ2xDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsYUFBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsY0FBYyxFQUFFLGlEQUFpRCxDQUFDLENBQUM7UUFDeEcsTUFBTSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0tBQ3RDO1NBQU0sSUFBSSxnQkFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUNoQyxNQUFNLENBQUMsT0FBTyxHQUFHLGFB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LElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7SUFFOUIsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO0lBQ2hCLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUVuQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsSUFBSSxRQUFRLEVBQUU7UUFDekMsSUFBSSxDQUFDLEdBQUcsUUFBUSxHQUFHLE1BQU0sRUFBRTtZQUN6QixRQUFRLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQztTQUN2QjtRQUNELE1BQU0sSUFBSSxNQUFNLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUM7S0FDOUU7SUFFRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDIiwiZmlsZSI6ImxpYi9yZXF1ZXN0L2hlbHBlcnMvZGF0YS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGlzVVJMU2VhcmNoUGFyYW1zLCBpc09iamVjdCwgaXNTdHJlYW0sIGlzRm9ybURhdGEsIGlzQXJyYXlCdWZmZXIsIGlzRmlsZSwgaXNCbG9iLCBpc0J1ZmZlciB9IGZyb20gJy4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgZ2V0VmVyc2lvbiwgdW5pcXVlSWQgfSBmcm9tICcuLy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IEZzUmVxdWVzdE9wdGlvbnMsIEZzUmVzcG9uc2UgfSBmcm9tICcuLy4uL3R5cGVzJztcbmltcG9ydCB7IHNldCB9IGZyb20gJy4vaGVhZGVycyc7XG5pbXBvcnQgKiBhcyBwYXJzZXIgZnJvbSAnZmFzdC14bWwtcGFyc2VyJztcbmltcG9ydCBEZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoJ2ZzOnJlcXVlc3Q6ZGF0YScpO1xuXG4vKipcbiAqIFByZXBhcmUgcmVxdWVzdCBhbmQgc2V0IGNvbnRlbnQtdHlwZSBoZWFkZXIgYmFzZWQgb24gZGF0YVxuICpcbiAqIEBwYXJhbSBoZWFkZXJzXG4gKiBAcGFyYW0gZGF0YVxuICovXG5leHBvcnQgY29uc3QgcHJlcGFyZURhdGEgPSAoY29uZmlnOiBGc1JlcXVlc3RPcHRpb25zKSA9PiB7XG4gIC8vIHNldCBmaWxlc3RhY2sgZGVidWcgaGVhZGVycyBmaXJzdFxuICBjb25maWcgPSBmaWxlc3RhY2tIZWFkZXJzKGNvbmZpZyk7XG5cbiAgaWYgKGlzRm9ybURhdGEoY29uZmlnLmRhdGEpIHx8IGlzQnVmZmVyKGNvbmZpZy5kYXRhKSB8fCBpc1N0cmVhbShjb25maWcuZGF0YSkgfHwgaXNGaWxlKGNvbmZpZy5kYXRhKSB8fCBpc0Jsb2IoY29uZmlnLmRhdGEpKSB7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuXG4gIC8vIEB0b2RvIGNvbnZlcnQgaXQgdG8gQXJyYXlCdWZmZXJWaWV3IGZvciBicm93c2VyXG4gIGlmIChpc0FycmF5QnVmZmVyKGNvbmZpZy5kYXRhKSkge1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBpZiAoaXNVUkxTZWFyY2hQYXJhbXMoY29uZmlnLmRhdGEpKSB7XG4gICAgY29uZmlnLmhlYWRlcnMgPSBzZXQoY29uZmlnLmhlYWRlcnMsICdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICBjb25maWcuZGF0YSA9IGNvbmZpZy5kYXRhLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoY29uZmlnLmRhdGEpKSB7XG4gICAgY29uZmlnLmhlYWRlcnMgPSBzZXQoY29uZmlnLmhlYWRlcnMsICdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicsIHRydWUpO1xuICAgIGNvbmZpZy5kYXRhID0gSlNPTi5zdHJpbmdpZnkoY29uZmlnLmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG5cbi8qKlxuICogQWRkIGZpbGVzdGFjayBkZWJ1ZyBoZWFkZXJzIHRvIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0gY29uZmlnXG4gKi9cbmV4cG9ydCBjb25zdCBmaWxlc3RhY2tIZWFkZXJzID0gKGNvbmZpZzogRnNSZXF1ZXN0T3B0aW9ucykgPT4ge1xuICBpZiAoIWNvbmZpZy5maWxlc3RhY2tIZWFkZXJzKSB7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuXG4gIGNvbmZpZy5oZWFkZXJzID0gc2V0KGNvbmZpZy5oZWFkZXJzLCAnZmlsZXN0YWNrLXNvdXJjZScsIGdldFZlcnNpb24oKSk7XG4gIGNvbmZpZy5oZWFkZXJzID0gc2V0KGNvbmZpZy5oZWFkZXJzLCAnZmlsZXN0YWNrLXRyYWNlLWlkJywgYCR7TWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCl9LSR7dW5pcXVlSWQoKX1gKTtcbiAgY29uZmlnLmhlYWRlcnMgPSBzZXQoY29uZmlnLmhlYWRlcnMsICdmaWxlc3RhY2stdHJhY2Utc3BhbicsIGBqc3Nkay0ke3VuaXF1ZUlkKCl9YCk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG5cbi8qKlxuICogUHJlcGFyZSByZXNwb25zZSBkYXRhIGJhc2VkIG9uIGNvbnRlbnQgdHlwZVxuICpcbiAqIEBwYXJhbSByZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgcGFyc2VSZXNwb25zZSA9IGFzeW5jIChyZXNwb25zZTogRnNSZXNwb25zZSk6IFByb21pc2U8RnNSZXNwb25zZT4gPT4ge1xuICBpZiAoIXJlc3BvbnNlLmhlYWRlcnMgfHwgIXJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gIH1cblxuICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuXG4gIGlmICgvYXBwbGljYXRpb25cXC9qc29uLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgIHRyeSB7XG4gICAgICByZXNwb25zZS5kYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZS5kYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnQ2Fubm90IHBhcnNlIHJlc3BvbnNlICVPIC0gJU8nLCByZXNwb25zZS5kYXRhLCByZXNwb25zZS5oZWFkZXJzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoL3RleHRcXC8ocGxhaW58aHRtbCkvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgaWYgKGlzQnVmZmVyKHJlc3BvbnNlLmRhdGEpKSB7XG4gICAgICByZXNwb25zZS5kYXRhID0gYnVmZmVyVG9TdHJpbmcocmVzcG9uc2UuZGF0YSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKC9hcHBsaWNhdGlvblxcL3htbC8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICBsZXQgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG5cbiAgICBpZiAoaXNCdWZmZXIocmVzcG9uc2UuZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBidWZmZXJUb1N0cmluZyhyZXNwb25zZS5kYXRhKTtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VyLnZhbGlkYXRlKGRhdGEpID09PSB0cnVlKSB7XG4gICAgICByZXNwb25zZS5kYXRhID0gcGFyc2VyLnBhcnNlKGRhdGEsIHtcbiAgICAgICAgaWdub3JlQXR0cmlidXRlcyA6IHRydWUsXG4gICAgICAgIHRyaW1WYWx1ZXM6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcbn07XG5cbmZ1bmN0aW9uIGJ1ZmZlclRvU3RyaW5nKGJ1ZmZlcikge1xuICBjb25zdCBidWZWaWV3ID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcik7XG4gIGNvbnN0IGxlbmd0aCA9IGJ1ZlZpZXcubGVuZ3RoO1xuXG4gIGxldCByZXN1bHQgPSAnJztcbiAgbGV0IGFkZGl0aW9uID0gTWF0aC5wb3coMiwgMTYpIC0gMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBhZGRpdGlvbikge1xuICAgIGlmIChpICsgYWRkaXRpb24gPiBsZW5ndGgpIHtcbiAgICAgIGFkZGl0aW9uID0gbGVuZ3RoIC0gaTtcbiAgICB9XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmVmlldy5zdWJhcnJheShpLCBpICsgYWRkaXRpb24pKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iXX0=


/***/ }),

/***/ 4639:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var utils_1 = __nccwpck_require__(2790);
var ignoreDuplicates = [
    'expires',
    'from',
    'host',
    'if-modified-since',
    'if-unmodified-since',
    'age',
    'authorization',
    'content-length',
    'content-type',
    'etag',
    'last-modified',
    'location',
    'max-forwards',
    'proxy-authorization',
    'referer',
    'retry-after',
    'user-agent',
];
/**
 * Parse response raw header (xhr)
 *
 * @param {string} headers - raw headers string
 */
exports.parse = function (headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
        return parsed;
    }
    headers.split('\n').forEach(function (line) {
        i = line.indexOf(':');
        key = utils_1.trim(line.substr(0, i)).toLowerCase();
        val = utils_1.trim(line.substr(i + 1));
        if (!key) {
            return;
        }
        if (parsed[key] && ignoreDuplicates.indexOf(key) >= 0) {
            return;
        }
        if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        }
        else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
    });
    return parsed;
};
/**
 * Normalize input headers
 *
 * @param headers
 */
exports.normalizeHeaders = function (headers) {
    if (!headers) {
        return {};
    }
    var toReturn = {};
    for (var i in headers) {
        toReturn[exports.normalizeName(i)] = headers[i];
    }
    return toReturn;
};
// expect(set({}, 'set-cookies', 'value')).toEqual({ 'Set-Cookies': 'value' });
/**
 * Set request headers
 *
 * @param headers - object containing headers
 * @param name - header name
 * @param value - header value
 * @param setIFExists - determine if we should change header value if exists
 */
exports.set = function (headers, name, value, setIFExists) {
    if (setIFExists === void 0) { setIFExists = false; }
    var normalizedName = exports.normalizeName(name);
    if (!headers) {
        headers = {};
    }
    // cleanup headers from undefined vals
    headers = JSON.parse(JSON.stringify(headers));
    if (headers[name] === undefined && headers[normalizedName] === undefined) {
        headers[normalizedName] = value;
    }
    else if (setIFExists) {
        delete headers[name];
        headers[normalizedName] = value;
    }
    return headers;
};
/**
 * Normalize header names according to rfc spec
 *
 * @param {string} name - header name
 */
exports.normalizeName = function (name) {
    // the exceptions
    var result = {
        'content-md5': 'Content-MD5',
        dnt: 'DNT',
        etag: 'ETag',
        'last-event-id': 'Last-Event-ID',
        tcn: 'TCN',
        te: 'TE',
        'www-authenticate': 'WWW-Authenticate',
        'x-dnsprefetch-control': 'X-DNSPrefetch-Control',
    }[name.toLowerCase()];
    if (result) {
        return result;
    }
    // the default
    return name
        .split('-')
        .map(function (text) {
        return text.charAt(0).toUpperCase() + text.substr(1).toLowerCase();
    })
        .join('-');
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9oZWxwZXJzL2hlYWRlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxvQ0FBa0M7QUFHbEMsSUFBTSxnQkFBZ0IsR0FBRztJQUN2QixTQUFTO0lBQ1QsTUFBTTtJQUNOLE1BQU07SUFDTixtQkFBbUI7SUFDbkIscUJBQXFCO0lBQ3JCLEtBQUs7SUFDTCxlQUFlO0lBQ2YsZ0JBQWdCO0lBQ2hCLGNBQWM7SUFDZCxNQUFNO0lBQ04sZUFBZTtJQUNmLFVBQVU7SUFDVixjQUFjO0lBQ2QscUJBQXFCO0lBQ3JCLFNBQVM7SUFDVCxhQUFhO0lBQ2IsWUFBWTtDQUNiLENBQUM7QUFFRjs7OztHQUlHO0FBQ1UsUUFBQSxLQUFLLEdBQUcsVUFBQSxPQUFPO0lBQzFCLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztJQUNoQixJQUFJLEdBQUcsQ0FBQztJQUNSLElBQUksR0FBRyxDQUFDO0lBQ1IsSUFBSSxDQUFDLENBQUM7SUFFTixJQUFJLENBQUMsT0FBTyxFQUFFO1FBQ1osT0FBTyxNQUFNLENBQUM7S0FDZjtJQUVELE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQUEsSUFBSTtRQUM5QixDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN0QixHQUFHLEdBQUcsWUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDNUMsR0FBRyxHQUFHLFlBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRS9CLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDUixPQUFPO1NBQ1I7UUFFRCxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxnQkFBZ0IsQ0FBQyxPQUFP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RSxDQUFDO0lBQ3JFLENBQUMsQ0FBQztTQUNELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNmLENBQUMsQ0FBQyIsImZpbGUiOiJsaWIvcmVxdWVzdC9oZWxwZXJzL2hlYWRlcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEZpbGVzdGFja1xuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyB0cmltIH0gZnJvbSAnLi8uLi91dGlscyc7XG5pbXBvcnQgeyBGc1JlcXVlc3RIZWFkZXJzIH0gZnJvbSAnLi8uLi90eXBlcyc7XG5cbmNvbnN0IGlnbm9yZUR1cGxpY2F0ZXMgPSBbXG4gICdleHBpcmVzJyxcbiAgJ2Zyb20nLFxuICAnaG9zdCcsXG4gICdpZi1tb2RpZmllZC1zaW5jZScsXG4gICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2FnZScsXG4gICdhdXRob3JpemF0aW9uJyxcbiAgJ2NvbnRlbnQtbGVuZ3RoJyxcbiAgJ2NvbnRlbnQtdHlwZScsXG4gICdldGFnJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLFxuICAnbG9jYXRpb24nLFxuICAnbWF4LWZvcndhcmRzJyxcbiAgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsXG4gICdyZXRyeS1hZnRlcicsXG4gICd1c2VyLWFnZW50Jyxcbl07XG5cbi8qKlxuICogUGFyc2UgcmVzcG9uc2UgcmF3IGhlYWRlciAoeGhyKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXJzIC0gcmF3IGhlYWRlcnMgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZSA9IGhlYWRlcnMgPT4ge1xuICBsZXQgcGFyc2VkID0ge307XG4gIGxldCBrZXk7XG4gIGxldCB2YWw7XG4gIGxldCBpO1xuXG4gIGlmICghaGVhZGVycykge1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBoZWFkZXJzLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB0cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmICgha2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZXMuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBpbnB1dCBoZWFkZXJzXG4gKlxuICogQHBhcmFtIGhlYWRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZUhlYWRlcnMgPSAoaGVhZGVyczogRnNSZXF1ZXN0SGVhZGVycyk6IEZzUmVxdWVzdEhlYWRlcnMgPT4ge1xuICBpZiAoIWhlYWRlcnMpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCB0b1JldHVybiA9IHt9O1xuXG4gIGZvciAobGV0IGkgaW4gaGVhZGVycykge1xuICAgIHRvUmV0dXJuW25vcm1hbGl6ZU5hbWUoaSldID0gIGhlYWRlcnNbaV07XG4gIH1cblxuICByZXR1cm4gdG9SZXR1cm47XG59O1xuXG4vLyBleHBlY3Qoc2V0KHt9LCAnc2V0LWNvb2tpZXMnLCAndmFsdWUnKSkudG9FcXVhbCh7ICdTZXQtQ29va2llcyc6ICd2YWx1ZScgfSk7XG4vKipcbiAqIFNldCByZXF1ZXN0IGhlYWRlcnNcbiAqXG4gKiBAcGFyYW0gaGVhZGVycyAtIG9iamVjdCBjb250YWluaW5nIGhlYWRlcnNcbiAqIEBwYXJhbSBuYW1lIC0gaGVhZGVyIG5hbWVcbiAqIEBwYXJhbSB2YWx1ZSAtIGhlYWRlciB2YWx1ZVxuICogQHBhcmFtIHNldElGRXhpc3RzIC0gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBjaGFuZ2UgaGVhZGVyIHZhbHVlIGlmIGV4aXN0c1xuICovXG5leHBvcnQgY29uc3Qgc2V0ID0gKGhlYWRlcnM6IEZzUmVxdWVzdEhlYWRlcnMsIG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgc2V0SUZFeGlzdHMgPSBmYWxzZSkgPT4ge1xuICBjb25zdCBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7XG4gICAgaGVhZGVycyA9IHt9O1xuICB9XG5cbiAgLy8gY2xlYW51cCBoZWFkZXJzIGZyb20gdW5kZWZpbmVkIHZhbHNcbiAgaGVhZGVycyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaGVhZGVycykpO1xuICBpZiAoaGVhZGVyc1tuYW1lXSA9PT0gdW5kZWZpbmVkICYmIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKHNldElGRXhpc3RzKSB7XG4gICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgaGVhZGVyIG5hbWVzIGFjY29yZGluZyB0byByZmMgc3BlY1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gaGVhZGVyIG5hbWVcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZU5hbWUgPSAobmFtZTogc3RyaW5nKSA9PiB7XG4gIC8vIHRoZSBleGNlcHRpb25zXG4gIGxldCByZXN1bHQgPSB7XG4gICAgJ2NvbnRlbnQtbWQ1JzogJ0NvbnRlbnQtTUQ1JyxcbiAgICBkbnQ6ICdETlQnLFxuICAgIGV0YWc6ICdFVGFnJyxcbiAgICAnbGFzdC1ldmVudC1pZCc6ICdMYXN0LUV2ZW50LUlEJyxcbiAgICB0Y246ICdUQ04nLFxuICAgIHRlOiAnVEUnLFxuICAgICd3d3ctYXV0aGVudGljYXRlJzogJ1dXVy1BdXRoZW50aWNhdGUnLFxuICAgICd4LWRuc3ByZWZldGNoLWNvbnRyb2wnOiAnWC1ETlNQcmVmZXRjaC1Db250cm9sJyxcbiAgfVtuYW1lLnRvTG93ZXJDYXNlKCldO1xuXG4gIGlmIChyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gdGhlIGRlZmF1bHRcbiAgcmV0dXJuIG5hbWVcbiAgICAuc3BsaXQoJy0nKVxuICAgIC5tYXAoZnVuY3Rpb24odGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXh0LnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xuICAgIH0pXG4gICAgLmpvaW4oJy0nKTtcbn07XG4iXX0=


/***/ }),

/***/ 9083:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(6562), exports);
tslib_1.__exportStar(__nccwpck_require__(4639), exports);
tslib_1.__exportStar(__nccwpck_require__(6164), exports);
tslib_1.__exportStar(__nccwpck_require__(6265), exports);
tslib_1.__exportStar(__nccwpck_require__(1649), exports);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9oZWxwZXJzL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7OztBQUVILG9EQUEwQjtBQUMxQixvREFBMEI7QUFDMUIsaURBQXVCO0FBQ3ZCLGdEQUFzQjtBQUN0Qix3REFBOEIiLCJmaWxlIjoibGliL3JlcXVlc3QvaGVscGVycy9pbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0ICogZnJvbSAnLi9jb29raWVzJztcbmV4cG9ydCAqIGZyb20gJy4vaGVhZGVycyc7XG5leHBvcnQgKiBmcm9tICcuL2RhdGEnO1xuZXhwb3J0ICogZnJvbSAnLi91cmwnO1xuZXhwb3J0ICogZnJvbSAnLi9zaG91bGRSZXRyeSc7XG4iXX0=


/***/ }),

/***/ 1649:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var error_1 = __nccwpck_require__(8953);
var debug_1 = __nccwpck_require__(8237);
var debug = debug_1.default('fs:request:shouldRetry');
/**
 * Indicates if method should be retried
 *
 * @private
 * @param {FsRequestError} err
 * @returns
 * @memberof Dispatch
 */
exports.shouldRetry = function (err) {
    debug('Checking error for retry. Code: %n, type: %s', (err.response ? err.response.status : 'Malformed response'), err.code);
    // we always should retry on network failure
    switch (err.code) {
        case error_1.FsRequestErrorCode.NETWORK:
        case error_1.FsRequestErrorCode.SERVER:
        case error_1.FsRequestErrorCode.TIMEOUT:
            return true;
        // we should not make request on request aborted
        case error_1.FsRequestErrorCode.ABORTED:
            return false;
    }
    if (!err.response) {
        return false;
    }
    // we should retry on all server errors (5xx)
    // this should be handled by FsRequestErrorCode.SERVER but to be sure
    if (500 <= err.response.status && err.response.status <= 599) {
        return true;
    }
    // we should not retry on other errors (4xx) ie: BadRequest etc
    return false;
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9oZWxwZXJzL3Nob3VsZFJldHJ5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7O0FBRUgsb0NBQWdFO0FBQ2hFLCtCQUEwQjtBQUUxQixJQUFNLEtBQUssR0FBRyxlQUFLLENBQUMsd0JBQXdCLENBQUMsQ0FBQztBQUU5Qzs7Ozs7OztHQU9HO0FBQ1UsUUFBQSxXQUFXLEdBQUcsVUFBQyxHQUFtQjtJQUM3QyxLQUFLLENBQUMsOENBQThDLEVBQUUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsb0JBQW9CLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFN0gsNENBQTRDO0lBQzVDLFFBQVEsR0FBRyxDQUFDLElBQUksRUFBRTtRQUNoQixLQUFLLDBCQUFrQixDQUFDLE9BQU8sQ0FBQztRQUNoQyxLQUFLLDBCQUFrQixDQUFDLE1BQU0sQ0FBQztRQUMvQixLQUFLLDBCQUFrQixDQUFDLE9BQU87WUFDN0IsT0FBTyxJQUFJLENBQUM7UUFDZCxnREFBZ0Q7UUFDaEQsS0FBSywwQkFBa0IsQ0FBQyxPQUFPO1lBQzdCLE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0lBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUU7UUFDakIsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELDZDQUE2QztJQUM3QyxxRUFBcUU7SUFDckUsSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksR0FBRyxFQUFFO1FBQzVELE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFFRCwrREFBK0Q7SUFDL0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDLENBQUMiLCJmaWxlIjoibGliL3JlcXVlc3QvaGVscGVycy9zaG91bGRSZXRyeS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRnNSZXF1ZXN0RXJyb3IsIEZzUmVxdWVzdEVycm9yQ29kZSB9IGZyb20gJy4vLi4vZXJyb3InO1xuaW1wb3J0IERlYnVnIGZyb20gJ2RlYnVnJztcblxuY29uc3QgZGVidWcgPSBEZWJ1ZygnZnM6cmVxdWVzdDpzaG91bGRSZXRyeScpO1xuXG4vKipcbiAqIEluZGljYXRlcyBpZiBtZXRob2Qgc2hvdWxkIGJlIHJldHJpZWRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGc1JlcXVlc3RFcnJvcn0gZXJyXG4gKiBAcmV0dXJuc1xuICogQG1lbWJlcm9mIERpc3BhdGNoXG4gKi9cbmV4cG9ydCBjb25zdCBzaG91bGRSZXRyeSA9IChlcnI6IEZzUmVxdWVzdEVycm9yKSA9PiB7XG4gIGRlYnVnKCdDaGVja2luZyBlcnJvciBmb3IgcmV0cnkuIENvZGU6ICVuLCB0eXBlOiAlcycsIChlcnIucmVzcG9uc2UgPyBlcnIucmVzcG9uc2Uuc3RhdHVzIDogJ01hbGZvcm1lZCByZXNwb25zZScpLCBlcnIuY29kZSk7XG5cbiAgLy8gd2UgYWx3YXlzIHNob3VsZCByZXRyeSBvbiBuZXR3b3JrIGZhaWx1cmVcbiAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgIGNhc2UgRnNSZXF1ZXN0RXJyb3JDb2RlLk5FVFdPUks6XG4gICAgY2FzZSBGc1JlcXVlc3RFcnJvckNvZGUuU0VSVkVSOlxuICAgIGNhc2UgRnNSZXF1ZXN0RXJyb3JDb2RlLlRJTUVPVVQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyB3ZSBzaG91bGQgbm90IG1ha2UgcmVxdWVzdCBvbiByZXF1ZXN0IGFib3J0ZWRcbiAgICBjYXNlIEZzUmVxdWVzdEVycm9yQ29kZS5BQk9SVEVEOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFlcnIucmVzcG9uc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB3ZSBzaG91bGQgcmV0cnkgb24gYWxsIHNlcnZlciBlcnJvcnMgKDV4eClcbiAgLy8gdGhpcyBzaG91bGQgYmUgaGFuZGxlZCBieSBGc1JlcXVlc3RFcnJvckNvZGUuU0VSVkVSIGJ1dCB0byBiZSBzdXJlXG4gIGlmICg1MDAgPD0gZXJyLnJlc3BvbnNlLnN0YXR1cyAmJiBlcnIucmVzcG9uc2Uuc3RhdHVzIDw9IDU5OSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gd2Ugc2hvdWxkIG5vdCByZXRyeSBvbiBvdGhlciBlcnJvcnMgKDR4eCkgaWU6IEJhZFJlcXVlc3QgZXRjXG4gIHJldHVybiBmYWxzZTtcbn07XG4iXX0=


/***/ }),

/***/ 6265:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Combine url with qs parameters
 *
 * @param {String} url base url
 * @param {Object} params Query string params object
 */
exports.combineURL = function (url, params) {
    if (!params) {
        return url;
    }
    var serialized = exports.urlfy(params);
    var hashIndex = url.indexOf('#');
    if (hashIndex !== -1) {
        url = url.slice(0, hashIndex);
    }
    return url + (url.indexOf('?') === -1 ? '?' : '&') + serialized;
};
/**
 * Change request json params to url search ones
 *
 * @param {Object} obj Object to transform
 */
exports.urlfy = function (val) {
    return Object.keys(val)
        .filter(function (k) { return k && typeof val[k] !== 'undefined'; })
        .map(function (k) { return encodeURIComponent(k) + "=" + encodeURIComponent(val[k]); })
        .join('&');
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9oZWxwZXJzL3VybC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHOztBQUVIOzs7OztHQUtHO0FBQ1UsUUFBQSxVQUFVLEdBQUcsVUFBQyxHQUFHLEVBQUUsTUFBTTtJQUNwQyxJQUFJLENBQUMsTUFBTSxFQUFFO1FBQ1gsT0FBTyxHQUFHLENBQUM7S0FDWjtJQUVELElBQU0sVUFBVSxHQUFHLGFBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNqQyxJQUFNLFNBQVMsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRW5DLElBQUksU0FBUyxLQUFLLENBQUMsQ0FBQyxFQUFFO1FBQ3BCLEdBQUcsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztLQUMvQjtJQUVELE9BQU8sR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUM7QUFDbEUsQ0FBQyxDQUFDO0FBRUY7Ozs7R0FJRztBQUNVLFFBQUEsS0FBSyxHQUFHLFVBQUEsR0FBRztJQUN0QixPQUFBLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1NBQ2IsTUFBTSxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBQyxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLFdBQVcsRUFBbEMsQ0FBa0MsQ0FBQztTQUMvQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBRyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsU0FBSSxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUcsRUFBeEQsQ0FBd0QsQ0FBQztTQUNsRSxJQUFJLENBQUMsR0FBRyxDQUFDO0FBSFosQ0FHWSxDQUFDIiwiZmlsZSI6ImxpYi9yZXF1ZXN0L2hlbHBlcnMvdXJsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2tcbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIENvbWJpbmUgdXJsIHdpdGggcXMgcGFyYW1ldGVyc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgYmFzZSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgUXVlcnkgc3RyaW5nIHBhcmFtcyBvYmplY3RcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbWJpbmVVUkwgPSAodXJsLCBwYXJhbXMpID0+IHtcbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgY29uc3Qgc2VyaWFsaXplZCA9IHVybGZ5KHBhcmFtcyk7XG4gIGNvbnN0IGhhc2hJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG5cbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB1cmwgKyAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZDtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHJlcXVlc3QganNvbiBwYXJhbXMgdG8gdXJsIHNlYXJjaCBvbmVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gdHJhbnNmb3JtXG4gKi9cbmV4cG9ydCBjb25zdCB1cmxmeSA9IHZhbCA9PlxuICBPYmplY3Qua2V5cyh2YWwpXG4gICAgLmZpbHRlcihrID0+IGsgJiYgdHlwZW9mIHZhbFtrXSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgLm1hcChrID0+IGAke2VuY29kZVVSSUNvbXBvbmVudChrKX09JHtlbmNvZGVVUklDb21wb25lbnQodmFsW2tdKX1gKVxuICAgIC5qb2luKCcmJyk7XG4iXX0=


/***/ }),

/***/ 5606:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(6942), exports);
tslib_1.__exportStar(__nccwpck_require__(4112), exports);
tslib_1.__exportStar(__nccwpck_require__(8953), exports);
tslib_1.__exportStar(__nccwpck_require__(3917), exports);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHOzs7QUFFSCxrREFBd0I7QUFDeEIsb0RBQTBCO0FBQzFCLGtEQUF3QjtBQUN4QixrREFBd0IiLCJmaWxlIjoibGliL3JlcXVlc3QvaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEZpbGVzdGFja1xuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9yZXF1ZXN0JztcbmV4cG9ydCAqIGZyb20gJy4vZXJyb3InO1xuZXhwb3J0ICogZnJvbSAnLi90b2tlbic7XG4iXX0=


/***/ }),

/***/ 4112:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var types_1 = __nccwpck_require__(6942);
var dispatch_1 = __nccwpck_require__(4055);
var request_adapter_node_1 = __nccwpck_require__(5358);
/**
 * Main isomorphic Filestack request library
 *
 * @export
 * @class FsRequest
 */
var FsRequest = /** @class */ (function () {
    /**
     * Creates an instance of Request.
     *
     * @param {RequestOptions} [config]
     * @memberof FsRequest
     */
    function FsRequest(config) {
        this.defaults = config;
        this.dispatcher = new dispatch_1.Dispatch(new request_adapter_node_1.RequestAdapter());
    }
    /**
     * Returns static FsRequest instance
     *
     * @private
     * @static
     * @returns
     * @memberof FsRequest
     */
    FsRequest.getInstance = function () {
        if (!FsRequest.instance) {
            FsRequest.instance = new FsRequest();
        }
        return FsRequest.instance;
    };
    /**
     * Run request with given adapter
     *
     * @param {RequestOptions} config
     * @returns
     * @memberof Request
     */
    FsRequest.prototype.dispatch = function (config) {
        if (!config.method) {
            config.method = types_1.FsHttpMethod.GET;
        }
        return this.dispatcher.request(Object.assign({}, this.defaults, config));
    };
    /**
     * Dispatch request
     *
     * @static
     * @param {string} url
     * @param {FsRequestOptions} config
     * @returns {Promise<FsResponse>}
     * @memberof FsRequest
     */
    FsRequest.dispatch = function (url, config) {
        return FsRequest.getInstance().dispatch(Object.assign({}, config || {}, { url: url }));
    };
    /**
     * Dispatch GET request
     *
     * @static
     * @param {string} url
     * @param {FsRequestOptions} config
     * @returns {Promise<FsResponse>}
     * @memberof FsRequest
     */
    FsRequest.get = function (url, config) {
        return FsRequest.getInstance().dispatch(Object.assign({}, config || {}, { method: types_1.FsHttpMethod.GET, url: url }));
    };
    /**
     * Dispatch HEAD request
     *
     * @static
     * @param {string} url
     * @param {FsRequestOptions} config
     * @returns {Promise<FsResponse>}
     * @memberof FsRequest
     */
    FsRequest.head = function (url, config) {
        return FsRequest.getInstance().dispatch(Object.assign({}, config || {}, { method: types_1.FsHttpMethod.HEAD, url: url }));
    };
    /**
     * Dispatch OPTIONS request
     *
     * @static
     * @param {string} url
     * @param {FsRequestOptions} config
     * @returns {Promise<FsResponse>}
     * @memberof FsRequest
     */
    FsRequest.options = function (url, config) {
        return FsRequest.getInstance().dispatch(Object.assign({}, config || {}, { method: types_1.FsHttpMethod.OPTIONS, url: url }));
    };
    /**
     * Dispatch PURGE request
     *
     * @static
     * @param {string} url
     * @param {FsRequestOptions} config
     * @returns {Promise<FsResponse>}
     * @memberof FsRequest
     */
    FsRequest.purge = function (url, config) {
        return FsRequest.getInstance().dispatch(Object.assign({}, config || {}, { method: types_1.FsHttpMethod.PURGE, url: url }));
    };
    /**
     * Dispatch DELETE request
     *
     * @static
     * @param {string} url
     * @param {FsRequestOptions} config
     * @returns {Promise<FsResponse>}
     * @memberof FsRequest
     */
    FsRequest.delete = function (url, config) {
        return FsRequest.getInstance().dispatch(Object.assign({}, config || {}, { method: types_1.FsHttpMethod.DELETE, url: url }));
    };
    /**
     * Dispatch POST request
     *
     * @static
     * @param {string} url
     * @param {*} [data]
     * @param {FsRequestOptions} [config]
     * @returns {Promise<FsResponse>}
     * @memberof FsRequest
     */
    FsRequest.post = function (url, data, config) {
        return FsRequest.getInstance().dispatch(Object.assign({}, config || {}, { method: types_1.FsHttpMethod.POST, url: url, data: data }));
    };
    /**
     * Dispatch PUT request
     *
     * @static
     * @param {string} url
     * @param {*} [data]
     * @param {FsRequestOptions} [config]
     * @returns {Promise<FsResponse>}
     * @memberof FsRequest
     */
    FsRequest.put = function (url, data, config) {
        return FsRequest.getInstance().dispatch(Object.assign({}, config || {}, { method: types_1.FsHttpMethod.PUT, url: url, data: data }));
    };
    /**
     * Dispatch PATCH request
     *
     * @static
     * @param {string} url
     * @param {*} [data]
     * @param {FsRequestOptions} [config]
     * @returns {Promise<FsResponse>}
     * @memberof FsRequest
     */
    FsRequest.path = function (url, data, config) {
        return FsRequest.getInstance().dispatch(Object.assign({}, config || {}, { method: types_1.FsHttpMethod.PATH, url: url, data: data }));
    };
    return FsRequest;
}());
exports.FsRequest = FsRequest;
exports.default = FsRequest;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9yZXF1ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsaUNBQXFFO0FBQ3JFLHVDQUFzQztBQUN0QywrREFBd0Q7QUFFeEQ7Ozs7O0dBS0c7QUFDSDtJQTZCRTs7Ozs7T0FLRztJQUNILG1CQUFZLE1BQXlCO1FBRW5DLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxtQkFBUSxDQUFDLElBQUkscUNBQWMsRUFBRSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDWSxxQkFBVyxHQUExQjtRQUNFLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFO1lBQ3ZCLFNBQVMsQ0FBQyxRQUFRLEdBQUcsSUFBSSxTQUFTLEVBQUUsQ0FBQztTQUN0QztRQUVELE9BQU8sU0FBUyxDQUFDLFFBQVEsQ0FBQztJQUM1QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBRUksNEJBQVEsR0FBZixVQUFnQixNQUF3QjtRQUN0QyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTtZQUNsQixNQUFNLENBQUMsTUFBTSxHQUFHLG9CQUFZLENBQUMsR0FBRyxDQUFDO1NBQ2xDO1FBRUQsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ1csa0JBQVEsR0FBdEIsVUFBdUIsR0FBVyxFQUFFLE1BQXdCO1FBQzFELE9BQU8sU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLElBQUksRUFBRSxFQUFFLEVBQUUsR0FBRyxLQUFBLEVBQUUs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QU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxJQUFJLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxvQkFBWSxDQUFDLElBQUksRUFBRSxHQUFHLEtBQUEsRUFBRSxJQUFJLE1BQUEsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNySCxDQUFDO0lBQ0gsZ0JBQUM7QUFBRCxDQWhNQSxBQWdNQyxJQUFBO0FBaE1ZLDhCQUFTO0FBa010QixrQkFBZSxTQUFTLENBQUMiLCJmaWxlIjoibGliL3JlcXVlc3QvcmVxdWVzdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEZzUmVxdWVzdE9wdGlvbnMsIEZzSHR0cE1ldGhvZCwgRnNSZXNwb25zZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgRGlzcGF0Y2ggfSBmcm9tICcuL2Rpc3BhdGNoJztcbmltcG9ydCB7IFJlcXVlc3RBZGFwdGVyIH0gZnJvbSAnLi9yZXF1ZXN0X2FkYXB0ZXIubm9kZSc7XG5cbi8qKlxuICogTWFpbiBpc29tb3JwaGljIEZpbGVzdGFjayByZXF1ZXN0IGxpYnJhcnlcbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgRnNSZXF1ZXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBGc1JlcXVlc3Qge1xuICAvKipcbiAgICogUmVxdWVzdCBzdGF0aWMgaW5zdGFuY2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHN0YXRpY1xuICAgKiBAdHlwZSB7RnNSZXF1ZXN0fVxuICAgKiBAbWVtYmVyb2YgRnNSZXF1ZXN0XG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogRnNSZXF1ZXN0O1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHJlcXVlc3Qgb3B0aW9uc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7UmVxdWVzdE9wdGlvbnN9XG4gICAqIEBtZW1iZXJvZiBGc1JlcXVlc3RcbiAgICovXG4gIHByaXZhdGUgZGVmYXVsdHM6IEZzUmVxdWVzdE9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgRGlzcGF0Y2hlclxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7RGlzcGF0Y2h9XG4gICAqIEBtZW1iZXJvZiBGc1JlcXVlc3RcbiAgICovXG4gIHByaXZhdGUgZGlzcGF0Y2hlcjogRGlzcGF0Y2g7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW2NvbmZpZ11cbiAgICogQG1lbWJlcm9mIEZzUmVxdWVzdFxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnPzogRnNSZXF1ZXN0T3B0aW9ucykge1xuXG4gICAgdGhpcy5kZWZhdWx0cyA9IGNvbmZpZztcbiAgICB0aGlzLmRpc3BhdGNoZXIgPSBuZXcgRGlzcGF0Y2gobmV3IFJlcXVlc3RBZGFwdGVyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3RhdGljIEZzUmVxdWVzdCBpbnN0YW5jZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAc3RhdGljXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBGc1JlcXVlc3RcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgIGlmICghRnNSZXF1ZXN0Lmluc3RhbmNlKSB7XG4gICAgICBGc1JlcXVlc3QuaW5zdGFuY2UgPSBuZXcgRnNSZXF1ZXN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZzUmVxdWVzdC5pbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gcmVxdWVzdCB3aXRoIGdpdmVuIGFkYXB0ZXJcbiAgICpcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gY29uZmlnXG4gICAqIEByZXR1cm5zXG4gICAqIEBtZW1iZXJvZiBSZXF1ZXN0XG4gICAqL1xuXG4gIHB1YmxpYyBkaXNwYXRjaChjb25maWc6IEZzUmVxdWVzdE9wdGlvbnMpIHtcbiAgICBpZiAoIWNvbmZpZy5tZXRob2QpIHtcbiAgICAgIGNvbmZpZy5tZXRob2QgPSBGc0h0dHBNZXRob2QuR0VUO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoZXIucmVxdWVzdChPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzLCBjb25maWcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCByZXF1ZXN0XG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0ge0ZzUmVxdWVzdE9wdGlvbnN9IGNvbmZpZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGc1Jlc3BvbnNlPn1cbiAgICogQG1lbWJlcm9mIEZzUmVxdWVzdFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBkaXNwYXRjaCh1cmw6IHN0cmluZywgY29uZmlnOiBGc1JlcXVlc3RPcHRpb25zKTogUHJvbWlzZTxGc1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIEZzUmVxdWVzdC5nZXRJbnN0YW5jZSgpLmRpc3BhdGNoKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyB8fCB7fSwgeyB1cmwgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIEdFVCByZXF1ZXN0XG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0ge0ZzUmVxdWVzdE9wdGlvbnN9IGNvbmZpZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGc1Jlc3BvbnNlPn1cbiAgICogQG1lbWJlcm9mIEZzUmVxdWVzdFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXQodXJsOiBzdHJpbmcsIGNvbmZpZz86IEZzUmVxdWVzdE9wdGlvbnMpOiBQcm9taXNlPEZzUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gRnNSZXF1ZXN0LmdldEluc3RhbmNlKCkuZGlzcGF0Y2goT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnIHx8IHt9LCB7IG1ldGhvZDogRnNIdHRwTWV0aG9kLkdFVCwgdXJsIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBIRUFEIHJlcXVlc3RcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7RnNSZXF1ZXN0T3B0aW9uc30gY29uZmlnXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEZzUmVzcG9uc2U+fVxuICAgKiBAbWVtYmVyb2YgRnNSZXF1ZXN0XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGhlYWQodXJsOiBzdHJpbmcsIGNvbmZpZz86IEZzUmVxdWVzdE9wdGlvbnMpOiBQcm9taXNlPEZzUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gRnNSZXF1ZXN0LmdldEluc3RhbmNlKCkuZGlzcGF0Y2goT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnIHx8IHt9LCB7IG1ldGhvZDogRnNIdHRwTWV0aG9kLkhFQUQsIHVybCB9KSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2ggT1BUSU9OUyByZXF1ZXN0XG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0ge0ZzUmVxdWVzdE9wdGlvbnN9IGNvbmZpZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGc1Jlc3BvbnNlPn1cbiAgICogQG1lbWJlcm9mIEZzUmVxdWVzdFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBvcHRpb25zKHVybDogc3RyaW5nLCBjb25maWc/OiBGc1JlcXVlc3RPcHRpb25zKTogUHJvbWlzZTxGc1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIEZzUmVxdWVzdC5nZXRJbnN0YW5jZSgpLmRpc3BhdGNoKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyB8fCB7fSwgeyBtZXRob2Q6IEZzSHR0cE1ldGhvZC5PUFRJT05TLCB1cmwgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIFBVUkdFIHJlcXVlc3RcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7RnNSZXF1ZXN0T3B0aW9uc30gY29uZmlnXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEZzUmVzcG9uc2U+fVxuICAgKiBAbWVtYmVyb2YgRnNSZXF1ZXN0XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHB1cmdlKHVybDogc3RyaW5nLCBjb25maWc/OiBGc1JlcXVlc3RPcHRpb25zKTogUHJvbWlzZTxGc1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIEZzUmVxdWVzdC5nZXRJbnN0YW5jZSgpLmRpc3BhdGNoKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyB8fCB7fSwgeyBtZXRob2Q6IEZzSHR0cE1ldGhvZC5QVVJHRSwgdXJsIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBERUxFVEUgcmVxdWVzdFxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogQHBhcmFtIHtGc1JlcXVlc3RPcHRpb25zfSBjb25maWdcbiAgICogQHJldHVybnMge1Byb21pc2U8RnNSZXNwb25zZT59XG4gICAqIEBtZW1iZXJvZiBGc1JlcXVlc3RcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZGVsZXRlKHVybDogc3RyaW5nLCBjb25maWc/OiBGc1JlcXVlc3RPcHRpb25zKTogUHJvbWlzZTxGc1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIEZzUmVxdWVzdC5nZXRJbnN0YW5jZSgpLmRpc3BhdGNoKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyB8fCB7fSwgeyBtZXRob2Q6IEZzSHR0cE1ldGhvZC5ERUxFVEUsIHVybCB9KSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2ggUE9TVCByZXF1ZXN0XG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0geyp9IFtkYXRhXVxuICAgKiBAcGFyYW0ge0ZzUmVxdWVzdE9wdGlvbnN9IFtjb25maWddXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEZzUmVzcG9uc2U+fVxuICAgKiBAbWVtYmVyb2YgRnNSZXF1ZXN0XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHBvc3QodXJsOiBzdHJpbmcsIGRhdGE/OiBhbnksIGNvbmZpZz86IEZzUmVxdWVzdE9wdGlvbnMpOiBQcm9taXNlPEZzUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gRnNSZXF1ZXN0LmdldEluc3RhbmNlKCkuZGlzcGF0Y2goT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnIHx8IHt9LCB7IG1ldGhvZDogRnNIdHRwTWV0aG9kLlBPU1QsIHVybCwgZGF0YSB9KSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2ggUFVUIHJlcXVlc3RcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdXG4gICAqIEBwYXJhbSB7RnNSZXF1ZXN0T3B0aW9uc30gW2NvbmZpZ11cbiAgICogQHJldHVybnMge1Byb21pc2U8RnNSZXNwb25zZT59XG4gICAqIEBtZW1iZXJvZiBGc1JlcXVlc3RcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcHV0KHVybDogc3RyaW5nLCBkYXRhPzogYW55LCBjb25maWc/OiBGc1JlcXVlc3RPcHRpb25zKTogUHJvbWlzZTxGc1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIEZzUmVxdWVzdC5nZXRJbnN0YW5jZSgpLmRpc3BhdGNoKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyB8fCB7fSwgeyBtZXRob2Q6IEZzSHR0cE1ldGhvZC5QVVQsIHVybCwgZGF0YSB9KSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2ggUEFUQ0ggcmVxdWVzdFxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogQHBhcmFtIHsqfSBbZGF0YV1cbiAgICogQHBhcmFtIHtGc1JlcXVlc3RPcHRpb25zfSBbY29uZmlnXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGc1Jlc3BvbnNlPn1cbiAgICogQG1lbWJlcm9mIEZzUmVxdWVzdFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBwYXRoKHVybDogc3RyaW5nLCBkYXRhPzogYW55LCBjb25maWc/OiBGc1JlcXVlc3RPcHRpb25zKTogUHJvbWlzZTxGc1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIEZzUmVxdWVzdC5nZXRJbnN0YW5jZSgpLmRpc3BhdGNoKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyB8fCB7fSwgeyBtZXRob2Q6IEZzSHR0cE1ldGhvZC5QQVRILCB1cmwsIGRhdGEgfSkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZzUmVxdWVzdDtcbiJdfQ==


/***/ }),

/***/ 5358:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.RequestAdapter = __nccwpck_require__(9962).HttpAdapter;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9yZXF1ZXN0X2FkYXB0ZXIubm9kZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNVLFFBQUEsY0FBYyxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLFdBQVcsQ0FBQyIsImZpbGUiOiJsaWIvcmVxdWVzdC9yZXF1ZXN0X2FkYXB0ZXIubm9kZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBSZXF1ZXN0QWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpLkh0dHBBZGFwdGVyO1xuIl19


/***/ }),

/***/ 3917:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var eventemitter3_1 = __nccwpck_require__(1848);
/**
 * Filestack token that allow pause, resume or cancel given upload
 *
 * @export
 * @class FsToken
 * @extends {EventEmitter}
 */
var FsCancelToken = /** @class */ (function (_super) {
    tslib_1.__extends(FsCancelToken, _super);
    function FsCancelToken() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Cancel request action
     *
     * @param {(string | Error)} [reason]
     * @memberof Token
     */
    FsCancelToken.prototype.cancel = function (reason) {
        this.emit('cancel', reason);
        this.removeAllListeners();
    };
    return FsCancelToken;
}(eventemitter3_1.EventEmitter));
exports.FsCancelToken = FsCancelToken;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC90b2tlbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCwrQ0FBNkM7QUFFN0M7Ozs7OztHQU1HO0FBQ0g7SUFBbUMseUNBQVk7SUFBL0M7O0lBY0EsQ0FBQztJQVpDOzs7OztPQUtHO0lBQ0ksOEJBQU0sR0FBYixVQUFjLE1BQXVCO1FBQ25DLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRTVCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0lBQzVCLENBQUM7SUFFSCxvQkFBQztBQUFELENBZEEsQUFjQyxDQWRrQyw0QkFBWSxHQWM5QztBQWRZLHNDQUFhIiwiZmlsZSI6ImxpYi9yZXF1ZXN0L3Rva2VuLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2tcbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5cbi8qKlxuICogRmlsZXN0YWNrIHRva2VuIHRoYXQgYWxsb3cgcGF1c2UsIHJlc3VtZSBvciBjYW5jZWwgZ2l2ZW4gdXBsb2FkXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIEZzVG9rZW5cbiAqIEBleHRlbmRzIHtFdmVudEVtaXR0ZXJ9XG4gKi9cbmV4cG9ydCBjbGFzcyBGc0NhbmNlbFRva2VuIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICAvKipcbiAgICogQ2FuY2VsIHJlcXVlc3QgYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7KHN0cmluZyB8IEVycm9yKX0gW3JlYXNvbl1cbiAgICogQG1lbWJlcm9mIFRva2VuXG4gICAqL1xuICBwdWJsaWMgY2FuY2VsKHJlYXNvbj86IHN0cmluZyB8IEVycm9yKSB7XG4gICAgdGhpcy5lbWl0KCdjYW5jZWwnLCByZWFzb24pO1xuXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG59XG4iXX0=


/***/ }),

/***/ 6942:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var FsHttpMethod;
(function (FsHttpMethod) {
    FsHttpMethod["GET"] = "GET";
    FsHttpMethod["DELETE"] = "DELETE";
    FsHttpMethod["HEAD"] = "HEAD";
    FsHttpMethod["PURGE"] = "PURGE";
    FsHttpMethod["OPTIONS"] = "OPTIONS";
    FsHttpMethod["POST"] = "POST";
    FsHttpMethod["PUT"] = "PUT";
    FsHttpMethod["PATH"] = "PATH";
})(FsHttpMethod = exports.FsHttpMethod || (exports.FsHttpMethod = {}));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC90eXBlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQWtCQSxJQUFZLFlBU1g7QUFURCxXQUFZLFlBQVk7SUFDdEIsMkJBQVcsQ0FBQTtJQUNYLGlDQUFpQixDQUFBO0lBQ2pCLDZCQUFhLENBQUE7SUFDYiwrQkFBZSxDQUFBO0lBQ2YsbUNBQW1CLENBQUE7SUFDbkIsNkJBQWEsQ0FBQTtJQUNiLDJCQUFXLENBQUE7SUFDWCw2QkFBYSxDQUFBO0FBQ2YsQ0FBQyxFQVRXLFlBQVksR0FBWixvQkFBWSxLQUFaLG9CQUFZLFFBU3ZCIiwiZmlsZSI6ImxpYi9yZXF1ZXN0L3R5cGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2tcbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgRnNDYW5jZWxUb2tlbiB9IGZyb20gJy4vdG9rZW4nO1xuXG5leHBvcnQgZW51bSBGc0h0dHBNZXRob2Qge1xuICBHRVQgPSAnR0VUJyxcbiAgREVMRVRFID0gJ0RFTEVURScsXG4gIEhFQUQgPSAnSEVBRCcsXG4gIFBVUkdFID0gJ1BVUkdFJyxcbiAgT1BUSU9OUyA9ICdPUFRJT05TJyxcbiAgUE9TVCA9ICdQT1NUJyxcbiAgUFVUID0gJ1BVVCcsXG4gIFBBVEggPSAnUEFUSCcsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnNSZXRyeUNvbmZpZyB7XG4gIHJldHJ5OiBudW1iZXI7XG4gIG9uUmV0cnk/OiAocmVxdWVzdENvbmZpZzogYW55KSA9PiB2b2lkO1xuICByZXRyeU1heFRpbWU/OiBudW1iZXI7XG4gIHJldHJ5RmFjdG9yPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZzQXV0aENvbmZpZyB7XG4gIHVzZXJuYW1lOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnNSZXF1ZXN0SGVhZGVycyB7XG4gIFtuYW1lOiBzdHJpbmddOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnNSZXF1ZXN0UGFyYW1zIHtcbiAgW25hbWU6IHN0cmluZ106IHN0cmluZyB8IG51bWJlcjtcbn1cblxuLyoqXG4gKiBSZXF1ZXN0IHJ1bnRpbWUgZGF0YSBsaWtlIHJldHJ5Q291bnQgZXRjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRnNSZXF1ZXN0UnVudGltZSB7XG4gIHJldHJ5Q291bnQ/OiBudW1iZXI7XG4gIFtuYW1lOiBzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnNSZXF1ZXN0T3B0aW9ucyB7XG4gIHVybD86IHN0cmluZztcbiAgZGF0YT86IGFueTtcbiAgbWV0aG9kPzogRnNIdHRwTWV0aG9kO1xuICBtb2RlPzogUmVxdWVzdE1vZGU7XG4gIGNhY2hlPzogUmVxdWVzdENhY2hlO1xuICByZWRpcmVjdD86IFJlcXVlc3RSZWRpcmVjdDtcbiAgcGFyYW1zPzogRnNSZXF1ZXN0UGFyYW1zO1xuICBmaWxlc3RhY2tIZWFkZXJzPzogYm9vbGVhbjtcbiAgaGVhZGVycz86IEZzUmVxdWVzdEhlYWRlcnM7XG4gIGJsb2JSZXNwb25zZT86IGJvb2xlYW47IC8vIGJsb2IgcmVzcG9uc2Ugb25seSBmb3IgYnJvd3NlcnNcbiAgdGltZW91dD86IG51bWJlcjtcbiAgY2FuY2VsVG9rZW4/OiBGc0NhbmNlbFRva2VuO1xuICByZXRyeT86IEZzUmV0cnlDb25maWc7XG4gIG9uUHJvZ3Jlc3M/OiAocHI6IFByb2dyZXNzRXZlbnQpID0+IGFueTtcbiAgYXV0aD86IEZzQXV0aENvbmZpZztcbiAgcnVudGltZT86IEZzUmVxdWVzdFJ1bnRpbWU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnNSZXNwb25zZSB7XG4gIHN0YXR1czogbnVtYmVyO1xuICBzdGF0dXNUZXh0OiBzdHJpbmc7XG4gIGhlYWRlcnM6IGFueTtcbiAgZGF0YTogYW55O1xuICBjb25maWc6IEZzUmVxdWVzdE9wdGlvbnM7XG59XG4iXX0=


/***/ }),

/***/ 2790:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
exports.isArray = function (val) { return Object.prototype.toString.call(val) === '[object Array]'; };
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
exports.isArrayBuffer = function (val) { return Object.prototype.toString.call(val) === '[object ArrayBuffer]'; };
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
exports.isArrayBufferView = function (val) {
    var result;
    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
    }
    else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }
    return result;
};
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
exports.isObject = function (val) { return val !== null && typeof val === 'object'; };
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
exports.isString = function (val) { return typeof val === 'string' || val instanceof String; };
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
exports.isFile = function (val) { return Object.prototype.toString.call(val) === '[object File]'; };
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
exports.isBlob = function (val) { return Object.prototype.toString.call(val) === '[object Blob]'; };
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
exports.isURLSearchParams = function (val) { return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams; };
/**
 * Determine if value is form data
 *
 * @param val
 */
exports.isFormData = function (val) { return typeof FormData !== 'undefined' && val instanceof FormData; };
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
exports.trim = function (str) { return str.replace(/^\s*/, '').replace(/\s*$/, ''); };
tslib_1.__exportStar(__nccwpck_require__(5558), exports);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC91dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHOzs7QUFFSDs7Ozs7R0FLRztBQUNVLFFBQUEsT0FBTyxHQUFHLFVBQUMsR0FBVSxJQUFLLE9BQUEsTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLGdCQUFnQixFQUF4RCxDQUF3RCxDQUFDO0FBRWhHOzs7OztHQUtHO0FBQ1UsUUFBQSxhQUFhLEdBQUcsVUFBQyxHQUFnQixJQUFLLE9BQUEsTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLHNCQUFzQixFQUE5RCxDQUE4RCxDQUFDO0FBRWxIOzs7OztHQUtHO0FBQ1UsUUFBQSxpQkFBaUIsR0FBRyxVQUFDLEdBQW9CO0lBQ3BELElBQUksTUFBTSxDQUFDO0lBQ1gsSUFBSSxPQUFPLFdBQVcsS0FBSyxXQUFXLElBQUksV0FBVyxDQUFDLE1BQU0sRUFBRTtRQUM1RCxNQUFNLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNsQztTQUFNO1FBQ0wsTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBTSxJQUFJLEdBQUcsQ0FBQyxNQUFNLFlBQVksV0FBVyxDQUFDO0tBQ2pFO0lBRUQsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQyxDQUFDO0FBRUY7Ozs7O0dBS0c7QUFDVSxRQUFBLFFBQVEsR0FBRyxVQUFDLEdBQVEsSUFBSyxPQUFBLEdBQUcsS0FBSyxJQUFJLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUF2QyxDQUF1QyxDQUFDO0FBRTlFOzs7OztHQUtHO0FBQ1UsUUFBQSxRQUFRLEdBQUcsVUFBQyxHQUFRLElBQUssT0FBQSxPQUFPLEdBQUcsS0FBSyxRQUFRLElBQUksR0FBRyxZQUFZLE1BQU0sRUFBaEQsQ0FBZ0QsQ0FBQztBQUV2Rjs7Ozs7R0FLRztBQUNVLFFBQUEsTUFBTSxHQUFHLFVBQUMsR0FBUyxJQUFLLE9BQUEsTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLGVBQWUsRUFBdkQsQ0FBdUQsQ0FBQztBQUU3Rjs7Ozs7R0FLRztBQUNVLFFBQUEsTUFBTSxHQUFHLFVBQUMsR0FBUyxJQUFLLE9BQUEsTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLGVBQWUsRUFBdkQsQ0FBdUQsQ0FBQztBQUU3Rjs7Ozs7R0FLRztBQUNVLFFBQUEsaUJBQWlCLEdBQUcsVUFBQyxHQUFvQixJQUFLLE9BQUEsT0FBTyxlQUFlLEtBQUssV0FBVyxJQUFJLEdBQUcsWUFBWSxlQUFlLEVBQXhFLENBQXdFLENBQUM7QUFFcEk7Ozs7R0FJRztBQUNVLFFBQUEsVUFBVSxHQUFHLFVBQUEsR0FBRyxJQUFJLE9BQUEsT0FBTyxRQUFRLEtBQUssV0FBVyxJQUFJLEdBQUcsWUFBWSxRQUFRLEVBQTFELENBQTBELENBQUM7QUFFNUY7Ozs7O0dBS0c7QUFDVSxRQUFBLElBQUksR0FBRyxVQUFBLEdBQUcsSUFBSSxPQUFBLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQTNDLENBQTJDLENBQUM7QUFFdkUsdURBQTZCIiwiZmlsZSI6ImxpYi9yZXF1ZXN0L3V0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2tcbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5leHBvcnQgY29uc3QgaXNBcnJheSA9ICh2YWw6IGFueVtdKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGNvbnN0IGlzQXJyYXlCdWZmZXIgPSAodmFsOiBBcnJheUJ1ZmZlcikgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGNvbnN0IGlzQXJyYXlCdWZmZXJWaWV3ID0gKHZhbDogQXJyYXlCdWZmZXJWaWV3KSA9PiB7XG4gIGxldCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHZhbCAmJiB2YWwuYnVmZmVyICYmIHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBjb25zdCBpc09iamVjdCA9ICh2YWw6IGFueSkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBjb25zdCBpc1N0cmluZyA9ICh2YWw6IGFueSkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBjb25zdCBpc0ZpbGUgPSAodmFsOiBGaWxlKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Jsb2IgPSAodmFsOiBCbG9iKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBjb25zdCBpc1VSTFNlYXJjaFBhcmFtcyA9ICh2YWw6IFVSTFNlYXJjaFBhcmFtcykgPT4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB2YWx1ZSBpcyBmb3JtIGRhdGFcbiAqXG4gKiBAcGFyYW0gdmFsXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Zvcm1EYXRhID0gdmFsID0+IHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgRm9ybURhdGE7XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZXhwb3J0IGNvbnN0IHRyaW0gPSBzdHIgPT4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xuXG5leHBvcnQgKiBmcm9tICcuL3V0aWxzLm5vZGUnO1xuIl19


/***/ }),

/***/ 5558:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var stream = __nccwpck_require__(2413);
var utils_1 = __nccwpck_require__(2790);
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
exports.isBuffer = function (val) { return Buffer.isBuffer(val); };
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
exports.isStream = function (val) { return utils_1.isObject(val) && val instanceof stream.Stream && val instanceof stream.Readable; };

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC91dGlscy5ub2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsK0JBQWlDO0FBRWpDLGlDQUFtQztBQUVuQzs7Ozs7R0FLRztBQUNVLFFBQUEsUUFBUSxHQUFHLFVBQUEsR0FBRyxJQUFJLE9BQUEsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBcEIsQ0FBb0IsQ0FBQztBQUVwRDs7Ozs7R0FLRztBQUNVLFFBQUEsUUFBUSxHQUFHLFVBQUMsR0FBUSxJQUFLLE9BQUEsZ0JBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLFlBQVksTUFBTSxDQUFDLE1BQU0sSUFBSSxHQUFHLFlBQVksTUFBTSxDQUFDLFFBQVEsRUFBL0UsQ0FBK0UsQ0FBQyIsImZpbGUiOiJsaWIvcmVxdWVzdC91dGlscy5ub2RlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2tcbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0ICogYXMgc3RyZWFtIGZyb20gJ3N0cmVhbSc7XG5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBjb25zdCBpc0J1ZmZlciA9IHZhbCA9PiBCdWZmZXIuaXNCdWZmZXIodmFsKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGNvbnN0IGlzU3RyZWFtID0gKHZhbDogYW55KSA9PiBpc09iamVjdCh2YWwpICYmIHZhbCBpbnN0YW5jZW9mIHN0cmVhbS5TdHJlYW0gJiYgdmFsIGluc3RhbmNlb2Ygc3RyZWFtLlJlYWRhYmxlO1xuIl19


/***/ }),

/***/ 7599:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExtensionsMap = {
    'application/andrew-inset': ['ez'],
    'application/applixware': ['aw'],
    'application/atom+xml': ['atom'],
    'application/atomcat+xml': ['atomcat'],
    'application/atomsvc+xml': ['atomsvc'],
    'application/bdoc': ['bdoc'],
    'application/ccxml+xml': ['ccxml'],
    'application/cdmi-capability': ['cdmia'],
    'application/cdmi-container': ['cdmic'],
    'application/cdmi-domain': ['cdmid'],
    'application/cdmi-object': ['cdmio'],
    'application/cdmi-queue': ['cdmiq'],
    'application/cu-seeme': ['cu'],
    'application/dash+xml': ['mpd'],
    'application/davmount+xml': ['davmount'],
    'application/docbook+xml': ['dbk'],
    'application/dssc+der': ['dssc'],
    'application/dssc+xml': ['xdssc'],
    'application/ecmascript': ['ecma', 'es'],
    'application/emma+xml': ['emma'],
    'application/epub+zip': ['epub'],
    'application/exi': ['exi'],
    'application/font-tdpfr': ['pfr'],
    'application/geo+json': ['geojson'],
    'application/gml+xml': ['gml'],
    'application/gpx+xml': ['gpx'],
    'application/gxf': ['gxf'],
    'application/gzip': ['gz'],
    'application/hjson': ['hjson'],
    'application/hyperstudio': ['stk'],
    'application/inkml+xml': ['ink', 'inkml'],
    'application/ipfix': ['ipfix'],
    'application/java-archive': ['jar', 'war', 'ear'],
    'application/java-serialized-object': ['ser'],
    'application/java-vm': ['class'],
    'application/javascript': ['js', 'mjs'],
    'application/json': ['json', 'map'],
    'application/json5': ['json5'],
    'application/jsonml+json': ['jsonml'],
    'application/ld+json': ['jsonld'],
    'application/lost+xml': ['lostxml'],
    'application/mac-binhex40': ['hqx'],
    'application/mac-compactpro': ['cpt'],
    'application/mads+xml': ['mads'],
    'application/manifest+json': ['webmanifest'],
    'application/marc': ['mrc'],
    'application/marcxml+xml': ['mrcx'],
    'application/mathematica': ['ma', 'nb', 'mb'],
    'application/mathml+xml': ['mathml'],
    'application/mbox': ['mbox'],
    'application/mediaservercontrol+xml': ['mscml'],
    'application/metalink+xml': ['metalink'],
    'application/metalink4+xml': ['meta4'],
    'application/mets+xml': ['mets'],
    'application/mods+xml': ['mods'],
    'application/mp21': ['m21', 'mp21'],
    'application/mp4': ['mp4s', 'm4p'],
    'application/msword': ['doc', 'dot'],
    'application/mxf': ['mxf'],
    'application/n-quads': ['nq'],
    'application/n-triples': ['nt'],
    'application/octet-stream': [
        'bin',
        'dms',
        'lrf',
        'mar',
        'so',
        'dist',
        'distz',
        'pkg',
        'bpk',
        'dump',
        'elc',
        'deploy',
        'exe',
        'dll',
        'deb',
        'dmg',
        'iso',
        'msp',
        'buffer',
    ],
    'application/oda': ['oda'],
    'application/oebps-package+xml': ['opf'],
    'application/ogg': ['ogx'],
    'application/omdoc+xml': ['omdoc'],
    'application/onenote': ['onetoc', 'onetoc2', 'onetmp', 'onepkg'],
    'application/oxps': ['oxps'],
    'application/patch-ops-error+xml': ['xer'],
    'application/pdf': ['pdf'],
    'application/pgp-encrypted': ['pgp'],
    'application/pgp-signature': ['asc', 'sig'],
    'application/pics-rules': ['prf'],
    'application/pkcs10': ['p10'],
    'application/pkcs7-mime': ['p7m', 'p7c'],
    'application/pkcs7-signature': ['p7s'],
    'application/pkcs8': ['p8'],
    'application/pkix-attr-cert': ['ac'],
    'application/pkix-cert': ['cer'],
    'application/pkix-crl': ['crl'],
    'application/pkix-pkipath': ['pkipath'],
    'application/pkixcmp': ['pki'],
    'application/pls+xml': ['pls'],
    'application/postscript': ['ai', 'eps', 'ps'],
    'application/pskc+xml': ['pskcxml'],
    'application/raml+yaml': ['raml'],
    'application/rdf+xml': ['rdf', 'owl'],
    'application/reginfo+xml': ['rif'],
    'application/relax-ng-compact-syntax': ['rnc'],
    'application/resource-lists+xml': ['rl'],
    'application/resource-lists-diff+xml': ['rld'],
    'application/rls-services+xml': ['rs'],
    'application/rpki-ghostbusters': ['gbr'],
    'application/rpki-manifest': ['mft'],
    'application/rpki-roa': ['roa'],
    'application/rsd+xml': ['rsd'],
    'application/rss+xml': ['rss'],
    'application/rtf': ['rtf'],
    'application/sbml+xml': ['sbml'],
    'application/scvp-cv-request': ['scq'],
    'application/scvp-cv-response': ['scs'],
    'application/scvp-vp-request': ['spq'],
    'application/scvp-vp-response': ['spp'],
    'application/sdp': ['sdp'],
    'application/set-payment-initiation': ['setpay'],
    'application/set-registration-initiation': ['setreg'],
    'application/shf+xml': ['shf'],
    'application/sieve': ['siv', 'sieve'],
    'application/smil+xml': ['smi', 'smil'],
    'application/sparql-query': ['rq'],
    'application/sparql-results+xml': ['srx'],
    'application/srgs': ['gram'],
    'application/srgs+xml': ['grxml'],
    'application/sru+xml': ['sru'],
    'application/ssdl+xml': ['ssdl'],
    'application/ssml+xml': ['ssml'],
    'application/tei+xml': ['tei', 'teicorpus'],
    'application/thraud+xml': ['tfi'],
    'application/timestamped-data': ['tsd'],
    'application/voicexml+xml': ['vxml'],
    'application/wasm': ['wasm'],
    'application/widget': ['wgt'],
    'application/winhlp': ['hlp'],
    'application/wsdl+xml': ['wsdl'],
    'application/wspolicy+xml': ['wspolicy'],
    'application/xaml+xml': ['xaml'],
    'application/xcap-diff+xml': ['xdf'],
    'application/xenc+xml': ['xenc'],
    'application/xhtml+xml': ['xhtml', 'xht'],
    'application/xml': ['xml', 'xsl', 'xsd', 'rng'],
    'application/xml-dtd': ['dtd'],
    'application/xop+xml': ['xop'],
    'application/xproc+xml': ['xpl'],
    'application/xslt+xml': ['xslt'],
    'application/xspf+xml': ['xspf'],
    'application/xv+xml': ['mxml', 'xhvml', 'xvml', 'xvm'],
    'application/yang': ['yang'],
    'application/yin+xml': ['yin'],
    'application/zip': ['zip'],
    'audio/3gpp': ['*3gpp'],
    'audio/adpcm': ['adp'],
    'audio/basic': ['au', 'snd'],
    'audio/midi': ['mid', 'midi', 'kar', 'rmi'],
    'audio/mp3': ['*mp3'],
    'audio/mp4': ['m4a', 'mp4a'],
    'audio/mpeg': ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'],
    'audio/ogg': ['oga', 'ogg', 'spx'],
    'audio/s3m': ['s3m'],
    'audio/silk': ['sil'],
    'audio/wav': ['wav'],
    'audio/wave': ['*wav'],
    'audio/webm': ['weba'],
    'audio/xm': ['xm'],
    'font/collection': ['ttc'],
    'font/otf': ['otf'],
    'font/ttf': ['ttf'],
    'font/woff': ['woff'],
    'font/woff2': ['woff2'],
    'image/aces': ['exr'],
    'image/apng': ['apng'],
    'image/bmp': ['bmp'],
    'image/cgm': ['cgm'],
    'image/dicom-rle': ['drle'],
    'image/emf': ['emf'],
    'image/fits': ['fits'],
    'image/g3fax': ['g3'],
    'image/gif': ['gif'],
    'image/heic': ['heic'],
    'image/heic-sequence': ['heics'],
    'image/heif': ['heif'],
    'image/heif-sequence': ['heifs'],
    'image/ief': ['ief'],
    'image/jls': ['jls'],
    'image/jp2': ['jp2', 'jpg2'],
    'image/jpeg': ['jpeg', 'jpg', 'jpe'],
    'image/jpm': ['jpm'],
    'image/jpx': ['jpx', 'jpf'],
    'image/jxr': ['jxr'],
    'image/ktx': ['ktx'],
    'image/png': ['png'],
    'image/sgi': ['sgi'],
    'image/svg+xml': ['svg', 'svgz'],
    'image/t38': ['t38'],
    'image/tiff': ['tif', 'tiff'],
    'image/tiff-fx': ['tfx'],
    'image/webp': ['webp'],
    'image/wmf': ['wmf'],
    'message/disposition-notification': ['disposition-notification'],
    'message/global': ['u8msg'],
    'message/global-delivery-status': ['u8dsn'],
    'message/global-disposition-notification': ['u8mdn'],
    'message/global-headers': ['u8hdr'],
    'message/rfc822': ['eml', 'mime'],
    'model/3mf': ['3mf'],
    'model/gltf+json': ['gltf'],
    'model/gltf-binary': ['glb'],
    'model/iges': ['igs', 'iges'],
    'model/mesh': ['msh', 'mesh', 'silo'],
    'model/stl': ['stl'],
    'model/vrml': ['wrl', 'vrml'],
    'model/x3d+binary': ['*x3db', 'x3dbz'],
    'model/x3d+fastinfoset': ['x3db'],
    'model/x3d+vrml': ['*x3dv', 'x3dvz'],
    'model/x3d+xml': ['x3d', 'x3dz'],
    'model/x3d-vrml': ['x3dv'],
    'text/cache-manifest': ['appcache', 'manifest'],
    'text/calendar': ['ics', 'ifb'],
    'text/coffeescript': ['coffee', 'litcoffee'],
    'text/css': ['css'],
    'text/csv': ['csv'],
    'text/html': ['html', 'htm', 'shtml'],
    'text/jade': ['jade'],
    'text/jsx': ['jsx'],
    'text/less': ['less'],
    'text/markdown': ['markdown', 'md'],
    'text/mathml': ['mml'],
    'text/mdx': ['mdx'],
    'text/n3': ['n3'],
    'text/plain': ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini'],
    'text/richtext': ['rtx'],
    'application/font-ttf': 'ttf',
    'application/vnd.ms-fontobject': 'eot',
    'application/font-otf': 'otf',
    'text/rtf': ['*rtf'],
    'text/sgml': ['sgml', 'sgm'],
    'text/shex': ['shex'],
    'text/slim': ['slim', 'slm'],
    'text/stylus': ['stylus', 'styl'],
    'text/tab-separated-values': ['tsv'],
    'text/troff': ['t', 'tr', 'roff', 'man', 'me', 'ms'],
    'text/turtle': ['ttl'],
    'text/uri-list': ['uri', 'uris', 'urls'],
    'text/vcard': ['vcard', 'vcr'],
    'text/vtt': ['vtt'],
    'text/xml': ['*xml'],
    'text/yaml': ['yaml', 'yml'],
    'video/3gpp': ['3gp', '3gpp'],
    'video/3gpp2': ['3g2'],
    'video/h261': ['h261'],
    'video/h263': ['h263'],
    'video/h264': ['h264'],
    'video/jpeg': ['jpgv'],
    'video/jpm': ['*jpm', 'jpgm'],
    'video/mj2': ['mj2', 'mjp2'],
    'video/mp2t': ['ts'],
    'video/mp4': ['mp4', 'mp4v', 'mpg4'],
    'video/mpeg': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],
    'video/ogg': ['ogv'],
    'video/quicktime': ['qt', 'mov'],
    'video/webm': ['webm'],
    'application/prs.cww': ['cww'],
    'application/vnd.3gpp.pic-bw-large': ['plb'],
    'application/vnd.3gpp.pic-bw-small': ['psb'],
    'application/vnd.3gpp.pic-bw-var': ['pvb'],
    'application/vnd.3gpp2.tcap': ['tcap'],
    'application/vnd.3m.post-it-notes': ['pwn'],
    'application/vnd.accpac.simply.aso': ['aso'],
    'application/vnd.accpac.simply.imp': ['imp'],
    'application/vnd.acucobol': ['acu'],
    'application/vnd.acucorp': ['atc', 'acutc'],
    'application/vnd.adobe.air-application-installer-package+zip': ['air'],
    'application/vnd.adobe.formscentral.fcdt': ['fcdt'],
    'application/vnd.adobe.fxp': ['fxp', 'fxpl'],
    'application/vnd.adobe.xdp+xml': ['xdp'],
    'application/vnd.adobe.xfdf': ['xfdf'],
    'application/vnd.ahead.space': ['ahead'],
    'application/vnd.airzip.filesecure.azf': ['azf'],
    'application/vnd.airzip.filesecure.azs': ['azs'],
    'application/vnd.amazon.ebook': ['azw'],
    'application/vnd.americandynamics.acc': ['acc'],
    'application/vnd.amiga.ami': ['ami'],
    'application/vnd.android.package-archive': ['apk'],
    'application/vnd.anser-web-certificate-issue-initiation': ['cii'],
    'application/vnd.anser-web-funds-transfer-initiation': ['fti'],
    'application/vnd.antix.game-component': ['atx'],
    'application/vnd.apple.installer+xml': ['mpkg'],
    'application/vnd.apple.keynote': ['keynote', 'key'],
    'application/vnd.apple.mpegurl': ['m3u8'],
    'application/vnd.apple.numbers': ['numbers'],
    'application/vnd.apple.pages': ['pages'],
    'application/vnd.apple.key': ['key'],
    'application/vnd.apple.pkpass': ['pkpass'],
    'application/vnd.aristanetworks.swi': ['swi'],
    'application/vnd.astraea-software.iota': ['iota'],
    'application/vnd.audiograph': ['aep'],
    'application/vnd.blueice.multipass': ['mpm'],
    'application/vnd.bmi': ['bmi'],
    'application/vnd.businessobjects': ['rep'],
    'application/vnd.chemdraw+xml': ['cdxml'],
    'application/vnd.chipnuts.karaoke-mmd': ['mmd'],
    'application/vnd.cinderella': ['cdy'],
    'application/vnd.citationstyles.style+xml': ['csl'],
    'application/vnd.claymore': ['cla'],
    'application/vnd.cloanto.rp9': ['rp9'],
    'application/vnd.clonk.c4group': ['c4g', 'c4d', 'c4f', 'c4p', 'c4u'],
    'application/vnd.cluetrust.cartomobile-config': ['c11amc'],
    'application/vnd.cluetrust.cartomobile-config-pkg': ['c11amz'],
    'application/vnd.commonspace': ['csp'],
    'application/vnd.contact.cmsg': ['cdbcmsg'],
    'application/vnd.cosmocaller': ['cmc'],
    'application/vnd.crick.clicker': ['clkx'],
    'application/vnd.crick.clicker.keyboard': ['clkk'],
    'application/vnd.crick.clicker.palette': ['clkp'],
    'application/vnd.crick.clicker.template': ['clkt'],
    'application/vnd.crick.clicker.wordbank': ['clkw'],
    'application/vnd.criticaltools.wbs+xml': ['wbs'],
    'application/vnd.ctc-posml': ['pml'],
    'application/vnd.cups-ppd': ['ppd'],
    'application/vnd.curl.car': ['car'],
    'application/vnd.curl.pcurl': ['pcurl'],
    'application/vnd.dart': ['dart'],
    'application/vnd.data-vision.rdz': ['rdz'],
    'application/vnd.dece.data': ['uvf', 'uvvf', 'uvd', 'uvvd'],
    'application/vnd.dece.ttml+xml': ['uvt', 'uvvt'],
    'application/vnd.dece.unspecified': ['uvx', 'uvvx'],
    'application/vnd.dece.zip': ['uvz', 'uvvz'],
    'application/vnd.denovo.fcselayout-link': ['fe_launch'],
    'application/vnd.dna': ['dna'],
    'application/vnd.dolby.mlp': ['mlp'],
    'application/vnd.dpgraph': ['dpg'],
    'application/vnd.dreamfactory': ['dfac'],
    'application/vnd.ds-keypoint': ['kpxx'],
    'application/vnd.dvb.ait': ['ait'],
    'application/vnd.dvb.service': ['svc'],
    'application/vnd.dynageo': ['geo'],
    'application/vnd.ecowin.chart': ['mag'],
    'application/vnd.enliven': ['nml'],
    'application/vnd.epson.esf': ['esf'],
    'application/vnd.epson.msf': ['msf'],
    'application/vnd.epson.quickanime': ['qam'],
    'application/vnd.epson.salt': ['slt'],
    'application/vnd.epson.ssf': ['ssf'],
    'application/vnd.eszigno3+xml': ['es3', 'et3'],
    'application/vnd.ezpix-album': ['ez2'],
    'application/vnd.ezpix-package': ['ez3'],
    'application/vnd.fdf': ['fdf'],
    'application/vnd.fdsn.mseed': ['mseed'],
    'application/vnd.fdsn.seed': ['seed', 'dataless'],
    'application/vnd.flographit': ['gph'],
    'application/vnd.fluxtime.clip': ['ftc'],
    'application/vnd.framemaker': ['fm', 'frame', 'maker', 'book'],
    'application/vnd.frogans.fnc': ['fnc'],
    'application/vnd.frogans.ltf': ['ltf'],
    'application/vnd.fsc.weblaunch': ['fsc'],
    'application/vnd.fujitsu.oasys': ['oas'],
    'application/vnd.fujitsu.oasys2': ['oa2'],
    'application/vnd.fujitsu.oasys3': ['oa3'],
    'application/vnd.fujitsu.oasysgp': ['fg5'],
    'application/vnd.fujitsu.oasysprs': ['bh2'],
    'application/vnd.fujixerox.ddd': ['ddd'],
    'application/vnd.fujixerox.docuworks': ['xdw'],
    'application/vnd.fujixerox.docuworks.binder': ['xbd'],
    'application/vnd.fuzzysheet': ['fzs'],
    'application/vnd.genomatix.tuxedo': ['txd'],
    'application/vnd.geogebra.file': ['ggb'],
    'application/vnd.geogebra.tool': ['ggt'],
    'application/vnd.geometry-explorer': ['gex', 'gre'],
    'application/vnd.geonext': ['gxt'],
    'application/vnd.geoplan': ['g2w'],
    'application/vnd.geospace': ['g3w'],
    'application/vnd.gmx': ['gmx'],
    'application/vnd.google-apps.document': ['gdoc'],
    'application/vnd.google-apps.presentation': ['gslides'],
    'application/vnd.google-apps.spreadsheet': ['gsheet'],
    'application/vnd.google-earth.kml+xml': ['kml'],
    'application/vnd.google-earth.kmz': ['kmz'],
    'application/vnd.grafeq': ['gqf', 'gqs'],
    'application/vnd.groove-account': ['gac'],
    'application/vnd.groove-help': ['ghf'],
    'application/vnd.groove-identity-message': ['gim'],
    'application/vnd.groove-injector': ['grv'],
    'application/vnd.groove-tool-message': ['gtm'],
    'application/vnd.groove-tool-template': ['tpl'],
    'application/vnd.groove-vcard': ['vcg'],
    'application/vnd.hal+xml': ['hal'],
    'application/vnd.handheld-entertainment+xml': ['zmm'],
    'application/vnd.hbci': ['hbci'],
    'application/vnd.hhe.lesson-player': ['les'],
    'application/vnd.hp-hpgl': ['hpgl'],
    'application/vnd.hp-hpid': ['hpid'],
    'application/vnd.hp-hps': ['hps'],
    'application/vnd.hp-jlyt': ['jlt'],
    'application/vnd.hp-pcl': ['pcl'],
    'application/vnd.hp-pclxl': ['pclxl'],
    'application/vnd.hydrostatix.sof-data': ['sfd-hdstx'],
    'application/vnd.ibm.minipay': ['mpy'],
    'application/vnd.ibm.modcap': ['afp', 'listafp', 'list3820'],
    'application/vnd.ibm.rights-management': ['irm'],
    'application/vnd.ibm.secure-container': ['sc'],
    'application/vnd.iccprofile': ['icc', 'icm'],
    'application/vnd.igloader': ['igl'],
    'application/vnd.immervision-ivp': ['ivp'],
    'application/vnd.immervision-ivu': ['ivu'],
    'application/vnd.insors.igm': ['igm'],
    'application/vnd.intercon.formnet': ['xpw', 'xpx'],
    'application/vnd.intergeo': ['i2g'],
    'application/vnd.intu.qbo': ['qbo'],
    'application/vnd.intu.qfx': ['qfx'],
    'application/vnd.ipunplugged.rcprofile': ['rcprofile'],
    'application/vnd.irepository.package+xml': ['irp'],
    'application/vnd.is-xpr': ['xpr'],
    'application/vnd.isac.fcs': ['fcs'],
    'application/vnd.jam': ['jam'],
    'application/vnd.jcp.javame.midlet-rms': ['rms'],
    'application/vnd.jisp': ['jisp'],
    'application/vnd.joost.joda-archive': ['joda'],
    'application/vnd.kahootz': ['ktz', 'ktr'],
    'application/vnd.kde.karbon': ['karbon'],
    'application/vnd.kde.kchart': ['chrt'],
    'application/vnd.kde.kformula': ['kfo'],
    'application/vnd.kde.kivio': ['flw'],
    'application/vnd.kde.kontour': ['kon'],
    'application/vnd.kde.kpresenter': ['kpr', 'kpt'],
    'application/vnd.kde.kspread': ['ksp'],
    'application/vnd.kde.kword': ['kwd', 'kwt'],
    'application/vnd.kenameaapp': ['htke'],
    'application/vnd.kidspiration': ['kia'],
    'application/vnd.kinar': ['kne', 'knp'],
    'application/vnd.koan': ['skp', 'skd', 'skt', 'skm'],
    'application/vnd.kodak-descriptor': ['sse'],
    'application/vnd.las.las+xml': ['lasxml'],
    'application/vnd.llamagraphics.life-balance.desktop': ['lbd'],
    'application/vnd.llamagraphics.life-balance.exchange+xml': ['lbe'],
    'application/vnd.lotus-1-2-3': ['123'],
    'application/vnd.lotus-approach': ['apr'],
    'application/vnd.lotus-freelance': ['pre'],
    'application/vnd.lotus-notes': ['nsf'],
    'application/vnd.lotus-organizer': ['org'],
    'application/vnd.lotus-screencam': ['scm'],
    'application/vnd.lotus-wordpro': ['lwp'],
    'application/vnd.macports.portpkg': ['portpkg'],
    'application/vnd.mcd': ['mcd'],
    'application/vnd.medcalcdata': ['mc1'],
    'application/vnd.mediastation.cdkey': ['cdkey'],
    'application/vnd.mfer': ['mwf'],
    'application/vnd.mfmp': ['mfm'],
    'application/vnd.micrografx.flo': ['flo'],
    'application/vnd.micrografx.igx': ['igx'],
    'application/vnd.mif': ['mif'],
    'application/vnd.mobius.daf': ['daf'],
    'application/vnd.mobius.dis': ['dis'],
    'application/vnd.mobius.mbk': ['mbk'],
    'application/vnd.mobius.mqy': ['mqy'],
    'application/vnd.mobius.msl': ['msl'],
    'application/vnd.mobius.plc': ['plc'],
    'application/vnd.mobius.txf': ['txf'],
    'application/vnd.mophun.application': ['mpn'],
    'application/vnd.mophun.certificate': ['mpc'],
    'application/vnd.mozilla.xul+xml': ['xul'],
    'application/vnd.ms-artgalry': ['cil'],
    'application/vnd.ms-cab-compressed': ['cab'],
    'application/vnd.ms-excel': ['xls', 'xlm', 'xla', 'xlc', 'xlt', 'xlw'],
    'application/vnd.ms-excel.addin.macroenabled.12': ['xlam'],
    'application/vnd.ms-excel.sheet.binary.macroenabled.12': ['xlsb'],
    'application/vnd.ms-excel.sheet.macroenabled.12': ['xlsm'],
    'application/vnd.ms-excel.template.macroenabled.12': ['xltm'],
    'application/vnd.ms-htmlhelp': ['chm'],
    'application/vnd.ms-ims': ['ims'],
    'application/vnd.ms-lrm': ['lrm'],
    'application/vnd.ms-officetheme': ['thmx'],
    'application/vnd.ms-outlook': ['msg'],
    'application/vnd.ms-pki.seccat': ['cat'],
    'application/vnd.ms-pki.stl': ['*stl'],
    'application/vnd.ms-powerpoint': ['ppt', 'pps', 'pot'],
    'application/vnd.ms-powerpoint.addin.macroenabled.12': ['ppam'],
    'application/vnd.ms-powerpoint.presentation.macroenabled.12': ['pptm'],
    'application/vnd.ms-powerpoint.slide.macroenabled.12': ['sldm'],
    'application/vnd.ms-powerpoint.slideshow.macroenabled.12': ['ppsm'],
    'application/vnd.ms-powerpoint.template.macroenabled.12': ['potm'],
    'application/vnd.ms-project': ['mpp', 'mpt'],
    'application/vnd.ms-word.document.macroenabled.12': ['docm'],
    'application/vnd.ms-word.template.macroenabled.12': ['dotm'],
    'application/vnd.ms-works': ['wps', 'wks', 'wcm', 'wdb'],
    'application/vnd.ms-wpl': ['wpl'],
    'application/vnd.ms-xpsdocument': ['xps'],
    'application/vnd.mseq': ['mseq'],
    'application/vnd.musician': ['mus'],
    'application/vnd.muvee.style': ['msty'],
    'application/vnd.mynfc': ['taglet'],
    'application/vnd.neurolanguage.nlu': ['nlu'],
    'application/vnd.nitf': ['ntf', 'nitf'],
    'application/vnd.noblenet-directory': ['nnd'],
    'application/vnd.noblenet-sealer': ['nns'],
    'application/vnd.noblenet-web': ['nnw'],
    'application/vnd.nokia.n-gage.data': ['ngdat'],
    'application/vnd.nokia.n-gage.symbian.install': ['n-gage'],
    'application/vnd.nokia.radio-preset': ['rpst'],
    'application/vnd.nokia.radio-presets': ['rpss'],
    'application/vnd.novadigm.edm': ['edm'],
    'application/vnd.novadigm.edx': ['edx'],
    'application/vnd.novadigm.ext': ['ext'],
    'application/vnd.oasis.opendocument.chart': ['odc'],
    'application/vnd.oasis.opendocument.chart-template': ['otc'],
    'application/vnd.oasis.opendocument.database': ['odb'],
    'application/vnd.oasis.opendocument.formula': ['odf'],
    'application/vnd.oasis.opendocument.formula-template': ['odft'],
    'application/vnd.oasis.opendocument.graphics': ['odg'],
    'application/vnd.oasis.opendocument.graphics-template': ['otg'],
    'application/vnd.oasis.opendocument.image': ['odi'],
    'application/vnd.oasis.opendocument.image-template': ['oti'],
    'application/vnd.oasis.opendocument.presentation': ['odp'],
    'application/vnd.oasis.opendocument.presentation-template': ['otp'],
    'application/vnd.oasis.opendocument.spreadsheet': ['ods'],
    'application/vnd.oasis.opendocument.spreadsheet-template': ['ots'],
    'application/vnd.oasis.opendocument.text': ['odt'],
    'application/vnd.oasis.opendocument.text-master': ['odm'],
    'application/vnd.oasis.opendocument.text-template': ['ott'],
    'application/vnd.oasis.opendocument.text-web': ['oth'],
    'application/vnd.olpc-sugar': ['xo'],
    'application/vnd.oma.dd2+xml': ['dd2'],
    'application/vnd.openofficeorg.extension': ['oxt'],
    'application/vnd.openxmlformats-officedocument.presentationml.presentation': ['pptx'],
    'application/vnd.openxmlformats-officedocument.presentationml.slide': ['sldx'],
    'application/vnd.openxmlformats-officedocument.presentationml.slideshow': ['ppsx'],
    'application/vnd.openxmlformats-officedocument.presentationml.template': ['potx'],
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['xlsx'],
    'application/vnd.openxmlformats-officedocument.spreadsheetml.template': ['xltx'],
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['docx'],
    'application/vnd.openxmlformats-officedocument.wordprocessingml.template': ['dotx'],
    'application/vnd.osgeo.mapguide.package': ['mgp'],
    'application/vnd.osgi.dp': ['dp'],
    'application/vnd.osgi.subsystem': ['esa'],
    'application/vnd.palm': ['pdb', 'pqa', 'oprc'],
    'application/vnd.pawaafile': ['paw'],
    'application/vnd.pg.format': ['str'],
    'application/vnd.pg.osasli': ['ei6'],
    'application/vnd.picsel': ['efif'],
    'application/vnd.pmi.widget': ['wg'],
    'application/vnd.pocketlearn': ['plf'],
    'application/vnd.powerbuilder6': ['pbd'],
    'application/vnd.previewsystems.box': ['box'],
    'application/vnd.proteus.magazine': ['mgz'],
    'application/vnd.publishare-delta-tree': ['qps'],
    'application/vnd.pvi.ptid1': ['ptid'],
    'application/vnd.quark.quarkxpress': ['qxd', 'qxt', 'qwd', 'qwt', 'qxl', 'qxb'],
    'application/vnd.realvnc.bed': ['bed'],
    'application/vnd.recordare.musicxml': ['mxl'],
    'application/vnd.recordare.musicxml+xml': ['musicxml'],
    'application/vnd.rig.cryptonote': ['cryptonote'],
    'application/vnd.rim.cod': ['cod'],
    'application/vnd.rn-realmedia': ['rm'],
    'application/vnd.rn-realmedia-vbr': ['rmvb'],
    'application/vnd.route66.link66+xml': ['link66'],
    'application/vnd.sailingtracker.track': ['st'],
    'application/vnd.seemail': ['see'],
    'application/vnd.sema': ['sema'],
    'application/vnd.semd': ['semd'],
    'application/vnd.semf': ['semf'],
    'application/vnd.shana.informed.formdata': ['ifm'],
    'application/vnd.shana.informed.formtemplate': ['itp'],
    'application/vnd.shana.informed.interchange': ['iif'],
    'application/vnd.shana.informed.package': ['ipk'],
    'application/vnd.simtech-mindmapper': ['twd', 'twds'],
    'application/vnd.smaf': ['mmf'],
    'application/vnd.smart.teacher': ['teacher'],
    'application/vnd.solent.sdkm+xml': ['sdkm', 'sdkd'],
    'application/vnd.spotfire.dxp': ['dxp'],
    'application/vnd.spotfire.sfs': ['sfs'],
    'application/vnd.stardivision.calc': ['sdc'],
    'application/vnd.stardivision.draw': ['sda'],
    'application/vnd.stardivision.impress': ['sdd'],
    'application/vnd.stardivision.math': ['smf'],
    'application/vnd.stardivision.writer': ['sdw', 'vor'],
    'application/vnd.stardivision.writer-global': ['sgl'],
    'application/vnd.stepmania.package': ['smzip'],
    'application/vnd.stepmania.stepchart': ['sm'],
    'application/vnd.sun.wadl+xml': ['wadl'],
    'application/vnd.sun.xml.calc': ['sxc'],
    'application/vnd.sun.xml.calc.template': ['stc'],
    'application/vnd.sun.xml.draw': ['sxd'],
    'application/vnd.sun.xml.draw.template': ['std'],
    'application/vnd.sun.xml.impress': ['sxi'],
    'application/vnd.sun.xml.impress.template': ['sti'],
    'application/vnd.sun.xml.math': ['sxm'],
    'application/vnd.sun.xml.writer': ['sxw'],
    'application/vnd.sun.xml.writer.global': ['sxg'],
    'application/vnd.sun.xml.writer.template': ['stw'],
    'application/vnd.sus-calendar': ['sus', 'susp'],
    'application/vnd.svd': ['svd'],
    'application/vnd.symbian.install': ['sis', 'sisx'],
    'application/vnd.syncml+xml': ['xsm'],
    'application/vnd.syncml.dm+wbxml': ['bdm'],
    'application/vnd.syncml.dm+xml': ['xdm'],
    'application/vnd.tao.intent-module-archive': ['tao'],
    'application/vnd.tcpdump.pcap': ['pcap', 'cap', 'dmp'],
    'application/vnd.tmobile-livetv': ['tmo'],
    'application/vnd.trid.tpt': ['tpt'],
    'application/vnd.triscape.mxs': ['mxs'],
    'application/vnd.trueapp': ['tra'],
    'application/vnd.ufdl': ['ufd', 'ufdl'],
    'application/vnd.uiq.theme': ['utz'],
    'application/vnd.umajin': ['umj'],
    'application/vnd.unity': ['unityweb'],
    'application/vnd.uoml+xml': ['uoml'],
    'application/vnd.vcx': ['vcx'],
    'application/vnd.visio': ['vsd', 'vst', 'vss', 'vsw'],
    'application/vnd.visionary': ['vis'],
    'application/vnd.vsf': ['vsf'],
    'application/vnd.wap.wbxml': ['wbxml'],
    'application/vnd.wap.wmlc': ['wmlc'],
    'application/vnd.wap.wmlscriptc': ['wmlsc'],
    'application/vnd.webturbo': ['wtb'],
    'application/vnd.wolfram.player': ['nbp'],
    'application/vnd.wordperfect': ['wpd'],
    'application/vnd.wqd': ['wqd'],
    'application/vnd.wt.stf': ['stf'],
    'application/vnd.xara': ['xar'],
    'application/vnd.xfdl': ['xfdl'],
    'application/vnd.yamaha.hv-dic': ['hvd'],
    'application/vnd.yamaha.hv-script': ['hvs'],
    'application/vnd.yamaha.hv-voice': ['hvp'],
    'application/vnd.yamaha.openscoreformat': ['osf'],
    'application/vnd.yamaha.openscoreformat.osfpvg+xml': ['osfpvg'],
    'application/vnd.yamaha.smaf-audio': ['saf'],
    'application/vnd.yamaha.smaf-phrase': ['spf'],
    'application/vnd.yellowriver-custom-menu': ['cmp'],
    'application/vnd.zul': ['zir', 'zirz'],
    'application/vnd.zzazz.deck+xml': ['zaz'],
    'application/x-7z-compressed': ['7z'],
    'application/x-abiword': ['abw'],
    'application/x-ace-compressed': ['ace'],
    'application/x-apple-diskimage': ['*dmg'],
    'application/x-arj': ['arj'],
    'application/x-authorware-bin': ['aab', 'x32', 'u32', 'vox'],
    'application/x-authorware-map': ['aam'],
    'application/x-authorware-seg': ['aas'],
    'application/x-bcpio': ['bcpio'],
    'application/x-bdoc': ['*bdoc'],
    'application/x-bittorrent': ['torrent'],
    'application/x-blorb': ['blb', 'blorb'],
    'application/x-bzip': ['bz'],
    'application/x-bzip2': ['bz2', 'boz'],
    'application/x-cbr': ['cbr', 'cba', 'cbt', 'cbz', 'cb7'],
    'application/x-cdlink': ['vcd'],
    'application/x-cfs-compressed': ['cfs'],
    'application/x-chat': ['chat'],
    'application/x-chess-pgn': ['pgn'],
    'application/x-chrome-extension': ['crx'],
    'application/x-cocoa': ['cco'],
    'application/x-conference': ['nsc'],
    'application/x-cpio': ['cpio'],
    'application/x-csh': ['csh'],
    'application/x-debian-package': ['*deb', 'udeb'],
    'application/x-dgc-compressed': ['dgc'],
    'application/x-director': ['dir', 'dcr', 'dxr', 'cst', 'cct', 'cxt', 'w3d', 'fgd', 'swa'],
    'application/x-doom': ['wad'],
    'application/x-dtbncx+xml': ['ncx'],
    'application/x-dtbook+xml': ['dtb'],
    'application/x-dtbresource+xml': ['res'],
    'application/x-dvi': ['dvi'],
    'application/x-envoy': ['evy'],
    'application/x-eva': ['eva'],
    'application/x-font-bdf': ['bdf'],
    'application/x-font-ghostscript': ['gsf'],
    'application/x-font-linux-psf': ['psf'],
    'application/x-font-pcf': ['pcf'],
    'application/x-font-snf': ['snf'],
    'application/x-font-type1': ['pfa', 'pfb', 'pfm', 'afm'],
    'application/x-freearc': ['arc'],
    'application/x-futuresplash': ['spl'],
    'application/x-gca-compressed': ['gca'],
    'application/x-glulx': ['ulx'],
    'application/x-gnumeric': ['gnumeric'],
    'application/x-gramps-xml': ['gramps'],
    'application/x-gtar': ['gtar'],
    'application/x-hdf': ['hdf'],
    'application/x-httpd-php': ['php'],
    'application/x-install-instructions': ['install'],
    'application/x-iso9660-image': ['*iso'],
    'application/x-java-archive-diff': ['jardiff'],
    'application/x-java-jnlp-file': ['jnlp'],
    'application/x-latex': ['latex'],
    'application/x-lua-bytecode': ['luac'],
    'application/x-lzh-compressed': ['lzh', 'lha'],
    'application/x-makeself': ['run'],
    'application/x-mie': ['mie'],
    'application/x-mobipocket-ebook': ['prc', 'mobi'],
    'application/x-ms-application': ['application'],
    'application/x-ms-shortcut': ['lnk'],
    'application/x-ms-wmd': ['wmd'],
    'application/x-ms-wmz': ['wmz'],
    'application/x-ms-xbap': ['xbap'],
    'application/x-msaccess': ['mdb'],
    'application/x-msbinder': ['obd'],
    'application/x-mscardfile': ['crd'],
    'application/x-msclip': ['clp'],
    'application/x-msdos-program': ['*exe'],
    'application/x-msdownload': ['*exe', '*dll', 'com', 'bat', '*msi'],
    'application/x-msmediaview': ['mvb', 'm13', 'm14'],
    'application/x-msmetafile': ['*wmf', '*wmz', '*emf', 'emz'],
    'application/x-msmoney': ['mny'],
    'application/x-mspublisher': ['pub'],
    'application/x-msschedule': ['scd'],
    'application/x-msterminal': ['trm'],
    'application/x-mswrite': ['wri'],
    'application/x-netcdf': ['nc', 'cdf'],
    'application/x-ns-proxy-autoconfig': ['pac'],
    'application/x-nzb': ['nzb'],
    'application/x-perl': ['pl', 'pm'],
    'application/x-pilot': ['*prc', '*pdb'],
    'application/x-pkcs12': ['p12', 'pfx'],
    'application/x-pkcs7-certificates': ['p7b', 'spc'],
    'application/x-pkcs7-certreqresp': ['p7r'],
    'application/x-rar-compressed': ['rar'],
    'application/x-redhat-package-manager': ['rpm'],
    'application/x-research-info-systems': ['ris'],
    'application/x-sea': ['sea'],
    'application/x-sh': ['sh'],
    'application/x-shar': ['shar'],
    'application/x-shockwave-flash': ['swf'],
    'application/x-silverlight-app': ['xap'],
    'application/x-sql': ['sql'],
    'application/x-stuffit': ['sit'],
    'application/x-stuffitx': ['sitx'],
    'application/x-subrip': ['srt'],
    'application/x-sv4cpio': ['sv4cpio'],
    'application/x-sv4crc': ['sv4crc'],
    'application/x-t3vm-image': ['t3'],
    'application/x-tads': ['gam'],
    'application/x-tar': ['tar'],
    'application/x-tcl': ['tcl', 'tk'],
    'application/x-tex': ['tex'],
    'application/x-tex-tfm': ['tfm'],
    'application/x-texinfo': ['texinfo', 'texi'],
    'application/x-tgif': ['obj'],
    'application/x-ustar': ['ustar'],
    'application/x-virtualbox-hdd': ['hdd'],
    'application/x-virtualbox-ova': ['ova'],
    'application/x-virtualbox-ovf': ['ovf'],
    'application/x-virtualbox-vbox': ['vbox'],
    'application/x-virtualbox-vbox-extpack': ['vbox-extpack'],
    'application/x-virtualbox-vdi': ['vdi'],
    'application/x-virtualbox-vhd': ['vhd'],
    'application/x-virtualbox-vmdk': ['vmdk'],
    'application/x-wais-source': ['src'],
    'application/x-web-app-manifest+json': ['webapp'],
    'application/x-x509-ca-cert': ['der', 'crt', 'pem'],
    'application/x-xfig': ['fig'],
    'application/x-xliff+xml': ['xlf'],
    'application/x-xpinstall': ['xpi'],
    'application/x-xz': ['xz'],
    'application/x-zmachine': ['z1', 'z2', 'z3', 'z4', 'z5', 'z6', 'z7', 'z8'],
    'audio/vnd.dece.audio': ['uva', 'uvva'],
    'audio/vnd.digital-winds': ['eol'],
    'audio/vnd.dra': ['dra'],
    'audio/vnd.dts': ['dts'],
    'audio/vnd.dts.hd': ['dtshd'],
    'audio/vnd.lucent.voice': ['lvp'],
    'audio/vnd.ms-playready.media.pya': ['pya'],
    'audio/vnd.nuera.ecelp4800': ['ecelp4800'],
    'audio/vnd.nuera.ecelp7470': ['ecelp7470'],
    'audio/vnd.nuera.ecelp9600': ['ecelp9600'],
    'audio/vnd.rip': ['rip'],
    'audio/x-aac': ['aac'],
    'audio/x-aiff': ['aif', 'aiff', 'aifc'],
    'audio/x-caf': ['caf'],
    'audio/x-flac': ['flac'],
    'audio/x-m4a': ['*m4a'],
    'audio/x-matroska': ['mka'],
    'audio/x-mpegurl': ['m3u'],
    'audio/x-ms-wax': ['wax'],
    'audio/x-ms-wma': ['wma'],
    'audio/x-pn-realaudio': ['ram', 'ra'],
    'audio/x-pn-realaudio-plugin': ['rmp'],
    'audio/x-realaudio': ['*ra'],
    'audio/x-wav': ['*wav'],
    'chemical/x-cdx': ['cdx'],
    'chemical/x-cif': ['cif'],
    'chemical/x-cmdf': ['cmdf'],
    'chemical/x-cml': ['cml'],
    'chemical/x-csml': ['csml'],
    'chemical/x-xyz': ['xyz'],
    'image/prs.btif': ['btif'],
    'image/prs.pti': ['pti'],
    'image/vnd.adobe.photoshop': ['psd'],
    'image/vnd.airzip.accelerator.azv': ['azv'],
    'image/vnd.dece.graphic': ['uvi', 'uvvi', 'uvg', 'uvvg'],
    'image/vnd.djvu': ['djvu', 'djv'],
    'image/vnd.dvb.subtitle': ['*sub'],
    'image/vnd.dwg': ['dwg'],
    'image/vnd.dxf': ['dxf'],
    'image/vnd.fastbidsheet': ['fbs'],
    'image/vnd.fpx': ['fpx'],
    'image/vnd.fst': ['fst'],
    'image/vnd.fujixerox.edmics-mmr': ['mmr'],
    'image/vnd.fujixerox.edmics-rlc': ['rlc'],
    'image/vnd.microsoft.icon': ['ico'],
    'image/vnd.ms-modi': ['mdi'],
    'image/vnd.ms-photo': ['wdp'],
    'image/vnd.net-fpx': ['npx'],
    'image/vnd.tencent.tap': ['tap'],
    'image/vnd.valve.source.texture': ['vtf'],
    'image/vnd.wap.wbmp': ['wbmp'],
    'image/vnd.xiff': ['xif'],
    'image/vnd.zbrush.pcx': ['pcx'],
    'image/x-3ds': ['3ds'],
    'image/x-cmu-raster': ['ras'],
    'image/x-cmx': ['cmx'],
    'image/x-freehand': ['fh', 'fhc', 'fh4', 'fh5', 'fh7'],
    'image/x-icon': ['*ico'],
    'image/x-jng': ['jng'],
    'image/x-mrsid-image': ['sid'],
    'image/x-ms-bmp': ['*bmp'],
    'image/x-pcx': ['*pcx'],
    'image/x-pict': ['pic', 'pct'],
    'image/x-portable-anymap': ['pnm'],
    'image/x-portable-bitmap': ['pbm'],
    'image/x-portable-graymap': ['pgm'],
    'image/x-portable-pixmap': ['ppm'],
    'image/x-rgb': ['rgb'],
    'image/x-tga': ['tga'],
    'image/x-xbitmap': ['xbm'],
    'image/x-xpixmap': ['xpm'],
    'image/x-xwindowdump': ['xwd'],
    'message/vnd.wfa.wsc': ['wsc'],
    'model/vnd.collada+xml': ['dae'],
    'model/vnd.dwf': ['dwf'],
    'model/vnd.gdl': ['gdl'],
    'model/vnd.gtw': ['gtw'],
    'model/vnd.mts': ['mts'],
    'model/vnd.opengex': ['ogex'],
    'model/vnd.parasolid.transmit.binary': ['x_b'],
    'model/vnd.parasolid.transmit.text': ['x_t'],
    'model/vnd.usdz+zip': ['usdz'],
    'model/vnd.valve.source.compiled-map': ['bsp'],
    'model/vnd.vtu': ['vtu'],
    'text/prs.lines.tag': ['dsc'],
    'text/vnd.curl': ['curl'],
    'text/vnd.curl.dcurl': ['dcurl'],
    'text/vnd.curl.mcurl': ['mcurl'],
    'text/vnd.curl.scurl': ['scurl'],
    'text/vnd.dvb.subtitle': ['sub'],
    'text/vnd.fly': ['fly'],
    'text/vnd.fmi.flexstor': ['flx'],
    'text/vnd.graphviz': ['gv'],
    'text/vnd.in3d.3dml': ['3dml'],
    'text/vnd.in3d.spot': ['spot'],
    'text/vnd.sun.j2me.app-descriptor': ['jad'],
    'text/vnd.wap.wml': ['wml'],
    'text/vnd.wap.wmlscript': ['wmls'],
    'text/x-asm': ['s', 'asm'],
    'text/x-c': ['c', 'cc', 'cxx', 'cpp', 'h', 'hh', 'dic'],
    'text/x-component': ['htc'],
    'text/x-fortran': ['f', 'for', 'f77', 'f90'],
    'text/x-handlebars-template': ['hbs'],
    'text/x-java-source': ['java'],
    'text/x-lua': ['lua'],
    'text/x-markdown': ['mkd'],
    'text/x-nfo': ['nfo'],
    'text/x-opml': ['opml'],
    'text/x-org': ['*org'],
    'text/x-pascal': ['p', 'pas'],
    'text/x-processing': ['pde'],
    'text/x-sass': ['sass'],
    'text/x-scss': ['scss'],
    'text/x-setext': ['etx'],
    'text/x-sfv': ['sfv'],
    'text/x-suse-ymp': ['ymp'],
    'text/x-uuencode': ['uu'],
    'text/x-vcalendar': ['vcs'],
    'text/x-vcard': ['vcf'],
    'video/vnd.dece.hd': ['uvh', 'uvvh'],
    'video/vnd.dece.mobile': ['uvm', 'uvvm'],
    'video/vnd.dece.pd': ['uvp', 'uvvp'],
    'video/vnd.dece.sd': ['uvs', 'uvvs'],
    'video/vnd.dece.video': ['uvv', 'uvvv'],
    'video/vnd.dvb.file': ['dvb'],
    'video/vnd.fvt': ['fvt'],
    'video/vnd.mpegurl': ['mxu', 'm4u'],
    'video/vnd.ms-playready.media.pyv': ['pyv'],
    'video/vnd.uvvu.mp4': ['uvu', 'uvvu'],
    'video/vnd.vivo': ['viv'],
    'video/x-f4v': ['f4v'],
    'video/x-fli': ['fli'],
    'video/x-flv': ['flv'],
    'video/x-m4v': ['m4v'],
    'video/x-matroska': ['mkv', 'mk3d', 'mks'],
    'video/x-mng': ['mng'],
    'video/x-ms-asf': ['asf', 'asx'],
    'video/x-ms-vob': ['vob'],
    'video/x-ms-wm': ['wm'],
    'video/x-ms-wmv': ['wmv'],
    'video/x-ms-wmx': ['wmx'],
    'video/x-ms-wvx': ['wvx'],
    'video/x-msvideo': ['avi'],
    'video/x-sgi-movie': ['movie'],
    'video/x-smv': ['smv'],
    'x-conference/x-cooltalk': ['ice'],
    'application/x-msi': 'msi',
    'application/x-ms': 'ms',
    'application/vnd.geo+json': 'geojson',
    'application/vnd.debian.binary-package': 'deb',
    'application/font-woff': 'woff',
    'application/font-woff2': 'woff2',
    'application/x-font-ttf': ['ttc', 'ttf'],
    'font/opentype': 'otf',
    'application/x-bb-appworld': 'bbaw',
    'application/x-cd-image': 'iso',
    'application/x-opera-extension': 'oex',
    'application/x-ms-dos-executable': 'exe',
    'text/vnd.rim.location.xloc': 'xloc',
    'application/x-desktop': 'desktop',
    'application/x-typescript': 'ts',
    'application/x-java-archive': 'jar',
    'application/x-sharedlib': 'so',
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdXRpbHMvZXh0ZW5zaW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHOztBQUVVLFFBQUEsYUFBYSxHQUFHO0lBQzNCLDBCQUEwQixFQUFFLENBQUMsSUFBSSxDQUFDO0lBQ2xDLHdCQUF3QixFQUFFLENBQUMsSUFBSSxDQUFDO0lBQ2hDLHNCQUFzQixFQUFFLENBQUMsTUFBTSxDQUFDO0lBQ2hDLHlCQUF5QixFQUFFLENBQUMsU0FBUyxDQUFDO0lBQ3RDLHlCQUF5QixFQUFFLENBQUMsU0FBUyxDQUFDO0lBQ3RDLGtCQUFrQixFQUFFLENBQUMsTUFBTSxDQUFDO0lBQzVCLHVCQUF1QixFQUFFLENBQUMsT0FBTyxDQUFDO0lBQ2xDLDZCQUE2QixFQUFFLENBQUMsT0FBTyxDQUFDO0lBQ3hDLDRCQUE0QixFQUFFLENBQUMsT0FBTyxDQUFDO0lBQ3ZDLHlCQUF5QixFQUFFLENBQUMsT0FBTyxDQUFDO0lBQ3BDLHlCQUF5QixFQUFFLENBQUMsT0FBTyxDQUFDO0lBQ3BDLHdCQUF3QixFQUFFLENBQUMsT0FBTyxDQUFDO0lBQ25DLHNCQUFzQixFQUFFLENBQUMsSUFBSSxDQUFDO0lBQzlCLHNCQUFzQixFQUFFLENBQUMsS0FBSyxDQUFDO0lBQy9CLDBCQUEwQixFQUFFLENBQUMsVUFBVSxDQUFDO0lBQ3hDLHlCQUF5QixFQUFFLENBQUMsS0FBSyxDQUFDO0lBQ2xDLHNCQUFzQixFQUFFLENBQUMsTUFBTSxDQUFDO0lBQ2hDLHNCQUFzQixFQUFFLENBQUMsT0FBTyxDQUFDO0lBQ2pDLHdCQUF3QixFQUFFLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQztJQUN4QyxzQkFBc0IsRUFBRSxDQUFDLE1BQU0sQ0FBQztJQUNoQyxzQkFBc0IsRUFBRSxDQUFDLE1BQU0sQ0FBQztJQUNoQyxpQkFBaUIsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUMxQix3QkFBd0IsRUFBRSxDQUFDLEtBQUssQ0FBQztJ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QUssQ0FBQztJQUN0QyxnQ0FBZ0MsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUN6QyxpQ0FBaUMsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUMxQyw2QkFBNkIsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUN0QyxpQ0FBaUMsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUMxQyxpQ0FBaUMsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUMxQywrQkFBK0IsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUN4QyxrQ0FBa0MsRUFBRSxDQUFDLFNBQVMsQ0FBQztJQUMvQyxxQkFBcUIsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUM5Qiw2QkFBNkIsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUN0QyxvQ0FBb0MsRUFBRSxDQUFDLE9BQU8sQ0FBQztJQUMvQyxzQkFBc0IsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUMvQixzQkFBc0IsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUMvQixnQ0FBZ0MsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUN6QyxnQ0FBZ0MsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUN6QyxxQkFBcUIsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUM5Qiw0QkFBNEIsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUNyQyw0QkFBNEIsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUNyQyw0QkFBNEIsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUNyQyw0QkFBNEIsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUNyQyw0QkFBNEIsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUNyQyw0QkFBNEIsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUNyQyw0QkFBNEIsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUNyQyxvQ0FBb0MsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUM3QyxvQ0FBb0MsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUM3QyxpQ0FBaUMsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUMxQyw2QkFBNkIsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUN0QyxtQ0FBbUMsRUFBRSxDQUFDLEtBQUssQ0FBQztJ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QixFQUFFLENBQUMsS0FBSyxDQUFDO0lBQ3pCLGlCQUFpQixFQUFFLENBQUMsS0FBSyxDQUFDO0lBQzFCLG1CQUFtQixFQUFFLENBQUMsT0FBTyxDQUFDO0lBQzlCLGFBQWEsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUN0Qix5QkFBeUIsRUFBRSxDQUFDLEtBQUssQ0FBQztJQUNsQyxtQkFBbUIsRUFBRSxLQUFLO0lBQzFCLGtCQUFrQixFQUFFLElBQUk7SUFDeEIsMEJBQTBCLEVBQUUsU0FBUztJQUNyQyx1Q0FBdUMsRUFBRSxLQUFLO0lBQzlDLHVCQUF1QixFQUFFLE1BQU07SUFDL0Isd0JBQXdCLEVBQUUsT0FBTztJQUNqQyx3QkFBd0IsRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUM7SUFDeEMsZUFBZSxFQUFFLEtBQUs7SUFDdEIsMkJBQTJCLEVBQUUsTUFBTTtJQUNuQyx3QkFBd0IsRUFBRSxLQUFLO0lBQy9CLCtCQUErQixFQUFFLEtBQUs7SUFDdEMsaUNBQWlDLEVBQUUsS0FBSztJQUN4Qyw0QkFBNEIsRUFBRSxNQUFNO0lBQ3BDLHVCQUF1QixFQUFFLFNBQVM7SUFDbEMsMEJBQTBCLEVBQUUsSUFBSTtJQUNoQyw0QkFBNEIsRUFBRSxLQUFLO0lBQ25DLHlCQUF5QixFQUFFLElBQUk7Q0FDaEMsQ0FBQyIsImZpbGUiOiJsaWIvdXRpbHMvZXh0ZW5zaW9ucy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBFeHRlbnNpb25zTWFwID0ge1xuICAnYXBwbGljYXRpb24vYW5kcmV3LWluc2V0JzogWydleiddLFxuICAnYXBwbGljYXRpb24vYXBwbGl4d2FyZSc6IFsnYXcnXSxcbiAgJ2FwcGxpY2F0aW9uL2F0b20reG1sJzogWydhdG9tJ10sXG4gICdhcHBsaWNhdGlvbi9hdG9tY2F0K3htbCc6IFsnYXRvbWNhdCddLFxuICAnYXBwbGljYXRpb24vYXRvbXN2Yyt4bWwnOiBbJ2F0b21zdmMnXSxcbiAgJ2FwcGxpY2F0aW9uL2Jkb2MnOiBbJ2Jkb2MnXSxcbiAgJ2FwcGxpY2F0aW9uL2NjeG1sK3htbCc6IFsnY2N4bWwnXSxcbiAgJ2FwcGxpY2F0aW9uL2NkbWktY2FwYWJpbGl0eSc6IFsnY2RtaWEnXSxcbiAgJ2FwcGxpY2F0aW9uL2NkbWktY29udGFpbmVyJzogWydjZG1pYyddLFxuICAnYXBwbGljYXRpb24vY2RtaS1kb21haW4nOiBbJ2NkbWlkJ10sXG4gICdhcHBsaWNhdGlvbi9jZG1pLW9iamVjdCc6IFsnY2RtaW8nXSxcbiAgJ2FwcGxpY2F0aW9uL2NkbWktcXVldWUnOiBbJ2NkbWlxJ10sXG4gICdhcHBsaWNhdGlvbi9jdS1zZWVtZSc6IFsnY3UnXSxcbiAgJ2FwcGxpY2F0aW9uL2Rhc2greG1sJzogWydtcGQnXSxcbiAgJ2FwcGxpY2F0aW9uL2Rhdm1vdW50K3htbCc6IFsnZGF2bW91bnQnXSxcbiAgJ2FwcGxpY2F0aW9uL2RvY2Jvb2sreG1sJzogWydkYmsnXSxcbiAgJ2FwcGxpY2F0aW9uL2Rzc2MrZGVyJzogWydkc3NjJ10sXG4gICdhcHBsaWNhdGlvbi9kc3NjK3htbCc6IFsneGRzc2MnXSxcbiAgJ2FwcGxpY2F0aW9uL2VjbWFzY3JpcHQnOiBbJ2VjbWEnLCAnZXMnXSxcbiAgJ2FwcGxpY2F0aW9uL2VtbWEreG1sJzogWydlbW1hJ10sXG4gICdhcHBsaWNhdGlvbi9lcHViK3ppcCc6IFsnZXB1YiddLFxuICAnYXBwbGljYXRpb24vZXhpJzogWydleGknXSxcbiAgJ2FwcGxpY2F0aW9uL2ZvbnQtdGRwZnInOiBbJ3BmciddLFxuICAnYXBwbGljYXRpb24vZ2VvK2pzb24nOiBbJ2dlb2pzb24nXSxcbiAgJ2FwcGxpY2F0aW9uL2dtbCt4bWwnOiBbJ2dtbCddLFxuICAnYXBwbGljYXRpb24vZ3B4K3htbCc6IFsnZ3B4J10sXG4gICdhcHBsaWNhdGlvbi9neGYnOiBbJ2d4ZiddLFxuICAnYXBwbGljYXRpb24vZ3ppcCc6IFsnZ3onXSxcbiAgJ2FwcGxpY2F0aW9uL2hqc29uJzogWydoanNvbiddLFxuICAnYXBwbGljYXRpb24vaHlwZXJzdHVkaW8nOiBbJ3N0ayddLFxuICAnYXBwbGljYXRpb24vaW5rbWwreG1sJzogWydpbmsnLCAnaW5rbWwnXSxcbiAgJ2FwcGxpY2F0aW9uL2lwZml4JzogWydpcGZpeCddLFxuICAnYXBwbGljYXRpb24vamF2YS1hcmNoaXZlJzogWydqYXInLCAnd2FyJywgJ2VhciddLFxuICAnYXBwbGljYXRpb24vamF2YS1zZXJpYWxpemVkLW9iamVjdCc6IFsnc2VyJ10sXG4gICdhcHBsaWNhdGlvbi9qYXZhLXZtJzogWydjbGFzcyddLFxuICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6IFsnanMnLCAnbWpzJ10sXG4gICdhcHBsaWNhdGlvbi9qc29uJzogWydqc29uJywgJ21hcCddLFxuICAnYXBwbGljYXRpb24vanNvbjUnOiBbJ2pzb241J10sXG4gICdhcHBsaWNhdGlvbi9qc29ubWwranNvbic6IFsnanNvbm1sJ10sXG4gICdhcHBsaWNhdGlvbi9sZCtqc29uJzogWydqc29ubGQnXSxcbiAgJ2FwcGxpY2F0aW9uL2xvc3QreG1sJzogWydsb3N0eG1sJ10sXG4gICdhcHBsaWNhdGlvbi9tYWMtYmluaGV4NDAnOiBbJ2hxeCddLFxuICAnYXBwbGljYXRpb24vbWFjLWNvbXBhY3Rwcm8nOiBbJ2NwdCddLFxuICAnYXBwbGljYXRpb24vbWFkcyt4bWwnOiBbJ21hZHMnXSxcbiAgJ2FwcGxpY2F0aW9uL21hbmlmZXN0K2pzb24nOiBbJ3dlYm1hbmlmZXN0J10sXG4gICdhcHBsaWNhdGlvbi9tYXJjJzogWydtcmMnXSxcbiAgJ2FwcGxpY2F0aW9uL21hcmN4bWwreG1sJzogWydtcmN4J10sXG4gICdhcHBsaWNhdGlvbi9tYXRoZW1hdGljYSc6IFsnbWEnLCAnbmInLCAnbWInXSxcbiAgJ2FwcGxpY2F0aW9uL21hdGhtbCt4bWwnOiBbJ21hdGhtbCddLFxuICAnYXBwbGljYXRpb24vbWJveCc6IFsnbWJveCddLFxuICAnYXBwbGljYXRpb24vbWVkaWFzZXJ2ZXJjb250cm9sK3htbCc6IFsnbXNjbWwnXSxcbiAgJ2FwcGxpY2F0aW9uL21ldGFsaW5rK3htbCc6IFsnbWV0YWxpbmsnXSxcbiAgJ2FwcGxpY2F0aW9uL21ldGFsaW5rNCt4bWwnOiBbJ21ldGE0J10sXG4gICdhcHBsaWNhdGlvbi9tZXRzK3htbCc6IFsnbWV0cyddLFxuICAnYXBwbGljYXRpb24vbW9kcyt4bWwnOiBbJ21vZHMnXSxcbiAgJ2FwcGxpY2F0aW9uL21wMjEnOiBbJ20yMScsICdtcDIxJ10sXG4gICdhcHBsaWNhdGlvbi9tcDQnOiBbJ21wNHMnLCAnbTRwJ10sXG4gICdhcHBsaWNhdGlvbi9tc3dvcmQnOiBbJ2RvYycsICdkb3QnXSxcbiAgJ2FwcGxpY2F0aW9uL214Zic6IFsnbXhmJ10sXG4gICdhcHBsaWNhdGlvbi9uLXF1YWRzJzogWyducSddLFxuICAnYXBwbGljYXRpb24vbi10cmlwbGVzJzogWydudCddLFxuICAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJzogW1xuICAgICdiaW4nLFxuICAgICdkbXMnLFxuICAgICdscmYnLFxuICAgICdtYXInLFxuICAgICdzbycsXG4gICAgJ2Rpc3QnLFxuICAgICdkaXN0eicsXG4gICAgJ3BrZycsXG4gICAgJ2JwaycsXG4gICAgJ2R1bXAnLFxuICAgICdlbGMnLFxuICAgICdkZXBsb3knLFxuICAgICdleGUnLFxuICAgICdkbGwnLFxuICAgICdkZWInLFxuICAgICdkbWcnLFxuICAgICdpc28nLFxuICAgICdtc3AnLFxuICAgICdidWZmZXInLFxuICBdLFxuICAnYXBwbGljYXRpb24vb2RhJzogWydvZGEnXSxcbiAgJ2FwcGxpY2F0aW9uL29lYnBzLXBhY2thZ2UreG1sJzogWydvcGYnXSxcbiAgJ2FwcGxpY2F0aW9uL29nZyc6IFsnb2d4J10sXG4gICdhcHBsaWNhdGlvbi9vbWRvYyt4bWwnOiBbJ29tZG9jJ10sXG4gICdhcHBsaWNhdGlvbi9vbmVub3RlJzogWydvbmV0b2MnLCAnb25ldG9jMicsICdvbmV0bXAnLCAnb25lcGtnJ10sXG4gICdhcHBsaWNhdGlvbi9veHBzJzogWydveHBzJ10sXG4gICdhcHBsaWNhdGlvbi9wYXRjaC1vcHMtZXJyb3IreG1sJzogWyd4ZXInXSxcbiAgJ2FwcGxpY2F0aW9uL3BkZic6IFsncGRmJ10sXG4gICdhcHBsaWNhdGlvbi9wZ3AtZW5jcnlwdGVkJzogWydwZ3AnXSxcbiAgJ2FwcGxpY2F0aW9uL3BncC1zaWduYXR1cmUnOiBbJ2FzYycsICdzaWcnXSxcbiAgJ2FwcGxpY2F0aW9uL3BpY3MtcnVsZXMnOiBbJ3ByZiddLFxuICAnYXBwbGljYXRpb24vcGtjczEwJzogWydwMTAnXSxcbiAgJ2FwcGxpY2F0aW9uL3BrY3M3LW1pbWUnOiBbJ3A3bScsICdwN2MnXSxcbiAgJ2FwcGxpY2F0aW9uL3BrY3M3LXNpZ25hdHVyZSc6IFsncDdzJ10sXG4gICdhcHBsaWNhdGlvbi9wa2NzOCc6IFsncDgnXSxcbiAgJ2FwcGxpY2F0aW9uL3BraXgtYXR0ci1jZXJ0JzogWydhYyddLFxuICAnYXBwbGljYXRpb24vcGtpeC1jZXJ0JzogWydjZXInXSxcbiAgJ2FwcGxpY2F0aW9uL3BraXgtY3JsJzogWydjcmwnXSxcbiAgJ2FwcGxpY2F0aW9uL3BraXgtcGtpcGF0aCc6IFsncGtpcGF0aCddLFxuICAnYXBwbGljYXRpb24vcGtpeGNtcCc6IFsncGtpJ10sXG4gICdhcHBsaWNhdGlvbi9wbHMreG1sJzogWydwbHMnXSxcbiAgJ2FwcGxpY2F0aW9uL3Bvc3RzY3JpcHQnOiBbJ2FpJywgJ2VwcycsICdwcyddLFxuICAnYXBwbGljYXRpb24vcHNrYyt4bWwnOiBbJ3Bza2N4bWwnXSxcbiAgJ2FwcGxpY2F0aW9uL3JhbWwreWFtbCc6IFsncmFtbCddLFxuICAnYXBwbGljYXRpb24vcmRmK3htbCc6IFsncmRmJywgJ293bCddLFxuICAnYXBwbGljYXRpb24vcmVnaW5mbyt4bWwnOiBbJ3JpZiddLFxuICAnYXBwbGljYXRpb24vcmVsYXgtbmctY29tcGFjdC1zeW50YXgnOiBbJ3JuYyddLFxuICAnYXBwbGljYXRpb24vcmVzb3VyY2UtbGlzdHMreG1sJzogWydybCddLFxuICAnYXBwbGljYXRpb24vcmVzb3VyY2UtbGlzdHMtZGlmZit4bWwnOiBbJ3JsZCddLFxuICAnYXBwbGljYXRpb24vcmxzLXNlcnZpY2VzK3htbCc6IFsncnMnXSxcbiAgJ2FwcGxpY2F0aW9uL3Jwa2ktZ2hvc3RidXN0ZXJzJzogWydnYnInXSxcbiAgJ2FwcGxpY2F0aW9uL3Jwa2ktbWFuaWZlc3QnOiBbJ21mdCddLFxuICAnYXBwbGljYXRpb24vcnBraS1yb2EnOiBbJ3JvYSddLFxuICAnYXBwbGljYXRpb24vcnNkK3htbCc6IFsncnNkJ10sXG4gICdhcHBsaWNhdGlvbi9yc3MreG1sJzogWydyc3MnXSxcbiAgJ2FwcGxpY2F0aW9uL3J0Zic6IFsncnRmJ10sXG4gICdhcHBsaWNhdGlvbi9zYm1sK3htbCc6IFsnc2JtbCddLFxuICAnYXBwbGljYXRpb24vc2N2cC1jdi1yZXF1ZXN0JzogWydzY3EnXSxcbiAgJ2FwcGxpY2F0aW9uL3NjdnAtY3YtcmVzcG9uc2UnOiBbJ3NjcyddLFxuICAnYXBwbGljYXRpb24vc2N2cC12cC1yZXF1ZXN0JzogWydzcHEnXSxcbiAgJ2FwcGxpY2F0aW9uL3NjdnAtdnAtcmVzcG9uc2UnOiBbJ3NwcCddLFxuICAnYXBwbGljYXRpb24vc2RwJzogWydzZHAnXSxcbiAgJ2FwcGxpY2F0aW9uL3NldC1wYXltZW50LWluaXRpYXRpb24nOiBbJ3NldHBheSddLFxuICAnYXBwbGljYXRpb24vc2V0LXJlZ2lzdHJhdGlvbi1pbml0aWF0aW9uJzogWydzZXRyZWcnXSxcbiAgJ2FwcGxpY2F0aW9uL3NoZit4bWwnOiBbJ3NoZiddLFxuICAnYXBwbGljYXRpb24vc2lldmUnOiBbJ3NpdicsICdzaWV2ZSddLFxuICAnYXBwbGljYXRpb24vc21pbCt4bWwnOiBbJ3NtaScsICdzbWlsJ10sXG4gICdhcHBsaWNhdGlvbi9zcGFycWwtcXVlcnknOiBbJ3JxJ10sXG4gICdhcHBsaWNhdGlvbi9zcGFycWwtcmVzdWx0cyt4bWwnOiBbJ3NyeCddLFxuICAnYXBwbGljYXRpb24vc3Jncyc6IFsnZ3JhbSddLFxuICAnYXBwbGljYXRpb24vc3Jncyt4bWwnOiBbJ2dyeG1sJ10sXG4gICdhcHBsaWNhdGlvbi9zcnUreG1sJzogWydzcnUnXSxcbiAgJ2FwcGxpY2F0aW9uL3NzZGwreG1sJzogWydzc2RsJ10sXG4gICdhcHBsaWNhdGlvbi9zc21sK3htbCc6IFsnc3NtbCddLFxuICAnYXBwbGljYXRpb24vdGVpK3htbCc6IFsndGVpJywgJ3RlaWNvcnB1cyddLFxuICAnYXBwbGljYXRpb24vdGhyYXVkK3htbCc6IFsndGZpJ10sXG4gICdhcHBsaWNhdGlvbi90aW1lc3RhbXBlZC1kYXRhJzogWyd0c2QnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZvaWNleG1sK3htbCc6IFsndnhtbCddLFxuICAnYXBwbGljYXRpb24vd2FzbSc6IFsnd2FzbSddLFxuICAnYXBwbGljYXRpb24vd2lkZ2V0JzogWyd3Z3QnXSxcbiAgJ2FwcGxpY2F0aW9uL3dpbmhscCc6IFsnaGxwJ10sXG4gICdhcHBsaWNhdGlvbi93c2RsK3htbCc6IFsnd3NkbCddLFxuICAnYXBwbGljYXRpb24vd3Nwb2xpY3kreG1sJzogWyd3c3BvbGljeSddLFxuICAnYXBwbGljYXRpb24veGFtbCt4bWwnOiBbJ3hhbWwnXSxcbiAgJ2FwcGxpY2F0aW9uL3hjYXAtZGlmZit4bWwnOiBbJ3hkZiddLFxuICAnYXBwbGljYXRpb24veGVuYyt4bWwnOiBbJ3hlbmMnXSxcbiAgJ2FwcGxpY2F0aW9uL3hodG1sK3htbCc6IFsneGh0bWwnLCAneGh0J10sXG4gICdhcHBsaWNhdGlvbi94bWwnOiBbJ3htbCcsICd4c2wnLCAneHNkJywgJ3JuZyddLFxuICAnYXBwbGljYXRpb24veG1sLWR0ZCc6IFsnZHRkJ10sXG4gICdhcHBsaWNhdGlvbi94b3AreG1sJzogWyd4b3AnXSxcbiAgJ2FwcGxpY2F0aW9uL3hwcm9jK3htbCc6IFsneHBsJ10sXG4gICdhcHBsaWNhdGlvbi94c2x0K3htbCc6IFsneHNsdCddLFxuICAnYXBwbGljYXRpb24veHNwZit4bWwnOiBbJ3hzcGYnXSxcbiAgJ2FwcGxpY2F0aW9uL3h2K3htbCc6IFsnbXhtbCcsICd4aHZtbCcsICd4dm1sJywgJ3h2bSddLFxuICAnYXBwbGljYXRpb24veWFuZyc6IFsneWFuZyddLFxuICAnYXBwbGljYXRpb24veWluK3htbCc6IFsneWluJ10sXG4gICdhcHBsaWNhdGlvbi96aXAnOiBbJ3ppcCddLFxuICAnYXVkaW8vM2dwcCc6IFsnKjNncHAnXSxcbiAgJ2F1ZGlvL2FkcGNtJzogWydhZHAnXSxcbiAgJ2F1ZGlvL2Jhc2ljJzogWydhdScsICdzbmQnXSxcbiAgJ2F1ZGlvL21pZGknOiBbJ21pZCcsICdtaWRpJywgJ2thcicsICdybWknXSxcbiAgJ2F1ZGlvL21wMyc6IFsnKm1wMyddLFxuICAnYXVkaW8vbXA0JzogWydtNGEnLCAnbXA0YSddLFxuICAnYXVkaW8vbXBlZyc6IFsnbXBnYScsICdtcDInLCAnbXAyYScsICdtcDMnLCAnbTJhJywgJ20zYSddLFxuICAnYXVkaW8vb2dnJzogWydvZ2EnLCAnb2dnJywgJ3NweCddLFxuICAnYXVkaW8vczNtJzogWydzM20nXSxcbiAgJ2F1ZGlvL3NpbGsnOiBbJ3NpbCddLFxuICAnYXVkaW8vd2F2JzogWyd3YXYnXSxcbiAgJ2F1ZGlvL3dhdmUnOiBbJyp3YXYnXSxcbiAgJ2F1ZGlvL3dlYm0nOiBbJ3dlYmEnXSxcbiAgJ2F1ZGlvL3htJzogWyd4bSddLFxuICAnZm9udC9jb2xsZWN0aW9uJzogWyd0dGMnXSxcbiAgJ2ZvbnQvb3RmJzogWydvdGYnXSxcbiAgJ2ZvbnQvdHRmJzogWyd0dGYnXSxcbiAgJ2ZvbnQvd29mZic6IFsnd29mZiddLFxuICAnZm9udC93b2ZmMic6IFsnd29mZjInXSxcbiAgJ2ltYWdlL2FjZXMnOiBbJ2V4ciddLFxuICAnaW1hZ2UvYXBuZyc6IFsnYXBuZyddLFxuICAnaW1hZ2UvYm1wJzogWydibXAnXSxcbiAgJ2ltYWdlL2NnbSc6IFsnY2dtJ10sXG4gICdpbWFnZS9kaWNvbS1ybGUnOiBbJ2RybGUnXSxcbiAgJ2ltYWdlL2VtZic6IFsnZW1mJ10sXG4gICdpbWFnZS9maXRzJzogWydmaXRzJ10sXG4gICdpbWFnZS9nM2ZheCc6IFsnZzMnXSxcbiAgJ2ltYWdlL2dpZic6IFsnZ2lmJ10sXG4gICdpbWFnZS9oZWljJzogWydoZWljJ10sXG4gICdpbWFnZS9oZWljLXNlcXVlbmNlJzogWydoZWljcyddLFxuICAnaW1hZ2UvaGVpZic6IFsnaGVpZiddLFxuICAnaW1hZ2UvaGVpZi1zZXF1ZW5jZSc6IFsnaGVpZnMnXSxcbiAgJ2ltYWdlL2llZic6IFsnaWVmJ10sXG4gICdpbWFnZS9qbHMnOiBbJ2pscyddLFxuICAnaW1hZ2UvanAyJzogWydqcDInLCAnanBnMiddLFxuICAnaW1hZ2UvanBlZyc6IFsnanBlZycsICdqcGcnLCAnanBlJ10sXG4gICdpbWFnZS9qcG0nOiBbJ2pwbSddLFxuICAnaW1hZ2UvanB4JzogWydqcHgnLCAnanBmJ10sXG4gICdpbWFnZS9qeHInOiBbJ2p4ciddLFxuICAnaW1hZ2Uva3R4JzogWydrdHgnXSxcbiAgJ2ltYWdlL3BuZyc6IFsncG5nJ10sXG4gICdpbWFnZS9zZ2knOiBbJ3NnaSddLFxuICAnaW1hZ2Uvc3ZnK3htbCc6IFsnc3ZnJywgJ3N2Z3onXSxcbiAgJ2ltYWdlL3QzOCc6IFsndDM4J10sXG4gICdpbWFnZS90aWZmJzogWyd0aWYnLCAndGlmZiddLFxuICAnaW1hZ2UvdGlmZi1meCc6IFsndGZ4J10sXG4gICdpbWFnZS93ZWJwJzogWyd3ZWJwJ10sXG4gICdpbWFnZS93bWYnOiBbJ3dtZiddLFxuICAnbWVzc2FnZS9kaXNwb3NpdGlvbi1ub3RpZmljYXRpb24nOiBbJ2Rpc3Bvc2l0aW9uLW5vdGlmaWNhdGlvbiddLFxuICAnbWVzc2FnZS9nbG9iYWwnOiBbJ3U4bXNnJ10sXG4gICdtZXNzYWdlL2dsb2JhbC1kZWxpdmVyeS1zdGF0dXMnOiBbJ3U4ZHNuJ10sXG4gICdtZXNzYWdlL2dsb2JhbC1kaXNwb3NpdGlvbi1ub3RpZmljYXRpb24nOiBbJ3U4bWRuJ10sXG4gICdtZXNzYWdlL2dsb2JhbC1oZWFkZXJzJzogWyd1OGhkciddLFxuICAnbWVzc2FnZS9yZmM4MjInOiBbJ2VtbCcsICdtaW1lJ10sXG4gICdtb2RlbC8zbWYnOiBbJzNtZiddLFxuICAnbW9kZWwvZ2x0Zitqc29uJzogWydnbHRmJ10sXG4gICdtb2RlbC9nbHRmLWJpbmFyeSc6IFsnZ2xiJ10sXG4gICdtb2RlbC9pZ2VzJzogWydpZ3MnLCAnaWdlcyddLFxuICAnbW9kZWwvbWVzaCc6IFsnbXNoJywgJ21lc2gnLCAnc2lsbyddLFxuICAnbW9kZWwvc3RsJzogWydzdGwnXSxcbiAgJ21vZGVsL3ZybWwnOiBbJ3dybCcsICd2cm1sJ10sXG4gICdtb2RlbC94M2QrYmluYXJ5JzogWycqeDNkYicsICd4M2RieiddLFxuICAnbW9kZWwveDNkK2Zhc3RpbmZvc2V0JzogWyd4M2RiJ10sXG4gICdtb2RlbC94M2QrdnJtbCc6IFsnKngzZHYnLCAneDNkdnonXSxcbiAgJ21vZGVsL3gzZCt4bWwnOiBbJ3gzZCcsICd4M2R6J10sXG4gICdtb2RlbC94M2QtdnJtbCc6IFsneDNkdiddLFxuICAndGV4dC9jYWNoZS1tYW5pZmVzdCc6IFsnYXBwY2FjaGUnLCAnbWFuaWZlc3QnXSxcbiAgJ3RleHQvY2FsZW5kYXInOiBbJ2ljcycsICdpZmInXSxcbiAgJ3RleHQvY29mZmVlc2NyaXB0JzogWydjb2ZmZWUnLCAnbGl0Y29mZmVlJ10sXG4gICd0ZXh0L2Nzcyc6IFsnY3NzJ10sXG4gICd0ZXh0L2Nzdic6IFsnY3N2J10sXG4gICd0ZXh0L2h0bWwnOiBbJ2h0bWwnLCAnaHRtJywgJ3NodG1sJ10sXG4gICd0ZXh0L2phZGUnOiBbJ2phZGUnXSxcbiAgJ3RleHQvanN4JzogWydqc3gnXSxcbiAgJ3RleHQvbGVzcyc6IFsnbGVzcyddLFxuICAndGV4dC9tYXJrZG93bic6IFsnbWFya2Rvd24nLCAnbWQnXSxcbiAgJ3RleHQvbWF0aG1sJzogWydtbWwnXSxcbiAgJ3RleHQvbWR4JzogWydtZHgnXSxcbiAgJ3RleHQvbjMnOiBbJ24zJ10sXG4gICd0ZXh0L3BsYWluJzogWyd0eHQnLCAndGV4dCcsICdjb25mJywgJ2RlZicsICdsaXN0JywgJ2xvZycsICdpbicsICdpbmknXSxcbiAgJ3RleHQvcmljaHRleHQnOiBbJ3J0eCddLFxuICAnYXBwbGljYXRpb24vZm9udC10dGYnOiAndHRmJyxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1mb250b2JqZWN0JzogJ2VvdCcsXG4gICdhcHBsaWNhdGlvbi9mb250LW90Zic6ICdvdGYnLFxuICAndGV4dC9ydGYnOiBbJypydGYnXSxcbiAgJ3RleHQvc2dtbCc6IFsnc2dtbCcsICdzZ20nXSxcbiAgJ3RleHQvc2hleCc6IFsnc2hleCddLFxuICAndGV4dC9zbGltJzogWydzbGltJywgJ3NsbSddLFxuICAndGV4dC9zdHlsdXMnOiBbJ3N0eWx1cycsICdzdHlsJ10sXG4gICd0ZXh0L3RhYi1zZXBhcmF0ZWQtdmFsdWVzJzogWyd0c3YnXSxcbiAgJ3RleHQvdHJvZmYnOiBbJ3QnLCAndHInLCAncm9mZicsICdtYW4nLCAnbWUnLCAnbXMnXSxcbiAgJ3RleHQvdHVydGxlJzogWyd0dGwnXSxcbiAgJ3RleHQvdXJpLWxpc3QnOiBbJ3VyaScsICd1cmlzJywgJ3VybHMnXSxcbiAgJ3RleHQvdmNhcmQnOiBbJ3ZjYXJkJywgJ3ZjciddLFxuICAndGV4dC92dHQnOiBbJ3Z0dCddLFxuICAndGV4dC94bWwnOiBbJyp4bWwnXSxcbiAgJ3RleHQveWFtbCc6IFsneWFtbCcsICd5bWwnXSxcbiAgJ3ZpZGVvLzNncHAnOiBbJzNncCcsICczZ3BwJ10sXG4gICd2aWRlby8zZ3BwMic6IFsnM2cyJ10sXG4gICd2aWRlby9oMjYxJzogWydoMjYxJ10sXG4gICd2aWRlby9oMjYzJzogWydoMjYzJ10sXG4gICd2aWRlby9oMjY0JzogWydoMjY0J10sXG4gICd2aWRlby9qcGVnJzogWydqcGd2J10sXG4gICd2aWRlby9qcG0nOiBbJypqcG0nLCAnanBnbSddLFxuICAndmlkZW8vbWoyJzogWydtajInLCAnbWpwMiddLFxuICAndmlkZW8vbXAydCc6IFsndHMnXSxcbiAgJ3ZpZGVvL21wNCc6IFsnbXA0JywgJ21wNHYnLCAnbXBnNCddLFxuICAndmlkZW8vbXBlZyc6IFsnbXBlZycsICdtcGcnLCAnbXBlJywgJ20xdicsICdtMnYnXSxcbiAgJ3ZpZGVvL29nZyc6IFsnb2d2J10sXG4gICd2aWRlby9xdWlja3RpbWUnOiBbJ3F0JywgJ21vdiddLFxuICAndmlkZW8vd2VibSc6IFsnd2VibSddLFxuICAnYXBwbGljYXRpb24vcHJzLmN3dyc6IFsnY3d3J10sXG4gICdhcHBsaWNhdGlvbi92bmQuM2dwcC5waWMtYnctbGFyZ2UnOiBbJ3BsYiddLFxuICAnYXBwbGljYXRpb24vdm5kLjNncHAucGljLWJ3LXNtYWxsJzogWydwc2InXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC4zZ3BwLnBpYy1idy12YXInOiBbJ3B2YiddLFxuICAnYXBwbGljYXRpb24vdm5kLjNncHAyLnRjYXAnOiBbJ3RjYXAnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC4zbS5wb3N0LWl0LW5vdGVzJzogWydwd24nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5hY2NwYWMuc2ltcGx5LmFzbyc6IFsnYXNvJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuYWNjcGFjLnNpbXBseS5pbXAnOiBbJ2ltcCddLFxuICAnYXBwbGljYXRpb24vdm5kLmFjdWNvYm9sJzogWydhY3UnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5hY3Vjb3JwJzogWydhdGMnLCAnYWN1dGMnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5hZG9iZS5haXItYXBwbGljYXRpb24taW5zdGFsbGVyLXBhY2thZ2UremlwJzogWydhaXInXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5hZG9iZS5mb3Jtc2NlbnRyYWwuZmNkdCc6IFsnZmNkdCddLFxuICAnYXBwbGljYXRpb24vdm5kLmFkb2JlLmZ4cCc6IFsnZnhwJywgJ2Z4cGwnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5hZG9iZS54ZHAreG1sJzogWyd4ZHAnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5hZG9iZS54ZmRmJzogWyd4ZmRmJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuYWhlYWQuc3BhY2UnOiBbJ2FoZWFkJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuYWlyemlwLmZpbGVzZWN1cmUuYXpmJzogWydhemYnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5haXJ6aXAuZmlsZXNlY3VyZS5henMnOiBbJ2F6cyddLFxuICAnYXBwbGljYXRpb24vdm5kLmFtYXpvbi5lYm9vayc6IFsnYXp3J10sXG4gICdhcHBsaWNhdGlvbi92bmQuYW1lcmljYW5keW5hbWljcy5hY2MnOiBbJ2FjYyddLFxuICAnYXBwbGljYXRpb24vdm5kLmFtaWdhLmFtaSc6IFsnYW1pJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuYW5kcm9pZC5wYWNrYWdlLWFyY2hpdmUnOiBbJ2FwayddLFxuICAnYXBwbGljYXRpb24vdm5kLmFuc2VyLXdlYi1jZXJ0aWZpY2F0ZS1pc3N1ZS1pbml0aWF0aW9uJzogWydjaWknXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5hbnNlci13ZWItZnVuZHMtdHJhbnNmZXItaW5pdGlhdGlvbic6IFsnZnRpJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuYW50aXguZ2FtZS1jb21wb25lbnQnOiBbJ2F0eCddLFxuICAnYXBwbGljYXRpb24vdm5kLmFwcGxlLmluc3RhbGxlcit4bWwnOiBbJ21wa2cnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5rZXlub3RlJzogWydrZXlub3RlJywgJ2tleSddLFxuICAnYXBwbGljYXRpb24vdm5kLmFwcGxlLm1wZWd1cmwnOiBbJ20zdTgnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5udW1iZXJzJzogWydudW1iZXJzJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuYXBwbGUucGFnZXMnOiBbJ3BhZ2VzJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuYXBwbGUua2V5JzogWydrZXknXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5wa3Bhc3MnOiBbJ3BrcGFzcyddLFxuICAnYXBwbGljYXRpb24vdm5kLmFyaXN0YW5ldHdvcmtzLnN3aSc6IFsnc3dpJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuYXN0cmFlYS1zb2Z0d2FyZS5pb3RhJzogWydpb3RhJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuYXVkaW9ncmFwaCc6IFsnYWVwJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuYmx1ZWljZS5tdWx0aXBhc3MnOiBbJ21wbSddLFxuICAnYXBwbGljYXRpb24vdm5kLmJtaSc6IFsnYm1pJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuYnVzaW5lc3NvYmplY3RzJzogWydyZXAnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5jaGVtZHJhdyt4bWwnOiBbJ2NkeG1sJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuY2hpcG51dHMua2FyYW9rZS1tbWQnOiBbJ21tZCddLFxuICAnYXBwbGljYXRpb24vdm5kLmNpbmRlcmVsbGEnOiBbJ2NkeSddLFxuICAnYXBwbGljYXRpb24vdm5kLmNpdGF0aW9uc3R5bGVzLnN0eWxlK3htbCc6IFsnY3NsJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuY2xheW1vcmUnOiBbJ2NsYSddLFxuICAnYXBwbGljYXRpb24vdm5kLmNsb2FudG8ucnA5JzogWydycDknXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5jbG9uay5jNGdyb3VwJzogWydjNGcnLCAnYzRkJywgJ2M0ZicsICdjNHAnLCAnYzR1J10sXG4gICdhcHBsaWNhdGlvbi92bmQuY2x1ZXRydXN0LmNhcnRvbW9iaWxlLWNvbmZpZyc6IFsnYzExYW1jJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuY2x1ZXRydXN0LmNhcnRvbW9iaWxlLWNvbmZpZy1wa2cnOiBbJ2MxMWFteiddLFxuICAnYXBwbGljYXRpb24vdm5kLmNvbW1vbnNwYWNlJzogWydjc3AnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5jb250YWN0LmNtc2cnOiBbJ2NkYmNtc2cnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5jb3Ntb2NhbGxlcic6IFsnY21jJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuY3JpY2suY2xpY2tlcic6IFsnY2xreCddLFxuICAnYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXIua2V5Ym9hcmQnOiBbJ2Nsa2snXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLnBhbGV0dGUnOiBbJ2Nsa3AnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLnRlbXBsYXRlJzogWydjbGt0J10sXG4gICdhcHBsaWNhdGlvbi92bmQuY3JpY2suY2xpY2tlci53b3JkYmFuayc6IFsnY2xrdyddLFxuICAnYXBwbGljYXRpb24vdm5kLmNyaXRpY2FsdG9vbHMud2JzK3htbCc6IFsnd2JzJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuY3RjLXBvc21sJzogWydwbWwnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5jdXBzLXBwZCc6IFsncHBkJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuY3VybC5jYXInOiBbJ2NhciddLFxuICAnYXBwbGljYXRpb24vdm5kLmN1cmwucGN1cmwnOiBbJ3BjdXJsJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZGFydCc6IFsnZGFydCddLFxuICAnYXBwbGljYXRpb24vdm5kLmRhdGEtdmlzaW9uLnJkeic6IFsncmR6J10sXG4gICdhcHBsaWNhdGlvbi92bmQuZGVjZS5kYXRhJzogWyd1dmYnLCAndXZ2ZicsICd1dmQnLCAndXZ2ZCddLFxuICAnYXBwbGljYXRpb24vdm5kLmRlY2UudHRtbCt4bWwnOiBbJ3V2dCcsICd1dnZ0J10sXG4gICdhcHBsaWNhdGlvbi92bmQuZGVjZS51bnNwZWNpZmllZCc6IFsndXZ4JywgJ3V2dngnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5kZWNlLnppcCc6IFsndXZ6JywgJ3V2dnonXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5kZW5vdm8uZmNzZWxheW91dC1saW5rJzogWydmZV9sYXVuY2gnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5kbmEnOiBbJ2RuYSddLFxuICAnYXBwbGljYXRpb24vdm5kLmRvbGJ5Lm1scCc6IFsnbWxwJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZHBncmFwaCc6IFsnZHBnJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZHJlYW1mYWN0b3J5JzogWydkZmFjJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZHMta2V5cG9pbnQnOiBbJ2tweHgnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5kdmIuYWl0JzogWydhaXQnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5kdmIuc2VydmljZSc6IFsnc3ZjJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZHluYWdlbyc6IFsnZ2VvJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZWNvd2luLmNoYXJ0JzogWydtYWcnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5lbmxpdmVuJzogWydubWwnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5lcHNvbi5lc2YnOiBbJ2VzZiddLFxuICAnYXBwbGljYXRpb24vdm5kLmVwc29uLm1zZic6IFsnbXNmJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZXBzb24ucXVpY2thbmltZSc6IFsncWFtJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZXBzb24uc2FsdCc6IFsnc2x0J10sXG4gICdhcHBsaWNhdGlvbi92bmQuZXBzb24uc3NmJzogWydzc2YnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5lc3ppZ25vMyt4bWwnOiBbJ2VzMycsICdldDMnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5lenBpeC1hbGJ1bSc6IFsnZXoyJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZXpwaXgtcGFja2FnZSc6IFsnZXozJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZmRmJzogWydmZGYnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5mZHNuLm1zZWVkJzogWydtc2VlZCddLFxuICAnYXBwbGljYXRpb24vdm5kLmZkc24uc2VlZCc6IFsnc2VlZCcsICdkYXRhbGVzcyddLFxuICAnYXBwbGljYXRpb24vdm5kLmZsb2dyYXBoaXQnOiBbJ2dwaCddLFxuICAnYXBwbGljYXRpb24vdm5kLmZsdXh0aW1lLmNsaXAnOiBbJ2Z0YyddLFxuICAnYXBwbGljYXRpb24vdm5kLmZyYW1lbWFrZXInOiBbJ2ZtJywgJ2ZyYW1lJywgJ21ha2VyJywgJ2Jvb2snXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5mcm9nYW5zLmZuYyc6IFsnZm5jJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZnJvZ2Fucy5sdGYnOiBbJ2x0ZiddLFxuICAnYXBwbGljYXRpb24vdm5kLmZzYy53ZWJsYXVuY2gnOiBbJ2ZzYyddLFxuICAnYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXMnOiBbJ29hcyddLFxuICAnYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXMyJzogWydvYTInXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzMyc6IFsnb2EzJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5c2dwJzogWydmZzUnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzcHJzJzogWydiaDInXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guZGRkJzogWydkZGQnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guZG9jdXdvcmtzJzogWyd4ZHcnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guZG9jdXdvcmtzLmJpbmRlcic6IFsneGJkJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZnV6enlzaGVldCc6IFsnZnpzJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZ2Vub21hdGl4LnR1eGVkbyc6IFsndHhkJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZ2VvZ2VicmEuZmlsZSc6IFsnZ2diJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZ2VvZ2VicmEudG9vbCc6IFsnZ2d0J10sXG4gICdhcHBsaWNhdGlvbi92bmQuZ2VvbWV0cnktZXhwbG9yZXInOiBbJ2dleCcsICdncmUnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5nZW9uZXh0JzogWydneHQnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5nZW9wbGFuJzogWydnMncnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5nZW9zcGFjZSc6IFsnZzN3J10sXG4gICdhcHBsaWNhdGlvbi92bmQuZ214JzogWydnbXgnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5nb29nbGUtYXBwcy5kb2N1bWVudCc6IFsnZ2RvYyddLFxuICAnYXBwbGljYXRpb24vdm5kLmdvb2dsZS1hcHBzLnByZXNlbnRhdGlvbic6IFsnZ3NsaWRlcyddLFxuICAnYXBwbGljYXRpb24vdm5kLmdvb2dsZS1hcHBzLnNwcmVhZHNoZWV0JzogWydnc2hlZXQnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua21sK3htbCc6IFsna21sJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmtteic6IFsna216J10sXG4gICdhcHBsaWNhdGlvbi92bmQuZ3JhZmVxJzogWydncWYnLCAnZ3FzJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWFjY291bnQnOiBbJ2dhYyddLFxuICAnYXBwbGljYXRpb24vdm5kLmdyb292ZS1oZWxwJzogWydnaGYnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtaWRlbnRpdHktbWVzc2FnZSc6IFsnZ2ltJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWluamVjdG9yJzogWydncnYnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtdG9vbC1tZXNzYWdlJzogWydndG0nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtdG9vbC10ZW1wbGF0ZSc6IFsndHBsJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLXZjYXJkJzogWyd2Y2cnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5oYWwreG1sJzogWydoYWwnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5oYW5kaGVsZC1lbnRlcnRhaW5tZW50K3htbCc6IFsnem1tJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuaGJjaSc6IFsnaGJjaSddLFxuICAnYXBwbGljYXRpb24vdm5kLmhoZS5sZXNzb24tcGxheWVyJzogWydsZXMnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5ocC1ocGdsJzogWydocGdsJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuaHAtaHBpZCc6IFsnaHBpZCddLFxuICAnYXBwbGljYXRpb24vdm5kLmhwLWhwcyc6IFsnaHBzJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuaHAtamx5dCc6IFsnamx0J10sXG4gICdhcHBsaWNhdGlvbi92bmQuaHAtcGNsJzogWydwY2wnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5ocC1wY2x4bCc6IFsncGNseGwnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5oeWRyb3N0YXRpeC5zb2YtZGF0YSc6IFsnc2ZkLWhkc3R4J10sXG4gICdhcHBsaWNhdGlvbi92bmQuaWJtLm1pbmlwYXknOiBbJ21weSddLFxuICAnYXBwbGljYXRpb24vdm5kLmlibS5tb2RjYXAnOiBbJ2FmcCcsICdsaXN0YWZwJywgJ2xpc3QzODIwJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuaWJtLnJpZ2h0cy1tYW5hZ2VtZW50JzogWydpcm0nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5pYm0uc2VjdXJlLWNvbnRhaW5lcic6IFsnc2MnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5pY2Nwcm9maWxlJzogWydpY2MnLCAnaWNtJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuaWdsb2FkZXInOiBbJ2lnbCddLFxuICAnYXBwbGljYXRpb24vdm5kLmltbWVydmlzaW9uLWl2cCc6IFsnaXZwJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuaW1tZXJ2aXNpb24taXZ1JzogWydpdnUnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5pbnNvcnMuaWdtJzogWydpZ20nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5pbnRlcmNvbi5mb3JtbmV0JzogWyd4cHcnLCAneHB4J10sXG4gICdhcHBsaWNhdGlvbi92bmQuaW50ZXJnZW8nOiBbJ2kyZyddLFxuICAnYXBwbGljYXRpb24vdm5kLmludHUucWJvJzogWydxYm8nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5pbnR1LnFmeCc6IFsncWZ4J10sXG4gICdhcHBsaWNhdGlvbi92bmQuaXB1bnBsdWdnZWQucmNwcm9maWxlJzogWydyY3Byb2ZpbGUnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5pcmVwb3NpdG9yeS5wYWNrYWdlK3htbCc6IFsnaXJwJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuaXMteHByJzogWyd4cHInXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5pc2FjLmZjcyc6IFsnZmNzJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuamFtJzogWydqYW0nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5qY3AuamF2YW1lLm1pZGxldC1ybXMnOiBbJ3JtcyddLFxuICAnYXBwbGljYXRpb24vdm5kLmppc3AnOiBbJ2ppc3AnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5qb29zdC5qb2RhLWFyY2hpdmUnOiBbJ2pvZGEnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5rYWhvb3R6JzogWydrdHonLCAna3RyJ10sXG4gICdhcHBsaWNhdGlvbi92bmQua2RlLmthcmJvbic6IFsna2FyYm9uJ10sXG4gICdhcHBsaWNhdGlvbi92bmQua2RlLmtjaGFydCc6IFsnY2hydCddLFxuICAnYXBwbGljYXRpb24vdm5kLmtkZS5rZm9ybXVsYSc6IFsna2ZvJ10sXG4gICdhcHBsaWNhdGlvbi92bmQua2RlLmtpdmlvJzogWydmbHcnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua29udG91cic6IFsna29uJ10sXG4gICdhcHBsaWNhdGlvbi92bmQua2RlLmtwcmVzZW50ZXInOiBbJ2twcicsICdrcHQnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua3NwcmVhZCc6IFsna3NwJ10sXG4gICdhcHBsaWNhdGlvbi92bmQua2RlLmt3b3JkJzogWydrd2QnLCAna3d0J10sXG4gICdhcHBsaWNhdGlvbi92bmQua2VuYW1lYWFwcCc6IFsnaHRrZSddLFxuICAnYXBwbGljYXRpb24vdm5kLmtpZHNwaXJhdGlvbic6IFsna2lhJ10sXG4gICdhcHBsaWNhdGlvbi92bmQua2luYXInOiBbJ2tuZScsICdrbnAnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5rb2FuJzogWydza3AnLCAnc2tkJywgJ3NrdCcsICdza20nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5rb2Rhay1kZXNjcmlwdG9yJzogWydzc2UnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5sYXMubGFzK3htbCc6IFsnbGFzeG1sJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubGxhbWFncmFwaGljcy5saWZlLWJhbGFuY2UuZGVza3RvcCc6IFsnbGJkJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubGxhbWFncmFwaGljcy5saWZlLWJhbGFuY2UuZXhjaGFuZ2UreG1sJzogWydsYmUnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5sb3R1cy0xLTItMyc6IFsnMTIzJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubG90dXMtYXBwcm9hY2gnOiBbJ2FwciddLFxuICAnYXBwbGljYXRpb24vdm5kLmxvdHVzLWZyZWVsYW5jZSc6IFsncHJlJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubG90dXMtbm90ZXMnOiBbJ25zZiddLFxuICAnYXBwbGljYXRpb24vdm5kLmxvdHVzLW9yZ2FuaXplcic6IFsnb3JnJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubG90dXMtc2NyZWVuY2FtJzogWydzY20nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5sb3R1cy13b3JkcHJvJzogWydsd3AnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tYWNwb3J0cy5wb3J0cGtnJzogWydwb3J0cGtnJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubWNkJzogWydtY2QnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tZWRjYWxjZGF0YSc6IFsnbWMxJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubWVkaWFzdGF0aW9uLmNka2V5JzogWydjZGtleSddLFxuICAnYXBwbGljYXRpb24vdm5kLm1mZXInOiBbJ213ZiddLFxuICAnYXBwbGljYXRpb24vdm5kLm1mbXAnOiBbJ21mbSddLFxuICAnYXBwbGljYXRpb24vdm5kLm1pY3JvZ3JhZnguZmxvJzogWydmbG8nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5taWNyb2dyYWZ4LmlneCc6IFsnaWd4J10sXG4gICdhcHBsaWNhdGlvbi92bmQubWlmJzogWydtaWYnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMuZGFmJzogWydkYWYnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMuZGlzJzogWydkaXMnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMubWJrJzogWydtYmsnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMubXF5JzogWydtcXknXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMubXNsJzogWydtc2wnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMucGxjJzogWydwbGMnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMudHhmJzogWyd0eGYnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tb3BodW4uYXBwbGljYXRpb24nOiBbJ21wbiddLFxuICAnYXBwbGljYXRpb24vdm5kLm1vcGh1bi5jZXJ0aWZpY2F0ZSc6IFsnbXBjJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubW96aWxsYS54dWwreG1sJzogWyd4dWwnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1hcnRnYWxyeSc6IFsnY2lsJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubXMtY2FiLWNvbXByZXNzZWQnOiBbJ2NhYiddLFxuICAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJzogWyd4bHMnLCAneGxtJywgJ3hsYScsICd4bGMnLCAneGx0JywgJ3hsdyddLFxuICAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLmFkZGluLm1hY3JvZW5hYmxlZC4xMic6IFsneGxhbSddLFxuICAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnNoZWV0LmJpbmFyeS5tYWNyb2VuYWJsZWQuMTInOiBbJ3hsc2InXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5tYWNyb2VuYWJsZWQuMTInOiBbJ3hsc20nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTInOiBbJ3hsdG0nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1odG1saGVscCc6IFsnY2htJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubXMtaW1zJzogWydpbXMnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1scm0nOiBbJ2xybSddLFxuICAnYXBwbGljYXRpb24vdm5kLm1zLW9mZmljZXRoZW1lJzogWyd0aG14J10sXG4gICdhcHBsaWNhdGlvbi92bmQubXMtb3V0bG9vayc6IFsnbXNnJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubXMtcGtpLnNlY2NhdCc6IFsnY2F0J10sXG4gICdhcHBsaWNhdGlvbi92bmQubXMtcGtpLnN0bCc6IFsnKnN0bCddLFxuICAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQnOiBbJ3BwdCcsICdwcHMnLCAncG90J10sXG4gICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC5hZGRpbi5tYWNyb2VuYWJsZWQuMTInOiBbJ3BwYW0nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnByZXNlbnRhdGlvbi5tYWNyb2VuYWJsZWQuMTInOiBbJ3BwdG0nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnNsaWRlLm1hY3JvZW5hYmxlZC4xMic6IFsnc2xkbSddLFxuICAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQuc2xpZGVzaG93Lm1hY3JvZW5hYmxlZC4xMic6IFsncHBzbSddLFxuICAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyJzogWydwb3RtJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubXMtcHJvamVjdCc6IFsnbXBwJywgJ21wdCddLFxuICAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmQuZG9jdW1lbnQubWFjcm9lbmFibGVkLjEyJzogWydkb2NtJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubXMtd29yZC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTInOiBbJ2RvdG0nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy13b3Jrcyc6IFsnd3BzJywgJ3drcycsICd3Y20nLCAnd2RiJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubXMtd3BsJzogWyd3cGwnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy14cHNkb2N1bWVudCc6IFsneHBzJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubXNlcSc6IFsnbXNlcSddLFxuICAnYXBwbGljYXRpb24vdm5kLm11c2ljaWFuJzogWydtdXMnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5tdXZlZS5zdHlsZSc6IFsnbXN0eSddLFxuICAnYXBwbGljYXRpb24vdm5kLm15bmZjJzogWyd0YWdsZXQnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5uZXVyb2xhbmd1YWdlLm5sdSc6IFsnbmx1J10sXG4gICdhcHBsaWNhdGlvbi92bmQubml0Zic6IFsnbnRmJywgJ25pdGYnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5ub2JsZW5ldC1kaXJlY3RvcnknOiBbJ25uZCddLFxuICAnYXBwbGljYXRpb24vdm5kLm5vYmxlbmV0LXNlYWxlcic6IFsnbm5zJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubm9ibGVuZXQtd2ViJzogWydubncnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5uLWdhZ2UuZGF0YSc6IFsnbmdkYXQnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5uLWdhZ2Uuc3ltYmlhbi5pbnN0YWxsJzogWyduLWdhZ2UnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5yYWRpby1wcmVzZXQnOiBbJ3Jwc3QnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5yYWRpby1wcmVzZXRzJzogWydycHNzJ10sXG4gICdhcHBsaWNhdGlvbi92bmQubm92YWRpZ20uZWRtJzogWydlZG0nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5ub3ZhZGlnbS5lZHgnOiBbJ2VkeCddLFxuICAnYXBwbGljYXRpb24vdm5kLm5vdmFkaWdtLmV4dCc6IFsnZXh0J10sXG4gICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmNoYXJ0JzogWydvZGMnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuY2hhcnQtdGVtcGxhdGUnOiBbJ290YyddLFxuICAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5kYXRhYmFzZSc6IFsnb2RiJ10sXG4gICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmZvcm11bGEnOiBbJ29kZiddLFxuICAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5mb3JtdWxhLXRlbXBsYXRlJzogWydvZGZ0J10sXG4gICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmdyYXBoaWNzJzogWydvZGcnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZ3JhcGhpY3MtdGVtcGxhdGUnOiBbJ290ZyddLFxuICAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5pbWFnZSc6IFsnb2RpJ10sXG4gICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmltYWdlLXRlbXBsYXRlJzogWydvdGknXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uJzogWydvZHAnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uLXRlbXBsYXRlJzogWydvdHAnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuc3ByZWFkc2hlZXQnOiBbJ29kcyddLFxuICAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldC10ZW1wbGF0ZSc6IFsnb3RzJ10sXG4gICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQnOiBbJ29kdCddLFxuICAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0LW1hc3Rlcic6IFsnb2RtJ10sXG4gICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQtdGVtcGxhdGUnOiBbJ290dCddLFxuICAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0LXdlYic6IFsnb3RoJ10sXG4gICdhcHBsaWNhdGlvbi92bmQub2xwYy1zdWdhcic6IFsneG8nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5vbWEuZGQyK3htbCc6IFsnZGQyJ10sXG4gICdhcHBsaWNhdGlvbi92bmQub3Blbm9mZmljZW9yZy5leHRlbnNpb24nOiBbJ294dCddLFxuICAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnByZXNlbnRhdGlvbic6IFsncHB0eCddLFxuICAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlJzogWydzbGR4J10sXG4gICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGVzaG93JzogWydwcHN4J10sXG4gICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwudGVtcGxhdGUnOiBbJ3BvdHgnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0JzogWyd4bHN4J10sXG4gICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC50ZW1wbGF0ZSc6IFsneGx0eCddLFxuICAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnOiBbJ2RvY3gnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnRlbXBsYXRlJzogWydkb3R4J10sXG4gICdhcHBsaWNhdGlvbi92bmQub3NnZW8ubWFwZ3VpZGUucGFja2FnZSc6IFsnbWdwJ10sXG4gICdhcHBsaWNhdGlvbi92bmQub3NnaS5kcCc6IFsnZHAnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5vc2dpLnN1YnN5c3RlbSc6IFsnZXNhJ10sXG4gICdhcHBsaWNhdGlvbi92bmQucGFsbSc6IFsncGRiJywgJ3BxYScsICdvcHJjJ10sXG4gICdhcHBsaWNhdGlvbi92bmQucGF3YWFmaWxlJzogWydwYXcnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5wZy5mb3JtYXQnOiBbJ3N0ciddLFxuICAnYXBwbGljYXRpb24vdm5kLnBnLm9zYXNsaSc6IFsnZWk2J10sXG4gICdhcHBsaWNhdGlvbi92bmQucGljc2VsJzogWydlZmlmJ10sXG4gICdhcHBsaWNhdGlvbi92bmQucG1pLndpZGdldCc6IFsnd2cnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5wb2NrZXRsZWFybic6IFsncGxmJ10sXG4gICdhcHBsaWNhdGlvbi92bmQucG93ZXJidWlsZGVyNic6IFsncGJkJ10sXG4gICdhcHBsaWNhdGlvbi92bmQucHJldmlld3N5c3RlbXMuYm94JzogWydib3gnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5wcm90ZXVzLm1hZ2F6aW5lJzogWydtZ3onXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5wdWJsaXNoYXJlLWRlbHRhLXRyZWUnOiBbJ3FwcyddLFxuICAnYXBwbGljYXRpb24vdm5kLnB2aS5wdGlkMSc6IFsncHRpZCddLFxuICAnYXBwbGljYXRpb24vdm5kLnF1YXJrLnF1YXJreHByZXNzJzogWydxeGQnLCAncXh0JywgJ3F3ZCcsICdxd3QnLCAncXhsJywgJ3F4YiddLFxuICAnYXBwbGljYXRpb24vdm5kLnJlYWx2bmMuYmVkJzogWydiZWQnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5yZWNvcmRhcmUubXVzaWN4bWwnOiBbJ214bCddLFxuICAnYXBwbGljYXRpb24vdm5kLnJlY29yZGFyZS5tdXNpY3htbCt4bWwnOiBbJ211c2ljeG1sJ10sXG4gICdhcHBsaWNhdGlvbi92bmQucmlnLmNyeXB0b25vdGUnOiBbJ2NyeXB0b25vdGUnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5yaW0uY29kJzogWydjb2QnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5ybi1yZWFsbWVkaWEnOiBbJ3JtJ10sXG4gICdhcHBsaWNhdGlvbi92bmQucm4tcmVhbG1lZGlhLXZicic6IFsncm12YiddLFxuICAnYXBwbGljYXRpb24vdm5kLnJvdXRlNjYubGluazY2K3htbCc6IFsnbGluazY2J10sXG4gICdhcHBsaWNhdGlvbi92bmQuc2FpbGluZ3RyYWNrZXIudHJhY2snOiBbJ3N0J10sXG4gICdhcHBsaWNhdGlvbi92bmQuc2VlbWFpbCc6IFsnc2VlJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuc2VtYSc6IFsnc2VtYSddLFxuICAnYXBwbGljYXRpb24vdm5kLnNlbWQnOiBbJ3NlbWQnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5zZW1mJzogWydzZW1mJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuc2hhbmEuaW5mb3JtZWQuZm9ybWRhdGEnOiBbJ2lmbSddLFxuICAnYXBwbGljYXRpb24vdm5kLnNoYW5hLmluZm9ybWVkLmZvcm10ZW1wbGF0ZSc6IFsnaXRwJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuc2hhbmEuaW5mb3JtZWQuaW50ZXJjaGFuZ2UnOiBbJ2lpZiddLFxuICAnYXBwbGljYXRpb24vdm5kLnNoYW5hLmluZm9ybWVkLnBhY2thZ2UnOiBbJ2lwayddLFxuICAnYXBwbGljYXRpb24vdm5kLnNpbXRlY2gtbWluZG1hcHBlcic6IFsndHdkJywgJ3R3ZHMnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5zbWFmJzogWydtbWYnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5zbWFydC50ZWFjaGVyJzogWyd0ZWFjaGVyJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuc29sZW50LnNka20reG1sJzogWydzZGttJywgJ3Nka2QnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5zcG90ZmlyZS5keHAnOiBbJ2R4cCddLFxuICAnYXBwbGljYXRpb24vdm5kLnNwb3RmaXJlLnNmcyc6IFsnc2ZzJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLmNhbGMnOiBbJ3NkYyddLFxuICAnYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi5kcmF3JzogWydzZGEnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24uaW1wcmVzcyc6IFsnc2RkJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLm1hdGgnOiBbJ3NtZiddLFxuICAnYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi53cml0ZXInOiBbJ3NkdycsICd2b3InXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24ud3JpdGVyLWdsb2JhbCc6IFsnc2dsJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuc3RlcG1hbmlhLnBhY2thZ2UnOiBbJ3NtemlwJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuc3RlcG1hbmlhLnN0ZXBjaGFydCc6IFsnc20nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ud2FkbCt4bWwnOiBbJ3dhZGwnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmNhbGMnOiBbJ3N4YyddLFxuICAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwuY2FsYy50ZW1wbGF0ZSc6IFsnc3RjJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5kcmF3JzogWydzeGQnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmRyYXcudGVtcGxhdGUnOiBbJ3N0ZCddLFxuICAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwuaW1wcmVzcyc6IFsnc3hpJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5pbXByZXNzLnRlbXBsYXRlJzogWydzdGknXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLm1hdGgnOiBbJ3N4bSddLFxuICAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyJzogWydzeHcnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLndyaXRlci5nbG9iYWwnOiBbJ3N4ZyddLFxuICAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyLnRlbXBsYXRlJzogWydzdHcnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5zdXMtY2FsZW5kYXInOiBbJ3N1cycsICdzdXNwJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuc3ZkJzogWydzdmQnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5zeW1iaWFuLmluc3RhbGwnOiBbJ3NpcycsICdzaXN4J10sXG4gICdhcHBsaWNhdGlvbi92bmQuc3luY21sK3htbCc6IFsneHNtJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuc3luY21sLmRtK3dieG1sJzogWydiZG0nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC5zeW5jbWwuZG0reG1sJzogWyd4ZG0nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC50YW8uaW50ZW50LW1vZHVsZS1hcmNoaXZlJzogWyd0YW8nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC50Y3BkdW1wLnBjYXAnOiBbJ3BjYXAnLCAnY2FwJywgJ2RtcCddLFxuICAnYXBwbGljYXRpb24vdm5kLnRtb2JpbGUtbGl2ZXR2JzogWyd0bW8nXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC50cmlkLnRwdCc6IFsndHB0J10sXG4gICdhcHBsaWNhdGlvbi92bmQudHJpc2NhcGUubXhzJzogWydteHMnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC50cnVlYXBwJzogWyd0cmEnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC51ZmRsJzogWyd1ZmQnLCAndWZkbCddLFxuICAnYXBwbGljYXRpb24vdm5kLnVpcS50aGVtZSc6IFsndXR6J10sXG4gICdhcHBsaWNhdGlvbi92bmQudW1hamluJzogWyd1bWonXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC51bml0eSc6IFsndW5pdHl3ZWInXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC51b21sK3htbCc6IFsndW9tbCddLFxuICAnYXBwbGljYXRpb24vdm5kLnZjeCc6IFsndmN4J10sXG4gICdhcHBsaWNhdGlvbi92bmQudmlzaW8nOiBbJ3ZzZCcsICd2c3QnLCAndnNzJywgJ3ZzdyddLFxuICAnYXBwbGljYXRpb24vdm5kLnZpc2lvbmFyeSc6IFsndmlzJ10sXG4gICdhcHBsaWNhdGlvbi92bmQudnNmJzogWyd2c2YnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC53YXAud2J4bWwnOiBbJ3dieG1sJ10sXG4gICdhcHBsaWNhdGlvbi92bmQud2FwLndtbGMnOiBbJ3dtbGMnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC53YXAud21sc2NyaXB0Yyc6IFsnd21sc2MnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC53ZWJ0dXJibyc6IFsnd3RiJ10sXG4gICdhcHBsaWNhdGlvbi92bmQud29sZnJhbS5wbGF5ZXInOiBbJ25icCddLFxuICAnYXBwbGljYXRpb24vdm5kLndvcmRwZXJmZWN0JzogWyd3cGQnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC53cWQnOiBbJ3dxZCddLFxuICAnYXBwbGljYXRpb24vdm5kLnd0LnN0Zic6IFsnc3RmJ10sXG4gICdhcHBsaWNhdGlvbi92bmQueGFyYSc6IFsneGFyJ10sXG4gICdhcHBsaWNhdGlvbi92bmQueGZkbCc6IFsneGZkbCddLFxuICAnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5odi1kaWMnOiBbJ2h2ZCddLFxuICAnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5odi1zY3JpcHQnOiBbJ2h2cyddLFxuICAnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5odi12b2ljZSc6IFsnaHZwJ10sXG4gICdhcHBsaWNhdGlvbi92bmQueWFtYWhhLm9wZW5zY29yZWZvcm1hdCc6IFsnb3NmJ10sXG4gICdhcHBsaWNhdGlvbi92bmQueWFtYWhhLm9wZW5zY29yZWZvcm1hdC5vc2ZwdmcreG1sJzogWydvc2ZwdmcnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC55YW1haGEuc21hZi1hdWRpbyc6IFsnc2FmJ10sXG4gICdhcHBsaWNhdGlvbi92bmQueWFtYWhhLnNtYWYtcGhyYXNlJzogWydzcGYnXSxcbiAgJ2FwcGxpY2F0aW9uL3ZuZC55ZWxsb3dyaXZlci1jdXN0b20tbWVudSc6IFsnY21wJ10sXG4gICdhcHBsaWNhdGlvbi92bmQuenVsJzogWyd6aXInLCAnemlyeiddLFxuICAnYXBwbGljYXRpb24vdm5kLnp6YXp6LmRlY2sreG1sJzogWyd6YXonXSxcbiAgJ2FwcGxpY2F0aW9uL3gtN3otY29tcHJlc3NlZCc6IFsnN3onXSxcbiAgJ2FwcGxpY2F0aW9uL3gtYWJpd29yZCc6IFsnYWJ3J10sXG4gICdhcHBsaWNhdGlvbi94LWFjZS1jb21wcmVzc2VkJzogWydhY2UnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtYXBwbGUtZGlza2ltYWdlJzogWycqZG1nJ10sXG4gICdhcHBsaWNhdGlvbi94LWFyaic6IFsnYXJqJ10sXG4gICdhcHBsaWNhdGlvbi94LWF1dGhvcndhcmUtYmluJzogWydhYWInLCAneDMyJywgJ3UzMicsICd2b3gnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtYXV0aG9yd2FyZS1tYXAnOiBbJ2FhbSddLFxuICAnYXBwbGljYXRpb24veC1hdXRob3J3YXJlLXNlZyc6IFsnYWFzJ10sXG4gICdhcHBsaWNhdGlvbi94LWJjcGlvJzogWydiY3BpbyddLFxuICAnYXBwbGljYXRpb24veC1iZG9jJzogWycqYmRvYyddLFxuICAnYXBwbGljYXRpb24veC1iaXR0b3JyZW50JzogWyd0b3JyZW50J10sXG4gICdhcHBsaWNhdGlvbi94LWJsb3JiJzogWydibGInLCAnYmxvcmInXSxcbiAgJ2FwcGxpY2F0aW9uL3gtYnppcCc6IFsnYnonXSxcbiAgJ2FwcGxpY2F0aW9uL3gtYnppcDInOiBbJ2J6MicsICdib3onXSxcbiAgJ2FwcGxpY2F0aW9uL3gtY2JyJzogWydjYnInLCAnY2JhJywgJ2NidCcsICdjYnonLCAnY2I3J10sXG4gICdhcHBsaWNhdGlvbi94LWNkbGluayc6IFsndmNkJ10sXG4gICdhcHBsaWNhdGlvbi94LWNmcy1jb21wcmVzc2VkJzogWydjZnMnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtY2hhdCc6IFsnY2hhdCddLFxuICAnYXBwbGljYXRpb24veC1jaGVzcy1wZ24nOiBbJ3BnbiddLFxuICAnYXBwbGljYXRpb24veC1jaHJvbWUtZXh0ZW5zaW9uJzogWydjcngnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtY29jb2EnOiBbJ2NjbyddLFxuICAnYXBwbGljYXRpb24veC1jb25mZXJlbmNlJzogWyduc2MnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtY3Bpbyc6IFsnY3BpbyddLFxuICAnYXBwbGljYXRpb24veC1jc2gnOiBbJ2NzaCddLFxuICAnYXBwbGljYXRpb24veC1kZWJpYW4tcGFja2FnZSc6IFsnKmRlYicsICd1ZGViJ10sXG4gICdhcHBsaWNhdGlvbi94LWRnYy1jb21wcmVzc2VkJzogWydkZ2MnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtZGlyZWN0b3InOiBbJ2RpcicsICdkY3InLCAnZHhyJywgJ2NzdCcsICdjY3QnLCAnY3h0JywgJ3czZCcsICdmZ2QnLCAnc3dhJ10sXG4gICdhcHBsaWNhdGlvbi94LWRvb20nOiBbJ3dhZCddLFxuICAnYXBwbGljYXRpb24veC1kdGJuY3greG1sJzogWyduY3gnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtZHRib29rK3htbCc6IFsnZHRiJ10sXG4gICdhcHBsaWNhdGlvbi94LWR0YnJlc291cmNlK3htbCc6IFsncmVzJ10sXG4gICdhcHBsaWNhdGlvbi94LWR2aSc6IFsnZHZpJ10sXG4gICdhcHBsaWNhdGlvbi94LWVudm95JzogWydldnknXSxcbiAgJ2FwcGxpY2F0aW9uL3gtZXZhJzogWydldmEnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtZm9udC1iZGYnOiBbJ2JkZiddLFxuICAnYXBwbGljYXRpb24veC1mb250LWdob3N0c2NyaXB0JzogWydnc2YnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtZm9udC1saW51eC1wc2YnOiBbJ3BzZiddLFxuICAnYXBwbGljYXRpb24veC1mb250LXBjZic6IFsncGNmJ10sXG4gICdhcHBsaWNhdGlvbi94LWZvbnQtc25mJzogWydzbmYnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtZm9udC10eXBlMSc6IFsncGZhJywgJ3BmYicsICdwZm0nLCAnYWZtJ10sXG4gICdhcHBsaWNhdGlvbi94LWZyZWVhcmMnOiBbJ2FyYyddLFxuICAnYXBwbGljYXRpb24veC1mdXR1cmVzcGxhc2gnOiBbJ3NwbCddLFxuICAnYXBwbGljYXRpb24veC1nY2EtY29tcHJlc3NlZCc6IFsnZ2NhJ10sXG4gICdhcHBsaWNhdGlvbi94LWdsdWx4JzogWyd1bHgnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtZ251bWVyaWMnOiBbJ2dudW1lcmljJ10sXG4gICdhcHBsaWNhdGlvbi94LWdyYW1wcy14bWwnOiBbJ2dyYW1wcyddLFxuICAnYXBwbGljYXRpb24veC1ndGFyJzogWydndGFyJ10sXG4gICdhcHBsaWNhdGlvbi94LWhkZic6IFsnaGRmJ10sXG4gICdhcHBsaWNhdGlvbi94LWh0dHBkLXBocCc6IFsncGhwJ10sXG4gICdhcHBsaWNhdGlvbi94LWluc3RhbGwtaW5zdHJ1Y3Rpb25zJzogWydpbnN0YWxsJ10sXG4gICdhcHBsaWNhdGlvbi94LWlzbzk2NjAtaW1hZ2UnOiBbJyppc28nXSxcbiAgJ2FwcGxpY2F0aW9uL3gtamF2YS1hcmNoaXZlLWRpZmYnOiBbJ2phcmRpZmYnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtamF2YS1qbmxwLWZpbGUnOiBbJ2pubHAnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtbGF0ZXgnOiBbJ2xhdGV4J10sXG4gICdhcHBsaWNhdGlvbi94LWx1YS1ieXRlY29kZSc6IFsnbHVhYyddLFxuICAnYXBwbGljYXRpb24veC1semgtY29tcHJlc3NlZCc6IFsnbHpoJywgJ2xoYSddLFxuICAnYXBwbGljYXRpb24veC1tYWtlc2VsZic6IFsncnVuJ10sXG4gICdhcHBsaWNhdGlvbi94LW1pZSc6IFsnbWllJ10sXG4gICdhcHBsaWNhdGlvbi94LW1vYmlwb2NrZXQtZWJvb2snOiBbJ3ByYycsICdtb2JpJ10sXG4gICdhcHBsaWNhdGlvbi94LW1zLWFwcGxpY2F0aW9uJzogWydhcHBsaWNhdGlvbiddLFxuICAnYXBwbGljYXRpb24veC1tcy1zaG9ydGN1dCc6IFsnbG5rJ10sXG4gICdhcHBsaWNhdGlvbi94LW1zLXdtZCc6IFsnd21kJ10sXG4gICdhcHBsaWNhdGlvbi94LW1zLXdteic6IFsnd216J10sXG4gICdhcHBsaWNhdGlvbi94LW1zLXhiYXAnOiBbJ3hiYXAnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtbXNhY2Nlc3MnOiBbJ21kYiddLFxuICAnYXBwbGljYXRpb24veC1tc2JpbmRlcic6IFsnb2JkJ10sXG4gICdhcHBsaWNhdGlvbi94LW1zY2FyZGZpbGUnOiBbJ2NyZCddLFxuICAnYXBwbGljYXRpb24veC1tc2NsaXAnOiBbJ2NscCddLFxuICAnYXBwbGljYXRpb24veC1tc2Rvcy1wcm9ncmFtJzogWycqZXhlJ10sXG4gICdhcHBsaWNhdGlvbi94LW1zZG93bmxvYWQnOiBbJypleGUnLCAnKmRsbCcsICdjb20nLCAnYmF0JywgJyptc2knXSxcbiAgJ2FwcGxpY2F0aW9uL3gtbXNtZWRpYXZpZXcnOiBbJ212YicsICdtMTMnLCAnbTE0J10sXG4gICdhcHBsaWNhdGlvbi94LW1zbWV0YWZpbGUnOiBbJyp3bWYnLCAnKndteicsICcqZW1mJywgJ2VteiddLFxuICAnYXBwbGljYXRpb24veC1tc21vbmV5JzogWydtbnknXSxcbiAgJ2FwcGxpY2F0aW9uL3gtbXNwdWJsaXNoZXInOiBbJ3B1YiddLFxuICAnYXBwbGljYXRpb24veC1tc3NjaGVkdWxlJzogWydzY2QnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtbXN0ZXJtaW5hbCc6IFsndHJtJ10sXG4gICdhcHBsaWNhdGlvbi94LW1zd3JpdGUnOiBbJ3dyaSddLFxuICAnYXBwbGljYXRpb24veC1uZXRjZGYnOiBbJ25jJywgJ2NkZiddLFxuICAnYXBwbGljYXRpb24veC1ucy1wcm94eS1hdXRvY29uZmlnJzogWydwYWMnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtbnpiJzogWyduemInXSxcbiAgJ2FwcGxpY2F0aW9uL3gtcGVybCc6IFsncGwnLCAncG0nXSxcbiAgJ2FwcGxpY2F0aW9uL3gtcGlsb3QnOiBbJypwcmMnLCAnKnBkYiddLFxuICAnYXBwbGljYXRpb24veC1wa2NzMTInOiBbJ3AxMicsICdwZngnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtcGtjczctY2VydGlmaWNhdGVzJzogWydwN2InLCAnc3BjJ10sXG4gICdhcHBsaWNhdGlvbi94LXBrY3M3LWNlcnRyZXFyZXNwJzogWydwN3InXSxcbiAgJ2FwcGxpY2F0aW9uL3gtcmFyLWNvbXByZXNzZWQnOiBbJ3JhciddLFxuICAnYXBwbGljYXRpb24veC1yZWRoYXQtcGFja2FnZS1tYW5hZ2VyJzogWydycG0nXSxcbiAgJ2FwcGxpY2F0aW9uL3gtcmVzZWFyY2gtaW5mby1zeXN0ZW1zJzogWydyaXMnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtc2VhJzogWydzZWEnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtc2gnOiBbJ3NoJ10sXG4gICdhcHBsaWNhdGlvbi94LXNoYXInOiBbJ3NoYXInXSxcbiAgJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJzogWydzd2YnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtc2lsdmVybGlnaHQtYXBwJzogWyd4YXAnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtc3FsJzogWydzcWwnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtc3R1ZmZpdCc6IFsnc2l0J10sXG4gICdhcHBsaWNhdGlvbi94LXN0dWZmaXR4JzogWydzaXR4J10sXG4gICdhcHBsaWNhdGlvbi94LXN1YnJpcCc6IFsnc3J0J10sXG4gICdhcHBsaWNhdGlvbi94LXN2NGNwaW8nOiBbJ3N2NGNwaW8nXSxcbiAgJ2FwcGxpY2F0aW9uL3gtc3Y0Y3JjJzogWydzdjRjcmMnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtdDN2bS1pbWFnZSc6IFsndDMnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtdGFkcyc6IFsnZ2FtJ10sXG4gICdhcHBsaWNhdGlvbi94LXRhcic6IFsndGFyJ10sXG4gICdhcHBsaWNhdGlvbi94LXRjbCc6IFsndGNsJywgJ3RrJ10sXG4gICdhcHBsaWNhdGlvbi94LXRleCc6IFsndGV4J10sXG4gICdhcHBsaWNhdGlvbi94LXRleC10Zm0nOiBbJ3RmbSddLFxuICAnYXBwbGljYXRpb24veC10ZXhpbmZvJzogWyd0ZXhpbmZvJywgJ3RleGknXSxcbiAgJ2FwcGxpY2F0aW9uL3gtdGdpZic6IFsnb2JqJ10sXG4gICdhcHBsaWNhdGlvbi94LXVzdGFyJzogWyd1c3RhciddLFxuICAnYXBwbGljYXRpb24veC12aXJ0dWFsYm94LWhkZCc6IFsnaGRkJ10sXG4gICdhcHBsaWNhdGlvbi94LXZpcnR1YWxib3gtb3ZhJzogWydvdmEnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtdmlydHVhbGJveC1vdmYnOiBbJ292ZiddLFxuICAnYXBwbGljYXRpb24veC12aXJ0dWFsYm94LXZib3gnOiBbJ3Zib3gnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtdmlydHVhbGJveC12Ym94LWV4dHBhY2snOiBbJ3Zib3gtZXh0cGFjayddLFxuICAnYXBwbGljYXRpb24veC12aXJ0dWFsYm94LXZkaSc6IFsndmRpJ10sXG4gICdhcHBsaWNhdGlvbi94LXZpcnR1YWxib3gtdmhkJzogWyd2aGQnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtdmlydHVhbGJveC12bWRrJzogWyd2bWRrJ10sXG4gICdhcHBsaWNhdGlvbi94LXdhaXMtc291cmNlJzogWydzcmMnXSxcbiAgJ2FwcGxpY2F0aW9uL3gtd2ViLWFwcC1tYW5pZmVzdCtqc29uJzogWyd3ZWJhcHAnXSxcbiAgJ2FwcGxpY2F0aW9uL3gteDUwOS1jYS1jZXJ0JzogWydkZXInLCAnY3J0JywgJ3BlbSddLFxuICAnYXBwbGljYXRpb24veC14ZmlnJzogWydmaWcnXSxcbiAgJ2FwcGxpY2F0aW9uL3gteGxpZmYreG1sJzogWyd4bGYnXSxcbiAgJ2FwcGxpY2F0aW9uL3gteHBpbnN0YWxsJzogWyd4cGknXSxcbiAgJ2FwcGxpY2F0aW9uL3gteHonOiBbJ3h6J10sXG4gICdhcHBsaWNhdGlvbi94LXptYWNoaW5lJzogWyd6MScsICd6MicsICd6MycsICd6NCcsICd6NScsICd6NicsICd6NycsICd6OCddLFxuICAnYXVkaW8vdm5kLmRlY2UuYXVkaW8nOiBbJ3V2YScsICd1dnZhJ10sXG4gICdhdWRpby92bmQuZGlnaXRhbC13aW5kcyc6IFsnZW9sJ10sXG4gICdhdWRpby92bmQuZHJhJzogWydkcmEnXSxcbiAgJ2F1ZGlvL3ZuZC5kdHMnOiBbJ2R0cyddLFxuICAnYXVkaW8vdm5kLmR0cy5oZCc6IFsnZHRzaGQnXSxcbiAgJ2F1ZGlvL3ZuZC5sdWNlbnQudm9pY2UnOiBbJ2x2cCddLFxuICAnYXVkaW8vdm5kLm1zLXBsYXlyZWFkeS5tZWRpYS5weWEnOiBbJ3B5YSddLFxuICAnYXVkaW8vdm5kLm51ZXJhLmVjZWxwNDgwMCc6IFsnZWNlbHA0ODAwJ10sXG4gICdhdWRpby92bmQubnVlcmEuZWNlbHA3NDcwJzogWydlY2VscDc0NzAnXSxcbiAgJ2F1ZGlvL3ZuZC5udWVyYS5lY2VscDk2MDAnOiBbJ2VjZWxwOTYwMCddLFxuICAnYXVkaW8vdm5kLnJpcCc6IFsncmlwJ10sXG4gICdhdWRpby94LWFhYyc6IFsnYWFjJ10sXG4gICdhdWRpby94LWFpZmYnOiBbJ2FpZicsICdhaWZmJywgJ2FpZmMnXSxcbiAgJ2F1ZGlvL3gtY2FmJzogWydjYWYnXSxcbiAgJ2F1ZGlvL3gtZmxhYyc6IFsnZmxhYyddLFxuICAnYXVkaW8veC1tNGEnOiBbJyptNGEnXSxcbiAgJ2F1ZGlvL3gtbWF0cm9za2EnOiBbJ21rYSddLFxuICAnYXVkaW8veC1tcGVndXJsJzogWydtM3UnXSxcbiAgJ2F1ZGlvL3gtbXMtd2F4JzogWyd3YXgnXSxcbiAgJ2F1ZGlvL3gtbXMtd21hJzogWyd3bWEnXSxcbiAgJ2F1ZGlvL3gtcG4tcmVhbGF1ZGlvJzogWydyYW0nLCAncmEnXSxcbiAgJ2F1ZGlvL3gtcG4tcmVhbGF1ZGlvLXBsdWdpbic6IFsncm1wJ10sXG4gICdhdWRpby94LXJlYWxhdWRpbyc6IFsnKnJhJ10sXG4gICdhdWRpby94LXdhdic6IFsnKndhdiddLFxuICAnY2hlbWljYWwveC1jZHgnOiBbJ2NkeCddLFxuICAnY2hlbWljYWwveC1jaWYnOiBbJ2NpZiddLFxuICAnY2hlbWljYWwveC1jbWRmJzogWydjbWRmJ10sXG4gICdjaGVtaWNhbC94LWNtbCc6IFsnY21sJ10sXG4gICdjaGVtaWNhbC94LWNzbWwnOiBbJ2NzbWwnXSxcbiAgJ2NoZW1pY2FsL3gteHl6JzogWyd4eXonXSxcbiAgJ2ltYWdlL3Bycy5idGlmJzogWydidGlmJ10sXG4gICdpbWFnZS9wcnMucHRpJzogWydwdGknXSxcbiAgJ2ltYWdlL3ZuZC5hZG9iZS5waG90b3Nob3AnOiBbJ3BzZCddLFxuICAnaW1hZ2Uvdm5kLmFpcnppcC5hY2NlbGVyYXRvci5henYnOiBbJ2F6diddLFxuICAnaW1hZ2Uvdm5kLmRlY2UuZ3JhcGhpYyc6IFsndXZpJywgJ3V2dmknLCAndXZnJywgJ3V2dmcnXSxcbiAgJ2ltYWdlL3ZuZC5kanZ1JzogWydkanZ1JywgJ2RqdiddLFxuICAnaW1hZ2Uvdm5kLmR2Yi5zdWJ0aXRsZSc6IFsnKnN1YiddLFxuICAnaW1hZ2Uvdm5kLmR3Zyc6IFsnZHdnJ10sXG4gICdpbWFnZS92bmQuZHhmJzogWydkeGYnXSxcbiAgJ2ltYWdlL3ZuZC5mYXN0Ymlkc2hlZXQnOiBbJ2ZicyddLFxuICAnaW1hZ2Uvdm5kLmZweCc6IFsnZnB4J10sXG4gICdpbWFnZS92bmQuZnN0JzogWydmc3QnXSxcbiAgJ2ltYWdlL3ZuZC5mdWppeGVyb3guZWRtaWNzLW1tcic6IFsnbW1yJ10sXG4gICdpbWFnZS92bmQuZnVqaXhlcm94LmVkbWljcy1ybGMnOiBbJ3JsYyddLFxuICAnaW1hZ2Uvdm5kLm1pY3Jvc29mdC5pY29uJzogWydpY28nXSxcbiAgJ2ltYWdlL3ZuZC5tcy1tb2RpJzogWydtZGknXSxcbiAgJ2ltYWdlL3ZuZC5tcy1waG90byc6IFsnd2RwJ10sXG4gICdpbWFnZS92bmQubmV0LWZweCc6IFsnbnB4J10sXG4gICdpbWFnZS92bmQudGVuY2VudC50YXAnOiBbJ3RhcCddLFxuICAnaW1hZ2Uvdm5kLnZhbHZlLnNvdXJjZS50ZXh0dXJlJzogWyd2dGYnXSxcbiAgJ2ltYWdlL3ZuZC53YXAud2JtcCc6IFsnd2JtcCddLFxuICAnaW1hZ2Uvdm5kLnhpZmYnOiBbJ3hpZiddLFxuICAnaW1hZ2Uvdm5kLnpicnVzaC5wY3gnOiBbJ3BjeCddLFxuICAnaW1hZ2UveC0zZHMnOiBbJzNkcyddLFxuICAnaW1hZ2UveC1jbXUtcmFzdGVyJzogWydyYXMnXSxcbiAgJ2ltYWdlL3gtY214JzogWydjbXgnXSxcbiAgJ2ltYWdlL3gtZnJlZWhhbmQnOiBbJ2ZoJywgJ2ZoYycsICdmaDQnLCAnZmg1JywgJ2ZoNyddLFxuICAnaW1hZ2UveC1pY29uJzogWycqaWNvJ10sXG4gICdpbWFnZS94LWpuZyc6IFsnam5nJ10sXG4gICdpbWFnZS94LW1yc2lkLWltYWdlJzogWydzaWQnXSxcbiAgJ2ltYWdlL3gtbXMtYm1wJzogWycqYm1wJ10sXG4gICdpbWFnZS94LXBjeCc6IFsnKnBjeCddLFxuICAnaW1hZ2UveC1waWN0JzogWydwaWMnLCAncGN0J10sXG4gICdpbWFnZS94LXBvcnRhYmxlLWFueW1hcCc6IFsncG5tJ10sXG4gICdpbWFnZS94LXBvcnRhYmxlLWJpdG1hcCc6IFsncGJtJ10sXG4gICdpbWFnZS94LXBvcnRhYmxlLWdyYXltYXAnOiBbJ3BnbSddLFxuICAnaW1hZ2UveC1wb3J0YWJsZS1waXhtYXAnOiBbJ3BwbSddLFxuICAnaW1hZ2UveC1yZ2InOiBbJ3JnYiddLFxuICAnaW1hZ2UveC10Z2EnOiBbJ3RnYSddLFxuICAnaW1hZ2UveC14Yml0bWFwJzogWyd4Ym0nXSxcbiAgJ2ltYWdlL3gteHBpeG1hcCc6IFsneHBtJ10sXG4gICdpbWFnZS94LXh3aW5kb3dkdW1wJzogWyd4d2QnXSxcbiAgJ21lc3NhZ2Uvdm5kLndmYS53c2MnOiBbJ3dzYyddLFxuICAnbW9kZWwvdm5kLmNvbGxhZGEreG1sJzogWydkYWUnXSxcbiAgJ21vZGVsL3ZuZC5kd2YnOiBbJ2R3ZiddLFxuICAnbW9kZWwvdm5kLmdkbCc6IFsnZ2RsJ10sXG4gICdtb2RlbC92bmQuZ3R3JzogWydndHcnXSxcbiAgJ21vZGVsL3ZuZC5tdHMnOiBbJ210cyddLFxuICAnbW9kZWwvdm5kLm9wZW5nZXgnOiBbJ29nZXgnXSxcbiAgJ21vZGVsL3ZuZC5wYXJhc29saWQudHJhbnNtaXQuYmluYXJ5JzogWyd4X2InXSxcbiAgJ21vZGVsL3ZuZC5wYXJhc29saWQudHJhbnNtaXQudGV4dCc6IFsneF90J10sXG4gICdtb2RlbC92bmQudXNkeit6aXAnOiBbJ3VzZHonXSxcbiAgJ21vZGVsL3ZuZC52YWx2ZS5zb3VyY2UuY29tcGlsZWQtbWFwJzogWydic3AnXSxcbiAgJ21vZGVsL3ZuZC52dHUnOiBbJ3Z0dSddLFxuICAndGV4dC9wcnMubGluZXMudGFnJzogWydkc2MnXSxcbiAgJ3RleHQvdm5kLmN1cmwnOiBbJ2N1cmwnXSxcbiAgJ3RleHQvdm5kLmN1cmwuZGN1cmwnOiBbJ2RjdXJsJ10sXG4gICd0ZXh0L3ZuZC5jdXJsLm1jdXJsJzogWydtY3VybCddLFxuICAndGV4dC92bmQuY3VybC5zY3VybCc6IFsnc2N1cmwnXSxcbiAgJ3RleHQvdm5kLmR2Yi5zdWJ0aXRsZSc6IFsnc3ViJ10sXG4gICd0ZXh0L3ZuZC5mbHknOiBbJ2ZseSddLFxuICAndGV4dC92bmQuZm1pLmZsZXhzdG9yJzogWydmbHgnXSxcbiAgJ3RleHQvdm5kLmdyYXBodml6JzogWydndiddLFxuICAndGV4dC92bmQuaW4zZC4zZG1sJzogWyczZG1sJ10sXG4gICd0ZXh0L3ZuZC5pbjNkLnNwb3QnOiBbJ3Nwb3QnXSxcbiAgJ3RleHQvdm5kLnN1bi5qMm1lLmFwcC1kZXNjcmlwdG9yJzogWydqYWQnXSxcbiAgJ3RleHQvdm5kLndhcC53bWwnOiBbJ3dtbCddLFxuICAndGV4dC92bmQud2FwLndtbHNjcmlwdCc6IFsnd21scyddLFxuICAndGV4dC94LWFzbSc6IFsncycsICdhc20nXSxcbiAgJ3RleHQveC1jJzogWydjJywgJ2NjJywgJ2N4eCcsICdjcHAnLCAnaCcsICdoaCcsICdkaWMnXSxcbiAgJ3RleHQveC1jb21wb25lbnQnOiBbJ2h0YyddLFxuICAndGV4dC94LWZvcnRyYW4nOiBbJ2YnLCAnZm9yJywgJ2Y3NycsICdmOTAnXSxcbiAgJ3RleHQveC1oYW5kbGViYXJzLXRlbXBsYXRlJzogWydoYnMnXSxcbiAgJ3RleHQveC1qYXZhLXNvdXJjZSc6IFsnamF2YSddLFxuICAndGV4dC94LWx1YSc6IFsnbHVhJ10sXG4gICd0ZXh0L3gtbWFya2Rvd24nOiBbJ21rZCddLFxuICAndGV4dC94LW5mbyc6IFsnbmZvJ10sXG4gICd0ZXh0L3gtb3BtbCc6IFsnb3BtbCddLFxuICAndGV4dC94LW9yZyc6IFsnKm9yZyddLFxuICAndGV4dC94LXBhc2NhbCc6IFsncCcsICdwYXMnXSxcbiAgJ3RleHQveC1wcm9jZXNzaW5nJzogWydwZGUnXSxcbiAgJ3RleHQveC1zYXNzJzogWydzYXNzJ10sXG4gICd0ZXh0L3gtc2Nzcyc6IFsnc2NzcyddLFxuICAndGV4dC94LXNldGV4dCc6IFsnZXR4J10sXG4gICd0ZXh0L3gtc2Z2JzogWydzZnYnXSxcbiAgJ3RleHQveC1zdXNlLXltcCc6IFsneW1wJ10sXG4gICd0ZXh0L3gtdXVlbmNvZGUnOiBbJ3V1J10sXG4gICd0ZXh0L3gtdmNhbGVuZGFyJzogWyd2Y3MnXSxcbiAgJ3RleHQveC12Y2FyZCc6IFsndmNmJ10sXG4gICd2aWRlby92bmQuZGVjZS5oZCc6IFsndXZoJywgJ3V2dmgnXSxcbiAgJ3ZpZGVvL3ZuZC5kZWNlLm1vYmlsZSc6IFsndXZtJywgJ3V2dm0nXSxcbiAgJ3ZpZGVvL3ZuZC5kZWNlLnBkJzogWyd1dnAnLCAndXZ2cCddLFxuICAndmlkZW8vdm5kLmRlY2Uuc2QnOiBbJ3V2cycsICd1dnZzJ10sXG4gICd2aWRlby92bmQuZGVjZS52aWRlbyc6IFsndXZ2JywgJ3V2dnYnXSxcbiAgJ3ZpZGVvL3ZuZC5kdmIuZmlsZSc6IFsnZHZiJ10sXG4gICd2aWRlby92bmQuZnZ0JzogWydmdnQnXSxcbiAgJ3ZpZGVvL3ZuZC5tcGVndXJsJzogWydteHUnLCAnbTR1J10sXG4gICd2aWRlby92bmQubXMtcGxheXJlYWR5Lm1lZGlhLnB5dic6IFsncHl2J10sXG4gICd2aWRlby92bmQudXZ2dS5tcDQnOiBbJ3V2dScsICd1dnZ1J10sXG4gICd2aWRlby92bmQudml2byc6IFsndml2J10sXG4gICd2aWRlby94LWY0dic6IFsnZjR2J10sXG4gICd2aWRlby94LWZsaSc6IFsnZmxpJ10sXG4gICd2aWRlby94LWZsdic6IFsnZmx2J10sXG4gICd2aWRlby94LW00dic6IFsnbTR2J10sXG4gICd2aWRlby94LW1hdHJvc2thJzogWydta3YnLCAnbWszZCcsICdta3MnXSxcbiAgJ3ZpZGVvL3gtbW5nJzogWydtbmcnXSxcbiAgJ3ZpZGVvL3gtbXMtYXNmJzogWydhc2YnLCAnYXN4J10sXG4gICd2aWRlby94LW1zLXZvYic6IFsndm9iJ10sXG4gICd2aWRlby94LW1zLXdtJzogWyd3bSddLFxuICAndmlkZW8veC1tcy13bXYnOiBbJ3dtdiddLFxuICAndmlkZW8veC1tcy13bXgnOiBbJ3dteCddLFxuICAndmlkZW8veC1tcy13dngnOiBbJ3d2eCddLFxuICAndmlkZW8veC1tc3ZpZGVvJzogWydhdmknXSxcbiAgJ3ZpZGVvL3gtc2dpLW1vdmllJzogWydtb3ZpZSddLFxuICAndmlkZW8veC1zbXYnOiBbJ3NtdiddLFxuICAneC1jb25mZXJlbmNlL3gtY29vbHRhbGsnOiBbJ2ljZSddLFxuICAnYXBwbGljYXRpb24veC1tc2knOiAnbXNpJyxcbiAgJ2FwcGxpY2F0aW9uL3gtbXMnOiAnbXMnLFxuICAnYXBwbGljYXRpb24vdm5kLmdlbytqc29uJzogJ2dlb2pzb24nLFxuICAnYXBwbGljYXRpb24vdm5kLmRlYmlhbi5iaW5hcnktcGFja2FnZSc6ICdkZWInLFxuICAnYXBwbGljYXRpb24vZm9udC13b2ZmJzogJ3dvZmYnLFxuICAnYXBwbGljYXRpb24vZm9udC13b2ZmMic6ICd3b2ZmMicsXG4gICdhcHBsaWNhdGlvbi94LWZvbnQtdHRmJzogWyd0dGMnLCAndHRmJ10sXG4gICdmb250L29wZW50eXBlJzogJ290ZicsXG4gICdhcHBsaWNhdGlvbi94LWJiLWFwcHdvcmxkJzogJ2JiYXcnLFxuICAnYXBwbGljYXRpb24veC1jZC1pbWFnZSc6ICdpc28nLFxuICAnYXBwbGljYXRpb24veC1vcGVyYS1leHRlbnNpb24nOiAnb2V4JyxcbiAgJ2FwcGxpY2F0aW9uL3gtbXMtZG9zLWV4ZWN1dGFibGUnOiAnZXhlJyxcbiAgJ3RleHQvdm5kLnJpbS5sb2NhdGlvbi54bG9jJzogJ3hsb2MnLFxuICAnYXBwbGljYXRpb24veC1kZXNrdG9wJzogJ2Rlc2t0b3AnLFxuICAnYXBwbGljYXRpb24veC10eXBlc2NyaXB0JzogJ3RzJyxcbiAgJ2FwcGxpY2F0aW9uL3gtamF2YS1hcmNoaXZlJzogJ2phcicsXG4gICdhcHBsaWNhdGlvbi94LXNoYXJlZGxpYic6ICdzbycsXG59O1xuIl19


/***/ }),

/***/ 8123:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
var extensions_1 = __nccwpck_require__(7599);
var file_type_1 = __nccwpck_require__(4930);
var isutf8 = __nccwpck_require__(9061);
/**
 * Resolve cdn url based on handle type
 *
 * @private
 * @param session session object
 * @param handle file handle (hash, src://alias, url)
 */
exports.resolveCdnUrl = function (session, handle) {
    var cdnURL = session.urls.cdnUrl;
    if (handle && (handle.indexOf('src:') === 0 || handle.indexOf('http') === 0)) {
        if (!session.apikey) {
            throw new Error('Api key is required when storage alias is provided');
        }
        // apikey is required for alias or external sources call
        return cdnURL + "/" + session.apikey;
    }
    return cdnURL;
};
/**
 * Resolve all urls with provided cnames
 *
 * @private
 * @param urls
 * @param cname
 */
exports.resolveHost = function (urls, cname) {
    if (!cname) {
        return urls;
    }
    var hosts = /filestackapi.com|filestackcontent.com/i;
    Object.keys(urls).forEach(function (key) {
        urls[key] = urls[key].replace(hosts, cname);
    });
    return urls;
};
/**
 * Removes empty options from object
 *
 * @private
 * @param obj
 */
exports.removeEmpty = function (obj) {
    var newObj = tslib_1.__assign({}, obj);
    Object.keys(newObj).forEach(function (k) { return !newObj[k] && typeof newObj[k] !== 'boolean' && delete newObj[k]; });
    return newObj;
};
/**
 * Returns unique time
 */
var last;
exports.uniqueTime = function () {
    var time = Date.now();
    last = time === last ? time + 1 : time;
    return last;
};
/**
 * Generates random string with provided length
 *
 * @param len
 */
exports.uniqueId = function (len) {
    if (len === void 0) { len = 10; }
    return new Array(len).join().replace(/(.|$)/g, function () { return ((Math.random() * 36) | 0).toString(36)[Math.random() < 0.5 ? 'toString' : 'toUpperCase'](); });
};
/**
 * Check if input is a svg
 *
 * @param {Uint8Array | Buffer} file
 * @returns {string} - mimetype
 */
exports.getMimetype = function (file, name) {
    var type = file_type_1.default(file);
    var excludedMimetypes = ['text/plain', 'application/octet-stream', 'application/x-ms', 'application/x-msi', 'application/zip'];
    if (type && excludedMimetypes.indexOf(type.mime) === -1) {
        return type.mime;
    }
    if (name && name.indexOf('.') > -1) {
        var mime_1 = exports.extensionToMime(name);
        if (mime_1) {
            return mime_1;
        }
    }
    try {
        if (isutf8(file)) {
            return 'text/plain';
        }
    }
    catch (e) {
        /* istanbul ignore next */
        console.warn('Additional mimetype checks (text/plain) are currently not supported for browsers');
    }
    // this is only fallback, omit it in coverage
    /* istanbul ignore next */
    // if we cant find types by extensions and we have magic bytes fallback to it
    if (type) {
        return type.mime;
    }
    return 'application/octet-stream';
};
/**
 * Change extension to according mimetype using ext=>mimetype map
 *
 * @param ext - string
 * @return string|boolean
 */
exports.extensionToMime = function (ext) {
    if (!ext || ext.length === 0) {
        return;
    }
    if (ext.split('/').length === 2) {
        return ext;
    }
    if (ext.indexOf('.') > -1) {
        ext = ext.split('.').pop();
    }
    ext = ext.toLocaleLowerCase();
    var keys = Object.keys(extensions_1.ExtensionsMap);
    var mapLen = keys.length;
    for (var i = 0; i < mapLen; i++) {
        if (extensions_1.ExtensionsMap[keys[i]].indexOf(ext) > -1) {
            return keys[i];
        }
    }
    return;
};
/**
 * Sanitize file name
 *
 * @param name
 * @param {bool} options  - enable,disable sanitizer, default enabled
 * @param {string} options.replacement - replacement for sanitized chars defaults to "-"
 * @param {string[]} options.exclude - array with excluded chars default - ['\', '{', '}','|', '%', '`', '"', "'", '~', '[', ']', '#', '|', '^', '<', '>']
 */
exports.sanitizeName = function (name, options) {
    if (options === void 0) { options = true; }
    if (typeof options === 'boolean' && !options) {
        return name;
    }
    var ext;
    var replacement = typeof options !== 'boolean' && options.replacement ? options.replacement : '-';
    var exclude = typeof options !== 'boolean' && options.exclude ? options.exclude : ['\\', '{', '}', '|', '%', '`', '"', "'", '~', '[', ']', '#', '|', '^', '<', '>'];
    if (!name || name.length === 0) {
        return 'undefined';
    }
    var fileParts = name.split('.');
    if (fileParts.length > 1) {
        ext = fileParts.pop();
    }
    return "" + fileParts
        .join('.')
        .split('')
        .map(function (char) { return (exclude.indexOf(char) > -1 ? replacement : char); })
        .join('') + (ext ? '.' + ext : '');
};
/**
 * Filter object to given fields
 *
 * @param toFilter
 * @param requiredFields
 */
exports.filterObject = function (toFilter, requiredFields) {
    if (!requiredFields || requiredFields.length === 0) {
        return toFilter;
    }
    if (Object.keys(toFilter).length === 0) {
        return toFilter;
    }
    return Object.keys(toFilter)
        .filter(function (f) { return requiredFields.indexOf(f) > -1; })
        .reduce(function (obj, key) {
        var _a;
        return (tslib_1.__assign(tslib_1.__assign({}, obj), (_a = {}, _a[key] = toFilter[key], _a)));
    }, {});
};
/**
 * Deep cleanup object from functions
 *
 * @param obj
 */
exports.cleanUpCallbacks = function (obj) {
    if (!obj || Object.keys(obj).length === 0) {
        return obj;
    }
    Object.keys(obj).forEach(function (k) {
        if (typeof obj[k] === 'function') {
            obj[k] = undefined;
        }
        if (obj[k] === Object(obj[k])) {
            obj[k] = exports.cleanUpCallbacks(obj[k]);
        }
    });
    return obj;
};
tslib_1.__exportStar(__nccwpck_require__(2076), exports);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdXRpbHMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRzs7O0FBSUgsMkNBQTZDO0FBQzdDLHVDQUFpQztBQUNqQywrQkFBaUM7QUFFakM7Ozs7OztHQU1HO0FBQ1UsUUFBQSxhQUFhLEdBQUcsVUFBQyxPQUFnQixFQUFFLE1BQWM7SUFDNUQsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7SUFFbkMsSUFBSSxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO1FBQzVFLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFO1lBQ25CLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN2RTtRQUVELHdEQUF3RDtRQUN4RCxPQUFVLE1BQU0sU0FBSSxPQUFPLENBQUMsTUFBUSxDQUFDO0tBQ3RDO0lBRUQsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQyxDQUFDO0FBRUY7Ozs7OztHQU1HO0FBQ1UsUUFBQSxXQUFXLEdBQUcsVUFBQyxJQUFXLEVBQUUsS0FBYTtJQUNwRCxJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ1YsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELElBQU0sS0FBSyxHQUFHLHdDQUF3QyxDQUFDO0lBRXZELE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQUEsR0FBRztRQUMzQixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDOUMsQ0FBQyxDQUFDLENBQUM7SUFFSCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMsQ0FBQztB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QUFPLEdBQUcsQ0FBQztBQUNiLENBQUMsQ0FBQztBQUVGLHVEQUE2QiIsImZpbGUiOiJsaWIvdXRpbHMvaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBTZXNzaW9uIH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7IEhvc3RzIH0gZnJvbSAnLi8uLi8uLi9jb25maWcnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uc01hcCB9IGZyb20gJy4vZXh0ZW5zaW9ucyc7XG5pbXBvcnQgZmlsZVR5cGUgZnJvbSAnZmlsZS10eXBlJztcbmltcG9ydCAqIGFzIGlzdXRmOCBmcm9tICdpc3V0ZjgnO1xuXG4vKipcbiAqIFJlc29sdmUgY2RuIHVybCBiYXNlZCBvbiBoYW5kbGUgdHlwZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gc2Vzc2lvbiBzZXNzaW9uIG9iamVjdFxuICogQHBhcmFtIGhhbmRsZSBmaWxlIGhhbmRsZSAoaGFzaCwgc3JjOi8vYWxpYXMsIHVybClcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVDZG5VcmwgPSAoc2Vzc2lvbjogU2Vzc2lvbiwgaGFuZGxlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBjZG5VUkwgPSBzZXNzaW9uLnVybHMuY2RuVXJsO1xuXG4gIGlmIChoYW5kbGUgJiYgKGhhbmRsZS5pbmRleE9mKCdzcmM6JykgPT09IDAgfHwgaGFuZGxlLmluZGV4T2YoJ2h0dHAnKSA9PT0gMCkpIHtcbiAgICBpZiAoIXNlc3Npb24uYXBpa2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FwaSBrZXkgaXMgcmVxdWlyZWQgd2hlbiBzdG9yYWdlIGFsaWFzIGlzIHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgLy8gYXBpa2V5IGlzIHJlcXVpcmVkIGZvciBhbGlhcyBvciBleHRlcm5hbCBzb3VyY2VzIGNhbGxcbiAgICByZXR1cm4gYCR7Y2RuVVJMfS8ke3Nlc3Npb24uYXBpa2V5fWA7XG4gIH1cblxuICByZXR1cm4gY2RuVVJMO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlIGFsbCB1cmxzIHdpdGggcHJvdmlkZWQgY25hbWVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB1cmxzXG4gKiBAcGFyYW0gY25hbWVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVIb3N0ID0gKHVybHM6IEhvc3RzLCBjbmFtZTogc3RyaW5nKTogSG9zdHMgPT4ge1xuICBpZiAoIWNuYW1lKSB7XG4gICAgcmV0dXJuIHVybHM7XG4gIH1cblxuICBjb25zdCBob3N0cyA9IC9maWxlc3RhY2thcGkuY29tfGZpbGVzdGFja2NvbnRlbnQuY29tL2k7XG5cbiAgT2JqZWN0LmtleXModXJscykuZm9yRWFjaChrZXkgPT4ge1xuICAgIHVybHNba2V5XSA9IHVybHNba2V5XS5yZXBsYWNlKGhvc3RzLCBjbmFtZSk7XG4gIH0pO1xuXG4gIHJldHVybiB1cmxzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGVtcHR5IG9wdGlvbnMgZnJvbSBvYmplY3RcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIG9ialxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRW1wdHkgPSAob2JqOiBhbnkpID0+IHtcbiAgY29uc3QgbmV3T2JqID0geyAuLi5vYmogfTtcbiAgT2JqZWN0LmtleXMobmV3T2JqKS5mb3JFYWNoKGsgPT4gIW5ld09ialtrXSAmJiB0eXBlb2YgbmV3T2JqW2tdICE9PSAnYm9vbGVhbicgJiYgZGVsZXRlIG5ld09ialtrXSk7XG4gIHJldHVybiBuZXdPYmo7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdW5pcXVlIHRpbWVcbiAqL1xubGV0IGxhc3Q7XG5leHBvcnQgY29uc3QgdW5pcXVlVGltZSA9ICgpID0+IHtcbiAgY29uc3QgdGltZSA9IERhdGUubm93KCk7XG4gIGxhc3QgPSB0aW1lID09PSBsYXN0ID8gdGltZSArIDEgOiB0aW1lO1xuICByZXR1cm4gbGFzdDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHJhbmRvbSBzdHJpbmcgd2l0aCBwcm92aWRlZCBsZW5ndGhcbiAqXG4gKiBAcGFyYW0gbGVuXG4gKi9cbmV4cG9ydCBjb25zdCB1bmlxdWVJZCA9IChsZW46IG51bWJlciA9IDEwKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIG5ldyBBcnJheShsZW4pLmpvaW4oKS5yZXBsYWNlKC8oLnwkKS9nLCAoKSA9PiAoKE1hdGgucmFuZG9tKCkgKiAzNikgfCAwKS50b1N0cmluZygzNilbTWF0aC5yYW5kb20oKSA8IDAuNSA/ICd0b1N0cmluZycgOiAndG9VcHBlckNhc2UnXSgpKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgaW5wdXQgaXMgYSBzdmdcbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBCdWZmZXJ9IGZpbGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gbWltZXR5cGVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE1pbWV0eXBlID0gKGZpbGU6IFVpbnQ4QXJyYXkgfCBCdWZmZXIsIG5hbWU/OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBsZXQgdHlwZSA9IGZpbGVUeXBlKGZpbGUpO1xuXG4gIGNvbnN0IGV4Y2x1ZGVkTWltZXR5cGVzID0gWyd0ZXh0L3BsYWluJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsICdhcHBsaWNhdGlvbi94LW1zJywgJ2FwcGxpY2F0aW9uL3gtbXNpJywgJ2FwcGxpY2F0aW9uL3ppcCddO1xuXG4gIGlmICh0eXBlICYmIGV4Y2x1ZGVkTWltZXR5cGVzLmluZGV4T2YodHlwZS5taW1lKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHlwZS5taW1lO1xuICB9XG5cbiAgaWYgKG5hbWUgJiYgbmFtZS5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgIGNvbnN0IG1pbWUgPSBleHRlbnNpb25Ub01pbWUobmFtZSk7XG5cbiAgICBpZiAobWltZSkge1xuICAgICAgcmV0dXJuIG1pbWU7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoaXN1dGY4KGZpbGUpKSB7XG4gICAgICByZXR1cm4gJ3RleHQvcGxhaW4nO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgY29uc29sZS53YXJuKCdBZGRpdGlvbmFsIG1pbWV0eXBlIGNoZWNrcyAodGV4dC9wbGFpbikgYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGZvciBicm93c2VycycpO1xuICB9XG4gIC8vIHRoaXMgaXMgb25seSBmYWxsYmFjaywgb21pdCBpdCBpbiBjb3ZlcmFnZVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gIC8vIGlmIHdlIGNhbnQgZmluZCB0eXBlcyBieSBleHRlbnNpb25zIGFuZCB3ZSBoYXZlIG1hZ2ljIGJ5dGVzIGZhbGxiYWNrIHRvIGl0XG4gIGlmICh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUubWltZTtcbiAgfVxuXG4gIHJldHVybiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbn07XG5cbi8qKlxuICogQ2hhbmdlIGV4dGVuc2lvbiB0byBhY2NvcmRpbmcgbWltZXR5cGUgdXNpbmcgZXh0PT5taW1ldHlwZSBtYXBcbiAqXG4gKiBAcGFyYW0gZXh0IC0gc3RyaW5nXG4gKiBAcmV0dXJuIHN0cmluZ3xib29sZWFuXG4gKi9cbmV4cG9ydCBjb25zdCBleHRlbnNpb25Ub01pbWUgPSAoZXh0OiBzdHJpbmcpID0+IHtcbiAgaWYgKCFleHQgfHwgZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChleHQuc3BsaXQoJy8nKS5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gZXh0O1xuICB9XG5cbiAgaWYgKGV4dC5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgIGV4dCA9IGV4dC5zcGxpdCgnLicpLnBvcCgpO1xuICB9XG5cbiAgZXh0ID0gZXh0LnRvTG9jYWxlTG93ZXJDYXNlKCk7XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKEV4dGVuc2lvbnNNYXApO1xuICBjb25zdCBtYXBMZW4gPSBrZXlzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcExlbjsgaSsrKSB7XG4gICAgaWYgKEV4dGVuc2lvbnNNYXBba2V5c1tpXV0uaW5kZXhPZihleHQpID4gLTEpIHtcbiAgICAgIHJldHVybiBrZXlzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybjtcbn07XG5cbi8qKlxuICogU2FuaXRpemVyIE9wdGlvbnNcbiAqL1xuZXhwb3J0IHR5cGUgU2FuaXRpemVPcHRpb25zID1cbiAgfCBib29sZWFuXG4gIHwge1xuICAgIGV4Y2x1ZGU/OiBzdHJpbmdbXTtcbiAgICByZXBsYWNlbWVudD86IHN0cmluZztcbiAgfTtcblxuLyoqXG4gKiBTYW5pdGl6ZSBmaWxlIG5hbWVcbiAqXG4gKiBAcGFyYW0gbmFtZVxuICogQHBhcmFtIHtib29sfSBvcHRpb25zICAtIGVuYWJsZSxkaXNhYmxlIHNhbml0aXplciwgZGVmYXVsdCBlbmFibGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZXBsYWNlbWVudCAtIHJlcGxhY2VtZW50IGZvciBzYW5pdGl6ZWQgY2hhcnMgZGVmYXVsdHMgdG8gXCItXCJcbiAqIEBwYXJhbSB7c3RyaW5nW119IG9wdGlvbnMuZXhjbHVkZSAtIGFycmF5IHdpdGggZXhjbHVkZWQgY2hhcnMgZGVmYXVsdCAtIFsnXFwnLCAneycsICd9JywnfCcsICclJywgJ2AnLCAnXCInLCBcIidcIiwgJ34nLCAnWycsICddJywgJyMnLCAnfCcsICdeJywgJzwnLCAnPiddXG4gKi9cbmV4cG9ydCBjb25zdCBzYW5pdGl6ZU5hbWUgPSAobmFtZTogc3RyaW5nLCBvcHRpb25zOiBTYW5pdGl6ZU9wdGlvbnMgPSB0cnVlKTogc3RyaW5nID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicgJiYgIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIGxldCBleHQ7XG5cbiAgY29uc3QgcmVwbGFjZW1lbnQgPSB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMucmVwbGFjZW1lbnQgPyBvcHRpb25zLnJlcGxhY2VtZW50IDogJy0nO1xuICBjb25zdCBleGNsdWRlID0gdHlwZW9mIG9wdGlvbnMgIT09ICdib29sZWFuJyAmJiBvcHRpb25zLmV4Y2x1ZGUgPyBvcHRpb25zLmV4Y2x1ZGUgOiBbJ1xcXFwnLCAneycsICd9JywgJ3wnLCAnJScsICdgJywgJ1wiJywgXCInXCIsICd+JywgJ1snLCAnXScsICcjJywgJ3wnLCAnXicsICc8JywgJz4nXTtcblxuICBpZiAoIW5hbWUgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBjb25zdCBmaWxlUGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cbiAgaWYgKGZpbGVQYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgZXh0ID0gZmlsZVBhcnRzLnBvcCgpO1xuICB9XG5cbiAgcmV0dXJuIGAke2ZpbGVQYXJ0c1xuICAgIC5qb2luKCcuJylcbiAgICAuc3BsaXQoJycpXG4gICAgLm1hcChjaGFyID0+IChleGNsdWRlLmluZGV4T2YoY2hhcikgPiAtMSA/IHJlcGxhY2VtZW50IDogY2hhcikpXG4gICAgLmpvaW4oJycpfSR7ZXh0ID8gJy4nICsgZXh0IDogJyd9YDtcbn07XG5cbi8qKlxuICogRmlsdGVyIG9iamVjdCB0byBnaXZlbiBmaWVsZHNcbiAqXG4gKiBAcGFyYW0gdG9GaWx0ZXJcbiAqIEBwYXJhbSByZXF1aXJlZEZpZWxkc1xuICovXG5leHBvcnQgY29uc3QgZmlsdGVyT2JqZWN0ID0gKHRvRmlsdGVyLCByZXF1aXJlZEZpZWxkczogc3RyaW5nW10pID0+IHtcbiAgaWYgKCFyZXF1aXJlZEZpZWxkcyB8fCByZXF1aXJlZEZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdG9GaWx0ZXI7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXModG9GaWx0ZXIpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0b0ZpbHRlcjtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyh0b0ZpbHRlcilcbiAgICAuZmlsdGVyKGYgPT4gcmVxdWlyZWRGaWVsZHMuaW5kZXhPZihmKSA+IC0xKVxuICAgIC5yZWR1Y2UoKG9iaiwga2V5KSA9PiAoeyAuLi5vYmosIFtrZXldOiB0b0ZpbHRlcltrZXldIH0pLCB7fSk7XG59O1xuXG4vKipcbiAqIERlZXAgY2xlYW51cCBvYmplY3QgZnJvbSBmdW5jdGlvbnNcbiAqXG4gKiBAcGFyYW0gb2JqXG4gKi9cbmV4cG9ydCBjb25zdCBjbGVhblVwQ2FsbGJhY2tzID0gKG9iajogYW55KSA9PiB7XG4gIGlmICghb2JqIHx8IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrID0+IHtcbiAgICBpZiAodHlwZW9mIG9ialtrXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb2JqW2tdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChvYmpba10gPT09IE9iamVjdChvYmpba10pKSB7XG4gICAgICBvYmpba10gPSBjbGVhblVwQ2FsbGJhY2tzKG9ialtrXSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0ICogZnJvbSAnLi9pbmRleC5ub2RlJztcbiJdfQ==


/***/ }),

/***/ 2076:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Calculates a MD5 checksum for passed buffer
 * @private
 * @param data  Data to be hashed
 * @returns     base64 encoded MD5 hash
 */
exports.md5 = function (data) {
    return __nccwpck_require__(6417).createHash('md5')
        .update(data)
        .digest('base64');
};
/**
 * return based string
 * @param data
 */
exports.b64 = function (data, safeUrl) {
    if (safeUrl === void 0) { safeUrl = false; }
    var b64 = Buffer.from(data).toString('base64');
    if (safeUrl) {
        return b64.replace(/\//g, '_').replace(/\+/g, '-');
    }
    return b64;
};
/**
 * Return currently used filestack-js sdk version
 */
exports.getVersion = function () {
    return 'JS-3.25.0';
};
/**
 * Returns if browser is a mobile device (if node env always return false)
 */
/* istanbul ignore next */
exports.isMobile = function () { return false; };
/**
 * Check if application is runned in facebook browser
 */
exports.isFacebook = function () { return false; };

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdXRpbHMvaW5kZXgubm9kZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHOztBQUVIOzs7OztHQUtHO0FBQ1UsUUFBQSxHQUFHLEdBQUcsVUFBQyxJQUFTO0lBQzNCLE9BQU8sT0FBTyxDQUFDLFFBQVEsQ0FBQztTQUNuQixVQUFVLENBQUMsS0FBSyxDQUFDO1NBQ2pCLE1BQU0sQ0FBQyxJQUFJLENBQUM7U0FDWixNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDeEIsQ0FBQyxDQUFDO0FBRUY7OztHQUdHO0FBQ1UsUUFBQSxHQUFHLEdBQUcsVUFBQyxJQUFZLEVBQUUsT0FBd0I7SUFBeEIsd0JBQUEsRUFBQSxlQUF3QjtJQUN4RCxJQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUVqRCxJQUFJLE9BQU8sRUFBRTtRQUNYLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztLQUNwRDtJQUVELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQyxDQUFDO0FBRUY7O0dBRUc7QUFDVSxRQUFBLFVBQVUsR0FBRztJQUN4QixPQUFPLGVBQWUsQ0FBQztBQUN6QixDQUFDLENBQUM7QUFFRjs7R0FFRztBQUNILDBCQUEwQjtBQUNiLFFBQUEsUUFBUSxHQUFHLGNBQU0sT0FBQSxLQUFLLEVBQUwsQ0FBSyxDQUFDO0FBRXBDOztHQUVHO0FBQ1UsUUFBQSxVQUFVLEdBQUcsY0FBTSxPQUFBLEtBQUssRUFBTCxDQUFLLENBQUMiLCJmaWxlIjoibGliL3V0aWxzL2luZGV4Lm5vZGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSBNRDUgY2hlY2tzdW0gZm9yIHBhc3NlZCBidWZmZXJcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZGF0YSAgRGF0YSB0byBiZSBoYXNoZWRcbiAqIEByZXR1cm5zICAgICBiYXNlNjQgZW5jb2RlZCBNRDUgaGFzaFxuICovXG5leHBvcnQgY29uc3QgbWQ1ID0gKGRhdGE6IGFueSk6IHN0cmluZyA9PiB7XG4gIHJldHVybiByZXF1aXJlKCdjcnlwdG8nKVxuICAgICAgLmNyZWF0ZUhhc2goJ21kNScpXG4gICAgICAudXBkYXRlKGRhdGEpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcbn07XG5cbi8qKlxuICogcmV0dXJuIGJhc2VkIHN0cmluZ1xuICogQHBhcmFtIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGI2NCA9IChkYXRhOiBzdHJpbmcsIHNhZmVVcmw6IGJvb2xlYW4gPSBmYWxzZSk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGI2NCA9IEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCdiYXNlNjQnKTtcblxuICBpZiAoc2FmZVVybCkge1xuICAgIHJldHVybiBiNjQucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvXFwrL2csICctJyk7XG4gIH1cblxuICByZXR1cm4gYjY0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gY3VycmVudGx5IHVzZWQgZmlsZXN0YWNrLWpzIHNkayB2ZXJzaW9uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRWZXJzaW9uID0gKCkgPT4ge1xuICByZXR1cm4gJ0pTLUB7VkVSU0lPTn0nO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGlmIGJyb3dzZXIgaXMgYSBtb2JpbGUgZGV2aWNlIChpZiBub2RlIGVudiBhbHdheXMgcmV0dXJuIGZhbHNlKVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGlzTW9iaWxlID0gKCkgPT4gZmFsc2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgYXBwbGljYXRpb24gaXMgcnVubmVkIGluIGZhY2Vib29rIGJyb3dzZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRmFjZWJvb2sgPSAoKSA9PiBmYWxzZTtcbiJdfQ==


/***/ }),

/***/ 6373:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(9176), exports);
var STORE_TYPE;
(function (STORE_TYPE) {
    STORE_TYPE["SESSION"] = "sessionStorage";
    STORE_TYPE["LOCAL"] = "localStorage";
})(STORE_TYPE = exports.STORE_TYPE || (exports.STORE_TYPE = {}));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdXRpbHMvc3RvcmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRzs7O0FBRUgsdURBQTZCO0FBRTdCLElBQVksVUFHWDtBQUhELFdBQVksVUFBVTtJQUNwQix3Q0FBMEIsQ0FBQTtJQUMxQixvQ0FBc0IsQ0FBQTtBQUN4QixDQUFDLEVBSFcsVUFBVSxHQUFWLGtCQUFVLEtBQVYsa0JBQVUsUUFHckIiLCJmaWxlIjoibGliL3V0aWxzL3N0b3JlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2suXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0ICogZnJvbSAnLi9zdG9yZS5ub2RlJztcblxuZXhwb3J0IGVudW0gU1RPUkVfVFlQRSB7XG4gIFNFU1NJT04gPSAnc2Vzc2lvblN0b3JhZ2UnLFxuICBMT0NBTCA9ICdsb2NhbFN0b3JhZ2UnLFxufVxuIl19


/***/ }),

/***/ 9176:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Store = /** @class */ (function () {
    function Store() {
    }
    Store.prototype.getItem = function (key, prefStore) {
        console.warn('Storage is not supported');
        return undefined;
    };
    Store.prototype.setItem = function (key, value, prefStore) {
        console.warn('Storage is not supported');
        return undefined;
    };
    Store.prototype.removeItem = function (key, prefStore) {
        console.warn('Storage is not supported');
        return undefined;
    };
    Store.prototype.hasAccess = function (prefType) {
        console.warn('Storage is not supported');
        return undefined;
    };
    return Store;
}());
exports.Store = Store;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdXRpbHMvc3RvcmUubm9kZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQWtCQTtJQUFBO0lBb0JBLENBQUM7SUFuQlEsdUJBQU8sR0FBZCxVQUFlLEdBQVcsRUFBRSxTQUFzQjtRQUNoRCxPQUFPLENBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLENBQUM7UUFDekMsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVNLHVCQUFPLEdBQWQsVUFBZSxHQUFXLEVBQUUsS0FBYSxFQUFFLFNBQXNCO1FBQy9ELE9BQU8sQ0FBQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsQ0FBQztRQUN6QyxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRU0sMEJBQVUsR0FBakIsVUFBa0IsR0FBVyxFQUFFLFNBQXNCO1FBQ25ELE9BQU8sQ0FBQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsQ0FBQztRQUN6QyxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRU0seUJBQVMsR0FBaEIsVUFBaUIsUUFBcUI7UUFDcEMsT0FBTyxDQUFDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO1FBQ3pDLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFDSCxZQUFDO0FBQUQsQ0FwQkEsQUFvQkMsSUFBQTtBQXBCWSxzQkFBSyIsImZpbGUiOiJsaWIvdXRpbHMvc3RvcmUubm9kZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBTVE9SRV9UWVBFIH0gZnJvbSAnLi9zdG9yZSc7XG5cbmV4cG9ydCBjbGFzcyBTdG9yZSB7XG4gIHB1YmxpYyBnZXRJdGVtKGtleTogc3RyaW5nLCBwcmVmU3RvcmU/OiBTVE9SRV9UWVBFKTogc3RyaW5nIHtcbiAgICBjb25zb2xlLndhcm4oJ1N0b3JhZ2UgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwdWJsaWMgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgcHJlZlN0b3JlPzogU1RPUkVfVFlQRSkge1xuICAgIGNvbnNvbGUud2FybignU3RvcmFnZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVJdGVtKGtleTogc3RyaW5nLCBwcmVmU3RvcmU/OiBTVE9SRV9UWVBFKTogc3RyaW5nIHtcbiAgICBjb25zb2xlLndhcm4oJ1N0b3JhZ2UgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwdWJsaWMgaGFzQWNjZXNzKHByZWZUeXBlPzogU1RPUkVfVFlQRSk6IGJvb2xlYW4ge1xuICAgIGNvbnNvbGUud2FybignU3RvcmFnZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuIl19


/***/ }),

/***/ 9343:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.DefinitionsSchema = {
    '$schema': 'http://json-schema.org/draft-07/schema#',
    title: 'Filestack',
    description: 'Filestack common definitions',
    type: 'object',
    additionalProperties: false,
    definitions: {
        workflowsDef: {
            id: '/workflowsDef',
            type: 'array',
            additionalItems: false,
            minItems: 1,
            maxItems: 20,
            items: [{
                    oneOf: [{
                            type: 'string',
                        }, {
                            type: 'object',
                            additionalProperties: false,
                            properties: {
                                id: {
                                    type: 'string',
                                },
                            },
                        }],
                }],
        },
        securityCallDef: {
            id: '/securityCallDef',
            oneOf: [{
                    additionalProperties: false,
                    type: 'string',
                    enum: ['pick', 'read', 'stat', 'write', 'writeUrl', 'store', 'convert', 'remove', 'exif', 'runWorkflow'],
                }, {
                    type: 'array',
                    additionalProperties: false,
                    items: [{
                            minItems: 1,
                            maxItems: 10,
                            type: 'string',
                            additionalProperties: false,
                            enum: ['pick', 'read', 'stat', 'write', 'writeUrl', 'store', 'convert', 'remove', 'exif', 'runWorkflow'],
                        }],
                }],
        },
        regionsDef: {
            id: '/regionsDef',
            type: 'string',
        },
        locationsDef: {
            id: '/locationsDef',
            type: 'string',
            enum: ['s3', 'S3', 'rackspace', 'gcs', 'azure', 'dropbox'],
        },
        colorDef: {
            id: 'colorDef',
            oneOf: [{
                    type: 'string',
                    pattern: '^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$',
                }, {
                    type: 'string',
                    enum: ['aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue', 'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkgrey', 'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue', 'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dimgrey', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fractal', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray0', 'gray1', 'gray2', 'gray3', 'gray4', 'gray5', 'gray6', 'gray7', 'gray8', 'gray9', 'gray10', 'gray11', 'gray12', 'gray13', 'gray14', 'gray15', 'gray16', 'gray17', 'gray18', 'gray19', 'gray20', 'gray21', 'gray22', 'gray23', 'gray24', 'gray25', 'gray26', 'gray27', 'gray28', 'gray29', 'gray30', 'gray31', 'gray32', 'gray33', 'gray34', 'gray35', 'gray36', 'gray37', 'gray38', 'gray39', 'gray40', 'gray41', 'gray42', 'gray43', 'gray44', 'gray45', 'gray46', 'gray47', 'gray48', 'gray49', 'gray50', 'gray51', 'gray52', 'gray53', 'gray54', 'gray55', 'gray56', 'gray57', 'gray58', 'gray59', 'gray60', 'gray61', 'gray62', 'gray63', 'gray64', 'gray65', 'gray66', 'gray67', 'gray68', 'gray69', 'gray70', 'gray71', 'gray72', 'gray73', 'gray74', 'gray75', 'gray76', 'gray77', 'gray78', 'gray79', 'gray80', 'gray81', 'gray82', 'gray83', 'gray84', 'gray85', 'gray86', 'gray87', 'gray88', 'gray89', 'gray90', 'gray91', 'gray92', 'gray93', 'gray94', 'gray95', 'gray96', 'gray97', 'gray98', 'gray99', 'gray100', 'gray', 'green', 'greenyellow', 'grey', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow', 'lightgray', 'lightgreen', 'lightgrey', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray', 'lightslategrey', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine', 'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'none', 'oldlace', 'olive', 'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow', 'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'wheat', 'white', 'whitesmoke', 'yellow', 'yellowgreen', 'transparent'],
                }],
        },
        pageFormatDef: {
            id: '/pageFormatDef',
            type: 'string',
            enum: ['a2', 'a3', 'a4', 'a5', 'b4', 'b5', 'letter', 'legal', 'tabloid'],
        },
        pageRangeDef: {
            id: '/pageRangeDef',
            type: 'array',
            uniqueItems: true,
            items: [{
                    oneOf: [{
                            type: 'integer',
                            minimum: 1,
                        }, {
                            type: 'string',
                            pattern: '^(\\d+(?:-\\d+)?)$|^(-\\d+)$|^(\\d+-)$',
                            errorMessage: 'Param should be provided in one of the following formats: "1,2,3,5", "1-3", "1-", "-2" ',
                        }],
                }],
        },
        facesDef: {
            id: '/facesDef',
            oneOf: [{
                    type: 'string',
                    enum: ['all'],
                }, {
                    type: 'integer',
                    minimum: 1,
                    maximum: 1000,
                }, {
                    type: 'array',
                    uniqueItems: true,
                    items: [{
                            type: 'integer',
                            minimum: 1,
                            maximum: 1000,
                        }],
                }],
        },
        objectsDef: {
            id: '/objectsDef',
            type: 'array',
            minItems: 1,
            maxItems: 50,
            items: [{
                    type: 'array',
                    additionalItems: false,
                    minItems: 4,
                    items: [{
                            type: 'integer',
                            minimum: 0,
                            maximum: 10000,
                        }, {
                            type: 'integer',
                            minimum: 0,
                            maximum: 10000,
                        }, {
                            type: 'integer',
                            minimum: 1,
                            maximum: 10000,
                        }, {
                            type: 'integer',
                            minimum: 1,
                            maximum: 10000,
                        }],
                }],
        },
        positionDef: {
            id: '/positionDef',
            default: ['middle', 'center'],
            oneOf: [
                {
                    type: 'string',
                    enum: [
                        'top',
                        'middle',
                        'bottom',
                        'left',
                        'center',
                        'right',
                        'faces',
                    ],
                },
                {
                    type: 'array',
                    uniqueItems: true,
                    additionalItems: false,
                    minItems: 2,
                    maxItems: 2,
                    default: ['middle', 'center'],
                    items: [
                        {
                            type: 'string',
                            enum: [
                                'top',
                                'middle',
                                'bottom',
                            ],
                        }, {
                            type: 'string',
                            enum: [
                                'left',
                                'center',
                                'right',
                            ],
                        },
                    ],
                },
            ],
        },
    },
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvZGVmaW5pdGlvbnMuc2NoZW1hLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ1UsUUFBQSxpQkFBaUIsR0FBRztJQUMvQixTQUFTLEVBQUUseUNBQXlDO0lBQ3BELEtBQUssRUFBRSxXQUFXO0lBQ2xCLFdBQVcsRUFBRSw4QkFBOEI7SUFDM0MsSUFBSSxFQUFFLFFBQVE7SUFDZCxvQkFBb0IsRUFBRSxLQUFLO0lBQzNCLFdBQVcsRUFBRTtRQUNYLFlBQVksRUFBRTtZQUNaLEVBQUUsRUFBRSxlQUFlO1lBQ25CLElBQUksRUFBRSxPQUFPO1lBQ2IsZUFBZSxFQUFFLEtBQUs7WUFDdEIsUUFBUSxFQUFFLENBQUM7WUFDWCxRQUFRLEVBQUUsRUFBRTtZQUNaLEtBQUssRUFBRSxDQUFDO29CQUNOLEtBQUssRUFBRSxDQUFDOzRCQUNOLElBQUksRUFBRSxRQUFRO3lCQUNmLEVBQUU7NEJBQ0QsSUFBSSxFQUFFLFFBQVE7NEJBQ2Qsb0JBQW9CLEVBQUUsS0FBSzs0QkFDM0IsVUFBVSxFQUFFO2dDQUNWLEVBQUUsRUFBRTtvQ0FDRixJQUFJLEVBQUUsUUFBUTtpQ0FDZjs2QkFDRjt5QkFDRixDQUFDO2lCQUNILENBQUM7U0FDSDtRQUNELGVBQWUsRUFBRTtZQUNmLEVBQUUsRUFBRSxrQkFBa0I7WUFDdEIsS0FBSyxFQUFFLENBQUM7b0JBQ04sb0JBQW9CLEVBQUUsS0FBSztvQkFDM0IsSUFBSSxFQUFFLFFBQVE7b0JBQ2QsSUFBSSxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsYUFBYSxDQUFDO2lCQUN6RyxFQUFFO29CQUNELElBQUksRUFBRSxPQUFPO29CQUNiLG9CQUFvQixFQUFFLEtBQUs7b0JBQzNCLEtBQUssRUFBRSxDQUFDOzRCQUNOLFFBQVEsRUFBRSxDQUFDOzRCQUNYLFFBQVEsRUFBRSxFQUFFOzRCQUNaLElBQUksRUFBRSxRQUFROzRCQUNkLG9CQUFvQixFQUFFLEtBQUs7NEJBQzNCLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLGFBQWEsQ0FBQzt5QkFDekcsQ0FBQztpQkFDSCxDQUFDO1NBQ0g7UUFDRCxVQUFVLEVBQUU7WUFDVixFQUFFLEVBQUUsYUFBYTtZQUNqQixJQUFJLEVBQUUsUUFBUTtTQUlmO1FBQ0QsWUFBWSxFQUFFO1lBQ1osRUFBRSxFQUFFLGVBQWU7WUFDbkIsSUFBSSxFQUFFLFFBQVE7WUFDZCxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFNBQVMsQ0FBQztTQUMzRDtRQUNELFFBQVEsRUFBRTtZQUNSLEVBQUUsRUFBRSxVQUFVO1lBQ2QsS0FBSyxFQUFFLENBQUM7b0JBQ04sSUFBSSxFQUFFLFFBQVE7b0JBQ2QsT0FBTyxFQUFFLG1DQUFtQztpQkFDN0MsRUFBRTtvQkFDRCxJQUFJLEVBQUUsUUFBUTtvQkFDZCxJQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLGFBQWEsRUFBRSxnQkFBZ0IsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLGFBQWEsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLFdBQVcsRUFBRSxjQUFjLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsc0JBQXNCLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLGFBQWEsRUFBRSxlQUFlLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLGtCQUFrQixFQUFFLFlBQVksRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixFQUFFLGlCQUFpQixFQUFFLG1CQUFtQixFQUFFLGlCQUFpQixFQUFFLGlCQUFpQixFQUFFLGNBQWMsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxhQUFhLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUs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QUFFLFFBQVEsQ0FBQztZQUM3QixLQUFLLEVBQUU7Z0JBQ0w7b0JBQ0UsSUFBSSxFQUFFLFFBQVE7b0JBQ2QsSUFBSSxFQUFFO3dCQUNKLEtBQUs7d0JBQ0wsUUFBUTt3QkFDUixRQUFRO3dCQUNSLE1BQU07d0JBQ04sUUFBUTt3QkFDUixPQUFPO3dCQUNQLE9BQU87cUJBQ1I7aUJBQ0Y7Z0JBQ0Q7b0JBQ0UsSUFBSSxFQUFFLE9BQU87b0JBQ2IsV0FBVyxFQUFFLElBQUk7b0JBQ2pCLGVBQWUsRUFBRSxLQUFLO29CQUN0QixRQUFRLEVBQUUsQ0FBQztvQkFDWCxRQUFRLEVBQUUsQ0FBQztvQkFDWCxPQUFPLEVBQUUsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDO29CQUM3QixLQUFLLEVBQUU7d0JBQ0w7NEJBQ0UsSUFBSSxFQUFFLFFBQVE7NEJBQ2QsSUFBSSxFQUFFO2dDQUNKLEtBQUs7Z0NBQ0wsUUFBUTtnQ0FDUixRQUFROzZCQUNUO3lCQUNGLEVBQUU7NEJBQ0QsSUFBSSxFQUFFLFFBQVE7NEJBQ2QsSUFBSSxFQUFFO2dDQUNKLE1BQU07Z0NBQ04sUUFBUTtnQ0FDUixPQUFPOzZCQUNSO3lCQUNGO3FCQUNGO2lCQUNGO2FBQ0Y7U0FDRjtLQUNGO0NBQ0YsQ0FBQyIsImZpbGUiOiJzY2hlbWEvZGVmaW5pdGlvbnMuc2NoZW1hLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2suXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBEZWZpbml0aW9uc1NjaGVtYSA9IHtcbiAgJyRzY2hlbWEnOiAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjJyxcbiAgdGl0bGU6ICdGaWxlc3RhY2snLFxuICBkZXNjcmlwdGlvbjogJ0ZpbGVzdGFjayBjb21tb24gZGVmaW5pdGlvbnMnLFxuICB0eXBlOiAnb2JqZWN0JyxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICBkZWZpbml0aW9uczoge1xuICAgIHdvcmtmbG93c0RlZjoge1xuICAgICAgaWQ6ICcvd29ya2Zsb3dzRGVmJyxcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBhZGRpdGlvbmFsSXRlbXM6IGZhbHNlLFxuICAgICAgbWluSXRlbXM6IDEsXG4gICAgICBtYXhJdGVtczogMjAsXG4gICAgICBpdGVtczogW3tcbiAgICAgICAgb25lT2Y6IFt7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH1dLFxuICAgICAgfV0sXG4gICAgfSxcbiAgICBzZWN1cml0eUNhbGxEZWY6IHtcbiAgICAgIGlkOiAnL3NlY3VyaXR5Q2FsbERlZicsXG4gICAgICBvbmVPZjogW3tcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgZW51bTogWydwaWNrJywgJ3JlYWQnLCAnc3RhdCcsICd3cml0ZScsICd3cml0ZVVybCcsICdzdG9yZScsICdjb252ZXJ0JywgJ3JlbW92ZScsICdleGlmJywgJ3J1bldvcmtmbG93J10sXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgbWluSXRlbXM6IDEsXG4gICAgICAgICAgbWF4SXRlbXM6IDEwLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgICAgICBlbnVtOiBbJ3BpY2snLCAncmVhZCcsICdzdGF0JywgJ3dyaXRlJywgJ3dyaXRlVXJsJywgJ3N0b3JlJywgJ2NvbnZlcnQnLCAncmVtb3ZlJywgJ2V4aWYnLCAncnVuV29ya2Zsb3cnXSxcbiAgICAgICAgfV0sXG4gICAgICB9XSxcbiAgICB9LFxuICAgIHJlZ2lvbnNEZWY6IHtcbiAgICAgIGlkOiAnL3JlZ2lvbnNEZWYnLFxuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAvLyBmb3Igbm93IHdlIGRlY2lkZWQgdG8gcmVtb3ZlIHZhbGlkYXRpb24gb2YgcmVnaW9ucyAoQVdTICsgUmFja3NwYWNlKVxuICAgICAgLy8gcGF0dGVybjogJ15bYS16QS1aXXsyfS1bYS16QS16XXsxLH0tWzEtOV0kJyxcbiAgICAgIC8vIGVycm9yTWVzc2FnZTogJ0FXUyBSZWdpb24gUGFyYW0gaXMgaW4gaW52YWxpZCBmb3JtYXQnLFxuICAgIH0sXG4gICAgbG9jYXRpb25zRGVmOiB7XG4gICAgICBpZDogJy9sb2NhdGlvbnNEZWYnLFxuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ3MzJywgJ1MzJywgJ3JhY2tzcGFjZScsICdnY3MnLCAnYXp1cmUnLCAnZHJvcGJveCddLFxuICAgIH0sXG4gICAgY29sb3JEZWY6IHtcbiAgICAgIGlkOiAnY29sb3JEZWYnLFxuICAgICAgb25lT2Y6IFt7XG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICBwYXR0ZXJuOiAnXihbQS1GYS1mMC05XXs2fXxbQS1GYS1mMC05XXszfSkkJywgLy8gd2l0aG91dCAjIGF0IHRoZSBiZWdpbmluZ1xuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgZW51bTogWydhbGljZWJsdWUnLCAnYW50aXF1ZXdoaXRlJywgJ2FxdWEnLCAnYXF1YW1hcmluZScsICdhenVyZScsICdiZWlnZScsICdiaXNxdWUnLCAnYmxhY2snLCAnYmxhbmNoZWRhbG1vbmQnLCAnYmx1ZScsICdibHVldmlvbGV0JywgJ2Jyb3duJywgJ2J1cmx5d29vZCcsICdjYWRldGJsdWUnLCAnY2hhcnRyZXVzZScsICdjaG9jb2xhdGUnLCAnY29yYWwnLCAnY29ybmZsb3dlcmJsdWUnLCAnY29ybnNpbGsnLCAnY3JpbXNvbicsICdjeWFuJywgJ2RhcmtibHVlJywgJ2RhcmtjeWFuJywgJ2Rhcmtnb2xkZW5yb2QnLCAnZGFya2dyYXknLCAnZGFya2dyZWVuJywgJ2RhcmtncmV5JywgJ2RhcmtraGFraScsICdkYXJrbWFnZW50YScsICdkYXJrb2xpdmVncmVlbicsICdkYXJrb3JhbmdlJywgJ2RhcmtvcmNoaWQnLCAnZGFya3JlZCcsICdkYXJrc2FsbW9uJywgJ2RhcmtzZWFncmVlbicsICdkYXJrc2xhdGVibHVlJywgJ2RhcmtzbGF0ZWdyYXknLCAnZGFya3NsYXRlZ3JleScsICdkYXJrdHVycXVvaXNlJywgJ2Rhcmt2aW9sZXQnLCAnZGVlcHBpbmsnLCAnZGVlcHNreWJsdWUnLCAnZGltZ3JheScsICdkaW1ncmV5JywgJ2RvZGdlcmJsdWUnLCAnZmlyZWJyaWNrJywgJ2Zsb3JhbHdoaXRlJywgJ2ZvcmVzdGdyZWVuJywgJ2ZyYWN0YWwnLCAnZnVjaHNpYScsICdnYWluc2Jvcm8nLCAnZ2hvc3R3aGl0ZScsICdnb2xkJywgJ2dvbGRlbnJvZCcsICdncmF5MCcsICdncmF5MScsICdncmF5MicsICdncmF5MycsICdncmF5NCcsICdncmF5NScsICdncmF5NicsICdncmF5NycsICdncmF5OCcsICdncmF5OScsICdncmF5MTAnLCAnZ3JheTExJywgJ2dyYXkxMicsICdncmF5MTMnLCAnZ3JheTE0JywgJ2dyYXkxNScsICdncmF5MTYnLCAnZ3JheTE3JywgJ2dyYXkxOCcsICdncmF5MTknLCAnZ3JheTIwJywgJ2dyYXkyMScsICdncmF5MjInLCAnZ3JheTIzJywgJ2dyYXkyNCcsICdncmF5MjUnLCAnZ3JheTI2JywgJ2dyYXkyNycsICdncmF5MjgnLCAnZ3JheTI5JywgJ2dyYXkzMCcsICdncmF5MzEnLCAnZ3JheTMyJywgJ2dyYXkzMycsICdncmF5MzQnLCAnZ3JheTM1JywgJ2dyYXkzNicsICdncmF5MzcnLCAnZ3JheTM4JywgJ2dyYXkzOScsICdncmF5NDAnLCAnZ3JheTQxJywgJ2dyYXk0MicsICdncmF5NDMnLCAnZ3JheTQ0JywgJ2dyYXk0NScsICdncmF5NDYnLCAnZ3JheTQ3JywgJ2dyYXk0OCcsICdncmF5NDknLCAnZ3JheTUwJywgJ2dyYXk1MScsICdncmF5NTInLCAnZ3JheTUzJywgJ2dyYXk1NCcsICdncmF5NTUnLCAnZ3JheTU2JywgJ2dyYXk1NycsICdncmF5NTgnLCAnZ3JheTU5JywgJ2dyYXk2MCcsICdncmF5NjEnLCAnZ3JheTYyJywgJ2dyYXk2MycsICdncmF5NjQnLCAnZ3JheTY1JywgJ2dyYXk2NicsICdncmF5NjcnLCAnZ3JheTY4JywgJ2dyYXk2OScsICdncmF5NzAnLCAnZ3JheTcxJywgJ2dyYXk3MicsICdncmF5NzMnLCAnZ3JheTc0JywgJ2dyYXk3NScsICdncmF5NzYnLCAnZ3JheTc3JywgJ2dyYXk3OCcsICdncmF5NzknLCAnZ3JheTgwJywgJ2dyYXk4MScsICdncmF5ODInLCAnZ3JheTgzJywgJ2dyYXk4NCcsICdncmF5ODUnLCAnZ3JheTg2JywgJ2dyYXk4NycsICdncmF5ODgnLCAnZ3JheTg5JywgJ2dyYXk5MCcsICdncmF5OTEnLCAnZ3JheTkyJywgJ2dyYXk5MycsICdncmF5OTQnLCAnZ3JheTk1JywgJ2dyYXk5NicsICdncmF5OTcnLCAnZ3JheTk4JywgJ2dyYXk5OScsICdncmF5MTAwJywgJ2dyYXknLCAnZ3JlZW4nLCAnZ3JlZW55ZWxsb3cnLCAnZ3JleScsICdob25leWRldycsICdob3RwaW5rJywgJ2luZGlhbnJlZCcsICdpbmRpZ28nLCAnaXZvcnknLCAna2hha2knLCAnbGF2ZW5kZXInLCAnbGF2ZW5kZXJibHVzaCcsICdsYXduZ3JlZW4nLCAnbGVtb25jaGlmZm9uJywgJ2xpZ2h0Ymx1ZScsICdsaWdodGNvcmFsJywgJ2xpZ2h0Y3lhbicsICdsaWdodGdvbGRlbnJvZHllbGxvdycsICdsaWdodGdyYXknLCAnbGlnaHRncmVlbicsICdsaWdodGdyZXknLCAnbGlnaHRwaW5rJywgJ2xpZ2h0c2FsbW9uJywgJ2xpZ2h0c2VhZ3JlZW4nLCAnbGlnaHRza3libHVlJywgJ2xpZ2h0c2xhdGVncmF5JywgJ2xpZ2h0c2xhdGVncmV5JywgJ2xpZ2h0c3RlZWxibHVlJywgJ2xpZ2h0eWVsbG93JywgJ2xpbWUnLCAnbGltZWdyZWVuJywgJ2xpbmVuJywgJ21hZ2VudGEnLCAnbWFyb29uJywgJ21lZGl1bWFxdWFtYXJpbmUnLCAnbWVkaXVtYmx1ZScsICdtZWRpdW1vcmNoaWQnLCAnbWVkaXVtcHVycGxlJywgJ21lZGl1bXNlYWdyZWVuJywgJ21lZGl1bXNsYXRlYmx1ZScsICdtZWRpdW1zcHJpbmdncmVlbicsICdtZWRpdW10dXJxdW9pc2UnLCAnbWVkaXVtdmlvbGV0cmVkJywgJ21pZG5pZ2h0Ymx1ZScsICdtaW50Y3JlYW0nLCAnbWlzdHlyb3NlJywgJ21vY2Nhc2luJywgJ25hdmFqb3doaXRlJywgJ25hdnknLCAnbm9uZScsICdvbGRsYWNlJywgJ29saXZlJywgJ29saXZlZHJhYicsICdvcmFuZ2UnLCAnb3JhbmdlcmVkJywgJ29yY2hpZCcsICdwYWxlZ29sZGVucm9kJywgJ3BhbGVncmVlbicsICdwYWxldHVycXVvaXNlJywgJ3BhbGV2aW9sZXRyZWQnLCAncGFwYXlhd2hpcCcsICdwZWFjaHB1ZmYnLCAncGVydScsICdwaW5rJywgJ3BsdW0nLCAncG93ZGVyYmx1ZScsICdwdXJwbGUnLCAncmVkJywgJ3Jvc3licm93bicsICdyb3lhbGJsdWUnLCAnc2FkZGxlYnJvd24nLCAnc2FsbW9uJywgJ3NhbmR5YnJvd24nLCAnc2VhZ3JlZW4nLCAnc2Vhc2hlbGwnLCAnc2llbm5hJywgJ3NpbHZlcicsICdza3libHVlJywgJ3NsYXRlYmx1ZScsICdzbGF0ZWdyYXknLCAnc2xhdGVncmV5JywgJ3Nub3cnLCAnc3ByaW5nZ3JlZW4nLCAnc3RlZWxibHVlJywgJ3RhbicsICd0ZWFsJywgJ3RoaXN0bGUnLCAndG9tYXRvJywgJ3R1cnF1b2lzZScsICd2aW9sZXQnLCAnd2hlYXQnLCAnd2hpdGUnLCAnd2hpdGVzbW9rZScsICd5ZWxsb3cnLCAneWVsbG93Z3JlZW4nLCAndHJhbnNwYXJlbnQnXSxcbiAgICAgIH1dLFxuICAgIH0sXG4gICAgcGFnZUZvcm1hdERlZjoge1xuICAgICAgaWQ6ICcvcGFnZUZvcm1hdERlZicsXG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFsnYTInLCAnYTMnLCAnYTQnLCAnYTUnLCAnYjQnLCAnYjUnLCAnbGV0dGVyJywgJ2xlZ2FsJywgJ3RhYmxvaWQnXSxcbiAgICB9LFxuICAgIHBhZ2VSYW5nZURlZjoge1xuICAgICAgaWQ6ICcvcGFnZVJhbmdlRGVmJyxcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICB1bmlxdWVJdGVtczogdHJ1ZSxcbiAgICAgIGl0ZW1zOiBbe1xuICAgICAgICBvbmVPZjogW3tcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIHBhdHRlcm46ICdeKFxcXFxkKyg/Oi1cXFxcZCspPykkfF4oLVxcXFxkKykkfF4oXFxcXGQrLSkkJyxcbiAgICAgICAgICBlcnJvck1lc3NhZ2U6ICdQYXJhbSBzaG91bGQgYmUgcHJvdmlkZWQgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0czogXCIxLDIsMyw1XCIsIFwiMS0zXCIsIFwiMS1cIiwgXCItMlwiICcsXG4gICAgICAgIH1dLFxuICAgICAgfV0sXG4gICAgfSxcbiAgICBmYWNlc0RlZjoge1xuICAgICAgaWQ6ICcvZmFjZXNEZWYnLFxuICAgICAgb25lT2Y6IFt7XG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICBlbnVtOiBbJ2FsbCddLFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgIG1pbmltdW06IDEsXG4gICAgICAgIG1heGltdW06IDEwMDAsXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgICBtYXhpbXVtOiAxMDAwLFxuICAgICAgICB9XSxcbiAgICAgIH1dLFxuICAgIH0sXG4gICAgb2JqZWN0c0RlZjoge1xuICAgICAgaWQ6ICcvb2JqZWN0c0RlZicsXG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgbWluSXRlbXM6IDEsXG4gICAgICBtYXhJdGVtczogNTAsXG4gICAgICBpdGVtczogW3tcbiAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgYWRkaXRpb25hbEl0ZW1zOiBmYWxzZSxcbiAgICAgICAgbWluSXRlbXM6IDQsXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDEwMDAwLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgICBtYXhpbXVtOiAxMDAwMCxcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgIG1heGltdW06IDEwMDAwLFxuICAgICAgICB9XSxcbiAgICAgIH1dLFxuICAgIH0sXG4gICAgcG9zaXRpb25EZWY6IHtcbiAgICAgIGlkOiAnL3Bvc2l0aW9uRGVmJyxcbiAgICAgIGRlZmF1bHQ6IFsnbWlkZGxlJywgJ2NlbnRlciddLFxuICAgICAgb25lT2Y6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGVudW06IFtcbiAgICAgICAgICAgICd0b3AnLFxuICAgICAgICAgICAgJ21pZGRsZScsXG4gICAgICAgICAgICAnYm90dG9tJyxcbiAgICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgICAgICdjZW50ZXInLFxuICAgICAgICAgICAgJ3JpZ2h0JyxcbiAgICAgICAgICAgICdmYWNlcycsXG4gICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgdW5pcXVlSXRlbXM6IHRydWUsXG4gICAgICAgICAgYWRkaXRpb25hbEl0ZW1zOiBmYWxzZSxcbiAgICAgICAgICBtaW5JdGVtczogMixcbiAgICAgICAgICBtYXhJdGVtczogMixcbiAgICAgICAgICBkZWZhdWx0OiBbJ21pZGRsZScsICdjZW50ZXInXSxcbiAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgZW51bTogW1xuICAgICAgICAgICAgICAgICd0b3AnLFxuICAgICAgICAgICAgICAgICdtaWRkbGUnLFxuICAgICAgICAgICAgICAgICdib3R0b20nLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgZW51bTogW1xuICAgICAgICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAncmlnaHQnLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9LFxuICB9LFxufTtcbiJdfQ==


/***/ }),

/***/ 2782:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(5037), exports);
tslib_1.__exportStar(__nccwpck_require__(2596), exports);
tslib_1.__exportStar(__nccwpck_require__(7372), exports);
tslib_1.__exportStar(__nccwpck_require__(6423), exports);
tslib_1.__exportStar(__nccwpck_require__(8808), exports);
tslib_1.__exportStar(__nccwpck_require__(4998), exports);
tslib_1.__exportStar(__nccwpck_require__(2937), exports);
tslib_1.__exportStar(__nccwpck_require__(2059), exports);
tslib_1.__exportStar(__nccwpck_require__(9720), exports);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRzs7O0FBRUgsOERBQW9DO0FBQ3BDLHNEQUE0QjtBQUM1Qix5REFBK0I7QUFDL0IsNERBQWtDO0FBQ2xDLDJEQUFpQztBQUNqQywwREFBZ0M7QUFDaEMsMERBQWdDO0FBQ2hDLDREQUFrQztBQUNsQyw0REFBa0MiLCJmaWxlIjoic2NoZW1hL2luZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2suXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0ICogZnJvbSAnLi90cmFuc2Zvcm1zLnNjaGVtYSc7XG5leHBvcnQgKiBmcm9tICcuL3ZhbGlkYXRvcic7XG5leHBvcnQgKiBmcm9tICcuL3N0b3JlLnNjaGVtYSc7XG5leHBvcnQgKiBmcm9tICcuL3NlY3VyaXR5LnNjaGVtYSc7XG5leHBvcnQgKiBmcm9tICcuL3ByZXZpZXcuc2NoZW1hJztcbmV4cG9ydCAqIGZyb20gJy4vcGlja2VyLnNjaGVtYSc7XG5leHBvcnQgKiBmcm9tICcuL3VwbG9hZC5zY2hlbWEnO1xuZXhwb3J0ICogZnJvbSAnLi9tZXRhZGF0YS5zY2hlbWEnO1xuZXhwb3J0ICogZnJvbSAnLi9yZXRyaWV2ZS5zY2hlbWEnO1xuIl19


/***/ }),

/***/ 2059:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.MetadataParamsSchema = {
    '$schema': 'http://json-schema.org/draft-07/schema#',
    title: 'Filestack Metadata',
    description: 'Filestack Metadata Options',
    type: 'object',
    additionalProperties: false,
    properties: {
        size: {
            type: 'boolean',
        },
        mimetype: {
            type: 'boolean',
        },
        filename: {
            type: 'boolean',
        },
        width: {
            type: 'boolean',
        },
        metadata: {
            type: 'boolean',
        },
        height: {
            type: 'boolean',
        },
        uploaded: {
            type: 'boolean',
        },
        writeable: {
            type: 'boolean',
        },
        cloud: {
            type: 'boolean',
        },
        sourceUrl: {
            type: 'boolean',
        },
        md5: {
            type: 'boolean',
        },
        sha1: {
            type: 'boolean',
        },
        sha224: {
            type: 'boolean',
        },
        sha256: {
            type: 'boolean',
        },
        sha384: {
            type: 'boolean',
        },
        sha512: {
            type: 'boolean',
        },
        location: {
            type: 'boolean',
        },
        path: {
            type: 'boolean',
        },
        container: {
            type: 'boolean',
        },
        exif: {
            type: 'boolean',
        },
    },
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvbWV0YWRhdGEuc2NoZW1hLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ1UsUUFBQSxvQkFBb0IsR0FBRztJQUNsQyxTQUFTLEVBQUUseUNBQXlDO0lBQ3BELEtBQUssRUFBRSxvQkFBb0I7SUFDM0IsV0FBVyxFQUFFLDRCQUE0QjtJQUN6QyxJQUFJLEVBQUUsUUFBUTtJQUNkLG9CQUFvQixFQUFFLEtBQUs7SUFDM0IsVUFBVSxFQUFFO1FBQ1YsSUFBSSxFQUFFO1lBQ0osSUFBSSxFQUFFLFNBQVM7U0FDaEI7UUFDRCxRQUFRLEVBQUU7WUFDUixJQUFJLEVBQUUsU0FBUztTQUNoQjtRQUNELFFBQVEsRUFBRTtZQUNSLElBQUksRUFBRSxTQUFTO1NBQ2hCO1FBQ0QsS0FBSyxFQUFFO1lBQ0wsSUFBSSxFQUFFLFNBQVM7U0FDaEI7UUFDRCxRQUFRLEVBQUU7WUFDUixJQUFJLEVBQUUsU0FBUztTQUNoQjtRQUNELE1BQU0sRUFBRTtZQUNOLElBQUksRUFBRSxTQUFTO1NBQ2hCO1FBQ0QsUUFBUSxFQUFFO1lBQ1IsSUFBSSxFQUFFLFNBQVM7U0FDaEI7UUFDRCxTQUFTLEVBQUU7WUFDVCxJQUFJLEVBQUUsU0FBUztTQUNoQjtRQUNELEtBQUssRUFBRTtZQUNMLElBQUksRUFBRSxTQUFTO1NBQ2hCO1FBQ0QsU0FBUyxFQUFFO1lBQ1QsSUFBSSxFQUFFLFNBQVM7U0FDaEI7UUFDRCxHQUFHLEVBQUU7WUFDSCxJQUFJLEVBQUUsU0FBUztTQUNoQjtRQUNELElBQUksRUFBRTtZQUNKLElBQUksRUFBRSxTQUFTO1NBQ2hCO1FBQ0QsTUFBTSxFQUFFO1lBQ04sSUFBSSxFQUFFLFNBQVM7U0FDaEI7UUFDRCxNQUFNLEVBQUU7WUFDTixJQUFJLEVBQUUsU0FBUztTQUNoQjtRQUNELE1BQU0sRUFBRTtZQUNOLElBQUksRUFBRSxTQUFTO1NBQ2hCO1FBQ0QsTUFBTSxFQUFFO1lBQ04sSUFBSSxFQUFFLFNBQVM7U0FDaEI7UUFDRCxRQUFRLEVBQUU7WUFDUixJQUFJLEVBQUUsU0FBUztTQUNoQjtRQUNELElBQUksRUFBRTtZQUNKLElBQUksRUFBRSxTQUFTO1NBQ2hCO1FBQ0QsU0FBUyxFQUFFO1lBQ1QsSUFBSSxFQUFFLFNBQVM7U0FDaEI7UUFDRCxJQUFJLEVBQUU7WUFDSixJQUFJLEVBQUUsU0FBUztTQUNoQjtLQUNGO0NBQ0YsQ0FBQyIsImZpbGUiOiJzY2hlbWEvbWV0YWRhdGEuc2NoZW1hLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2suXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBNZXRhZGF0YVBhcmFtc1NjaGVtYSA9IHtcbiAgJyRzY2hlbWEnOiAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjJyxcbiAgdGl0bGU6ICdGaWxlc3RhY2sgTWV0YWRhdGEnLFxuICBkZXNjcmlwdGlvbjogJ0ZpbGVzdGFjayBNZXRhZGF0YSBPcHRpb25zJyxcbiAgdHlwZTogJ29iamVjdCcsXG4gIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgcHJvcGVydGllczoge1xuICAgIHNpemU6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIG1pbWV0eXBlOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgfSxcbiAgICBmaWxlbmFtZToge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIH0sXG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgfSxcbiAgICBoZWlnaHQ6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIHVwbG9hZGVkOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgfSxcbiAgICB3cml0ZWFibGU6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIGNsb3VkOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgfSxcbiAgICBzb3VyY2VVcmw6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIG1kNToge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIH0sXG4gICAgc2hhMToge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIH0sXG4gICAgc2hhMjI0OiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgfSxcbiAgICBzaGEyNTY6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIHNoYTM4NDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIH0sXG4gICAgc2hhNTEyOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgfSxcbiAgICBsb2NhdGlvbjoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIH0sXG4gICAgcGF0aDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIH0sXG4gICAgY29udGFpbmVyOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgfSxcbiAgICBleGlmOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgfSxcbiAgfSxcbn07XG4iXX0=


/***/ }),

/***/ 4998:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4351);
/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var upload_schema_1 = __nccwpck_require__(2937);
exports.PickerParamsSchema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    title: 'Filestack Picker',
    description: 'Filestack Picker Options',
    type: 'object',
    additionalProperties: false,
    // required: ['container'],
    properties: {
        allowManualRetry: {
            type: 'boolean',
        },
        accept: {
            additionalProperties: false,
            oneOf: [
                {
                    type: 'string',
                },
                {
                    type: 'array',
                    minItems: 1,
                    items: [
                        {
                            type: 'string',
                        },
                    ],
                },
            ],
        },
        acceptFn: {
            format: 'callback',
        },
        fromSources: {
            type: 'array',
            items: [
                {
                    type: ['string', 'object'],
                    additionalProperties: false,
                    enum: [
                        'local_file_system',
                        'url',
                        'imagesearch',
                        'facebook',
                        'instagram',
                        'googledrive',
                        'unsplash',
                        'dropbox',
                        'webcam',
                        'video',
                        'audio',
                        'box',
                        'github',
                        'gmail',
                        'googlephotos',
                        'onedrive',
                        'onedriveforbusiness',
                        'clouddrive',
                        'googlephotos',
                        'customsource',
                        'tint',
                    ],
                },
            ],
        },
        container: {
            format: 'HTMLContainer',
        },
        cleanupImageExif: {
            oneOf: [
                {
                    type: 'boolean',
                },
                {
                    type: 'object',
                    additionalProperties: false,
                    properties: {
                        keepOrientation: {
                            type: 'boolean',
                        },
                        keepICCandAPP: {
                            type: 'boolean',
                        },
                    },
                },
            ],
        },
        displayMode: {
            type: 'string',
            enum: ['inline', 'overlay', 'dropPane'],
        },
        concurrency: {
            type: 'integer',
            minimum: 1,
            maximum: 20,
        },
        supportEmail: {
            type: 'string',
        },
        customSourceContainer: {
            type: 'string',
        },
        customSourcePath: {
            type: 'string',
        },
        customSourceName: {
            type: 'string',
        },
        disableStorageKey: {
            type: 'boolean',
        },
        disableTransformer: {
            type: 'boolean',
        },
        disableThumbnails: {
            type: 'boolean',
        },
        exposeOriginalFile: {
            type: 'boolean',
        },
        globalDropZone: {
            type: 'boolean',
        },
        hideModalWhenUploading: {
            type: 'boolean',
        },
        imageDim: {
            type: 'array',
            minItems: 2,
            maxItems: 2,
            items: [
                {
                    type: 'integer',
                    minimum: 1,
                },
            ],
        },
        imageMax: {
            type: 'array',
            minItems: 2,
            maxItems: 2,
            items: [
                {
                    type: 'integer',
                    minimum: 1,
                },
            ],
        },
        imageMin: {
            type: 'array',
            minItems: 2,
            maxItems: 2,
            items: [
                {
                    type: 'integer',
                    minimum: 1,
                },
            ],
        },
        imageMinMaxBlock: {
            type: 'boolean',
            default: false,
        },
        lang: {
            type: 'string',
            enum: ['ca', 'da', 'de', 'en', 'es', 'fr', 'he', 'it', 'ja', 'ko', 'nl', 'no', 'pl', 'pt', 'sv', 'ru', 'vi', 'zh', 'tr', 'ar'],
        },
        minFiles: {
            type: 'integer',
            minimum: 1,
            maximum: 1000000,
        },
        maxFiles: {
            type: 'integer',
            minimum: 1,
            maximum: 1000000,
        },
        maxSize: {
            type: 'integer',
            minimum: 1,
        },
        modalSize: {
            type: 'array',
            minItems: 2,
            maxItems: 2,
            items: [
                {
                    type: 'integer',
                    minimum: 1,
                    maximum: 1000000,
                },
            ],
        },
        rootId: {
            type: 'string',
        },
        startUploadingWhenMaxFilesReached: {
            type: 'boolean',
        },
        uploadInBackground: {
            type: 'boolean',
        },
        videoResolution: {
            type: 'string',
        },
        onCancel: {
            format: 'callback',
        },
        onClose: {
            format: 'callback',
        },
        onOpen: {
            format: 'callback',
        },
        onFileSelected: {
            format: 'callback',
        },
        onFileUploadCancel: {
            format: 'callback',
        },
        onFileUploadStarted: {
            format: 'callback',
        },
        onFileUploadFinished: {
            format: 'callback',
        },
        onFileUploadFailed: {
            format: 'callback',
        },
        onFileUploadProgress: {
            format: 'callback',
        },
        onUploadStarted: {
            format: 'callback',
        },
        onUploadDone: {
            format: 'callback',
        },
        onFileCropped: {
            format: 'callback',
        },
        storeTo: {
            additionalProperties: false,
            type: 'object',
            properties: {
                filename: {
                    type: 'string',
                },
                location: {
                    $ref: 'locationsDef',
                },
                container: {
                    type: 'string',
                },
                path: {
                    type: 'string',
                },
                region: {
                    type: 'string',
                },
                access: {
                    type: 'string',
                    enum: ['public', 'private'],
                },
                workflows: {
                    $ref: 'workflowsDef',
                },
            },
        },
        viewType: {
            type: 'string',
            enum: ['grid', 'list'],
        },
        transformations: {
            type: 'object',
            additionalProperties: false,
            properties: {
                circle: {
                    type: 'boolean',
                },
                rotate: {
                    type: 'boolean',
                },
                force: {
                    type: 'boolean',
                },
                crop: {
                    oneOf: [
                        {
                            type: 'boolean',
                        },
                        {
                            type: 'object',
                            additionalProperties: false,
                            properties: {
                                force: {
                                    type: 'boolean',
                                },
                                aspectRatio: {
                                    type: 'number',
                                },
                            },
                        },
                    ],
                },
            },
        },
        customText: {
            type: 'object',
            patternProperties: {
                '.*': { type: 'string' },
            },
        },
        cropFiles: {
            type: 'array',
            minItems: 1,
        },
        loadCss: {
            type: 'string',
        },
        failOverMaxFiles: {
            type: 'boolean',
        },
        dropPane: {
            type: 'object',
            properties: {
                cropFiles: {
                    type: 'array',
                    minItems: 1,
                },
                customText: {
                    type: 'string',
                },
                disableClick: {
                    type: 'boolean',
                },
                overlay: {
                    type: 'boolean',
                },
                showIcon: {
                    type: 'boolean',
                },
                showProgress: {
                    type: 'boolean',
                },
                onDragEnter: {
                    format: 'callback',
                },
                onProgress: {
                    format: 'callback',
                },
                onDragLeave: {
                    format: 'callback',
                },
                onDragOver: {
                    format: 'callback',
                },
                onDrop: {
                    format: 'callback',
                },
                onSuccess: {
                    format: 'callback',
                },
                onError: {
                    format: 'callback',
                },
                onClick: {
                    format: 'callback',
                },
            },
        },
        errorsTimeout: {
            type: 'number',
            minimum: 0,
        },
        customAuthText: {
            type: 'object',
            patternProperties: {
                '.*': {
                    additionalProperties: false,
                    type: 'object',
                    required: ['top', 'bottom'],
                    properties: {
                        top: {
                            type: 'string',
                        },
                        bottom: {
                            type: 'string',
                        },
                    },
                },
            },
        },
        uploadConfig: {
            type: 'object',
            additionalProperties: false,
            properties: tslib_1.__assign(tslib_1.__assign({}, upload_schema_1.UploadParamsSchema.properties), { tags: {
                    type: 'object',
                    additionalProperties: {
                        anyOf: [
                            {
                                type: 'string',
                            },
                            {
                                format: 'callback',
                            },
                        ],
                    },
                } }),
        },
        useSentryBreadcrumbs: {
            type: 'boolean',
        },
        pasteMode: {
            type: 'object',
            additionalProperties: false,
            properties: {
                pasteToFirstInViewPort: {
                    type: 'boolean',
                },
                pasteToFirstInstance: {
                    type: 'boolean',
                },
            },
        },
    },
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvcGlja2VyLnNjaGVtYS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxpREFBcUQ7QUFFeEMsUUFBQSxrQkFBa0IsR0FBRztJQUNoQyxPQUFPLEVBQUUseUNBQXlDO0lBQ2xELEtBQUssRUFBRSxrQkFBa0I7SUFDekIsV0FBVyxFQUFFLDBCQUEwQjtJQUN2QyxJQUFJLEVBQUUsUUFBUTtJQUNkLG9CQUFvQixFQUFFLEtBQUs7SUFDM0IsMkJBQTJCO0lBQzNCLFVBQVUsRUFBRTtRQUNWLGdCQUFnQixFQUFFO1lBQ2hCLElBQUksRUFBRSxTQUFTO1NBQ2hCO1FBQ0QsTUFBTSxFQUFFO1lBQ04sb0JBQW9CLEVBQUUsS0FBSztZQUMzQixLQUFLLEVBQUU7Z0JBQ0w7b0JBQ0UsSUFBSSxFQUFFLFFBQVE7aUJBQ2Y7Z0JBQ0Q7b0JBQ0UsSUFBSSxFQUFFLE9BQU87b0JBQ2IsUUFBUSxFQUFFLENBQUM7b0JBQ1gsS0FBSyxFQUFFO3dCQUNMOzRCQUNFLElBQUksRUFBRSxRQUFRO3lCQUNmO3FCQUNGO2lCQUNGO2FBQ0Y7U0FDRjtRQUNELFFBQVEsRUFBRTtZQUNSLE1BQU0sRUFBRSxVQUFVO1NBQ25CO1FBQ0QsV0FBVyxFQUFFO1lBQ1gsSUFBSSxFQUFFLE9BQU87WUFDYixLQUFLLEVBQUU7Z0JBQ0w7b0JBQ0UsSUFBSSxFQUFFLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQztvQkFDMUIsb0JBQW9CLEVBQUUsS0FBSztvQkFDM0IsSUFBSSxFQUFFO3dCQUNKLG1CQUFtQjt3QkFDbkIsS0FBSzt3QkFDTCxhQUFhO3dCQUNiLFVBQVU7d0JBQ1YsV0FBVzt3QkFDWCxhQUFhO3dCQUNiLFVBQVU7d0JBQ1YsU0FBUzt3QkFDVCxRQUFRO3dCQUNSLE9BQU87d0JBQ1AsT0FBTzt3QkFDUCxLQUFLO3dCQUNMLFFBQVE7d0JBQ1IsT0FBTzt3QkFDUCxjQUFjO3dCQUNkLFVBQVU7d0JBQ1Ys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QUUsUUFBUTtZQUNkLG9CQUFvQixFQUFFLEtBQUs7WUFDM0IsVUFBVSxFQUFFO2dCQUNWLHNCQUFzQixFQUFFO29CQUN0QixJQUFJLEVBQUUsU0FBUztpQkFDaEI7Z0JBQ0Qsb0JBQW9CLEVBQUU7b0JBQ3BCLElBQUksRUFBRSxTQUFTO2lCQUNoQjthQUNGO1NBQ0Y7S0FDRjtDQUNGLENBQUMiLCJmaWxlIjoic2NoZW1hL3BpY2tlci5zY2hlbWEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgVXBsb2FkUGFyYW1zU2NoZW1hIH0gZnJvbSAnLi91cGxvYWQuc2NoZW1hJztcblxuZXhwb3J0IGNvbnN0IFBpY2tlclBhcmFtc1NjaGVtYSA9IHtcbiAgJHNjaGVtYTogJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hIycsXG4gIHRpdGxlOiAnRmlsZXN0YWNrIFBpY2tlcicsXG4gIGRlc2NyaXB0aW9uOiAnRmlsZXN0YWNrIFBpY2tlciBPcHRpb25zJyxcbiAgdHlwZTogJ29iamVjdCcsXG4gIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgLy8gcmVxdWlyZWQ6IFsnY29udGFpbmVyJ10sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBhbGxvd01hbnVhbFJldHJ5OiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgfSxcbiAgICBhY2NlcHQ6IHtcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgIG9uZU9mOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgbWluSXRlbXM6IDEsXG4gICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0sXG4gICAgYWNjZXB0Rm46IHtcbiAgICAgIGZvcm1hdDogJ2NhbGxiYWNrJyxcbiAgICB9LFxuICAgIGZyb21Tb3VyY2VzOiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFsnc3RyaW5nJywgJ29iamVjdCddLFxuICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgICAgICBlbnVtOiBbXG4gICAgICAgICAgICAnbG9jYWxfZmlsZV9zeXN0ZW0nLFxuICAgICAgICAgICAgJ3VybCcsXG4gICAgICAgICAgICAnaW1hZ2VzZWFyY2gnLFxuICAgICAgICAgICAgJ2ZhY2Vib29rJyxcbiAgICAgICAgICAgICdpbnN0YWdyYW0nLFxuICAgICAgICAgICAgJ2dvb2dsZWRyaXZlJyxcbiAgICAgICAgICAgICd1bnNwbGFzaCcsXG4gICAgICAgICAgICAnZHJvcGJveCcsXG4gICAgICAgICAgICAnd2ViY2FtJyxcbiAgICAgICAgICAgICd2aWRlbycsXG4gICAgICAgICAgICAnYXVkaW8nLFxuICAgICAgICAgICAgJ2JveCcsXG4gICAgICAgICAgICAnZ2l0aHViJyxcbiAgICAgICAgICAgICdnbWFpbCcsXG4gICAgICAgICAgICAnZ29vZ2xlcGhvdG9zJyxcbiAgICAgICAgICAgICdvbmVkcml2ZScsXG4gICAgICAgICAgICAnb25lZHJpdmVmb3JidXNpbmVzcycsXG4gICAgICAgICAgICAnY2xvdWRkcml2ZScsXG4gICAgICAgICAgICAnZ29vZ2xlcGhvdG9zJyxcbiAgICAgICAgICAgICdjdXN0b21zb3VyY2UnLFxuICAgICAgICAgICAgJ3RpbnQnLFxuICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0sXG4gICAgY29udGFpbmVyOiB7XG4gICAgICBmb3JtYXQ6ICdIVE1MQ29udGFpbmVyJyxcbiAgICB9LFxuICAgIGNsZWFudXBJbWFnZUV4aWY6IHtcbiAgICAgIG9uZU9mOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAga2VlcE9yaWVudGF0aW9uOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZWVwSUNDYW5kQVBQOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSxcbiAgICBkaXNwbGF5TW9kZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ2lubGluZScsICdvdmVybGF5JywgJ2Ryb3BQYW5lJ10sXG4gICAgfSxcbiAgICBjb25jdXJyZW5jeToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgbWluaW11bTogMSxcbiAgICAgIG1heGltdW06IDIwLFxuICAgIH0sXG4gICAgc3VwcG9ydEVtYWlsOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB9LFxuICAgIGN1c3RvbVNvdXJjZUNvbnRhaW5lcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgfSxcbiAgICBjdXN0b21Tb3VyY2VQYXRoOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB9LFxuICAgIGN1c3RvbVNvdXJjZU5hbWU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIH0sXG4gICAgZGlzYWJsZVN0b3JhZ2VLZXk6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIGRpc2FibGVUcmFuc2Zvcm1lcjoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIH0sXG4gICAgZGlzYWJsZVRodW1ibmFpbHM6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIGV4cG9zZU9yaWdpbmFsRmlsZToge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIH0sXG4gICAgZ2xvYmFsRHJvcFpvbmU6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIGhpZGVNb2RhbFdoZW5VcGxvYWRpbmc6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIGltYWdlRGltOiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgbWluSXRlbXM6IDIsXG4gICAgICBtYXhJdGVtczogMixcbiAgICAgIGl0ZW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSxcbiAgICBpbWFnZU1heDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIG1pbkl0ZW1zOiAyLFxuICAgICAgbWF4SXRlbXM6IDIsXG4gICAgICBpdGVtczogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIG1pbmltdW06IDEsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0sXG4gICAgaW1hZ2VNaW46IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBtaW5JdGVtczogMixcbiAgICAgIG1heEl0ZW1zOiAyLFxuICAgICAgaXRlbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9LFxuICAgIGltYWdlTWluTWF4QmxvY2s6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIH0sXG4gICAgbGFuZzoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ2NhJywgJ2RhJywgJ2RlJywgJ2VuJywgJ2VzJywgJ2ZyJywgJ2hlJywgJ2l0JywgJ2phJywgJ2tvJywgJ25sJywgJ25vJywgJ3BsJywgJ3B0JywgJ3N2JywgJ3J1JywgJ3ZpJywgJ3poJywgJ3RyJywgJ2FyJ10sXG4gICAgfSxcbiAgICBtaW5GaWxlczoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgbWluaW11bTogMSxcbiAgICAgIG1heGltdW06IDEwMDAwMDAsXG4gICAgfSxcbiAgICBtYXhGaWxlczoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgbWluaW11bTogMSxcbiAgICAgIG1heGltdW06IDEwMDAwMDAsXG4gICAgfSxcbiAgICBtYXhTaXplOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBtaW5pbXVtOiAxLFxuICAgIH0sXG4gICAgbW9kYWxTaXplOiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgbWluSXRlbXM6IDIsXG4gICAgICBtYXhJdGVtczogMixcbiAgICAgIGl0ZW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgICBtYXhpbXVtOiAxMDAwMDAwLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9LFxuICAgIHJvb3RJZDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgfSxcbiAgICBzdGFydFVwbG9hZGluZ1doZW5NYXhGaWxlc1JlYWNoZWQ6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIHVwbG9hZEluQmFja2dyb3VuZDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIH0sXG4gICAgdmlkZW9SZXNvbHV0aW9uOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB9LFxuICAgIG9uQ2FuY2VsOiB7XG4gICAgICBmb3JtYXQ6ICdjYWxsYmFjaycsXG4gICAgfSxcbiAgICBvbkNsb3NlOiB7XG4gICAgICBmb3JtYXQ6ICdjYWxsYmFjaycsXG4gICAgfSxcbiAgICBvbk9wZW46IHtcbiAgICAgIGZvcm1hdDogJ2NhbGxiYWNrJyxcbiAgICB9LFxuICAgIG9uRmlsZVNlbGVjdGVkOiB7XG4gICAgICBmb3JtYXQ6ICdjYWxsYmFjaycsXG4gICAgfSxcbiAgICBvbkZpbGVVcGxvYWRDYW5jZWw6IHtcbiAgICAgIGZvcm1hdDogJ2NhbGxiYWNrJyxcbiAgICB9LFxuICAgIG9uRmlsZVVwbG9hZFN0YXJ0ZWQ6IHtcbiAgICAgIGZvcm1hdDogJ2NhbGxiYWNrJyxcbiAgICB9LFxuICAgIG9uRmlsZVVwbG9hZEZpbmlzaGVkOiB7XG4gICAgICBmb3JtYXQ6ICdjYWxsYmFjaycsXG4gICAgfSxcbiAgICBvbkZpbGVVcGxvYWRGYWlsZWQ6IHtcbiAgICAgIGZvcm1hdDogJ2NhbGxiYWNrJyxcbiAgICB9LFxuICAgIG9uRmlsZVVwbG9hZFByb2dyZXNzOiB7XG4gICAgICBmb3JtYXQ6ICdjYWxsYmFjaycsXG4gICAgfSxcbiAgICBvblVwbG9hZFN0YXJ0ZWQ6IHtcbiAgICAgIGZvcm1hdDogJ2NhbGxiYWNrJyxcbiAgICB9LFxuICAgIG9uVXBsb2FkRG9uZToge1xuICAgICAgZm9ybWF0OiAnY2FsbGJhY2snLFxuICAgIH0sXG4gICAgb25GaWxlQ3JvcHBlZDoge1xuICAgICAgZm9ybWF0OiAnY2FsbGJhY2snLFxuICAgIH0sXG4gICAgc3RvcmVUbzoge1xuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGZpbGVuYW1lOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIH0sXG4gICAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgICAgJHJlZjogJ2xvY2F0aW9uc0RlZicsXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICB9LFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lvbjoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICB9LFxuICAgICAgICBhY2Nlc3M6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ3B1YmxpYycsICdwcml2YXRlJ10sXG4gICAgICAgIH0sXG4gICAgICAgIHdvcmtmbG93czoge1xuICAgICAgICAgICRyZWY6ICd3b3JrZmxvd3NEZWYnLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHZpZXdUeXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFsnZ3JpZCcsICdsaXN0J10sXG4gICAgfSxcbiAgICB0cmFuc2Zvcm1hdGlvbnM6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBjaXJjbGU6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0ZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgfSxcbiAgICAgICAgZm9yY2U6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIH0sXG4gICAgICAgIGNyb3A6IHtcbiAgICAgICAgICBvbmVPZjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgZm9yY2U6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIGN1c3RvbVRleHQ6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcGF0dGVyblByb3BlcnRpZXM6IHtcbiAgICAgICAgJy4qJzogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIGNyb3BGaWxlczoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIG1pbkl0ZW1zOiAxLFxuICAgIH0sXG4gICAgbG9hZENzczoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgfSxcbiAgICBmYWlsT3Zlck1heEZpbGVzOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgfSxcbiAgICBkcm9wUGFuZToge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGNyb3BGaWxlczoge1xuICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgbWluSXRlbXM6IDEsXG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbVRleHQ6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgfSxcbiAgICAgICAgZGlzYWJsZUNsaWNrOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICB9LFxuICAgICAgICBvdmVybGF5OiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICB9LFxuICAgICAgICBzaG93SWNvbjoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2hvd1Byb2dyZXNzOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICB9LFxuICAgICAgICBvbkRyYWdFbnRlcjoge1xuICAgICAgICAgIGZvcm1hdDogJ2NhbGxiYWNrJyxcbiAgICAgICAgfSxcbiAgICAgICAgb25Qcm9ncmVzczoge1xuICAgICAgICAgIGZvcm1hdDogJ2NhbGxiYWNrJyxcbiAgICAgICAgfSxcbiAgICAgICAgb25EcmFnTGVhdmU6IHtcbiAgICAgICAgICBmb3JtYXQ6ICdjYWxsYmFjaycsXG4gICAgICAgIH0sXG4gICAgICAgIG9uRHJhZ092ZXI6IHtcbiAgICAgICAgICBmb3JtYXQ6ICdjYWxsYmFjaycsXG4gICAgICAgIH0sXG4gICAgICAgIG9uRHJvcDoge1xuICAgICAgICAgIGZvcm1hdDogJ2NhbGxiYWNrJyxcbiAgICAgICAgfSxcbiAgICAgICAgb25TdWNjZXNzOiB7XG4gICAgICAgICAgZm9ybWF0OiAnY2FsbGJhY2snLFxuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiB7XG4gICAgICAgICAgZm9ybWF0OiAnY2FsbGJhY2snLFxuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrOiB7XG4gICAgICAgICAgZm9ybWF0OiAnY2FsbGJhY2snLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIGVycm9yc1RpbWVvdXQ6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICB9LFxuICAgIGN1c3RvbUF1dGhUZXh0OiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHBhdHRlcm5Qcm9wZXJ0aWVzOiB7XG4gICAgICAgICcuKic6IHtcbiAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgcmVxdWlyZWQ6IFsndG9wJywgJ2JvdHRvbSddLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIHRvcDoge1xuICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib3R0b206IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgdXBsb2FkQ29uZmlnOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gbWFudWFsIGltcG9ydCB1cGxvYWQgZGVmaW5pdGlvbnNcbiAgICAgICAgLi4uVXBsb2FkUGFyYW1zU2NoZW1hLnByb3BlcnRpZXMsXG4gICAgICAgIHRhZ3M6IHtcbiAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge1xuICAgICAgICAgICAgYW55T2Y6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnY2FsbGJhY2snLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHVzZVNlbnRyeUJyZWFkY3J1bWJzOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgfSxcbiAgICBwYXN0ZU1vZGU6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBwYXN0ZVRvRmlyc3RJblZpZXdQb3J0OiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICB9LFxuICAgICAgICBwYXN0ZVRvRmlyc3RJbnN0YW5jZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn07XG4iXX0=


/***/ }),

/***/ 8808:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.PreviewParamsSchema = {
    '$schema': 'http://json-schema.org/draft-07/schema#',
    title: 'Filestack Preview',
    description: 'Filestack Preview Options',
    type: 'object',
    additionalProperties: false,
    properties: {
        id: {
            type: 'string',
        },
        css: {
            type: 'string',
        },
    },
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvcHJldmlldy5zY2hlbWEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDVSxRQUFBLG1CQUFtQixHQUFHO0lBQ2pDLFNBQVMsRUFBRSx5Q0FBeUM7SUFDcEQsS0FBSyxFQUFFLG1CQUFtQjtJQUMxQixXQUFXLEVBQUUsMkJBQTJCO0lBQ3hDLElBQUksRUFBRSxRQUFRO0lBQ2Qsb0JBQW9CLEVBQUUsS0FBSztJQUMzQixVQUFVLEVBQUU7UUFDVixFQUFFLEVBQUU7WUFDRixJQUFJLEVBQUUsUUFBUTtTQUNmO1FBQ0QsR0FBRyxFQUFFO1lBQ0gsSUFBSSxFQUFFLFFBQVE7U0FDZjtLQUNGO0NBQ0YsQ0FBQyIsImZpbGUiOiJzY2hlbWEvcHJldmlldy5zY2hlbWEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZXhwb3J0IGNvbnN0IFByZXZpZXdQYXJhbXNTY2hlbWEgPSB7XG4gICckc2NoZW1hJzogJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hIycsXG4gIHRpdGxlOiAnRmlsZXN0YWNrIFByZXZpZXcnLFxuICBkZXNjcmlwdGlvbjogJ0ZpbGVzdGFjayBQcmV2aWV3IE9wdGlvbnMnLFxuICB0eXBlOiAnb2JqZWN0JyxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIH0sXG4gICAgY3NzOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB9LFxuICB9LFxufTtcbiJdfQ==


/***/ }),

/***/ 9720:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.RetrieveParamsSchema = {
    '$schema': 'http://json-schema.org/draft-07/schema#',
    title: 'Filestack Retrieve',
    description: 'Filestack Retrieve Options',
    type: 'object',
    additionalProperties: false,
    properties: {
        metadata: {
            type: 'boolean',
        },
        head: {
            type: 'boolean',
        },
        dl: {
            type: 'boolean',
        },
        cache: {
            type: 'boolean',
        },
        extension: {
            type: 'string',
        },
    },
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvcmV0cmlldmUuc2NoZW1hLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ1UsUUFBQSxvQkFBb0IsR0FBRztJQUNsQyxTQUFTLEVBQUUseUNBQXlDO0lBQ3BELEtBQUssRUFBRSxvQkFBb0I7SUFDM0IsV0FBVyxFQUFFLDRCQUE0QjtJQUN6QyxJQUFJLEVBQUUsUUFBUTtJQUNkLG9CQUFvQixFQUFFLEtBQUs7SUFDM0IsVUFBVSxFQUFFO1FBQ1YsUUFBUSxFQUFFO1lBQ1IsSUFBSSxFQUFFLFNBQVM7U0FDaEI7UUFDRCxJQUFJLEVBQUU7WUFDSixJQUFJLEVBQUUsU0FBUztTQUNoQjtRQUNELEVBQUUsRUFBRTtZQUNGLElBQUksRUFBRSxTQUFTO1NBQ2hCO1FBQ0QsS0FBSyxFQUFFO1lBQ0wsSUFBSSxFQUFFLFNBQVM7U0FDaEI7UUFDRCxTQUFTLEVBQUU7WUFDVCxJQUFJLEVBQUUsUUFBUTtTQUNmO0tBQ0Y7Q0FDRixDQUFDIiwiZmlsZSI6InNjaGVtYS9yZXRyaWV2ZS5zY2hlbWEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZXhwb3J0IGNvbnN0IFJldHJpZXZlUGFyYW1zU2NoZW1hID0ge1xuICAnJHNjaGVtYSc6ICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSMnLFxuICB0aXRsZTogJ0ZpbGVzdGFjayBSZXRyaWV2ZScsXG4gIGRlc2NyaXB0aW9uOiAnRmlsZXN0YWNrIFJldHJpZXZlIE9wdGlvbnMnLFxuICB0eXBlOiAnb2JqZWN0JyxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIGhlYWQ6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIGRsOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgfSxcbiAgICBjYWNoZToge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIH0sXG4gICAgZXh0ZW5zaW9uOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB9LFxuICB9LFxufTtcbiJdfQ==


/***/ }),

/***/ 6423:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.SecurityParamsSchema = {
    '$schema': 'http://json-schema.org/draft-07/schema#',
    title: 'Filestack Security',
    description: 'Filestack Security Options',
    type: 'object',
    additionalProperties: false,
    properties: {
        expiry: {
            type: 'number',
        },
        call: {
            '$ref': 'securityCallDef',
        },
        handle: {
            type: 'string',
        },
        url: {
            type: 'string',
        },
        maxSize: {
            type: 'number',
        },
        minSize: {
            type: 'number',
        },
        path: {
            type: 'string',
        },
        container: {
            type: 'string',
        },
    },
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvc2VjdXJpdHkuc2NoZW1hLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ1UsUUFBQSxvQkFBb0IsR0FBRztJQUNsQyxTQUFTLEVBQUUseUNBQXlDO0lBQ3BELEtBQUssRUFBRSxvQkFBb0I7SUFDM0IsV0FBVyxFQUFFLDRCQUE0QjtJQUN6QyxJQUFJLEVBQUUsUUFBUTtJQUNkLG9CQUFvQixFQUFFLEtBQUs7SUFDM0IsVUFBVSxFQUFFO1FBQ1YsTUFBTSxFQUFFO1lBQ04sSUFBSSxFQUFFLFFBQVE7U0FDZjtRQUNELElBQUksRUFBRTtZQUNKLE1BQU0sRUFBRSxpQkFBaUI7U0FDMUI7UUFDRCxNQUFNLEVBQUU7WUFDTixJQUFJLEVBQUUsUUFBUTtTQUNmO1FBQ0QsR0FBRyxFQUFFO1lBQ0gsSUFBSSxFQUFFLFFBQVE7U0FDZjtRQUNELE9BQU8sRUFBRTtZQUNQLElBQUksRUFBRSxRQUFRO1NBQ2Y7UUFDRCxPQUFPLEVBQUU7WUFDUCxJQUFJLEVBQUUsUUFBUTtTQUNmO1FBQ0QsSUFBSSxFQUFFO1lBQ0osSUFBSSxFQUFFLFFBQVE7U0FDZjtRQUNELFNBQVMsRUFBRTtZQUNULElBQUksRUFBRSxRQUFRO1NBQ2Y7S0FDRjtDQUNGLENBQUMiLCJmaWxlIjoic2NoZW1hL3NlY3VyaXR5LnNjaGVtYS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5leHBvcnQgY29uc3QgU2VjdXJpdHlQYXJhbXNTY2hlbWEgPSB7XG4gICckc2NoZW1hJzogJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hIycsXG4gIHRpdGxlOiAnRmlsZXN0YWNrIFNlY3VyaXR5JyxcbiAgZGVzY3JpcHRpb246ICdGaWxlc3RhY2sgU2VjdXJpdHkgT3B0aW9ucycsXG4gIHR5cGU6ICdvYmplY3QnLFxuICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBleHBpcnk6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgIH0sXG4gICAgY2FsbDoge1xuICAgICAgJyRyZWYnOiAnc2VjdXJpdHlDYWxsRGVmJyxcbiAgICB9LFxuICAgIGhhbmRsZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgfSxcbiAgICB1cmw6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIH0sXG4gICAgbWF4U2l6ZToge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgfSxcbiAgICBtaW5TaXplOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICB9LFxuICAgIHBhdGg6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIH0sXG4gICAgY29udGFpbmVyOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB9LFxuICB9LFxufTtcbiJdfQ==


/***/ }),

/***/ 7372:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.StoreParamsSchema = {
    '$schema': 'http://json-schema.org/draft-07/schema#',
    title: 'Filestack Store',
    description: 'Filestack Store Options',
    type: 'object',
    additionalProperties: false,
    properties: {
        filename: {
            oneOf: [{
                    type: 'string',
                }, {
                    format: 'callback',
                }],
        },
        location: {
            '$ref': 'locationsDef',
        },
        path: {
            type: 'string',
        },
        container: {
            type: 'string',
        },
        region: {
            '$ref': 'regionsDef',
        },
        access: {
            type: 'string',
            enum: ['public', 'private'],
            default: 'private',
        },
        base64decode: {
            type: 'boolean',
        },
        workflows: {
            '$ref': 'workflowsDef',
        },
        disableStorageKey: {
            type: 'boolean',
        },
        tags: {
            type: 'object',
            additionalProperties: {
                type: 'string',
            },
        },
        sanitizer: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    additionalProperties: false,
                    properties: {
                        exclude: {
                            type: 'array',
                            items: [{
                                    type: 'string',
                                }],
                        },
                        replacement: {
                            type: 'string',
                        },
                    },
                }],
        },
    },
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvc3RvcmUuc2NoZW1hLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ1UsUUFBQSxpQkFBaUIsR0FBRztJQUMvQixTQUFTLEVBQUUseUNBQXlDO0lBQ3BELEtBQUssRUFBRSxpQkFBaUI7SUFDeEIsV0FBVyxFQUFFLHlCQUF5QjtJQUN0QyxJQUFJLEVBQUUsUUFBUTtJQUNkLG9CQUFvQixFQUFFLEtBQUs7SUFDM0IsVUFBVSxFQUFFO1FBQ1YsUUFBUSxFQUFFO1lBQ1IsS0FBSyxFQUFFLENBQUM7b0JBQ04sSUFBSSxFQUFFLFFBQVE7aUJBQ2YsRUFBRTtvQkFDRCxNQUFNLEVBQUUsVUFBVTtpQkFDbkIsQ0FBQztTQUNIO1FBQ0QsUUFBUSxFQUFFO1lBQ1IsTUFBTSxFQUFFLGNBQWM7U0FDdkI7UUFDRCxJQUFJLEVBQUU7WUFDSixJQUFJLEVBQUUsUUFBUTtTQUNmO1FBQ0QsU0FBUyxFQUFFO1lBQ1QsSUFBSSxFQUFFLFFBQVE7U0FDZjtRQUNELE1BQU0sRUFBRTtZQUNOLE1BQU0sRUFBRSxZQUFZO1NBQ3JCO1FBQ0QsTUFBTSxFQUFFO1lBQ04sSUFBSSxFQUFFLFFBQVE7WUFDZCxJQUFJLEVBQUUsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDO1lBQzNCLE9BQU8sRUFBRSxTQUFTO1NBQ25CO1FBQ0QsWUFBWSxFQUFFO1lBQ1osSUFBSSxFQUFFLFNBQVM7U0FDaEI7UUFDRCxTQUFTLEVBQUU7WUFDVCxNQUFNLEVBQUUsY0FBYztTQUN2QjtRQUNELGlCQUFpQixFQUFFO1lBQ2pCLElBQUksRUFBRSxTQUFTO1NBQ2hCO1FBQ0QsSUFBSSxFQUFFO1lBQ0osSUFBSSxFQUFFLFFBQVE7WUFDZCxvQkFBb0IsRUFBRTtnQkFDcEIsSUFBSSxFQUFFLFFBQVE7YUFDZjtTQUNGO1FBQ0QsU0FBUyxFQUFFO1lBQ1QsS0FBSyxFQUFFLENBQUM7b0JBQ04sSUFBSSxFQUFFLFNBQVM7aUJBQ2hCLEVBQUU7b0JBQ0QsSUFBSSxFQUFFLFFBQVE7b0JBQ2Qsb0JBQW9CLEVBQUUsS0FBSztvQkFDM0IsVUFBVSxFQUFFO3dCQUNWLE9BQU8sRUFBRTs0QkFDUCxJQUFJLEVBQUUsT0FBTzs0QkFDYixLQUFLLEVBQUUsQ0FBQztvQ0FDTixJQUFJLEVBQUUsUUFBUTtpQ0FDZixDQUFDO3lCQUNIO3dCQUNELFdBQVcsRUFBRTs0QkFDWCxJQUFJLEVBQUUsUUFBUTt5QkFDZjtxQkFDRjtpQkFDRixDQUFDO1NBQ0g7S0FDRjtDQUNGLENBQUMiLCJmaWxlIjoic2NoZW1hL3N0b3JlLnNjaGVtYS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5leHBvcnQgY29uc3QgU3RvcmVQYXJhbXNTY2hlbWEgPSB7XG4gICckc2NoZW1hJzogJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hIycsXG4gIHRpdGxlOiAnRmlsZXN0YWNrIFN0b3JlJyxcbiAgZGVzY3JpcHRpb246ICdGaWxlc3RhY2sgU3RvcmUgT3B0aW9ucycsXG4gIHR5cGU6ICdvYmplY3QnLFxuICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBmaWxlbmFtZToge1xuICAgICAgb25lT2Y6IFt7XG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgfSwge1xuICAgICAgICBmb3JtYXQ6ICdjYWxsYmFjaycsXG4gICAgICB9XSxcbiAgICB9LFxuICAgIGxvY2F0aW9uOiB7XG4gICAgICAnJHJlZic6ICdsb2NhdGlvbnNEZWYnLFxuICAgIH0sXG4gICAgcGF0aDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgfSxcbiAgICBjb250YWluZXI6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIH0sXG4gICAgcmVnaW9uOiB7XG4gICAgICAnJHJlZic6ICdyZWdpb25zRGVmJyxcbiAgICB9LFxuICAgIGFjY2Vzczoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ3B1YmxpYycsICdwcml2YXRlJ10sXG4gICAgICBkZWZhdWx0OiAncHJpdmF0ZScsXG4gICAgfSxcbiAgICBiYXNlNjRkZWNvZGU6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIHdvcmtmbG93czoge1xuICAgICAgJyRyZWYnOiAnd29ya2Zsb3dzRGVmJyxcbiAgICB9LFxuICAgIGRpc2FibGVTdG9yYWdlS2V5OiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgfSxcbiAgICB0YWdzOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHNhbml0aXplcjoge1xuICAgICAgb25lT2Y6IFt7XG4gICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGV4Y2x1ZGU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlcGxhY2VtZW50OiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfV0sXG4gICAgfSxcbiAgfSxcbn07XG4iXX0=


/***/ }),

/***/ 5037:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.TransformSchema = {
    '$schema': 'http://json-schema.org/draft-07/schema#',
    title: 'Filestack Transformations',
    description: 'Filestack transformations parameters',
    type: 'object',
    additionalProperties: false,
    properties: {
        flip: {
            type: 'boolean',
            additionalProperties: false,
        },
        auto_image: {
            type: 'boolean',
            additionalProperties: false,
        },
        no_metadata: {
            type: 'boolean',
            additionalProperties: false,
        },
        compress: {
            additionalProperties: false,
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        metadata: {
                            type: 'boolean',
                            default: false,
                        },
                    },
                }],
        },
        flop: {
            type: 'boolean',
            additionalProperties: false,
        },
        enhance: {
            default: true,
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    additionalProperties: false,
                    properties: {
                        preset: {
                            type: 'string',
                            enum: ['auto', 'vivid', 'beautify', 'beautify_plus', 'fix_dark', 'fix_noise', 'fix_tint', 'outdoor', 'fireworks'],
                        },
                    },
                }],
        },
        redeye: {
            type: 'boolean',
            additionalProperties: false,
        },
        monochrome: {
            type: 'boolean',
            additionalProperties: false,
        },
        negative: {
            type: 'boolean',
            additionalProperties: false,
        },
        tags: {
            type: 'boolean',
            additionalProperties: false,
        },
        sfw: {
            type: 'boolean',
            additionalProperties: false,
        },
        imagesize: {
            type: 'boolean',
            additionalProperties: false,
        },
        smart_crop: {
            width: {
                type: 'integer',
                minimum: 0,
                maximum: 10000,
            },
            height: {
                type: 'integer',
                minimum: 0,
                maximum: 10000,
            },
            mode: {
                type: 'string',
                default: 'auto',
                enum: ['face', 'auto'],
            },
        },
        animate: {
            type: 'object',
            properties: {
                delay: {
                    type: 'integer',
                    minimum: 0,
                    maximum: 10000,
                    default: 1000,
                },
                loop: {
                    type: 'integer',
                    minimum: 0,
                    maximum: 1000,
                    default: 0,
                },
                width: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 1800,
                },
                height: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 1800,
                },
                fit: {
                    type: 'string',
                    default: 'clip',
                    enum: ['clip', 'scale', 'crop'],
                },
                background: {
                    '$ref': 'colorDef',
                    default: 'transparent',
                },
                align: {
                    '$ref': 'positionDef',
                    default: 'center',
                },
            },
        },
        metadata: {
            type: 'object',
            params: {
                type: 'array',
                items: {
                    type: 'string',
                    enum: [
                        'filename',
                        'mimetype',
                        'size',
                        'width',
                        'height',
                        'writeable',
                        'path',
                        'container',
                        'cloud',
                        'exif',
                        'source_url',
                        'md5',
                        'sha256',
                        'sha1',
                        'sha512',
                    ],
                },
                minItems: 0,
                uniqueItems: true,
                additionalItems: false,
            },
            additionalProperties: false,
        },
        resize: {
            type: 'object',
            properties: {
                width: {
                    type: 'number',
                    minimum: 0,
                    maximum: 10000,
                },
                height: {
                    type: 'number',
                    minimum: 0,
                    maximum: 10000,
                },
                fit: {
                    type: 'string',
                    enum: ['clip', 'crop', 'scale', 'max'],
                    default: 'clip',
                },
                align: {
                    '$ref': 'positionDef',
                    default: 'center',
                },
            },
            // required: ['width', 'height'],
            additionalProperties: false,
            anyOf: [
                { required: ['width'] },
                { required: ['height'] },
            ],
        },
        crop: {
            type: 'object',
            properties: {
                dim: {
                    type: 'array',
                    additionalItems: false,
                    minItems: 4,
                    items: [{
                            type: 'integer',
                            minimum: 0,
                            maximum: 100000,
                        }, {
                            type: 'integer',
                            minimum: 0,
                            maximum: 100000,
                        }, {
                            type: 'integer',
                            minimum: 1,
                            maximum: 100000,
                        }, {
                            type: 'integer',
                            minimum: 1,
                            maximum: 100000,
                        }],
                },
            },
            required: ['dim'],
        },
        rotate: {
            type: 'object',
            properties: {
                deg: {
                    oneOf: [{
                            type: 'string',
                            enum: ['exif'],
                        }, {
                            type: 'number',
                            minimum: 0,
                            maximum: 359,
                        }],
                },
                exif: {
                    type: 'boolean',
                },
                background: {
                    '$ref': 'colorDef',
                    default: 'FFFFFFFF',
                },
            },
            additionalProperties: false,
        },
        detect_faces: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        maxsize: {
                            type: 'number',
                            minimum: 0,
                            maximum: 10000,
                            default: 0.35,
                        },
                        minsize: {
                            type: 'number',
                            minimum: 0,
                            maximum: 10000,
                            default: 0.35,
                        },
                        export: {
                            type: 'boolean',
                        },
                        color: {
                            '$ref': 'colorDef',
                            default: '000000FF',
                        },
                    },
                    additionalProperties: false,
                }],
        },
        crop_faces: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        faces: {
                            default: 1,
                            '$ref': 'facesDef',
                        },
                        width: {
                            type: 'number',
                            minimum: 1,
                            maximum: 10000,
                        },
                        height: {
                            type: 'number',
                            minimum: 1,
                            maximum: 10000,
                        },
                        maxsize: {
                            type: 'number',
                            minimum: 0,
                            maximum: 10000,
                            default: 0.35,
                        },
                        minsize: {
                            type: 'number',
                            minimum: 0,
                            maximum: 10000,
                            default: 0.35,
                        },
                        buffer: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 10000,
                        },
                        mode: {
                            type: 'string',
                            enum: ['crop', 'thumb', 'fill'],
                            default: 'thumb',
                        },
                    },
                    additionalProperties: false,
                }],
        },
        pixelate_faces: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        faces: {
                            '$ref': 'facesDef',
                            default: 'all',
                        },
                        maxsize: {
                            type: 'number',
                            minimum: 0,
                            maximum: 10000,
                            default: 0.35,
                        },
                        minsize: {
                            type: 'number',
                            minimum: 0,
                            maximum: 10000,
                            default: 0.35,
                        },
                        buffer: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 10000,
                        },
                        amount: {
                            type: 'integer',
                            minimum: 2,
                            maximum: 100,
                            default: 10,
                        },
                        blur: {
                            type: 'number',
                            minimum: 0,
                            maximum: 20,
                            default: 4,
                        },
                        type: {
                            type: 'string',
                            enum: ['rect', 'oval'],
                            default: 'rect',
                        },
                    },
                    additionalProperties: false,
                }],
        },
        blur_faces: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        faces: {
                            '$ref': 'facesDef',
                            default: 'all',
                        },
                        maxsize: {
                            type: 'number',
                            minimum: 0,
                            maximum: 10000,
                            default: 0.35,
                        },
                        minsize: {
                            type: 'number',
                            minimum: 0,
                            maximum: 10000,
                            default: 0.35,
                        },
                        buffer: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 10000,
                        },
                        amount: {
                            type: 'number',
                            minimum: 0,
                            maximum: 10,
                            default: 10,
                        },
                        blur: {
                            type: 'number',
                            minimum: 0,
                            maximum: 20,
                            default: 4,
                        },
                        type: {
                            type: 'string',
                            enum: ['rect', 'oval'],
                            default: 'rect',
                        },
                    },
                    additionalProperties: false,
                }],
        },
        rounded_corners: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        radius: {
                            oneOf: [{
                                    type: 'integer',
                                    minimum: 1,
                                    maximum: 10000,
                                }, {
                                    type: 'string',
                                    enum: ['max'],
                                }],
                        },
                        blur: {
                            type: 'number',
                            minimum: 0,
                            maximum: 20,
                            default: 0.3,
                        },
                        background: {
                            '$ref': 'colorDef',
                        },
                    },
                    additionalProperties: false,
                }],
        },
        vignette: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        amount: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 100,
                            default: 20,
                        },
                        blurmode: {
                            type: 'string',
                            enum: ['gaussian', 'linear'],
                            default: 'gaussian',
                        },
                        background: {
                            '$ref': 'colorDef',
                        },
                    },
                    additionalProperties: false,
                }],
        },
        polaroid: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        rotate: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 359,
                        },
                        color: {
                            '$ref': 'colorDef',
                            default: 'snow',
                        },
                        background: {
                            '$ref': 'colorDef',
                        },
                    },
                    additionalProperties: false,
                }],
        },
        torn_edges: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        spread: {
                            type: 'array',
                            additionalItems: false,
                            minItems: 2,
                            items: [{
                                    type: 'integer',
                                    minimum: 1,
                                    maximum: 10000,
                                    default: 1,
                                }, {
                                    type: 'integer',
                                    minimum: 1,
                                    maximum: 10000,
                                    default: 10,
                                }],
                        },
                        background: {
                            '$ref': 'colorDef',
                        },
                    },
                    additionalProperties: false,
                }],
        },
        shadow: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        blur: {
                            type: 'number',
                            minimum: 0,
                            maximum: 20,
                            default: 100,
                        },
                        opacity: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 100,
                            default: 60,
                        },
                        vector: {
                            type: 'array',
                            additionalItems: false,
                            minItems: 2,
                            items: [{
                                    type: 'integer',
                                    minimum: -1000,
                                    maximum: 1000,
                                    default: 4,
                                }, {
                                    type: 'integer',
                                    minimum: -1000,
                                    maximum: 1000,
                                    default: 4,
                                }],
                        },
                        color: {
                            '$ref': 'colorDef',
                        },
                        background: {
                            '$ref': 'colorDef',
                        },
                    },
                    additionalProperties: false,
                }],
        },
        circle: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        background: {
                            '$ref': 'colorDef',
                        },
                    },
                    additionalProperties: false,
                }],
        },
        border: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        color: {
                            '$ref': 'colorDef',
                        },
                        background: {
                            '$ref': 'colorDef',
                        },
                        width: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 1000,
                        },
                    },
                    additionalProperties: false,
                }],
        },
        sharpen: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        amount: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 20,
                            default: 2,
                        },
                    },
                    additionalProperties: false,
                }],
        },
        blur: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        amount: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 20,
                            default: 2,
                        },
                    },
                    additionalProperties: false,
                }],
        },
        blackwhite: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        threshold: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 100,
                            default: 50,
                        },
                    },
                    additionalProperties: false,
                }],
        },
        sepia: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        tone: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 100,
                            default: 80,
                        },
                    },
                    additionalProperties: false,
                }],
        },
        pixelate: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        amount: {
                            type: 'integer',
                            minimum: 2,
                            maximum: 100,
                            default: 2,
                        },
                    },
                    additionalProperties: false,
                }],
        },
        oil_paint: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        amount: {
                            type: 'integer',
                            minimum: 2,
                            maximum: 100,
                            default: 2,
                        },
                    },
                    additionalProperties: false,
                }],
        },
        modulate: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        brightness: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 10000,
                            default: 100,
                        },
                        saturation: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 10000,
                            default: 100,
                        },
                        hue: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 359,
                            default: 0,
                        },
                    },
                    additionalProperties: false,
                }],
        },
        ascii: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        foreground: {
                            '$ref': 'colorDef',
                            default: '000000FF',
                        },
                        background: {
                            '$ref': 'colorDef',
                            default: 'FFFFFFFF',
                        },
                        colored: {
                            type: 'boolean',
                            default: false,
                        },
                        size: {
                            type: 'integer',
                            minimum: 10,
                            maximum: 100,
                            default: 100,
                        },
                        reverse: {
                            type: 'boolean',
                            default: false,
                        },
                    },
                    additionalProperties: false,
                }],
        },
        collage: {
            type: 'object',
            properties: {
                files: {
                    type: 'array',
                    minItems: 1,
                    items: [{
                            type: 'string',
                        }],
                },
                margin: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 100,
                    default: 10,
                },
                width: {
                    type: 'integer',
                    minimum: 0,
                    maximum: 10000,
                },
                height: {
                    type: 'integer',
                    minimum: 0,
                    maximum: 10000,
                },
                color: {
                    '$ref': 'colorDef',
                    default: 'FFFFFFFF',
                },
                fit: {
                    type: 'string',
                    enum: ['auto', 'crop'],
                },
                autorotate: {
                    type: 'boolean',
                    default: false,
                },
            },
            required: ['width', 'height', 'files'],
            additionalProperties: false,
        },
        urlscreenshot: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        agent: {
                            type: 'string',
                            enum: ['desktop', 'mobile'],
                            default: 'desktop',
                        },
                        width: {
                            type: 'integer',
                            minimum: 1,
                            maximum: 1920,
                            default: 1024,
                        },
                        height: {
                            type: 'integer',
                            minimum: 1,
                            maximum: 8000,
                            default: 768,
                        },
                        mode: {
                            type: 'string',
                            enum: ['all', 'window'],
                            default: 'all',
                        },
                        delay: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 20000,
                            default: 1000,
                        },
                        orientation: {
                            type: 'string',
                            enum: ['portrait', 'landscape'],
                            default: 'portrait',
                        },
                        device: {
                            type: 'string',
                            default: '',
                        },
                    },
                    additionalProperties: false,
                }],
        },
        upscale: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        noise: {
                            type: 'string',
                            enum: ['none', 'low', 'medium', 'high'],
                            default: 'none',
                        },
                        upscale: {
                            type: 'boolean',
                            default: true,
                        },
                        style: {
                            type: 'string',
                            enum: ['artwork', 'photo'],
                            default: 'photo',
                        },
                    },
                    additionalProperties: false,
                }],
        },
        output: {
            type: 'object',
            additionalProperties: false,
            properties: {
                format: {
                    type: 'string',
                    enum: ['doc', 'docx', 'html', 'jpg', 'odp', 'ods', 'odt', 'pjpg', 'pdf', 'png', 'ppt', 'pptx', 'svg', 'txt', 'webp', 'xls', 'xlsx'],
                },
                page: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 99999,
                },
                density: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 500,
                },
                compress: {
                    type: 'boolean',
                },
                quality: {
                    oneOf: [{
                            type: 'string',
                            enum: ['input'],
                        }, {
                            type: 'integer',
                            minimum: 1,
                            maximum: 100,
                            default: 95,
                        }],
                },
                secure: {
                    type: 'boolean',
                    default: false,
                },
                docinfo: {
                    type: 'boolean',
                    default: false,
                },
                strip: {
                    type: 'boolean',
                    default: false,
                },
                colorspace: {
                    type: 'string',
                    enum: ['rgb', 'cmyk', 'input'],
                    default: 'rgb',
                },
                background: {
                    '$ref': 'colorDef',
                },
                pageformat: {
                    type: 'string',
                    enum: ['a2', 'a3', 'a4', 'a5', 'b4', 'b5', 'letter', 'legal', 'tabloid'],
                },
                pageorientation: {
                    type: 'string',
                    enum: ['landscape', 'portrait'],
                },
            },
        },
        pjpg: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    additionalProperties: false,
                    properties: {
                        quality: {
                            type: 'integer',
                            minimum: 0,
                            maximum: 100,
                        },
                        metadata: {
                            type: 'boolean',
                            default: false,
                        },
                    },
                }],
        },
        quality: {
            type: 'object',
            additionalProperties: false,
            properties: {
                value: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 100,
                },
            },
        },
        cache: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        expiry: {
                            type: 'integer',
                        },
                    },
                }],
        },
        video_convert: {
            type: 'object',
            additionalProperties: false,
            properties: {
                width: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 4096,
                },
                height: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 4096,
                },
                preset: {
                    type: 'string',
                },
                force: {
                    type: 'boolean',
                },
                title: {
                    type: 'string',
                },
                extname: {
                    type: 'string',
                },
                upscale: {
                    type: 'boolean',
                },
                aspect_mode: {
                    type: 'string',
                    enum: ['letterbox', 'pad', 'crop', 'preserve', 'constrain'],
                    default: 'letterbox',
                },
                audio_sample_rate: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 99999,
                },
                two_pass: {
                    type: 'boolean',
                },
                video_bitrate: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 5000,
                },
                fps: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 300,
                },
                keyframe_interval: {
                    type: 'integer',
                    minimum: 250,
                    maximum: 250,
                },
                audio_bitrate: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 999,
                },
                audio_channels: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 12,
                },
                clip_length: {
                    type: 'string',
                    pattern: "^([0-1]?\\d|2[0-3])(?::([0-5]?\\d))?(?::([0-5]?\\d))?$",
                },
                clip_offset: {
                    type: 'string',
                    pattern: "^([0-1]?\\d|2[0-3])(?::([0-5]?\\d))?(?::([0-5]?\\d))?$",
                },
                watermark_url: {
                    type: 'string',
                },
                watermark_top: {
                    type: 'integer',
                    minimum: 0,
                    maximum: 9999,
                },
                watermark_right: {
                    type: 'integer',
                    minimum: 0,
                    maximum: 9999,
                },
                watermark_bottom: {
                    type: 'integer',
                    minimum: 0,
                    maximum: 9999,
                },
                watermark_left: {
                    type: 'integer',
                    minimum: 0,
                    maximum: 9999,
                },
                frame_count: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 1,
                    default: 1,
                },
                filename: {
                    type: 'string',
                },
                location: {
                    '$ref': 'locationsDef',
                },
                path: {
                    type: 'string',
                },
                container: {
                    type: 'string',
                },
                access: {
                    type: 'string',
                    enum: ['public', 'private'],
                    default: 'public',
                },
            },
        },
        store: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    additionalProperties: false,
                    properties: {
                        filename: {
                            type: 'string',
                        },
                        location: {
                            '$ref': 'locationsDef',
                        },
                        path: {
                            type: 'string',
                        },
                        container: {
                            type: 'string',
                        },
                        region: {
                            '$ref': 'regionsDef',
                        },
                        access: {
                            type: 'string',
                            enum: ['public', 'private'],
                            default: 'private',
                        },
                        base64decode: {
                            type: 'boolean',
                        },
                        workflows: {
                            '$ref': 'workflowsDef',
                        },
                    },
                }],
        },
        watermark: {
            type: 'object',
            properties: {
                file: {
                    type: 'string',
                },
                size: {
                    type: 'number',
                    minimum: 0,
                    maximum: 500,
                },
                position: {
                    '$ref': 'positionDef',
                },
            },
            required: [
                'file',
            ],
            additionalProperties: false,
        },
        partial_blur: {
            type: 'object',
            properties: {
                objects: {
                    '$ref': 'objectsDef',
                },
                amount: {
                    type: 'number',
                    minimum: 0,
                    maximum: 20,
                },
                blur: {
                    type: 'number',
                    minimum: 0,
                    maximum: 20,
                },
                type: {
                    type: 'string',
                    enum: ['rect', 'oval'],
                },
            },
            required: ['objects'],
        },
        partial_pixelate: {
            type: 'object',
            properties: {
                objects: {
                    '$ref': 'objectsDef',
                },
                amount: {
                    type: 'number',
                    minimum: 2,
                    maximum: 100,
                },
                blur: {
                    type: 'number',
                    minimum: 0,
                    maximum: 20,
                },
                type: {
                    type: 'string',
                    enum: ['rect', 'oval'],
                },
            },
            required: ['objects'],
        },
        security: {
            type: 'object',
            additionalProperties: false,
            properties: {
                policy: {
                    type: 'string',
                },
                signature: {
                    type: 'string',
                },
            },
            required: ['policy', 'signature'],
        },
        pdfinfo: {
            oneOf: [{
                    type: 'boolean',
                }, {
                    type: 'object',
                    properties: {
                        colorinfo: {
                            type: 'boolean',
                        },
                    },
                }],
        },
        pdfconvert: {
            type: 'object',
            additionalProperties: false,
            properties: {
                pageorientation: {
                    type: 'string',
                    enum: ['portrait', 'landscape'],
                },
                pageformat: {
                    '$ref': 'pageFormatDef',
                },
                pages: {
                    '$ref': 'pageRangeDef',
                },
            },
            anyOf: [{
                    required: ['pageorientation'],
                }, {
                    required: ['pageformat'],
                }, {
                    required: ['pages'],
                }],
        },
        fallback: {
            type: 'object',
            additionalProperties: false,
            properties: {
                handle: {
                    type: 'string',
                },
                cache: {
                    type: 'integer',
                    minimum: 1,
                    maximum: 31536000,
                },
            },
            required: ['handle'],
        },
        zip: {
            type: 'string',
        },
        minify_css: {
            type: 'object',
            additionalProperties: false,
            properties: {
                gzip: {
                    type: 'boolean',
                },
                level: {
                    type: 'number',
                    enum: [1, 2],
                },
            },
        },
        minify_js: {
            type: 'object',
            additionalProperties: false,
            properties: {
                gzip: {
                    type: 'boolean',
                },
                use_babel_polyfill: {
                    type: 'boolean',
                },
                keep_fn_name: {
                    type: 'boolean',
                },
                keep_class_name: {
                    type: 'boolean',
                },
                mangle: {
                    type: 'boolean',
                },
                merge_vars: {
                    type: 'boolean',
                },
                remove_console: {
                    type: 'boolean',
                },
                remove_undefined: {
                    type: 'boolean',
                },
                targets: {
                    type: 'string',
                },
            },
        },
    },
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvdHJhbnNmb3Jtcy5zY2hlbWEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDVSxRQUFBLGVBQWUsR0FBRztJQUM3QixTQUFTLEVBQUUseUNBQXlDO0lBQ3BELEtBQUssRUFBRSwyQkFBMkI7SUFDbEMsV0FBVyxFQUFFLHNDQUFzQztJQUNuRCxJQUFJLEVBQUUsUUFBUTtJQUNkLG9CQUFvQixFQUFFLEtBQUs7SUFDM0IsVUFBVSxFQUFFO1FBQ1YsSUFBSSxFQUFFO1lBQ0osSUFBSSxFQUFFLFNBQVM7WUFDZixvQkFBb0IsRUFBRSxLQUFLO1NBQzVCO1FBQ0QsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFLFNBQVM7WUFDZixvQkFBb0IsRUFBRSxLQUFLO1NBQzVCO1FBQ0QsV0FBVyxFQUFFO1lBQ1gsSUFBSSxFQUFFLFNBQVM7WUFDZixvQkFBb0IsRUFBRSxLQUFLO1NBQzVCO1FBQ0QsUUFBUSxFQUFFO1lBQ1Isb0JBQW9CLEVBQUUsS0FBSztZQUMzQixLQUFLLEVBQUUsQ0FBQztvQkFDTixJQUFJLEVBQUUsU0FBUztpQkFDaEIsRUFBRTtvQkFDRCxJQUFJLEVBQUUsUUFBUTtvQkFDZCxVQUFVLEVBQUU7d0JBQ1YsUUFBUSxFQUFFOzRCQUNSLElBQUksRUFBRSxTQUFTOzRCQUNmLE9BQU8sRUFBRSxLQUFLO3lCQUNmO3FCQUNGO2lCQUNGLENBQUM7U0FDSDtRQUNELElBQUksRUFBRTtZQUNKLElBQUksRUFBRSxTQUFTO1lBQ2Ysb0JBQW9CLEVBQUUsS0FBSztTQUM1QjtRQUNELE9BQU8sRUFBRTtZQUNQLE9BQU8sRUFBRSxJQUFJO1lBQ2IsS0FBSyxFQUFFLENBQUM7b0JBQ04sSUFBSSxFQUFFLFNBQVM7aUJBQ2hCLEVBQUU7b0JBQ0QsSUFBSSxFQUFFLFFBQVE7b0JBQ2Qsb0JBQW9CLEVBQUUsS0FBSztvQkFDM0IsVUFBVSxFQUFFO3dCQUNWLE1BQU0sRUFBRTs0QkFDTixJ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QUFFLFNBQVM7aUJBQ2hCO2dCQUNELEtBQUssRUFBRTtvQkFDTCxJQUFJLEVBQUUsUUFBUTtvQkFDZCxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2lCQUNiO2FBQ0Y7U0FDRjtRQUNELFNBQVMsRUFBRTtZQUNULElBQUksRUFBRSxRQUFRO1lBQ2Qsb0JBQW9CLEVBQUUsS0FBSztZQUMzQixVQUFVLEVBQUU7Z0JBQ1YsSUFBSSxFQUFFO29CQUNKLElBQUksRUFBRSxTQUFTO2lCQUNoQjtnQkFDRCxrQkFBa0IsRUFBRTtvQkFDbEIsSUFBSSxFQUFFLFNBQVM7aUJBQ2hCO2dCQUNELFlBQVksRUFBRTtvQkFDWixJQUFJLEVBQUUsU0FBUztpQkFDaEI7Z0JBQ0QsZUFBZSxFQUFFO29CQUNmLElBQUksRUFBRSxTQUFTO2lCQUNoQjtnQkFDRCxNQUFNLEVBQUU7b0JBQ04sSUFBSSxFQUFFLFNBQVM7aUJBQ2hCO2dCQUNELFVBQVUsRUFBRTtvQkFDVixJQUFJLEVBQUUsU0FBUztpQkFDaEI7Z0JBQ0QsY0FBYyxFQUFFO29CQUNkLElBQUksRUFBRSxTQUFTO2lCQUNoQjtnQkFDRCxnQkFBZ0IsRUFBRTtvQkFDaEIsSUFBSSxFQUFFLFNBQVM7aUJBQ2hCO2dCQUNELE9BQU8sRUFBRTtvQkFDUCxJQUFJLEVBQUUsUUFBUTtpQkFDZjthQUNGO1NBQ0Y7S0FDRjtDQUNGLENBQUMiLCJmaWxlIjoic2NoZW1hL3RyYW5zZm9ybXMuc2NoZW1hLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBGaWxlc3RhY2suXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBUcmFuc2Zvcm1TY2hlbWEgPSB7XG4gICckc2NoZW1hJzogJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hIycsXG4gIHRpdGxlOiAnRmlsZXN0YWNrIFRyYW5zZm9ybWF0aW9ucycsXG4gIGRlc2NyaXB0aW9uOiAnRmlsZXN0YWNrIHRyYW5zZm9ybWF0aW9ucyBwYXJhbWV0ZXJzJyxcbiAgdHlwZTogJ29iamVjdCcsXG4gIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgcHJvcGVydGllczoge1xuICAgIGZsaXA6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICB9LFxuICAgIGF1dG9faW1hZ2U6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICB9LFxuICAgIG5vX21ldGFkYXRhOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgfSxcbiAgICBjb21wcmVzczoge1xuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgb25lT2Y6IFt7XG4gICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH1dLFxuICAgIH0sXG4gICAgZmxvcDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgIH0sXG4gICAgZW5oYW5jZToge1xuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgIG9uZU9mOiBbe1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZW51bTogWydhdXRvJywgJ3ZpdmlkJywgJ2JlYXV0aWZ5JywgJ2JlYXV0aWZ5X3BsdXMnLCAnZml4X2RhcmsnLCAnZml4X25vaXNlJywgJ2ZpeF90aW50JywgJ291dGRvb3InLCAnZmlyZXdvcmtzJ10sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH1dLFxuICAgIH0sXG4gICAgcmVkZXllOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgfSxcbiAgICBtb25vY2hyb21lOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgfSxcbiAgICBuZWdhdGl2ZToge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgIH0sXG4gICAgdGFnczoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgIH0sXG4gICAgc2Z3OiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgfSxcbiAgICBpbWFnZXNpemU6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICB9LFxuICAgIHNtYXJ0X2Nyb3A6IHtcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICB9LFxuICAgICAgbW9kZToge1xuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ2F1dG8nLFxuICAgICAgICBlbnVtOiBbJ2ZhY2UnLCAnYXV0byddLFxuICAgICAgfSxcbiAgICB9LFxuICAgIGFuaW1hdGU6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBkZWxheToge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDEwMDAwLFxuICAgICAgICAgIGRlZmF1bHQ6IDEwMDAsXG4gICAgICAgIH0sXG4gICAgICAgIGxvb3A6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAxMDAwLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIG1pbmltdW06IDEsXG4gICAgICAgICAgbWF4aW11bTogMTgwMCxcbiAgICAgICAgfSxcbiAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIG1pbmltdW06IDEsXG4gICAgICAgICAgbWF4aW11bTogMTgwMCxcbiAgICAgICAgfSxcbiAgICAgICAgZml0OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ2NsaXAnLFxuICAgICAgICAgIGVudW06IFsnY2xpcCcsICdzY2FsZScsICdjcm9wJ10sXG4gICAgICAgIH0sXG4gICAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgICAnJHJlZic6ICdjb2xvckRlZicsXG4gICAgICAgICAgZGVmYXVsdDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgfSxcbiAgICAgICAgYWxpZ246IHtcbiAgICAgICAgICAnJHJlZic6ICdwb3NpdGlvbkRlZicsXG4gICAgICAgICAgZGVmYXVsdDogJ2NlbnRlcicsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZW51bTogW1xuICAgICAgICAgICAgJ2ZpbGVuYW1lJyxcbiAgICAgICAgICAgICdtaW1ldHlwZScsXG4gICAgICAgICAgICAnc2l6ZScsXG4gICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICAnd3JpdGVhYmxlJyxcbiAgICAgICAgICAgICdwYXRoJyxcbiAgICAgICAgICAgICdjb250YWluZXInLFxuICAgICAgICAgICAgJ2Nsb3VkJyxcbiAgICAgICAgICAgICdleGlmJyxcbiAgICAgICAgICAgICdzb3VyY2VfdXJsJyxcbiAgICAgICAgICAgICdtZDUnLFxuICAgICAgICAgICAgJ3NoYTI1NicsXG4gICAgICAgICAgICAnc2hhMScsXG4gICAgICAgICAgICAnc2hhNTEyJyxcbiAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBtaW5JdGVtczogMCxcbiAgICAgICAgdW5pcXVlSXRlbXM6IHRydWUsXG4gICAgICAgIGFkZGl0aW9uYWxJdGVtczogZmFsc2UsXG4gICAgICB9LFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgIH0sXG4gICAgcmVzaXplOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDEwMDAwLFxuICAgICAgICB9LFxuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDEwMDAwLFxuICAgICAgICB9LFxuICAgICAgICBmaXQ6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ2NsaXAnLCAnY3JvcCcsICdzY2FsZScgLCdtYXgnXSxcbiAgICAgICAgICBkZWZhdWx0OiAnY2xpcCcsXG4gICAgICAgIH0sXG4gICAgICAgIGFsaWduOiB7XG4gICAgICAgICAgJyRyZWYnOiAncG9zaXRpb25EZWYnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdjZW50ZXInLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIC8vIHJlcXVpcmVkOiBbJ3dpZHRoJywgJ2hlaWdodCddLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgYW55T2Y6IFtcbiAgICAgICAgeyByZXF1aXJlZDogWyd3aWR0aCddIH0sXG4gICAgICAgIHsgcmVxdWlyZWQ6IFsnaGVpZ2h0J10gfSxcbiAgICAgIF0sXG4gICAgfSxcbiAgICBjcm9wOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgZGltOiB7XG4gICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICBhZGRpdGlvbmFsSXRlbXM6IGZhbHNlLFxuICAgICAgICAgIG1pbkl0ZW1zOiA0LFxuICAgICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDEwMDAwMCxcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwMDAwLFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICAgIG1pbmltdW06IDEsXG4gICAgICAgICAgICBtYXhpbXVtOiAxMDAwMDAsXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgICAgIG1heGltdW06IDEwMDAwMCxcbiAgICAgICAgICB9XSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogWydkaW0nXSxcbiAgICB9LFxuICAgIHJvdGF0ZToge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGRlZzoge1xuICAgICAgICAgIG9uZU9mOiBbe1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBlbnVtOiBbJ2V4aWYnXSxcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICBtYXhpbXVtOiAzNTksXG4gICAgICAgICAgfV0sXG4gICAgICAgIH0sXG4gICAgICAgIGV4aWY6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgICAnJHJlZic6ICdjb2xvckRlZicsXG4gICAgICAgICAgZGVmYXVsdDogJ0ZGRkZGRkZGJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgfSxcbiAgICBkZXRlY3RfZmFjZXM6IHtcbiAgICAgIG9uZU9mOiBbe1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgbWF4c2l6ZToge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLjM1LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWluc2l6ZToge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLjM1LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXhwb3J0OiB7XG4gICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgJyRyZWYnOiAnY29sb3JEZWYnLFxuICAgICAgICAgICAgZGVmYXVsdDogJzAwMDAwMEZGJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICB9XSxcbiAgICB9LFxuICAgIGNyb3BfZmFjZXM6IHtcbiAgICAgIG9uZU9mOiBbe1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZmFjZXM6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgICAnJHJlZic6ICdmYWNlc0RlZicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3aWR0aDoge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgICAgIG1heGltdW06IDEwMDAwLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWF4c2l6ZToge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLjM1LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWluc2l6ZToge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLjM1LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYnVmZmVyOiB7XG4gICAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVudW06IFsnY3JvcCcsICd0aHVtYicsICdmaWxsJ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAndGh1bWInLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgIH1dLFxuICAgIH0sXG4gICAgcGl4ZWxhdGVfZmFjZXM6IHtcbiAgICAgIG9uZU9mOiBbe1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZmFjZXM6IHtcbiAgICAgICAgICAgICckcmVmJzogJ2ZhY2VzRGVmJyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdhbGwnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWF4c2l6ZToge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLjM1LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWluc2l6ZToge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLjM1LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYnVmZmVyOiB7XG4gICAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbW91bnQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICAgIG1pbmltdW06IDIsXG4gICAgICAgICAgICBtYXhpbXVtOiAxMDAsXG4gICAgICAgICAgICBkZWZhdWx0OiAxMCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJsdXI6IHtcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDIwLFxuICAgICAgICAgICAgZGVmYXVsdDogNCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZW51bTogWydyZWN0JywgJ292YWwnXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdyZWN0JyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICB9XSxcbiAgICB9LFxuICAgIGJsdXJfZmFjZXM6IHtcbiAgICAgIG9uZU9mOiBbe1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZmFjZXM6IHtcbiAgICAgICAgICAgICckcmVmJzogJ2ZhY2VzRGVmJyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdhbGwnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWF4c2l6ZToge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLjM1LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWluc2l6ZToge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLjM1LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYnVmZmVyOiB7XG4gICAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwMDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbW91bnQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDEwLFxuICAgICAgICAgICAgZGVmYXVsdDogMTAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBibHVyOiB7XG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICBtYXhpbXVtOiAyMCxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDQsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVudW06IFsncmVjdCcsICdvdmFsJ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAncmVjdCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgfV0sXG4gICAgfSxcbiAgICByb3VuZGVkX2Nvcm5lcnM6IHtcbiAgICAgIG9uZU9mOiBbe1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgcmFkaXVzOiB7XG4gICAgICAgICAgICBvbmVPZjogW3tcbiAgICAgICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgICAgICBtYXhpbXVtOiAxMDAwMCxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgIGVudW06IFsnbWF4J10sXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJsdXI6IHtcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDIwLFxuICAgICAgICAgICAgZGVmYXVsdDogMC4zLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICAgICAgJyRyZWYnOiAnY29sb3JEZWYnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgIH1dLFxuICAgIH0sXG4gICAgdmlnbmV0dGU6IHtcbiAgICAgIG9uZU9mOiBbe1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgYW1vdW50OiB7XG4gICAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwLFxuICAgICAgICAgICAgZGVmYXVsdDogMjAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBibHVybW9kZToge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBlbnVtOiBbJ2dhdXNzaWFuJywgJ2xpbmVhciddLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2dhdXNzaWFuJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgICAgICckcmVmJzogJ2NvbG9yRGVmJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICB9XSxcbiAgICB9LFxuICAgIHBvbGFyb2lkOiB7XG4gICAgICBvbmVPZjogW3tcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHJvdGF0ZToge1xuICAgICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDM1OSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICAnJHJlZic6ICdjb2xvckRlZicsXG4gICAgICAgICAgICBkZWZhdWx0OiAnc25vdycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgICAgICAnJHJlZic6ICdjb2xvckRlZicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgfV0sXG4gICAgfSxcbiAgICB0b3JuX2VkZ2VzOiB7XG4gICAgICBvbmVPZjogW3tcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHNwcmVhZDoge1xuICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxJdGVtczogZmFsc2UsXG4gICAgICAgICAgICBtaW5JdGVtczogMixcbiAgICAgICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgICAgIG1pbmltdW06IDEsXG4gICAgICAgICAgICAgIG1heGltdW06IDEwMDAwLFxuICAgICAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgICAgIG1pbmltdW06IDEsXG4gICAgICAgICAgICAgIG1heGltdW06IDEwMDAwLFxuICAgICAgICAgICAgICBkZWZhdWx0OiAxMCxcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICAgICAgJyRyZWYnOiAnY29sb3JEZWYnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgIH1dLFxuICAgIH0sXG4gICAgc2hhZG93OiB7XG4gICAgICBvbmVPZjogW3tcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGJsdXI6IHtcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDIwLFxuICAgICAgICAgICAgZGVmYXVsdDogMTAwLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDEwMCxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDYwLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVjdG9yOiB7XG4gICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgYWRkaXRpb25hbEl0ZW1zOiBmYWxzZSxcbiAgICAgICAgICAgIG1pbkl0ZW1zOiAyLFxuICAgICAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICAgICAgbWluaW11bTogLTEwMDAsXG4gICAgICAgICAgICAgIG1heGltdW06IDEwMDAsXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IDQsXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICAgICAgbWluaW11bTogLTEwMDAsXG4gICAgICAgICAgICAgIG1heGltdW06IDEwMDAsXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IDQsXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICAnJHJlZic6ICdjb2xvckRlZicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgICAgICAnJHJlZic6ICdjb2xvckRlZicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgfV0sXG4gICAgfSxcbiAgICBjaXJjbGU6IHtcbiAgICAgIG9uZU9mOiBbe1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICAgICAgJyRyZWYnOiAnY29sb3JEZWYnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgIH1dLFxuICAgIH0sXG4gICAgYm9yZGVyOiB7XG4gICAgICBvbmVPZjogW3tcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICAnJHJlZic6ICdjb2xvckRlZicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgICAgICAnJHJlZic6ICdjb2xvckRlZicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3aWR0aDoge1xuICAgICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDEwMDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgfV0sXG4gICAgfSxcbiAgICBzaGFycGVuOiB7XG4gICAgICBvbmVPZjogW3tcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGFtb3VudDoge1xuICAgICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDIwLFxuICAgICAgICAgICAgZGVmYXVsdDogMixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICB9XSxcbiAgICB9LFxuICAgIGJsdXI6IHtcbiAgICAgIG9uZU9mOiBbe1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgYW1vdW50OiB7XG4gICAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMjAsXG4gICAgICAgICAgICBkZWZhdWx0OiAyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgIH1dLFxuICAgIH0sXG4gICAgYmxhY2t3aGl0ZToge1xuICAgICAgb25lT2Y6IFt7XG4gICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICB0aHJlc2hvbGQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICBtYXhpbXVtOiAxMDAsXG4gICAgICAgICAgICBkZWZhdWx0OiA1MCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICB9XSxcbiAgICB9LFxuICAgIHNlcGlhOiB7XG4gICAgICBvbmVPZjogW3tcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHRvbmU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICBtYXhpbXVtOiAxMDAsXG4gICAgICAgICAgICBkZWZhdWx0OiA4MCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICB9XSxcbiAgICB9LFxuICAgIHBpeGVsYXRlOiB7XG4gICAgICBvbmVPZjogW3tcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGFtb3VudDoge1xuICAgICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgICAgbWluaW11bTogMixcbiAgICAgICAgICAgIG1heGltdW06IDEwMCxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgfV0sXG4gICAgfSxcbiAgICBvaWxfcGFpbnQ6IHtcbiAgICAgIG9uZU9mOiBbe1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgYW1vdW50OiB7XG4gICAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAyLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwLFxuICAgICAgICAgICAgZGVmYXVsdDogMixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICB9XSxcbiAgICB9LFxuICAgIG1vZHVsYXRlOiB7XG4gICAgICBvbmVPZjogW3tcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGJyaWdodG5lc3M6IHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICBtYXhpbXVtOiAxMDAwMCxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDEwMCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNhdHVyYXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICBtYXhpbXVtOiAxMDAwMCxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDEwMCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGh1ZToge1xuICAgICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDM1OSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgfV0sXG4gICAgfSxcbiAgICBhc2NpaToge1xuICAgICAgb25lT2Y6IFt7XG4gICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB7XG4gICAgICAgICAgICAnJHJlZic6ICdjb2xvckRlZicsXG4gICAgICAgICAgICBkZWZhdWx0OiAnMDAwMDAwRkYnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICAgICAgJyRyZWYnOiAnY29sb3JEZWYnLFxuICAgICAgICAgICAgZGVmYXVsdDogJ0ZGRkZGRkZGJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbG9yZWQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgICAgbWluaW11bTogMTAsXG4gICAgICAgICAgICBtYXhpbXVtOiAxMDAsXG4gICAgICAgICAgICBkZWZhdWx0OiAxMDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXZlcnNlOiB7XG4gICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICB9XSxcbiAgICB9LFxuICAgIGNvbGxhZ2U6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBmaWxlczoge1xuICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgbWluSXRlbXM6IDEsXG4gICAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICB9XSxcbiAgICAgICAgfSxcbiAgICAgICAgbWFyZ2luOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIG1pbmltdW06IDEsXG4gICAgICAgICAgbWF4aW11bTogMTAwLFxuICAgICAgICAgIGRlZmF1bHQ6IDEwLFxuICAgICAgICB9LFxuICAgICAgICB3aWR0aDoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDEwMDAwLFxuICAgICAgICB9LFxuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAxMDAwMCxcbiAgICAgICAgfSxcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAnJHJlZic6ICdjb2xvckRlZicsXG4gICAgICAgICAgZGVmYXVsdDogJ0ZGRkZGRkZGJyxcbiAgICAgICAgfSxcbiAgICAgICAgZml0OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZW51bTogWydhdXRvJywgJ2Nyb3AnXSxcbiAgICAgICAgfSxcbiAgICAgICAgYXV0b3JvdGF0ZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogWyd3aWR0aCcsICdoZWlnaHQnLCAnZmlsZXMnXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICB9LFxuICAgIHVybHNjcmVlbnNob3Q6IHtcbiAgICAgIG9uZU9mOiBbe1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgYWdlbnQ6IHtcbiAgICAgICAgICAgIHR5cGUgOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVudW06IFsnZGVza3RvcCcsICdtb2JpbGUnXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdkZXNrdG9wJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgICAgbWF4aW11bTogMTkyMCxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDEwMjQsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICAgIG1pbmltdW06IDEsXG4gICAgICAgICAgICBtYXhpbXVtOiA4MDAwLFxuICAgICAgICAgICAgZGVmYXVsdDogNzY4LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBlbnVtOiBbJ2FsbCcsICd3aW5kb3cnXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdhbGwnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVsYXk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICBtYXhpbXVtOiAyMDAwMCxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDEwMDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcmllbnRhdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBlbnVtOiBbJ3BvcnRyYWl0JywgJ2xhbmRzY2FwZSddLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3BvcnRyYWl0JyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRldmljZToge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICB9XSxcbiAgICB9LFxuICAgIHVwc2NhbGU6IHtcbiAgICAgIG9uZU9mOiBbe1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgbm9pc2U6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZW51bTogWydub25lJywgJ2xvdycsICdtZWRpdW0nLCAnaGlnaCddLFxuICAgICAgICAgICAgZGVmYXVsdDogJ25vbmUnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBzY2FsZToge1xuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVudW06IFsnYXJ0d29yaycsICdwaG90byddLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3Bob3RvJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICB9XSxcbiAgICB9LFxuICAgIG91dHB1dDoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGVudW06IFsnZG9jJywgJ2RvY3gnLCAnaHRtbCcsICdqcGcnLCAnb2RwJywgJ29kcycsICdvZHQnLCAncGpwZycsICdwZGYnLCAncG5nJywgJ3BwdCcsICdwcHR4JywgJ3N2ZycsICd0eHQnLCAnd2VicCcsICd4bHMnLCAneGxzeCddLFxuICAgICAgICB9LFxuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIG1pbmltdW06IDEsXG4gICAgICAgICAgbWF4aW11bTogOTk5OTksXG4gICAgICAgIH0sXG4gICAgICAgIGRlbnNpdHk6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgICBtYXhpbXVtOiA1MDAsXG4gICAgICAgIH0sXG4gICAgICAgIGNvbXByZXNzOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICB9LFxuICAgICAgICBxdWFsaXR5OiB7XG4gICAgICAgICAgb25lT2Y6IFt7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVudW06IFsnaW5wdXQnXSxcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgICAgbWF4aW11bTogMTAwLFxuICAgICAgICAgICAgZGVmYXVsdDogOTUsXG4gICAgICAgICAgfV0sXG4gICAgICAgIH0sXG4gICAgICAgIHNlY3VyZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgZG9jaW5mbzoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgc3RyaXA6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIGNvbG9yc3BhY2U6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ3JnYicsICdjbXlrJywgJ2lucHV0J10sXG4gICAgICAgICAgZGVmYXVsdDogJ3JnYicsXG4gICAgICAgIH0sXG4gICAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgICAnJHJlZic6ICdjb2xvckRlZicsXG4gICAgICAgIH0sXG4gICAgICAgIHBhZ2Vmb3JtYXQ6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ2EyJywgJ2EzJywgJ2E0JywgJ2E1JywgJ2I0JywgJ2I1JywgJ2xldHRlcicsICdsZWdhbCcsICd0YWJsb2lkJ10sXG4gICAgICAgIH0sXG4gICAgICAgIHBhZ2VvcmllbnRhdGlvbjoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGVudW06IFsnbGFuZHNjYXBlJywgJ3BvcnRyYWl0J10sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgcGpwZzoge1xuICAgICAgb25lT2Y6IFt7XG4gICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHF1YWxpdHk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICBtYXhpbXVtOiAxMDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH1dLFxuICAgIH0sXG4gICAgcXVhbGl0eToge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIG1pbmltdW06IDEsXG4gICAgICAgICAgbWF4aW11bTogMTAwLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIGNhY2hlOiB7XG4gICAgICBvbmVPZjogW3tcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGV4cGlyeToge1xuICAgICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9XSxcbiAgICB9LFxuICAgIHZpZGVvX2NvbnZlcnQ6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICB3aWR0aDoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgIG1heGltdW06IDQwOTYsXG4gICAgICAgIH0sXG4gICAgICAgIGhlaWdodDoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgIG1heGltdW06IDQwOTYsXG4gICAgICAgIH0sXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICB9LFxuICAgICAgICBmb3JjZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgfSxcbiAgICAgICAgZXh0bmFtZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICB9LFxuICAgICAgICB1cHNjYWxlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICB9LFxuICAgICAgICBhc3BlY3RfbW9kZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGVudW06IFsnbGV0dGVyYm94JywgJ3BhZCcsICdjcm9wJywgJ3ByZXNlcnZlJywgJ2NvbnN0cmFpbiddLFxuICAgICAgICAgIGRlZmF1bHQ6ICdsZXR0ZXJib3gnLFxuICAgICAgICB9LFxuICAgICAgICBhdWRpb19zYW1wbGVfcmF0ZToge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgIG1heGltdW06IDk5OTk5LFxuICAgICAgICB9LFxuICAgICAgICB0d29fcGFzczoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgfSxcbiAgICAgICAgdmlkZW9fYml0cmF0ZToge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgIG1heGltdW06IDUwMDAsXG4gICAgICAgIH0sXG4gICAgICAgIGZwczoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgIG1heGltdW06IDMwMCxcbiAgICAgICAgfSxcbiAgICAgICAga2V5ZnJhbWVfaW50ZXJ2YWw6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMjUwLFxuICAgICAgICAgIG1heGltdW06IDI1MCxcbiAgICAgICAgfSxcbiAgICAgICAgYXVkaW9fYml0cmF0ZToge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgIG1heGltdW06IDk5OSxcbiAgICAgICAgfSxcbiAgICAgICAgYXVkaW9fY2hhbm5lbHM6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgICBtYXhpbXVtOiAxMixcbiAgICAgICAgfSxcbiAgICAgICAgY2xpcF9sZW5ndGg6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBwYXR0ZXJuOiBgXihbMC0xXT9cXFxcZHwyWzAtM10pKD86OihbMC01XT9cXFxcZCkpPyg/OjooWzAtNV0/XFxcXGQpKT8kYCxcbiAgICAgICAgfSxcbiAgICAgICAgY2xpcF9vZmZzZXQ6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBwYXR0ZXJuOiBgXihbMC0xXT9cXFxcZHwyWzAtM10pKD86OihbMC01XT9cXFxcZCkpPyg/OjooWzAtNV0/XFxcXGQpKT8kYCxcbiAgICAgICAgfSxcbiAgICAgICAgd2F0ZXJtYXJrX3VybDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICB9LFxuICAgICAgICB3YXRlcm1hcmtfdG9wOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogOTk5OSxcbiAgICAgICAgfSxcbiAgICAgICAgd2F0ZXJtYXJrX3JpZ2h0OiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogOTk5OSxcbiAgICAgICAgfSxcbiAgICAgICAgd2F0ZXJtYXJrX2JvdHRvbToge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDk5OTksXG4gICAgICAgIH0sXG4gICAgICAgIHdhdGVybWFya19sZWZ0OiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogOTk5OSxcbiAgICAgICAgfSxcbiAgICAgICAgZnJhbWVfY291bnQ6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgIH0sXG4gICAgICAgIGZpbGVuYW1lOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIH0sXG4gICAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgICAgJyRyZWYnOiAnbG9jYXRpb25zRGVmJyxcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICB9LFxuICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgfSxcbiAgICAgICAgYWNjZXNzOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZW51bTogWydwdWJsaWMnLCAncHJpdmF0ZSddLFxuICAgICAgICAgIGRlZmF1bHQ6ICdwdWJsaWMnLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHN0b3JlOiB7XG4gICAgICBvbmVPZjogW3tcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZmlsZW5hbWU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgICAgICckcmVmJzogJ2xvY2F0aW9uc0RlZicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWdpb246IHtcbiAgICAgICAgICAgICckcmVmJzogJ3JlZ2lvbnNEZWYnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWNjZXNzOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVudW06IFsncHVibGljJywgJ3ByaXZhdGUnXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdwcml2YXRlJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJhc2U2NGRlY29kZToge1xuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgd29ya2Zsb3dzOiB7XG4gICAgICAgICAgICAnJHJlZic6ICd3b3JrZmxvd3NEZWYnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9XSxcbiAgICB9LFxuICAgIHdhdGVybWFyazoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGZpbGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogNTAwLFxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICckcmVmJzogJ3Bvc2l0aW9uRGVmJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogW1xuICAgICAgICAnZmlsZScsXG4gICAgICBdLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgIH0sXG4gICAgcGFydGlhbF9ibHVyOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgb2JqZWN0czoge1xuICAgICAgICAgICckcmVmJzogJ29iamVjdHNEZWYnLFxuICAgICAgICB9LFxuICAgICAgICBhbW91bnQ6IHtcbiAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDIwLFxuICAgICAgICB9LFxuICAgICAgICBibHVyOiB7XG4gICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAyMCxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGVudW06IFsncmVjdCcsICdvdmFsJ10sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IFsnb2JqZWN0cyddLFxuICAgIH0sXG4gICAgcGFydGlhbF9waXhlbGF0ZToge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIG9iamVjdHM6IHtcbiAgICAgICAgICAnJHJlZic6ICdvYmplY3RzRGVmJyxcbiAgICAgICAgfSxcbiAgICAgICAgYW1vdW50OiB7XG4gICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgbWluaW11bTogMixcbiAgICAgICAgICBtYXhpbXVtOiAxMDAsXG4gICAgICAgIH0sXG4gICAgICAgIGJsdXI6IHtcbiAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDIwLFxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZW51bTogWydyZWN0JywgJ292YWwnXSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogWydvYmplY3RzJ10sXG4gICAgfSxcbiAgICBzZWN1cml0eToge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHBvbGljeToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICB9LFxuICAgICAgICBzaWduYXR1cmU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogWydwb2xpY3knLCAnc2lnbmF0dXJlJ10sXG4gICAgfSxcbiAgICBwZGZpbmZvOiB7XG4gICAgICBvbmVPZjogW3tcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGNvbG9yaW5mbzoge1xuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9XSxcbiAgICB9LFxuICAgIHBkZmNvbnZlcnQ6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBwYWdlb3JpZW50YXRpb246IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ3BvcnRyYWl0JywgJ2xhbmRzY2FwZSddLFxuICAgICAgICB9LFxuICAgICAgICBwYWdlZm9ybWF0OiB7XG4gICAgICAgICAgJyRyZWYnOiAncGFnZUZvcm1hdERlZicsXG4gICAgICAgIH0sXG4gICAgICAgIHBhZ2VzOiB7XG4gICAgICAgICAgJyRyZWYnOiAncGFnZVJhbmdlRGVmJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBhbnlPZjogW3tcbiAgICAgICAgcmVxdWlyZWQ6IFsncGFnZW9yaWVudGF0aW9uJ10sXG4gICAgICB9LCB7XG4gICAgICAgIHJlcXVpcmVkOiBbJ3BhZ2Vmb3JtYXQnXSxcbiAgICAgIH0sIHtcbiAgICAgICAgcmVxdWlyZWQ6IFsncGFnZXMnXSxcbiAgICAgIH1dLFxuICAgIH0sXG4gICAgZmFsbGJhY2s6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBoYW5kbGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgfSxcbiAgICAgICAgY2FjaGU6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgICBtYXhpbXVtOiAzMTUzNjAwMCxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogWydoYW5kbGUnXSxcbiAgICB9LFxuICAgIHppcDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgfSxcbiAgICBtaW5pZnlfY3NzOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgZ3ppcDoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgfSxcbiAgICAgICAgbGV2ZWw6IHtcbiAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICBlbnVtOiBbMSwgMl0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgbWluaWZ5X2pzOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgZ3ppcDoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgfSxcbiAgICAgICAgdXNlX2JhYmVsX3BvbHlmaWxsOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICB9LFxuICAgICAgICBrZWVwX2ZuX25hbWU6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIH0sXG4gICAgICAgIGtlZXBfY2xhc3NfbmFtZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgfSxcbiAgICAgICAgbWFuZ2xlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICB9LFxuICAgICAgICBtZXJnZV92YXJzOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVfY29uc29sZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlX3VuZGVmaW5lZDoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgfSxcbiAgICAgICAgdGFyZ2V0czoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICB9LFxufTtcbiJdfQ==


/***/ }),

/***/ 2937:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.UploadParamsSchema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    title: 'Filestack Upload',
    description: 'Filestack Upload Options',
    type: 'object',
    additionalProperties: false,
    properties: {
        partSize: {
            type: 'integer',
            minimum: 5 * 1024 * 1024,
        },
        concurrency: {
            type: 'integer',
            minimum: 1,
            maximum: 20,
        },
        progressInterval: {
            type: 'integer',
            minimum: 1,
        },
        retry: {
            type: 'integer',
            minimum: 0,
            maximum: 20,
        },
        retryFactor: {
            type: 'integer',
        },
        retryMaxTime: {
            type: 'integer',
        },
        timeout: {
            type: 'integer',
            minimum: 1,
            maximum: 60 * 60 * 1000,
        },
        intelligent: {
            oneOf: [
                {
                    type: 'boolean',
                },
                {
                    type: 'string',
                    enum: ['fallback'],
                },
            ],
        },
        intelligentChunkSize: {
            type: 'integer',
        },
        onProgress: {
            format: 'callback',
        },
        onRetry: {
            format: 'callback',
        },
        disableIntegrityCheck: {
            type: 'boolean',
        },
        tags: {
            type: 'object',
            maxItems: 10,
            additionalProperties: {
                type: 'string',
                maxlength: 256,
            },
        },
    },
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvdXBsb2FkLnNjaGVtYS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNVLFFBQUEsa0JBQWtCLEdBQUc7SUFDaEMsT0FBTyxFQUFFLHlDQUF5QztJQUNsRCxLQUFLLEVBQUUsa0JBQWtCO0lBQ3pCLFdBQVcsRUFBRSwwQkFBMEI7SUFDdkMsSUFBSSxFQUFFLFFBQVE7SUFDZCxvQkFBb0IsRUFBRSxLQUFLO0lBQzNCLFVBQVUsRUFBRTtRQUNWLFFBQVEsRUFBRTtZQUNSLElBQUksRUFBRSxTQUFTO1lBQ2YsT0FBTyxFQUFFLENBQUMsR0FBRyxJQUFJLEdBQUcsSUFBSTtTQUN6QjtRQUNELFdBQVcsRUFBRTtZQUNYLElBQUksRUFBRSxTQUFTO1lBQ2YsT0FBTyxFQUFFLENBQUM7WUFDVixPQUFPLEVBQUUsRUFBRTtTQUNaO1FBQ0QsZ0JBQWdCLEVBQUU7WUFDaEIsSUFBSSxFQUFFLFNBQVM7WUFDZixPQUFPLEVBQUUsQ0FBQztTQUNYO1FBQ0QsS0FBSyxFQUFFO1lBQ0wsSUFBSSxFQUFFLFNBQVM7WUFDZixPQUFPLEVBQUUsQ0FBQztZQUNWLE9BQU8sRUFBRSxFQUFFO1NBQ1o7UUFDRCxXQUFXLEVBQUU7WUFDWCxJQUFJLEVBQUUsU0FBUztTQUNoQjtRQUNELFlBQVksRUFBRTtZQUNaLElBQUksRUFBRSxTQUFTO1NBQ2hCO1FBQ0QsT0FBTyxFQUFFO1lBQ1AsSUFBSSxFQUFFLFNBQVM7WUFDZixPQUFPLEVBQUUsQ0FBQztZQUNWLE9BQU8sRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUk7U0FDeEI7UUFDRCxXQUFXLEVBQUU7WUFDWCxLQUFLLEVBQUU7Z0JBQ0w7b0JBQ0UsSUFBSSxFQUFFLFNBQVM7aUJBQ2hCO2dCQUNEO29CQUNFLElBQUksRUFBRSxRQUFRO29CQUNkLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQztpQkFDbkI7YUFDRjtTQUNGO1FBQ0Qsb0JBQW9CLEVBQUU7WUFDcEIsSUFBSSxFQUFFLFNBQVM7U0FDaEI7UUFDRCxVQUFVLEVBQUU7WUFDVixNQUFNLEVBQUUsVUFBVTtTQUNuQjtRQUNELE9BQU8sRUFBRTtZQUNQLE1BQU0sRUFBRSxVQUFVO1NBQ25CO1FBQ0QscUJBQXFCLEVBQUU7WUFDckIsSUFBSSxFQUFFLFNBQVM7U0FDaEI7UUFDRCxJQUFJLEVBQUU7WUFDSixJQUFJLEVBQUUsUUFBUTtZQUNkLFFBQVEsRUFBRSxFQUFFO1lBQ1osb0JBQW9CLEVBQUU7Z0JBQ3BCLElBQUksRUFBRSxRQUFRO2dCQUNkLFNBQVMsRUFBRSxHQUFHO2FBQ2Y7U0FDRjtLQUNGO0NBQ0YsQ0FBQyIsImZpbGUiOiJzY2hlbWEvdXBsb2FkLnNjaGVtYS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5leHBvcnQgY29uc3QgVXBsb2FkUGFyYW1zU2NoZW1hID0ge1xuICAkc2NoZW1hOiAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjJyxcbiAgdGl0bGU6ICdGaWxlc3RhY2sgVXBsb2FkJyxcbiAgZGVzY3JpcHRpb246ICdGaWxlc3RhY2sgVXBsb2FkIE9wdGlvbnMnLFxuICB0eXBlOiAnb2JqZWN0JyxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgcGFydFNpemU6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIG1pbmltdW06IDUgKiAxMDI0ICogMTAyNCxcbiAgICB9LFxuICAgIGNvbmN1cnJlbmN5OiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBtaW5pbXVtOiAxLFxuICAgICAgbWF4aW11bTogMjAsXG4gICAgfSxcbiAgICBwcm9ncmVzc0ludGVydmFsOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBtaW5pbXVtOiAxLFxuICAgIH0sXG4gICAgcmV0cnk6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAyMCxcbiAgICB9LFxuICAgIHJldHJ5RmFjdG9yOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgfSxcbiAgICByZXRyeU1heFRpbWU6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICB9LFxuICAgIHRpbWVvdXQ6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIG1pbmltdW06IDEsXG4gICAgICBtYXhpbXVtOiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIGludGVsbGlnZW50OiB7XG4gICAgICBvbmVPZjogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZW51bTogWydmYWxsYmFjayddLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9LFxuICAgIGludGVsbGlnZW50Q2h1bmtTaXplOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgfSxcbiAgICBvblByb2dyZXNzOiB7XG4gICAgICBmb3JtYXQ6ICdjYWxsYmFjaycsXG4gICAgfSxcbiAgICBvblJldHJ5OiB7XG4gICAgICBmb3JtYXQ6ICdjYWxsYmFjaycsXG4gICAgfSxcbiAgICBkaXNhYmxlSW50ZWdyaXR5Q2hlY2s6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICB9LFxuICAgIHRhZ3M6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgbWF4SXRlbXM6IDEwLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHtcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIG1heGxlbmd0aDogMjU2LFxuICAgICAgfSxcbiAgICB9LFxuICB9LFxufTtcbiJdfQ==


/***/ }),

/***/ 2596:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var jsonschema_1 = __nccwpck_require__(3978);
var definitions_schema_1 = __nccwpck_require__(9343);
var v = new jsonschema_1.Validator();
jsonschema_1.Validator.prototype.customFormats.callback = function (input) { return typeof input === 'function'; };
// check if element have HTML in to string method ie HTMLDivElement
jsonschema_1.Validator.prototype.customFormats.HTMLContainer = function (input) { return typeof input === 'string' || (input.toString && input.toString().indexOf('HTML') > -1); };
/**
 * Returns validator instance
 */
exports.getValidator = function (schema) {
    return function (params) {
        v.addSchema(definitions_schema_1.DefinitionsSchema);
        return v.validate(params, schema);
    };
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvdmFsaWRhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gseUNBQXVDO0FBQ3ZDLDJEQUF5RDtBQUV6RCxJQUFNLENBQUMsR0FBRyxJQUFJLHNCQUFTLEVBQUUsQ0FBQztBQUUxQixzQkFBUyxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsUUFBUSxHQUFHLFVBQUMsS0FBSyxJQUFLLE9BQUEsT0FBTyxLQUFLLEtBQUssVUFBVSxFQUEzQixDQUEyQixDQUFDO0FBQ3BGLG1FQUFtRTtBQUNuRSxzQkFBUyxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsYUFBYSxHQUFHLFVBQUMsS0FBSyxJQUFLLE9BQUEsT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsSUFBSSxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQXRGLENBQXNGLENBQUM7QUFFcEo7O0dBRUc7QUFDVSxRQUFBLFlBQVksR0FBRyxVQUFDLE1BQU07SUFDakMsT0FBTyxVQUFDLE1BQU07UUFDWixDQUFDLENBQUMsU0FBUyxDQUFDLHNDQUFpQixDQUFDLENBQUM7UUFDL0IsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNwQyxDQUFDLENBQUM7QUFDSixDQUFDLENBQUMiLCJmaWxlIjoic2NoZW1hL3ZhbGlkYXRvci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBWYWxpZGF0b3IgfSBmcm9tICdqc29uc2NoZW1hJztcbmltcG9ydCB7IERlZmluaXRpb25zU2NoZW1hIH0gZnJvbSAnLi9kZWZpbml0aW9ucy5zY2hlbWEnO1xuXG5jb25zdCB2ID0gbmV3IFZhbGlkYXRvcigpO1xuXG5WYWxpZGF0b3IucHJvdG90eXBlLmN1c3RvbUZvcm1hdHMuY2FsbGJhY2sgPSAoaW5wdXQpID0+IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJztcbi8vIGNoZWNrIGlmIGVsZW1lbnQgaGF2ZSBIVE1MIGluIHRvIHN0cmluZyBtZXRob2QgaWUgSFRNTERpdkVsZW1lbnRcblZhbGlkYXRvci5wcm90b3R5cGUuY3VzdG9tRm9ybWF0cy5IVE1MQ29udGFpbmVyID0gKGlucHV0KSA9PiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IChpbnB1dC50b1N0cmluZyAmJiBpbnB1dC50b1N0cmluZygpLmluZGV4T2YoJ0hUTUwnKSA+IC0xKTtcblxuLyoqXG4gKiBSZXR1cm5zIHZhbGlkYXRvciBpbnN0YW5jZVxuICovXG5leHBvcnQgY29uc3QgZ2V0VmFsaWRhdG9yID0gKHNjaGVtYSkgPT4ge1xuICByZXR1cm4gKHBhcmFtcykgPT4ge1xuICAgIHYuYWRkU2NoZW1hKERlZmluaXRpb25zU2NoZW1hKTtcbiAgICByZXR1cm4gdi52YWxpZGF0ZShwYXJhbXMsIHNjaGVtYSk7XG4gIH07XG59O1xuIl19


/***/ }),

/***/ 6330:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */



const util = __nccwpck_require__(1669);
const toRegexRange = __nccwpck_require__(1861);

const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const transform = toNumber => {
  return value => toNumber === true ? Number(value) : String(value);
};

const isValidValue = value => {
  return typeof value === 'number' || (typeof value === 'string' && value !== '');
};

const isNumber = num => Number.isInteger(+num);

const zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;
  while (value[++index] === '0');
  return index > 0;
};

const stringify = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }
  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};

const toMaxLen = (input, maxLength) => {
  let negative = input[0] === '-' ? '-' : '';
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength) input = '0' + input;
  return negative ? ('-' + input) : input;
};

const toSequence = (parts, options) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
    positives = parts.positives.join('|');
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.join('|')})`;
  }

  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
    return toRegexRange(a, b, { wrap: false, ...options });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
    let wrap = options.wrap === true;
    let prefix = options.capture ? '' : '?:';
    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
  }
  return toRegexRange(start, end, options);
};

const rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + util.inspect(...args));
};

const invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

const invalidStep = (step, options) => {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};

const fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  }

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify(start, end, options) === false;
  let format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  let parts = { negatives: [], positives: [] };
  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1
      ? toSequence(parts, options)
      : toRegex(range, null, { wrap: false, ...options });
  }

  return range;
};

const fillLetters = (start, end, step = 1, options = {}) => {
  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {
    return invalidRange(start, end, options);
  }


  let format = options.transform || (val => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, { wrap: false, options });
  }

  return range;
};

const fill = (start, end, step, options = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return fill(start, end, 1, { transform: step });
  }

  if (isObject(step)) {
    return fill(start, end, 0, step);
  }

  let opts = { ...options };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject(step)) return invalidStep(step, opts);
    return fill(start, end, 1, step);
  }

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

module.exports = fill;


/***/ }),

/***/ 4655:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var isGlob = __nccwpck_require__(4466);
var pathPosixDirname = __nccwpck_require__(5622).posix.dirname;
var isWin32 = __nccwpck_require__(2087).platform() === 'win32';

var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;

/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 * @returns {string}
 */
module.exports = function globParent(str, opts) {
  var options = Object.assign({ flipBackslashes: true }, opts);

  // flip windows path separators
  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  }

  // special case for strings ending in enclosure containing path separator
  if (enclosure.test(str)) {
    str += slash;
  }

  // preserves full path in case of trailing path separator
  str += 'a';

  // remove path parts that are globby
  do {
    str = pathPosixDirname(str);
  } while (isGlob(str) || globby.test(str));

  // remove escape chars and return result
  return str.replace(escaped, '$1');
};


/***/ }),

/***/ 4824:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nccwpck_require__) => {

"use strict";
// ESM COMPAT FLAG
__nccwpck_require__.r(__webpack_exports__);

// EXPORTS
__nccwpck_require__.d(__webpack_exports__, {
  "generateGlobTasks": () => (/* binding */ generateGlobTasks),
  "generateGlobTasksSync": () => (/* binding */ generateGlobTasksSync),
  "globby": () => (/* binding */ globby),
  "globbyStream": () => (/* binding */ globbyStream),
  "globbySync": () => (/* binding */ globbySync),
  "isDynamicPattern": () => (/* binding */ isDynamicPattern),
  "isGitIgnored": () => (/* reexport */ isGitIgnored),
  "isGitIgnoredSync": () => (/* reexport */ isGitIgnoredSync)
});

;// CONCATENATED MODULE: external "node:fs"
const external_node_fs_namespaceObject = require("node:fs");
;// CONCATENATED MODULE: external "node:path"
const external_node_path_namespaceObject = require("node:path");
// EXTERNAL MODULE: ./node_modules/merge2/index.js
var merge2 = __nccwpck_require__(2578);
// EXTERNAL MODULE: ./node_modules/fast-glob/out/index.js
var out = __nccwpck_require__(3664);
// EXTERNAL MODULE: ./node_modules/dir-glob/index.js
var dir_glob = __nccwpck_require__(2738);
;// CONCATENATED MODULE: external "node:process"
const external_node_process_namespaceObject = require("node:process");
// EXTERNAL MODULE: ./node_modules/globby/node_modules/ignore/index.js
var ignore = __nccwpck_require__(2069);
;// CONCATENATED MODULE: ./node_modules/globby/node_modules/slash/index.js
function slash(path) {
	const isExtendedLengthPath = /^\\\\\?\\/.test(path);
	const hasNonAscii = /[^\u0000-\u0080]+/.test(path); // eslint-disable-line no-control-regex

	if (isExtendedLengthPath || hasNonAscii) {
		return path;
	}

	return path.replace(/\\/g, '/');
}

;// CONCATENATED MODULE: external "node:url"
const external_node_url_namespaceObject = require("node:url");
;// CONCATENATED MODULE: external "node:stream"
const external_node_stream_namespaceObject = require("node:stream");
;// CONCATENATED MODULE: ./node_modules/globby/utilities.js



const toPath = urlOrPath => urlOrPath instanceof URL ? (0,external_node_url_namespaceObject.fileURLToPath)(urlOrPath) : urlOrPath;

class FilterStream extends external_node_stream_namespaceObject.Transform {
	constructor(filter) {
		super({
			objectMode: true,
			transform(data, encoding, callback) {
				callback(undefined, filter(data) ? data : undefined);
			},
		});
	}
}

const isNegativePattern = pattern => pattern[0] === '!';

;// CONCATENATED MODULE: ./node_modules/globby/ignore.js








const ignoreFilesGlobOptions = {
	ignore: [
		'**/node_modules',
		'**/flow-typed',
		'**/coverage',
		'**/.git',
	],
	absolute: true,
	dot: true,
};

const GITIGNORE_FILES_PATTERN = '**/.gitignore';

const applyBaseToPattern = (pattern, base) => isNegativePattern(pattern)
	? '!' + external_node_path_namespaceObject.posix.join(base, pattern.slice(1))
	: external_node_path_namespaceObject.posix.join(base, pattern);

const parseIgnoreFile = (file, cwd) => {
	const base = slash(external_node_path_namespaceObject.relative(cwd, external_node_path_namespaceObject.dirname(file.filePath)));

	return file.content
		.split(/\r?\n/)
		.filter(line => line && !line.startsWith('#'))
		.map(pattern => applyBaseToPattern(pattern, base));
};

const toRelativePath = (fileOrDirectory, cwd) => {
	cwd = slash(cwd);
	if (external_node_path_namespaceObject.isAbsolute(fileOrDirectory)) {
		if (slash(fileOrDirectory).startsWith(cwd)) {
			return external_node_path_namespaceObject.relative(cwd, fileOrDirectory);
		}

		throw new Error(`Path ${fileOrDirectory} is not in cwd ${cwd}`);
	}

	return fileOrDirectory;
};

const getIsIgnoredPredicate = (files, cwd) => {
	const patterns = files.flatMap(file => parseIgnoreFile(file, cwd));
	const ignores = ignore().add(patterns);

	return fileOrDirectory => {
		fileOrDirectory = toPath(fileOrDirectory);
		fileOrDirectory = toRelativePath(fileOrDirectory, cwd);
		return ignores.ignores(slash(fileOrDirectory));
	};
};

const normalizeOptions = (options = {}) => ({
	cwd: toPath(options.cwd) || external_node_process_namespaceObject.cwd(),
});

const isIgnoredByIgnoreFiles = async (patterns, options) => {
	const {cwd} = normalizeOptions(options);

	const paths = await out(patterns, {cwd, ...ignoreFilesGlobOptions});

	const files = await Promise.all(
		paths.map(async filePath => ({
			filePath,
			content: await external_node_fs_namespaceObject.promises.readFile(filePath, 'utf8'),
		})),
	);

	return getIsIgnoredPredicate(files, cwd);
};

const isIgnoredByIgnoreFilesSync = (patterns, options) => {
	const {cwd} = normalizeOptions(options);

	const paths = out.sync(patterns, {cwd, ...ignoreFilesGlobOptions});

	const files = paths.map(filePath => ({
		filePath,
		content: external_node_fs_namespaceObject.readFileSync(filePath, 'utf8'),
	}));

	return getIsIgnoredPredicate(files, cwd);
};

const isGitIgnored = options => isIgnoredByIgnoreFiles(GITIGNORE_FILES_PATTERN, options);
const isGitIgnoredSync = options => isIgnoredByIgnoreFilesSync(GITIGNORE_FILES_PATTERN, options);

;// CONCATENATED MODULE: ./node_modules/globby/index.js








const assertPatternsInput = patterns => {
	if (patterns.some(pattern => typeof pattern !== 'string')) {
		throw new TypeError('Patterns must be a string or an array of strings');
	}
};

const toPatternsArray = patterns => {
	patterns = [...new Set([patterns].flat())];
	assertPatternsInput(patterns);
	return patterns;
};

const checkCwdOption = options => {
	if (!options.cwd) {
		return;
	}

	let stat;
	try {
		stat = external_node_fs_namespaceObject.statSync(options.cwd);
	} catch {
		return;
	}

	if (!stat.isDirectory()) {
		throw new Error('The `cwd` option must be a path to a directory');
	}
};

const globby_normalizeOptions = (options = {}) => {
	options = {
		ignore: [],
		expandDirectories: true,
		...options,
		cwd: toPath(options.cwd),
	};

	checkCwdOption(options);

	return options;
};

const normalizeArguments = fn => async (patterns, options) => fn(toPatternsArray(patterns), globby_normalizeOptions(options));
const normalizeArgumentsSync = fn => (patterns, options) => fn(toPatternsArray(patterns), globby_normalizeOptions(options));

const getIgnoreFilesPatterns = options => {
	const {ignoreFiles, gitignore} = options;

	const patterns = ignoreFiles ? toPatternsArray(ignoreFiles) : [];
	if (gitignore) {
		patterns.push(GITIGNORE_FILES_PATTERN);
	}

	return patterns;
};

const getFilter = async options => {
	const ignoreFilesPatterns = getIgnoreFilesPatterns(options);
	return createFilterFunction(
		ignoreFilesPatterns.length > 0 && await isIgnoredByIgnoreFiles(ignoreFilesPatterns, {cwd: options.cwd}),
	);
};

const getFilterSync = options => {
	const ignoreFilesPatterns = getIgnoreFilesPatterns(options);
	return createFilterFunction(
		ignoreFilesPatterns.length > 0 && isIgnoredByIgnoreFilesSync(ignoreFilesPatterns, {cwd: options.cwd}),
	);
};

const createFilterFunction = isIgnored => {
	const seen = new Set();

	return fastGlobResult => {
		const path = fastGlobResult.path || fastGlobResult;
		const pathKey = external_node_path_namespaceObject.normalize(path);
		const seenOrIgnored = seen.has(pathKey) || (isIgnored && isIgnored(path));
		seen.add(pathKey);
		return !seenOrIgnored;
	};
};

const unionFastGlobResults = (results, filter) => results.flat().filter(fastGlobResult => filter(fastGlobResult));
const unionFastGlobStreams = (streams, filter) => merge2(streams).pipe(new FilterStream(fastGlobResult => filter(fastGlobResult)));

const convertNegativePatterns = (patterns, options) => {
	const tasks = [];

	while (patterns.length > 0) {
		const index = patterns.findIndex(pattern => isNegativePattern(pattern));

		if (index === -1) {
			tasks.push({patterns, options});
			break;
		}

		const ignorePattern = patterns[index].slice(1);

		for (const task of tasks) {
			task.options.ignore.push(ignorePattern);
		}

		if (index !== 0) {
			tasks.push({
				patterns: patterns.slice(0, index),
				options: {
					...options,
					ignore: [
						...options.ignore,
						ignorePattern,
					],
				},
			});
		}

		patterns = patterns.slice(index + 1);
	}

	return tasks;
};

const getDirGlobOptions = (options, cwd) => ({
	...(cwd ? {cwd} : {}),
	...(Array.isArray(options) ? {files: options} : options),
});

const generateTasks = async (patterns, options) => {
	const globTasks = convertNegativePatterns(patterns, options);

	const {cwd, expandDirectories} = options;

	if (!expandDirectories) {
		return globTasks;
	}

	const patternExpandOptions = getDirGlobOptions(expandDirectories, cwd);
	const ignoreExpandOptions = cwd ? {cwd} : undefined;

	return Promise.all(
		globTasks.map(async task => {
			let {patterns, options} = task;

			[
				patterns,
				options.ignore,
			] = await Promise.all([
				dir_glob(patterns, patternExpandOptions),
				dir_glob(options.ignore, ignoreExpandOptions),
			]);

			return {patterns, options};
		}),
	);
};

const generateTasksSync = (patterns, options) => {
	const globTasks = convertNegativePatterns(patterns, options);

	const {cwd, expandDirectories} = options;

	if (!expandDirectories) {
		return globTasks;
	}

	const patternExpandOptions = getDirGlobOptions(expandDirectories, cwd);
	const ignoreExpandOptions = cwd ? {cwd} : undefined;

	return globTasks.map(task => {
		let {patterns, options} = task;
		patterns = dir_glob.sync(patterns, patternExpandOptions);
		options.ignore = dir_glob.sync(options.ignore, ignoreExpandOptions);
		return {patterns, options};
	});
};

const globby = normalizeArguments(async (patterns, options) => {
	const [
		tasks,
		filter,
	] = await Promise.all([
		generateTasks(patterns, options),
		getFilter(options),
	]);
	const results = await Promise.all(tasks.map(task => out(task.patterns, task.options)));

	return unionFastGlobResults(results, filter);
});

const globbySync = normalizeArgumentsSync((patterns, options) => {
	const tasks = generateTasksSync(patterns, options);
	const filter = getFilterSync(options);
	const results = tasks.map(task => out.sync(task.patterns, task.options));

	return unionFastGlobResults(results, filter);
});

const globbyStream = normalizeArgumentsSync((patterns, options) => {
	const tasks = generateTasksSync(patterns, options);
	const filter = getFilterSync(options);
	const streams = tasks.map(task => out.stream(task.patterns, task.options));

	return unionFastGlobStreams(streams, filter);
});

const isDynamicPattern = normalizeArgumentsSync(
	(patterns, options) => patterns.some(pattern => out.isDynamicPattern(pattern, options)),
);

const generateGlobTasks = normalizeArguments(generateTasks);
const generateGlobTasksSync = normalizeArgumentsSync(generateTasksSync);




/***/ }),

/***/ 2069:
/***/ ((module) => {

// A simple implementation of make-array
function makeArray (subject) {
  return Array.isArray(subject)
    ? subject
    : [subject]
}

const EMPTY = ''
const SPACE = ' '
const ESCAPE = '\\'
const REGEX_TEST_BLANK_LINE = /^\s+$/
const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/
const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/
const REGEX_SPLITALL_CRLF = /\r?\n/g
// /foo,
// ./foo,
// ../foo,
// .
// ..
const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/

const SLASH = '/'
const KEY_IGNORE = typeof Symbol !== 'undefined'
  ? Symbol.for('node-ignore')
  /* istanbul ignore next */
  : 'node-ignore'

const define = (object, key, value) =>
  Object.defineProperty(object, key, {value})

const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g

const RETURN_FALSE = () => false

// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const sanitizeRange = range => range.replace(
  REGEX_REGEXP_RANGE,
  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)
    ? match
    // Invalid range (out of order) which is ok for gitignore rules but
    //   fatal for JavaScript regular expression, so eliminate it.
    : EMPTY
)

// See fixtures #59
const cleanRangeBackSlash = slashes => {
  const {length} = slashes
  return slashes.slice(0, length - length % 2)
}

// > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`

// '`foo/`' should not continue with the '`..`'
const REPLACERS = [

  // > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [
    // (a\ ) -> (a )
    // (a  ) -> (a)
    // (a \ ) -> (a  )
    /\\?\s+$/,
    match => match.indexOf('\\') === 0
      ? SPACE
      : EMPTY
  ],

  // replace (\ ) with ' '
  [
    /\\\s/g,
    () => SPACE
  ],

  // Escape metacharacters
  // which is written down by users but means special for regular expressions.

  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [
    /[\\$.|*+(){^]/g,
    match => `\\${match}`
  ],

  [
    // > a question mark (?) matches a single character
    /(?!\\)\?/g,
    () => '[^/]'
  ],

  // leading slash
  [

    // > A leading slash matches the beginning of the pathname.
    // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
    // A leading slash matches the beginning of the pathname
    /^\//,
    () => '^'
  ],

  // replace special metacharacter slash after the leading slash
  [
    /\//g,
    () => '\\/'
  ],

  [
    // > A leading "**" followed by a slash means match in all directories.
    // > For example, "**/foo" matches file or directory "foo" anywhere,
    // > the same as pattern "foo".
    // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
    // >   under directory "foo".
    // Notice that the '*'s have been replaced as '\\*'
    /^\^*\\\*\\\*\\\//,

    // '**/foo' <-> 'foo'
    () => '^(?:.*\\/)?'
  ],

  // starting
  [
    // there will be no leading '/'
    //   (which has been replaced by section "leading slash")
    // If starts with '**', adding a '^' to the regular expression also works
    /^(?=[^^])/,
    function startingReplacer () {
      // If has a slash `/` at the beginning or middle
      return !/\/(?!$)/.test(this)
        // > Prior to 2.22.1
        // > If the pattern does not contain a slash /,
        // >   Git treats it as a shell glob pattern
        // Actually, if there is only a trailing slash,
        //   git also treats it as a shell glob pattern

        // After 2.22.1 (compatible but clearer)
        // > If there is a separator at the beginning or middle (or both)
        // > of the pattern, then the pattern is relative to the directory
        // > level of the particular .gitignore file itself.
        // > Otherwise the pattern may also match at any level below
        // > the .gitignore level.
        ? '(?:^|\\/)'

        // > Otherwise, Git treats the pattern as a shell glob suitable for
        // >   consumption by fnmatch(3)
        : '^'
    }
  ],

  // two globstars
  [
    // Use lookahead assertions so that we could match more than one `'/**'`
    /\\\/\\\*\\\*(?=\\\/|$)/g,

    // Zero, one or several directories
    // should not use '*', or it will be replaced by the next replacer

    // Check if it is not the last `'/**'`
    (_, index, str) => index + 6 < str.length

      // case: /**/
      // > A slash followed by two consecutive asterisks then a slash matches
      // >   zero or more directories.
      // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
      // '/**/'
      ? '(?:\\/[^\\/]+)*'

      // case: /**
      // > A trailing `"/**"` matches everything inside.

      // #21: everything inside but it should not include the current folder
      : '\\/.+'
  ],

  // intermediate wildcards
  [
    // Never replace escaped '*'
    // ignore rule '\*' will match the path '*'

    // 'abc.*/' -> go
    // 'abc.*'  -> skip this rule
    /(^|[^\\]+)\\\*(?=.+)/g,

    // '*.js' matches '.js'
    // '*.js' doesn't match 'abc'
    (_, p1) => `${p1}[^\\/]*`
  ],

  [
    // unescape, revert step 3 except for back slash
    // For example, if a user escape a '\\*',
    // after step 3, the result will be '\\\\\\*'
    /\\\\\\(?=[$.|*+(){^])/g,
    () => ESCAPE
  ],

  [
    // '\\\\' -> '\\'
    /\\\\/g,
    () => ESCAPE
  ],

  [
    // > The range notation, e.g. [a-zA-Z],
    // > can be used to match one of the characters in a range.

    // `\` is escaped by step 3
    /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE
      // '\\[bar]' -> '\\\\[bar\\]'
      ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}`
      : close === ']'
        ? endEscape.length % 2 === 0
          // A normal case, and it is a range notation
          // '[bar]'
          // '[bar\\\\]'
          ? `[${sanitizeRange(range)}${endEscape}]`
          // Invalid range notaton
          // '[bar\\]' -> '[bar\\\\]'
          : '[]'
        : '[]'
  ],

  // ending
  [
    // 'js' will not match 'js.'
    // 'ab' will not match 'abc'
    /(?:[^*])$/,

    // WTF!
    // https://git-scm.com/docs/gitignore
    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
    // which re-fixes #24, #38

    // > If there is a separator at the end of the pattern then the pattern
    // > will only match directories, otherwise the pattern can match both
    // > files and directories.

    // 'js*' will not match 'a.js'
    // 'js/' will not match 'a.js'
    // 'js' will match 'a.js' and 'a.js/'
    match => /\/$/.test(match)
      // foo/ will not match 'foo'
      ? `${match}$`
      // foo matches 'foo' and 'foo/'
      : `${match}(?=$|\\/$)`
  ],

  // trailing wildcard
  [
    /(\^|\\\/)?\\\*$/,
    (_, p1) => {
      const prefix = p1
        // '\^':
        // '/*' does not match EMPTY
        // '/*' does not match everything

        // '\\\/':
        // 'abc/*' does not match 'abc/'
        ? `${p1}[^/]+`

        // 'a*' matches 'a'
        // 'a*' matches 'aa'
        : '[^/]*'

      return `${prefix}(?=$|\\/$)`
    }
  ],
]

// A simple cache, because an ignore rule only has only one certain meaning
const regexCache = Object.create(null)

// @param {pattern}
const makeRegex = (pattern, ignoreCase) => {
  let source = regexCache[pattern]

  if (!source) {
    source = REPLACERS.reduce(
      (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
      pattern
    )
    regexCache[pattern] = source
  }

  return ignoreCase
    ? new RegExp(source, 'i')
    : new RegExp(source)
}

const isString = subject => typeof subject === 'string'

// > A blank line matches no files, so it can serve as a separator for readability.
const checkPattern = pattern => pattern
  && isString(pattern)
  && !REGEX_TEST_BLANK_LINE.test(pattern)

  // > A line starting with # serves as a comment.
  && pattern.indexOf('#') !== 0

const splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)

class IgnoreRule {
  constructor (
    origin,
    pattern,
    negative,
    regex
  ) {
    this.origin = origin
    this.pattern = pattern
    this.negative = negative
    this.regex = regex
  }
}

const createRule = (pattern, ignoreCase) => {
  const origin = pattern
  let negative = false

  // > An optional prefix "!" which negates the pattern;
  if (pattern.indexOf('!') === 0) {
    negative = true
    pattern = pattern.substr(1)
  }

  pattern = pattern
  // > Put a backslash ("\") in front of the first "!" for patterns that
  // >   begin with a literal "!", for example, `"\!important!.txt"`.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
  // > Put a backslash ("\") in front of the first hash for patterns that
  // >   begin with a hash.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')

  const regex = makeRegex(pattern, ignoreCase)

  return new IgnoreRule(
    origin,
    pattern,
    negative,
    regex
  )
}

const throwError = (message, Ctor) => {
  throw new Ctor(message)
}

const checkPath = (path, originalPath, doThrow) => {
  if (!isString(path)) {
    return doThrow(
      `path must be a string, but got \`${originalPath}\``,
      TypeError
    )
  }

  // We don't know if we should ignore EMPTY, so throw
  if (!path) {
    return doThrow(`path must not be empty`, TypeError)
  }

  // Check if it is a relative path
  if (checkPath.isNotRelative(path)) {
    const r = '`path.relative()`d'
    return doThrow(
      `path should be a ${r} string, but got "${originalPath}"`,
      RangeError
    )
  }

  return true
}

const isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)

checkPath.isNotRelative = isNotRelative
checkPath.convert = p => p

class Ignore {
  constructor ({
    ignorecase = true,
    ignoreCase = ignorecase,
    allowRelativePaths = false
  } = {}) {
    define(this, KEY_IGNORE, true)

    this._rules = []
    this._ignoreCase = ignoreCase
    this._allowRelativePaths = allowRelativePaths
    this._initCache()
  }

  _initCache () {
    this._ignoreCache = Object.create(null)
    this._testCache = Object.create(null)
  }

  _addPattern (pattern) {
    // #32
    if (pattern && pattern[KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern._rules)
      this._added = true
      return
    }

    if (checkPattern(pattern)) {
      const rule = createRule(pattern, this._ignoreCase)
      this._added = true
      this._rules.push(rule)
    }
  }

  // @param {Array<string> | string | Ignore} pattern
  add (pattern) {
    this._added = false

    makeArray(
      isString(pattern)
        ? splitPattern(pattern)
        : pattern
    ).forEach(this._addPattern, this)

    // Some rules have just added to the ignore,
    // making the behavior changed.
    if (this._added) {
      this._initCache()
    }

    return this
  }

  // legacy
  addPattern (pattern) {
    return this.add(pattern)
  }

  //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X

  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen

  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.

  // @returns {TestResult} true if a file is ignored
  _testOne (path, checkUnignored) {
    let ignored = false
    let unignored = false

    this._rules.forEach(rule => {
      const {negative} = rule
      if (
        unignored === negative && ignored !== unignored
        || negative && !ignored && !unignored && !checkUnignored
      ) {
        return
      }

      const matched = rule.regex.test(path)

      if (matched) {
        ignored = !negative
        unignored = negative
      }
    })

    return {
      ignored,
      unignored
    }
  }

  // @returns {TestResult}
  _test (originalPath, cache, checkUnignored, slices) {
    const path = originalPath
      // Supports nullable path
      && checkPath.convert(originalPath)

    checkPath(
      path,
      originalPath,
      this._allowRelativePaths
        ? RETURN_FALSE
        : throwError
    )

    return this._t(path, cache, checkUnignored, slices)
  }

  _t (path, cache, checkUnignored, slices) {
    if (path in cache) {
      return cache[path]
    }

    if (!slices) {
      // path/to/a.js
      // ['path', 'to', 'a.js']
      slices = path.split(SLASH)
    }

    slices.pop()

    // If the path has no parent directory, just test it
    if (!slices.length) {
      return cache[path] = this._testOne(path, checkUnignored)
    }

    const parent = this._t(
      slices.join(SLASH) + SLASH,
      cache,
      checkUnignored,
      slices
    )

    // If the path contains a parent directory, check the parent first
    return cache[path] = parent.ignored
      // > It is not possible to re-include a file if a parent directory of
      // >   that file is excluded.
      ? parent
      : this._testOne(path, checkUnignored)
  }

  ignores (path) {
    return this._test(path, this._ignoreCache, false).ignored
  }

  createFilter () {
    return path => !this.ignores(path)
  }

  filter (paths) {
    return makeArray(paths).filter(this.createFilter())
  }

  // @returns {TestResult}
  test (path) {
    return this._test(path, this._testCache, true)
  }
}

const factory = options => new Ignore(options)

const isPathValid = path =>
  checkPath(path && checkPath.convert(path), path, RETURN_FALSE)

factory.isPathValid = isPathValid

// Fixes typescript
factory.default = factory

module.exports = factory

// Windows
// --------------------------------------------------------------
/* istanbul ignore if  */
if (
  // Detect `process` so that it can run in browsers.
  typeof process !== 'undefined'
  && (
    process.env && process.env.IGNORE_TEST_WIN32
    || process.platform === 'win32'
  )
) {
  /* eslint no-control-regex: "off" */
  const makePosix = str => /^\\\\\?\\/.test(str)
  || /["<>|\u0000-\u001F]+/u.test(str)
    ? str
    : str.replace(/\\/g, '/')

  checkPath.convert = makePosix

  // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
  // 'd:\\foo'
  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i
  checkPath.isNotRelative = path =>
    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)
    || isNotRelative(path)
}


/***/ }),

/***/ 1621:
/***/ ((module) => {

"use strict";

module.exports = (flag, argv) => {
	argv = argv || process.argv;
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const pos = argv.indexOf(prefix + flag);
	const terminatorPos = argv.indexOf('--');
	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};


/***/ }),

/***/ 6435:
/***/ ((module) => {

/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;
  while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};


/***/ }),

/***/ 4466:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isExtglob = __nccwpck_require__(6435);
var chars = { '{': '}', '(': ')', '[': ']'};
var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;

module.exports = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var regex = strictRegex;
  var match;

  // optionally relax regex
  if (options && options.strict === false) {
    regex = relaxedRegex;
  }

  while ((match = regex.exec(str))) {
    if (match[2]) return true;
    var idx = match.index + match[0].length;

    // if an open bracket/brace/paren is escaped,
    // set the index to the next closing character
    var open = match[1];
    var close = open ? chars[open] : null;
    if (open && close) {
      var n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }

    str = str.slice(idx);
  }
  return false;
};


/***/ }),

/***/ 5680:
/***/ ((module) => {

"use strict";
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */



module.exports = function(num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};


/***/ }),

/***/ 9061:
/***/ ((module) => {

"use strict";

/*
    https://tools.ietf.org/html/rfc3629

    UTF8-char = UTF8-1 / UTF8-2 / UTF8-3 / UTF8-4

    UTF8-1    = %x00-7F

    UTF8-2    = %xC2-DF UTF8-tail

    UTF8-3    = %xE0 %xA0-BF UTF8-tail
                %xE1-EC 2( UTF8-tail )
                %xED %x80-9F UTF8-tail
                %xEE-EF 2( UTF8-tail )

    UTF8-4    = %xF0 %x90-BF 2( UTF8-tail )
                %xF1-F3 3( UTF8-tail )
                %xF4 %x80-8F 2( UTF8-tail )

    UTF8-tail = %x80-BF
*/

/**
 * Check if a Node.js Buffer or Uint8Array is utf-8
 *
 * @param {Buffer|Uint8Array} buf
 * @returns {boolean}
 */
function isUtf8(buf) {
    if (!buf) {
        return false;
    }

    var i = 0, len = buf.length;

    while(i < len) {
        // UTF8-1 = %x00-7F
        if (buf[i] <= 0x7F) {
            i++;

            continue;
        }

        // UTF8-2 = %xC2-DF UTF8-tail
        if (buf[i] >= 0xC2 && buf[i] <= 0xDF) {
            // if(buf[i + 1] >= 0x80 && buf[i + 1] <= 0xBF) {
            if (buf[i + 1] >> 6 === 2) {
                i += 2;

                continue;
            } else {
                return false;
            }
        }

        // UTF8-3 = %xE0 %xA0-BF UTF8-tail
        // UTF8-3 = %xED %x80-9F UTF8-tail
        if (
                (
                    (buf[i] === 0xE0 && buf[i + 1] >= 0xA0 && buf[i + 1] <= 0xBF) ||
                    (buf[i] === 0xED && buf[i + 1] >= 0x80 && buf[i + 1] <= 0x9F)
                ) && buf[i + 2] >> 6 === 2
            ) {
            i += 3;

            continue;
        }

        // UTF8-3 = %xE1-EC 2( UTF8-tail )
        // UTF8-3 = %xEE-EF 2( UTF8-tail )
        if (
                (
                    (buf[i] >= 0xE1 && buf[i] <= 0xEC) ||
                    (buf[i] >= 0xEE && buf[i] <= 0xEF)
                ) &&
                buf[i + 1] >> 6 === 2 &&
                buf[i + 2] >> 6 === 2
        ) {
            i += 3;

            continue;
        }

        // UTF8-4 = %xF0 %x90-BF 2( UTF8-tail )
        //          %xF1-F3 3( UTF8-tail )
        //          %xF4 %x80-8F 2( UTF8-tail )
        if (
                (
                    (buf[i] === 0xF0 && buf[i + 1] >= 0x90 && buf[i + 1] <= 0xBF) ||
                    (buf[i] >= 0xF1 && buf[i] <= 0xF3 && buf[i + 1] >> 6 === 2) ||
                    (buf[i] === 0xF4  && buf[i + 1] >= 0x80 && buf[i + 1] <= 0x8F)
                ) &&
            buf[i + 2] >> 6 === 2 &&
            buf[i + 3] >> 6 === 2
        ) {
            i += 4;

            continue;
        }

        return false;
    }

    return true;
}

module.exports = isUtf8;


/***/ }),

/***/ 1568:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var helpers = __nccwpck_require__(4801);

/** @type ValidatorResult */
var ValidatorResult = helpers.ValidatorResult;
/** @type SchemaError */
var SchemaError = helpers.SchemaError;

var attribute = {};

attribute.ignoreProperties = {
  // informative properties
  'id': true,
  'default': true,
  'description': true,
  'title': true,
  // arguments to other properties
  'additionalItems': true,
  'then': true,
  'else': true,
  // special-handled properties
  '$schema': true,
  '$ref': true,
  'extends': true,
};

/**
 * @name validators
 */
var validators = attribute.validators = {};

/**
 * Validates whether the instance if of a certain type
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {ValidatorResult|null}
 */
validators.type = function validateType (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var types = Array.isArray(schema.type) ? schema.type : [schema.type];
  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {
    var list = types.map(function (v) {
      if(!v) return;
      var id = v.$id || v.id;
      return id ? ('<' + id + '>') : (v+'');
    });
    result.addError({
      name: 'type',
      argument: list,
      message: "is not of a type(s) " + list,
    });
  }
  return result;
};

function testSchemaNoThrow(instance, options, ctx, callback, schema){
  var throwError = options.throwError;
  var throwAll = options.throwAll;
  options.throwError = false;
  options.throwAll = false;
  var res = this.validateSchema(instance, schema, options, ctx);
  options.throwError = throwError;
  options.throwAll = throwAll;

  if (!res.valid && callback instanceof Function) {
    callback(res);
  }
  return res.valid;
}

/**
 * Validates whether the instance matches some of the given schemas
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {ValidatorResult|null}
 */
validators.anyOf = function validateAnyOf (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var inner = new ValidatorResult(instance, schema, options, ctx);
  if (!Array.isArray(schema.anyOf)){
    throw new SchemaError("anyOf must be an array");
  }
  if (!schema.anyOf.some(
    testSchemaNoThrow.bind(
      this, instance, options, ctx, function(res){inner.importErrors(res);}
    ))) {
    var list = schema.anyOf.map(function (v, i) {
      var id = v.$id || v.id;
      if(id) return '<' + id + '>';
      return(v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
    });
    if (options.nestedErrors) {
      result.importErrors(inner);
    }
    result.addError({
      name: 'anyOf',
      argument: list,
      message: "is not any of " + list.join(','),
    });
  }
  return result;
};

/**
 * Validates whether the instance matches every given schema
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null}
 */
validators.allOf = function validateAllOf (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  if (!Array.isArray(schema.allOf)){
    throw new SchemaError("allOf must be an array");
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var self = this;
  schema.allOf.forEach(function(v, i){
    var valid = self.validateSchema(instance, v, options, ctx);
    if(!valid.valid){
      var id = v.$id || v.id;
      var msg = id || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
      result.addError({
        name: 'allOf',
        argument: { id: msg, length: valid.errors.length, valid: valid },
        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',
      });
      result.importErrors(valid);
    }
  });
  return result;
};

/**
 * Validates whether the instance matches exactly one of the given schemas
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null}
 */
validators.oneOf = function validateOneOf (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  if (!Array.isArray(schema.oneOf)){
    throw new SchemaError("oneOf must be an array");
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var inner = new ValidatorResult(instance, schema, options, ctx);
  var count = schema.oneOf.filter(
    testSchemaNoThrow.bind(
      this, instance, options, ctx, function(res) {inner.importErrors(res);}
    ) ).length;
  var list = schema.oneOf.map(function (v, i) {
    var id = v.$id || v.id;
    return id || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
  });
  if (count!==1) {
    if (options.nestedErrors) {
      result.importErrors(inner);
    }
    result.addError({
      name: 'oneOf',
      argument: list,
      message: "is not exactly one from " + list.join(','),
    });
  }
  return result;
};

/**
 * Validates "then" or "else" depending on the result of validating "if"
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null}
 */
validators.if = function validateIf (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) return null;
  if (!helpers.isSchema(schema.if)) throw new Error('Expected "if" keyword to be a schema');
  var ifValid = testSchemaNoThrow.call(this, instance, options, ctx, null, schema.if);
  var result = new ValidatorResult(instance, schema, options, ctx);
  var res;
  if(ifValid){
    if (schema.then === undefined) return;
    if (!helpers.isSchema(schema.then)) throw new Error('Expected "then" keyword to be a schema');
    res = this.validateSchema(instance, schema.then, options, ctx.makeChild(schema.then));
    result.importErrors(res);
  }else{
    if (schema.else === undefined) return;
    if (!helpers.isSchema(schema.else)) throw new Error('Expected "else" keyword to be a schema');
    res = this.validateSchema(instance, schema.else, options, ctx.makeChild(schema.else));
    result.importErrors(res);
  }
  return result;
};

function getEnumerableProperty(object, key){
  // Determine if `key` shows up in `for(var key in object)`
  // First test Object.hasOwnProperty.call as an optimization: that guarantees it does
  if(Object.hasOwnProperty.call(object, key)) return object[key];
  // Test `key in object` as an optimization; false means it won't
  if(!(key in object)) return;
  while( (object = Object.getPrototypeOf(object)) ){
    if(Object.propertyIsEnumerable.call(object, key)) return object[key];
  }
}

/**
 * Validates propertyNames
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.propertyNames = function validatePropertyNames (instance, schema, options, ctx) {
  if(!this.types.object(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var subschema = schema.propertyNames!==undefined ? schema.propertyNames : {};
  if(!helpers.isSchema(subschema)) throw new SchemaError('Expected "propertyNames" to be a schema (object or boolean)');

  for (var property in instance) {
    if(getEnumerableProperty(instance, property) !== undefined){
      var res = this.validateSchema(property, subschema, options, ctx.makeChild(subschema));
      result.importErrors(res);
    }
  }

  return result;
};

/**
 * Validates properties
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.properties = function validateProperties (instance, schema, options, ctx) {
  if(!this.types.object(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var properties = schema.properties || {};
  for (var property in properties) {
    var subschema = properties[property];
    if(subschema===undefined){
      continue;
    }else if(subschema===null){
      throw new SchemaError('Unexpected null, expected schema in "properties"');
    }
    if (typeof options.preValidateProperty == 'function') {
      options.preValidateProperty(instance, property, subschema, options, ctx);
    }
    var prop = getEnumerableProperty(instance, property);
    var res = this.validateSchema(prop, subschema, options, ctx.makeChild(subschema, property));
    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
    result.importErrors(res);
  }
  return result;
};

/**
 * Test a specific property within in instance against the additionalProperties schema attribute
 * This ignores properties with definitions in the properties schema attribute, but no other attributes.
 * If too many more types of property-existence tests pop up they may need their own class of tests (like `type` has)
 * @private
 * @return {boolean}
 */
function testAdditionalProperty (instance, schema, options, ctx, property, result) {
  if(!this.types.object(instance)) return;
  if (schema.properties && schema.properties[property] !== undefined) {
    return;
  }
  if (schema.additionalProperties === false) {
    result.addError({
      name: 'additionalProperties',
      argument: property,
      message: "is not allowed to have the additional property " + JSON.stringify(property),
    });
  } else {
    var additionalProperties = schema.additionalProperties || {};

    if (typeof options.preValidateProperty == 'function') {
      options.preValidateProperty(instance, property, additionalProperties, options, ctx);
    }

    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));
    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
    result.importErrors(res);
  }
}

/**
 * Validates patternProperties
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {
  if(!this.types.object(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var patternProperties = schema.patternProperties || {};

  for (var property in instance) {
    var test = true;
    for (var pattern in patternProperties) {
      var subschema = patternProperties[pattern];
      if(subschema===undefined){
        continue;
      }else if(subschema===null){
        throw new SchemaError('Unexpected null, expected schema in "patternProperties"');
      }
      try {
        var regexp = new RegExp(pattern, 'u');
      } catch(_e) {
        // In the event the stricter handling causes an error, fall back on the forgiving handling
        // DEPRECATED
        regexp = new RegExp(pattern);
      }
      if (!regexp.test(property)) {
        continue;
      }
      test = false;

      if (typeof options.preValidateProperty == 'function') {
        options.preValidateProperty(instance, property, subschema, options, ctx);
      }

      var res = this.validateSchema(instance[property], subschema, options, ctx.makeChild(subschema, property));
      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
      result.importErrors(res);
    }
    if (test) {
      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
    }
  }

  return result;
};

/**
 * Validates additionalProperties
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {
  if(!this.types.object(instance)) return;
  // if patternProperties is defined then we'll test when that one is called instead
  if (schema.patternProperties) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  for (var property in instance) {
    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
  }
  return result;
};

/**
 * Validates whether the instance value is at least of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minProperties = function validateMinProperties (instance, schema, options, ctx) {
  if (!this.types.object(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var keys = Object.keys(instance);
  if (!(keys.length >= schema.minProperties)) {
    result.addError({
      name: 'minProperties',
      argument: schema.minProperties,
      message: "does not meet minimum property length of " + schema.minProperties,
    });
  }
  return result;
};

/**
 * Validates whether the instance value is at most of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {
  if (!this.types.object(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var keys = Object.keys(instance);
  if (!(keys.length <= schema.maxProperties)) {
    result.addError({
      name: 'maxProperties',
      argument: schema.maxProperties,
      message: "does not meet maximum property length of " + schema.maxProperties,
    });
  }
  return result;
};

/**
 * Validates items when instance is an array
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.items = function validateItems (instance, schema, options, ctx) {
  var self = this;
  if (!this.types.array(instance)) return;
  if (schema.items===undefined) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  instance.every(function (value, i) {
    if(Array.isArray(schema.items)){
      var items =  schema.items[i]===undefined ? schema.additionalItems : schema.items[i];
    }else{
      var items = schema.items;
    }
    if (items === undefined) {
      return true;
    }
    if (items === false) {
      result.addError({
        name: 'items',
        message: "additionalItems not permitted",
      });
      return false;
    }
    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));
    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;
    result.importErrors(res);
    return true;
  });
  return result;
};

/**
 * Validates the "contains" keyword
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.contains = function validateContains (instance, schema, options, ctx) {
  var self = this;
  if (!this.types.array(instance)) return;
  if (schema.contains===undefined) return;
  if (!helpers.isSchema(schema.contains)) throw new Error('Expected "contains" keyword to be a schema');
  var result = new ValidatorResult(instance, schema, options, ctx);
  var count = instance.some(function (value, i) {
    var res = self.validateSchema(value, schema.contains, options, ctx.makeChild(schema.contains, i));
    return res.errors.length===0;
  });
  if(count===false){
    result.addError({
      name: 'contains',
      argument: schema.contains,
      message: "must contain an item matching given schema",
    });
  }
  return result;
};

/**
 * Validates minimum and exclusiveMinimum when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minimum = function validateMinimum (instance, schema, options, ctx) {
  if (!this.types.number(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {
    if(!(instance > schema.minimum)){
      result.addError({
        name: 'minimum',
        argument: schema.minimum,
        message: "must be greater than " + schema.minimum,
      });
    }
  } else {
    if(!(instance >= schema.minimum)){
      result.addError({
        name: 'minimum',
        argument: schema.minimum,
        message: "must be greater than or equal to " + schema.minimum,
      });
    }
  }
  return result;
};

/**
 * Validates maximum and exclusiveMaximum when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maximum = function validateMaximum (instance, schema, options, ctx) {
  if (!this.types.number(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {
    if(!(instance < schema.maximum)){
      result.addError({
        name: 'maximum',
        argument: schema.maximum,
        message: "must be less than " + schema.maximum,
      });
    }
  } else {
    if(!(instance <= schema.maximum)){
      result.addError({
        name: 'maximum',
        argument: schema.maximum,
        message: "must be less than or equal to " + schema.maximum,
      });
    }
  }
  return result;
};

/**
 * Validates the number form of exclusiveMinimum when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.exclusiveMinimum = function validateExclusiveMinimum (instance, schema, options, ctx) {
  // Support the boolean form of exclusiveMinimum, which is handled by the "minimum" keyword.
  if(typeof schema.exclusiveMinimum === 'boolean') return;
  if (!this.types.number(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var valid = instance > schema.exclusiveMinimum;
  if (!valid) {
    result.addError({
      name: 'exclusiveMinimum',
      argument: schema.exclusiveMinimum,
      message: "must be strictly greater than " + schema.exclusiveMinimum,
    });
  }
  return result;
};

/**
 * Validates the number form of exclusiveMaximum when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.exclusiveMaximum = function validateExclusiveMaximum (instance, schema, options, ctx) {
  // Support the boolean form of exclusiveMaximum, which is handled by the "maximum" keyword.
  if(typeof schema.exclusiveMaximum === 'boolean') return;
  if (!this.types.number(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var valid = instance < schema.exclusiveMaximum;
  if (!valid) {
    result.addError({
      name: 'exclusiveMaximum',
      argument: schema.exclusiveMaximum,
      message: "must be strictly less than " + schema.exclusiveMaximum,
    });
  }
  return result;
};

/**
 * Perform validation for multipleOf and divisibleBy, which are essentially the same.
 * @param instance
 * @param schema
 * @param validationType
 * @param errorMessage
 * @returns {String|null}
 */
var validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {
  if (!this.types.number(instance)) return;

  var validationArgument = schema[validationType];
  if (validationArgument == 0) {
    throw new SchemaError(validationType + " cannot be zero");
  }

  var result = new ValidatorResult(instance, schema, options, ctx);

  var instanceDecimals = helpers.getDecimalPlaces(instance);
  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);

  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);
  var multiplier = Math.pow(10, maxDecimals);

  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {
    result.addError({
      name: validationType,
      argument:  validationArgument,
      message: errorMessage + JSON.stringify(validationArgument),
    });
  }

  return result;
};

/**
 * Validates divisibleBy when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {
  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, "multipleOf", "is not a multiple of (divisible by) ");
};

/**
 * Validates multipleOf when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {
  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, "divisibleBy", "is not divisible by (multiple of) ");
};

/**
 * Validates whether the instance value is present.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.required = function validateRequired (instance, schema, options, ctx) {
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (instance === undefined && schema.required === true) {
    // A boolean form is implemented for reverse-compatibility with schemas written against older drafts
    result.addError({
      name: 'required',
      message: "is required",
    });
  } else if (this.types.object(instance) && Array.isArray(schema.required)) {
    schema.required.forEach(function(n){
      if(getEnumerableProperty(instance, n)===undefined){
        result.addError({
          name: 'required',
          argument: n,
          message: "requires property " + JSON.stringify(n),
        });
      }
    });
  }
  return result;
};

/**
 * Validates whether the instance value matches the regular expression, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.pattern = function validatePattern (instance, schema, options, ctx) {
  if (!this.types.string(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var pattern = schema.pattern;
  try {
    var regexp = new RegExp(pattern, 'u');
  } catch(_e) {
    // In the event the stricter handling causes an error, fall back on the forgiving handling
    // DEPRECATED
    regexp = new RegExp(pattern);
  }
  if (!instance.match(regexp)) {
    result.addError({
      name: 'pattern',
      argument: schema.pattern,
      message: "does not match pattern " + JSON.stringify(schema.pattern.toString()),
    });
  }
  return result;
};

/**
 * Validates whether the instance value is of a certain defined format or a custom
 * format.
 * The following formats are supported for string types:
 *   - date-time
 *   - date
 *   - time
 *   - ip-address
 *   - ipv6
 *   - uri
 *   - color
 *   - host-name
 *   - alpha
 *   - alpha-numeric
 *   - utc-millisec
 * @param instance
 * @param schema
 * @param [options]
 * @param [ctx]
 * @return {String|null}
 */
validators.format = function validateFormat (instance, schema, options, ctx) {
  if (instance===undefined) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {
    result.addError({
      name: 'format',
      argument: schema.format,
      message: "does not conform to the " + JSON.stringify(schema.format) + " format",
    });
  }
  return result;
};

/**
 * Validates whether the instance value is at least of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minLength = function validateMinLength (instance, schema, options, ctx) {
  if (!this.types.string(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var hsp = instance.match(/[\uDC00-\uDFFF]/g);
  var length = instance.length - (hsp ? hsp.length : 0);
  if (!(length >= schema.minLength)) {
    result.addError({
      name: 'minLength',
      argument: schema.minLength,
      message: "does not meet minimum length of " + schema.minLength,
    });
  }
  return result;
};

/**
 * Validates whether the instance value is at most of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maxLength = function validateMaxLength (instance, schema, options, ctx) {
  if (!this.types.string(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  // TODO if this was already computed in "minLength", use that value instead of re-computing
  var hsp = instance.match(/[\uDC00-\uDFFF]/g);
  var length = instance.length - (hsp ? hsp.length : 0);
  if (!(length <= schema.maxLength)) {
    result.addError({
      name: 'maxLength',
      argument: schema.maxLength,
      message: "does not meet maximum length of " + schema.maxLength,
    });
  }
  return result;
};

/**
 * Validates whether instance contains at least a minimum number of items, when the instance is an Array.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minItems = function validateMinItems (instance, schema, options, ctx) {
  if (!this.types.array(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!(instance.length >= schema.minItems)) {
    result.addError({
      name: 'minItems',
      argument: schema.minItems,
      message: "does not meet minimum length of " + schema.minItems,
    });
  }
  return result;
};

/**
 * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maxItems = function validateMaxItems (instance, schema, options, ctx) {
  if (!this.types.array(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!(instance.length <= schema.maxItems)) {
    result.addError({
      name: 'maxItems',
      argument: schema.maxItems,
      message: "does not meet maximum length of " + schema.maxItems,
    });
  }
  return result;
};

/**
 * Deep compares arrays for duplicates
 * @param v
 * @param i
 * @param a
 * @private
 * @return {boolean}
 */
function testArrays (v, i, a) {
  var j, len = a.length;
  for (j = i + 1, len; j < len; j++) {
    if (helpers.deepCompareStrict(v, a[j])) {
      return false;
    }
  }
  return true;
}

/**
 * Validates whether there are no duplicates, when the instance is an Array.
 * @param instance
 * @return {String|null}
 */
validators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {
  if (schema.uniqueItems!==true) return;
  if (!this.types.array(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!instance.every(testArrays)) {
    result.addError({
      name: 'uniqueItems',
      message: "contains duplicate item",
    });
  }
  return result;
};

/**
 * Validate for the presence of dependency properties, if the instance is an object.
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {null|ValidatorResult}
 */
validators.dependencies = function validateDependencies (instance, schema, options, ctx) {
  if (!this.types.object(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  for (var property in schema.dependencies) {
    if (instance[property] === undefined) {
      continue;
    }
    var dep = schema.dependencies[property];
    var childContext = ctx.makeChild(dep, property);
    if (typeof dep == 'string') {
      dep = [dep];
    }
    if (Array.isArray(dep)) {
      dep.forEach(function (prop) {
        if (instance[prop] === undefined) {
          result.addError({
            // FIXME there's two different "dependencies" errors here with slightly different outputs
            // Can we make these the same? Or should we create different error types?
            name: 'dependencies',
            argument: childContext.propertyPath,
            message: "property " + prop + " not found, required by " + childContext.propertyPath,
          });
        }
      });
    } else {
      var res = this.validateSchema(instance, dep, options, childContext);
      if(result.instance !== res.instance) result.instance = res.instance;
      if (res && res.errors.length) {
        result.addError({
          name: 'dependencies',
          argument: childContext.propertyPath,
          message: "does not meet dependency required by " + childContext.propertyPath,
        });
        result.importErrors(res);
      }
    }
  }
  return result;
};

/**
 * Validates whether the instance value is one of the enumerated values.
 *
 * @param instance
 * @param schema
 * @return {ValidatorResult|null}
 */
validators['enum'] = function validateEnum (instance, schema, options, ctx) {
  if (instance === undefined) {
    return null;
  }
  if (!Array.isArray(schema['enum'])) {
    throw new SchemaError("enum expects an array", schema);
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {
    result.addError({
      name: 'enum',
      argument: schema['enum'],
      message: "is not one of enum values: " + schema['enum'].map(String).join(','),
    });
  }
  return result;
};

/**
 * Validates whether the instance exactly matches a given value
 *
 * @param instance
 * @param schema
 * @return {ValidatorResult|null}
 */
validators['const'] = function validateEnum (instance, schema, options, ctx) {
  if (instance === undefined) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!helpers.deepCompareStrict(schema['const'], instance)) {
    result.addError({
      name: 'const',
      argument: schema['const'],
      message: "does not exactly match expected constant: " + schema['const'],
    });
  }
  return result;
};

/**
 * Validates whether the instance if of a prohibited type.
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {null|ValidatorResult}
 */
validators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {
  var self = this;
  if(instance===undefined) return null;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var notTypes = schema.not || schema.disallow;
  if(!notTypes) return null;
  if(!Array.isArray(notTypes)) notTypes=[notTypes];
  notTypes.forEach(function (type) {
    if (self.testType(instance, schema, options, ctx, type)) {
      var id = type && (type.$id || type.id);
      var schemaId = id || type;
      result.addError({
        name: 'not',
        argument: schemaId,
        message: "is of prohibited type " + schemaId,
      });
    }
  });
  return result;
};

module.exports = attribute;


/***/ }),

/***/ 4801:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


var uri = __nccwpck_require__(8835);

var ValidationError = exports.ValidationError = function ValidationError (message, instance, schema, path, name, argument) {
  if(Array.isArray(path)){
    this.path = path;
    this.property = path.reduce(function(sum, item){
      return sum + makeSuffix(item);
    }, 'instance');
  }else if(path !== undefined){
    this.property = path;
  }
  if (message) {
    this.message = message;
  }
  if (schema) {
    var id = schema.$id || schema.id;
    this.schema = id || schema;
  }
  if (instance !== undefined) {
    this.instance = instance;
  }
  this.name = name;
  this.argument = argument;
  this.stack = this.toString();
};

ValidationError.prototype.toString = function toString() {
  return this.property + ' ' + this.message;
};

var ValidatorResult = exports.ValidatorResult = function ValidatorResult(instance, schema, options, ctx) {
  this.instance = instance;
  this.schema = schema;
  this.options = options;
  this.path = ctx.path;
  this.propertyPath = ctx.propertyPath;
  this.errors = [];
  this.throwError = options && options.throwError;
  this.throwFirst = options && options.throwFirst;
  this.throwAll = options && options.throwAll;
  this.disableFormat = options && options.disableFormat === true;
};

ValidatorResult.prototype.addError = function addError(detail) {
  var err;
  if (typeof detail == 'string') {
    err = new ValidationError(detail, this.instance, this.schema, this.path);
  } else {
    if (!detail) throw new Error('Missing error detail');
    if (!detail.message) throw new Error('Missing error message');
    if (!detail.name) throw new Error('Missing validator type');
    err = new ValidationError(detail.message, this.instance, this.schema, this.path, detail.name, detail.argument);
  }

  this.errors.push(err);
  if (this.throwFirst) {
    throw new ValidatorResultError(this);
  }else if(this.throwError){
    throw err;
  }
  return err;
};

ValidatorResult.prototype.importErrors = function importErrors(res) {
  if (typeof res == 'string' || (res && res.validatorType)) {
    this.addError(res);
  } else if (res && res.errors) {
    this.errors = this.errors.concat(res.errors);
  }
};

function stringizer (v,i){
  return i+': '+v.toString()+'\n';
}
ValidatorResult.prototype.toString = function toString(res) {
  return this.errors.map(stringizer).join('');
};

Object.defineProperty(ValidatorResult.prototype, "valid", { get: function() {
  return !this.errors.length;
} });

module.exports.ValidatorResultError = ValidatorResultError;
function ValidatorResultError(result) {
  if(Error.captureStackTrace){
    Error.captureStackTrace(this, ValidatorResultError);
  }
  this.instance = result.instance;
  this.schema = result.schema;
  this.options = result.options;
  this.errors = result.errors;
}
ValidatorResultError.prototype = new Error();
ValidatorResultError.prototype.constructor = ValidatorResultError;
ValidatorResultError.prototype.name = "Validation Error";

/**
 * Describes a problem with a Schema which prevents validation of an instance
 * @name SchemaError
 * @constructor
 */
var SchemaError = exports.SchemaError = function SchemaError (msg, schema) {
  this.message = msg;
  this.schema = schema;
  Error.call(this, msg);
  Error.captureStackTrace(this, SchemaError);
};
SchemaError.prototype = Object.create(Error.prototype,
  {
    constructor: {value: SchemaError, enumerable: false},
    name: {value: 'SchemaError', enumerable: false},
  });

var SchemaContext = exports.SchemaContext = function SchemaContext (schema, options, path, base, schemas) {
  this.schema = schema;
  this.options = options;
  if(Array.isArray(path)){
    this.path = path;
    this.propertyPath = path.reduce(function(sum, item){
      return sum + makeSuffix(item);
    }, 'instance');
  }else{
    this.propertyPath = path;
  }
  this.base = base;
  this.schemas = schemas;
};

SchemaContext.prototype.resolve = function resolve (target) {
  return uri.resolve(this.base, target);
};

SchemaContext.prototype.makeChild = function makeChild(schema, propertyName){
  var path = (propertyName===undefined) ? this.path : this.path.concat([propertyName]);
  var id = schema.$id || schema.id;
  var base = uri.resolve(this.base, id||'');
  var ctx = new SchemaContext(schema, this.options, path, base, Object.create(this.schemas));
  if(id && !ctx.schemas[base]){
    ctx.schemas[base] = schema;
  }
  return ctx;
};

var FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {
  // 7.3.1. Dates, Times, and Duration
  'date-time': /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\.\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,
  'date': /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,
  'time': /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,
  'duration': /P(T\d+(H(\d+M(\d+S)?)?|M(\d+S)?|S)|\d+(D|M(\d+D)?|Y(\d+M(\d+D)?)?)(T\d+(H(\d+M(\d+S)?)?|M(\d+S)?|S))?|\d+W)/i,

  // 7.3.2. Email Addresses
  // TODO: fix the email production
  'email': /^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/,
  'idn-email': /^("(?:[!#-\[\]-\u{10FFFF}]|\\[\t -\u{10FFFF}])*"|[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}](?:\.?[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}])*)@([!#-'*+\-/-9=?A-Z\^-\u{10FFFF}](?:\.?[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}])*|\[[!-Z\^-\u{10FFFF}]*\])$/u,

  // 7.3.3. Hostnames

  // 7.3.4. IP Addresses
  'ip-address': /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
  // FIXME whitespace is invalid
  'ipv6': /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,

  // 7.3.5. Resource Identifiers
  // TODO: A more accurate regular expression for "uri" goes:
  // [A-Za-z][+\-.0-9A-Za-z]*:((/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?)?#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])|/?%[0-9A-Fa-f]{2}|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*(#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?|/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)?)?
  'uri': /^[a-zA-Z][a-zA-Z0-9+.-]*:[^\s]*$/,
  'uri-reference': /^(((([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|([A-Za-z][+\-.0-9A-Za-z]*:?)?)|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?))#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(([A-Za-z][+\-.0-9A-Za-z]*)?%[0-9A-Fa-f]{2}|[!$&-.0-9;=@_~]|[A-Za-z][+\-.0-9A-Za-z]*[!$&-*,;=@_~])(%[0-9A-Fa-f]{2}|[!$&-.0-9;=@-Z_a-z~])*((([/?](%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?#|[/?])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?|([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)?|[A-Za-z][+\-.0-9A-Za-z]*:?)?$/,
  'iri': /^[a-zA-Z][a-zA-Z0-9+.-]*:[^\s]*$/,
  'iri-reference': /^(((([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~-\u{10FFFF}]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|([A-Za-z][+\-.0-9A-Za-z]*:?)?)|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|(\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?))#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|(([A-Za-z][+\-.0-9A-Za-z]*)?%[0-9A-Fa-f]{2}|[!$&-.0-9;=@_~-\u{10FFFF}]|[A-Za-z][+\-.0-9A-Za-z]*[!$&-*,;=@_~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-.0-9;=@-Z_a-z~-\u{10FFFF}])*((([/?](%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*)?#|[/?])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*)?|([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~-\u{10FFFF}]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)?|[A-Za-z][+\-.0-9A-Za-z]*:?)?$/u,
  'uuid': /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,

  // 7.3.6. uri-template
  'uri-template': /(%[0-9a-f]{2}|[!#$&(-;=?@\[\]_a-z~]|\{[!#&+,./;=?@|]?(%[0-9a-f]{2}|[0-9_a-z])(\.?(%[0-9a-f]{2}|[0-9_a-z]))*(:[1-9]\d{0,3}|\*)?(,(%[0-9a-f]{2}|[0-9_a-z])(\.?(%[0-9a-f]{2}|[0-9_a-z]))*(:[1-9]\d{0,3}|\*)?)*\})*/iu,

  // 7.3.7. JSON Pointers
  'json-pointer': /^(\/([\x00-\x2e0-@\[-}\x7f]|~[01])*)*$/iu,
  'relative-json-pointer': /^\d+(#|(\/([\x00-\x2e0-@\[-}\x7f]|~[01])*)*)$/iu,

  // hostname regex from: http://stackoverflow.com/a/1420225/5628
  'hostname': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
  'host-name': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,

  'utc-millisec': function (input) {
    return (typeof input === 'string') && parseFloat(input) === parseInt(input, 10) && !isNaN(input);
  },

  // 7.3.8. regex
  'regex': function (input) {
    var result = true;
    try {
      new RegExp(input);
    } catch (e) {
      result = false;
    }
    return result;
  },

  // Other definitions
  // "style" was removed from JSON Schema in draft-4 and is deprecated
  'style': /[\r\n\t ]*[^\r\n\t ][^:]*:[\r\n\t ]*[^\r\n\t ;]*[\r\n\t ]*;?/,
  // "color" was removed from JSON Schema in draft-4 and is deprecated
  'color': /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/,
  'phone': /^\+(?:[0-9] ?){6,14}[0-9]$/,
  'alpha': /^[a-zA-Z]+$/,
  'alphanumeric': /^[a-zA-Z0-9]+$/,
};

FORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;
FORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;
FORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS['ip-address'];

exports.isFormat = function isFormat (input, format, validator) {
  if (typeof input === 'string' && FORMAT_REGEXPS[format] !== undefined) {
    if (FORMAT_REGEXPS[format] instanceof RegExp) {
      return FORMAT_REGEXPS[format].test(input);
    }
    if (typeof FORMAT_REGEXPS[format] === 'function') {
      return FORMAT_REGEXPS[format](input);
    }
  } else if (validator && validator.customFormats &&
      typeof validator.customFormats[format] === 'function') {
    return validator.customFormats[format](input);
  }
  return true;
};

var makeSuffix = exports.makeSuffix = function makeSuffix (key) {
  key = key.toString();
  // This function could be capable of outputting valid a ECMAScript string, but the
  // resulting code for testing which form to use would be tens of thousands of characters long
  // That means this will use the name form for some illegal forms
  if (!key.match(/[.\s\[\]]/) && !key.match(/^[\d]/)) {
    return '.' + key;
  }
  if (key.match(/^\d+$/)) {
    return '[' + key + ']';
  }
  return '[' + JSON.stringify(key) + ']';
};

exports.deepCompareStrict = function deepCompareStrict (a, b) {
  if (typeof a !== typeof b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    return a.every(function (v, i) {
      return deepCompareStrict(a[i], b[i]);
    });
  }
  if (typeof a === 'object') {
    if (!a || !b) {
      return a === b;
    }
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    return aKeys.every(function (v) {
      return deepCompareStrict(a[v], b[v]);
    });
  }
  return a === b;
};

function deepMerger (target, dst, e, i) {
  if (typeof e === 'object') {
    dst[i] = deepMerge(target[i], e);
  } else {
    if (target.indexOf(e) === -1) {
      dst.push(e);
    }
  }
}

function copyist (src, dst, key) {
  dst[key] = src[key];
}

function copyistWithDeepMerge (target, src, dst, key) {
  if (typeof src[key] !== 'object' || !src[key]) {
    dst[key] = src[key];
  }
  else {
    if (!target[key]) {
      dst[key] = src[key];
    } else {
      dst[key] = deepMerge(target[key], src[key]);
    }
  }
}

function deepMerge (target, src) {
  var array = Array.isArray(src);
  var dst = array && [] || {};

  if (array) {
    target = target || [];
    dst = dst.concat(target);
    src.forEach(deepMerger.bind(null, target, dst));
  } else {
    if (target && typeof target === 'object') {
      Object.keys(target).forEach(copyist.bind(null, target, dst));
    }
    Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));
  }

  return dst;
}

module.exports.deepMerge = deepMerge;

/**
 * Validates instance against the provided schema
 * Implements URI+JSON Pointer encoding, e.g. "%7e"="~0"=>"~", "~1"="%2f"=>"/"
 * @param o
 * @param s The path to walk o along
 * @return any
 */
exports.objectGetPath = function objectGetPath(o, s) {
  var parts = s.split('/').slice(1);
  var k;
  while (typeof (k=parts.shift()) == 'string') {
    var n = decodeURIComponent(k.replace(/~0/,'~').replace(/~1/g,'/'));
    if (!(n in o)) return;
    o = o[n];
  }
  return o;
};

function pathEncoder (v) {
  return '/'+encodeURIComponent(v).replace(/~/g,'%7E');
}
/**
 * Accept an Array of property names and return a JSON Pointer URI fragment
 * @param Array a
 * @return {String}
 */
exports.encodePath = function encodePointer(a){
  // ~ must be encoded explicitly because hacks
  // the slash is encoded by encodeURIComponent
  return a.map(pathEncoder).join('');
};


/**
 * Calculate the number of decimal places a number uses
 * We need this to get correct results out of multipleOf and divisibleBy
 * when either figure is has decimal places, due to IEEE-754 float issues.
 * @param number
 * @returns {number}
 */
exports.getDecimalPlaces = function getDecimalPlaces(number) {

  var decimalPlaces = 0;
  if (isNaN(number)) return decimalPlaces;

  if (typeof number !== 'number') {
    number = Number(number);
  }

  var parts = number.toString().split('e');
  if (parts.length === 2) {
    if (parts[1][0] !== '-') {
      return decimalPlaces;
    } else {
      decimalPlaces = Number(parts[1].slice(1));
    }
  }

  var decimalParts = parts[0].split('.');
  if (decimalParts.length === 2) {
    decimalPlaces += decimalParts[1].length;
  }

  return decimalPlaces;
};

exports.isSchema = function isSchema(val){
  return (typeof val === 'object' && val) || (typeof val === 'boolean');
};



/***/ }),

/***/ 3978:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Validator = module.exports.Validator = __nccwpck_require__(8669);

module.exports.ValidatorResult = __nccwpck_require__(4801).ValidatorResult;
module.exports.ValidatorResultError = __nccwpck_require__(4801).ValidatorResultError;
module.exports.ValidationError = __nccwpck_require__(4801).ValidationError;
module.exports.SchemaError = __nccwpck_require__(4801).SchemaError;
module.exports.SchemaScanResult = __nccwpck_require__(9534).SchemaScanResult;
module.exports.scan = __nccwpck_require__(9534).scan;

module.exports.validate = function (instance, schema, options) {
  var v = new Validator();
  return v.validate(instance, schema, options);
};


/***/ }),

/***/ 9534:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var urilib = __nccwpck_require__(8835);
var helpers = __nccwpck_require__(4801);

module.exports.SchemaScanResult = SchemaScanResult;
function SchemaScanResult(found, ref){
  this.id = found;
  this.ref = ref;
}

/**
 * Adds a schema with a certain urn to the Validator instance.
 * @param string uri
 * @param object schema
 * @return {Object}
 */
module.exports.scan = function scan(base, schema){
  function scanSchema(baseuri, schema){
    if(!schema || typeof schema!='object') return;
    // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined
    if(schema.$ref){
      var resolvedUri = urilib.resolve(baseuri, schema.$ref);
      ref[resolvedUri] = ref[resolvedUri] ? ref[resolvedUri]+1 : 0;
      return;
    }
    var id = schema.$id || schema.id;
    var ourBase = id ? urilib.resolve(baseuri, id) : baseuri;
    if (ourBase) {
      // If there's no fragment, append an empty one
      if(ourBase.indexOf('#')<0) ourBase += '#';
      if(found[ourBase]){
        if(!helpers.deepCompareStrict(found[ourBase], schema)){
          throw new Error('Schema <'+ourBase+'> already exists with different definition');
        }
        return found[ourBase];
      }
      found[ourBase] = schema;
      // strip trailing fragment
      if(ourBase[ourBase.length-1]=='#'){
        found[ourBase.substring(0, ourBase.length-1)] = schema;
      }
    }
    scanArray(ourBase+'/items', (Array.isArray(schema.items)?schema.items:[schema.items]));
    scanArray(ourBase+'/extends', (Array.isArray(schema.extends)?schema.extends:[schema.extends]));
    scanSchema(ourBase+'/additionalItems', schema.additionalItems);
    scanObject(ourBase+'/properties', schema.properties);
    scanSchema(ourBase+'/additionalProperties', schema.additionalProperties);
    scanObject(ourBase+'/definitions', schema.definitions);
    scanObject(ourBase+'/patternProperties', schema.patternProperties);
    scanObject(ourBase+'/dependencies', schema.dependencies);
    scanArray(ourBase+'/disallow', schema.disallow);
    scanArray(ourBase+'/allOf', schema.allOf);
    scanArray(ourBase+'/anyOf', schema.anyOf);
    scanArray(ourBase+'/oneOf', schema.oneOf);
    scanSchema(ourBase+'/not', schema.not);
  }
  function scanArray(baseuri, schemas){
    if(!Array.isArray(schemas)) return;
    for(var i=0; i<schemas.length; i++){
      scanSchema(baseuri+'/'+i, schemas[i]);
    }
  }
  function scanObject(baseuri, schemas){
    if(!schemas || typeof schemas!='object') return;
    for(var p in schemas){
      scanSchema(baseuri+'/'+p, schemas[p]);
    }
  }

  var found = {};
  var ref = {};
  scanSchema(base, schema);
  return new SchemaScanResult(found, ref);
};


/***/ }),

/***/ 8669:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var urilib = __nccwpck_require__(8835);

var attribute = __nccwpck_require__(1568);
var helpers = __nccwpck_require__(4801);
var scanSchema = __nccwpck_require__(9534).scan;
var ValidatorResult = helpers.ValidatorResult;
var ValidatorResultError = helpers.ValidatorResultError;
var SchemaError = helpers.SchemaError;
var SchemaContext = helpers.SchemaContext;
//var anonymousBase = 'vnd.jsonschema:///';
var anonymousBase = '/';

/**
 * Creates a new Validator object
 * @name Validator
 * @constructor
 */
var Validator = function Validator () {
  // Allow a validator instance to override global custom formats or to have their
  // own custom formats.
  this.customFormats = Object.create(Validator.prototype.customFormats);
  this.schemas = {};
  this.unresolvedRefs = [];

  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.
  this.types = Object.create(types);
  this.attributes = Object.create(attribute.validators);
};

// Allow formats to be registered globally.
Validator.prototype.customFormats = {};

// Hint at the presence of a property
Validator.prototype.schemas = null;
Validator.prototype.types = null;
Validator.prototype.attributes = null;
Validator.prototype.unresolvedRefs = null;

/**
 * Adds a schema with a certain urn to the Validator instance.
 * @param schema
 * @param urn
 * @return {Object}
 */
Validator.prototype.addSchema = function addSchema (schema, base) {
  var self = this;
  if (!schema) {
    return null;
  }
  var scan = scanSchema(base||anonymousBase, schema);
  var ourUri = base || schema.$id || schema.id;
  for(var uri in scan.id){
    this.schemas[uri] = scan.id[uri];
  }
  for(var uri in scan.ref){
    // If this schema is already defined, it will be filtered out by the next step
    this.unresolvedRefs.push(uri);
  }
  // Remove newly defined schemas from unresolvedRefs
  this.unresolvedRefs = this.unresolvedRefs.filter(function(uri){
    return typeof self.schemas[uri]==='undefined';
  });
  return this.schemas[ourUri];
};

Validator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {
  if(!Array.isArray(schemas)) return;
  for(var i=0; i<schemas.length; i++){
    this.addSubSchema(baseuri, schemas[i]);
  }
};

Validator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {
  if(!schemas || typeof schemas!='object') return;
  for(var p in schemas){
    this.addSubSchema(baseuri, schemas[p]);
  }
};



/**
 * Sets all the schemas of the Validator instance.
 * @param schemas
 */
Validator.prototype.setSchemas = function setSchemas (schemas) {
  this.schemas = schemas;
};

/**
 * Returns the schema of a certain urn
 * @param urn
 */
Validator.prototype.getSchema = function getSchema (urn) {
  return this.schemas[urn];
};

/**
 * Validates instance against the provided schema
 * @param instance
 * @param schema
 * @param [options]
 * @param [ctx]
 * @return {Array}
 */
Validator.prototype.validate = function validate (instance, schema, options, ctx) {
  if((typeof schema !== 'boolean' && typeof schema !== 'object') || schema === null){
    throw new SchemaError('Expected `schema` to be an object or boolean');
  }
  if (!options) {
    options = {};
  }
  // This section indexes subschemas in the provided schema, so they don't need to be added with Validator#addSchema
  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI
  var id = schema.$id || schema.id;
  var base = urilib.resolve(options.base||anonymousBase, id||'');
  if(!ctx){
    ctx = new SchemaContext(schema, options, [], base, Object.create(this.schemas));
    if (!ctx.schemas[base]) {
      ctx.schemas[base] = schema;
    }
    var found = scanSchema(base, schema);
    for(var n in found.id){
      var sch = found.id[n];
      ctx.schemas[n] = sch;
    }
  }
  if(options.required && instance===undefined){
    var result = new ValidatorResult(instance, schema, options, ctx);
    result.addError('is required, but is undefined');
    return result;
  }
  var result = this.validateSchema(instance, schema, options, ctx);
  if (!result) {
    throw new Error('Result undefined');
  }else if(options.throwAll && result.errors.length){
    throw new ValidatorResultError(result);
  }
  return result;
};

/**
* @param Object schema
* @return mixed schema uri or false
*/
function shouldResolve(schema) {
  var ref = (typeof schema === 'string') ? schema : schema.$ref;
  if (typeof ref=='string') return ref;
  return false;
}

/**
 * Validates an instance against the schema (the actual work horse)
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @private
 * @return {ValidatorResult}
 */
Validator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {
  var result = new ValidatorResult(instance, schema, options, ctx);

  // Support for the true/false schemas
  if(typeof schema==='boolean') {
    if(schema===true){
      // `true` is always valid
      schema = {};
    }else if(schema===false){
      // `false` is always invalid
      schema = {type: []};
    }
  }else if(!schema){
    // This might be a string
    throw new Error("schema is undefined");
  }

  if (schema['extends']) {
    if (Array.isArray(schema['extends'])) {
      var schemaobj = {schema: schema, ctx: ctx};
      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));
      schema = schemaobj.schema;
      schemaobj.schema = null;
      schemaobj.ctx = null;
      schemaobj = null;
    } else {
      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));
    }
  }

  // If passed a string argument, load that schema URI
  var switchSchema = shouldResolve(schema);
  if (switchSchema) {
    var resolved = this.resolve(schema, switchSchema, ctx);
    var subctx = new SchemaContext(resolved.subschema, options, ctx.path, resolved.switchSchema, ctx.schemas);
    return this.validateSchema(instance, resolved.subschema, options, subctx);
  }

  var skipAttributes = options && options.skipAttributes || [];
  // Validate each schema attribute against the instance
  for (var key in schema) {
    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {
      var validatorErr = null;
      var validator = this.attributes[key];
      if (validator) {
        validatorErr = validator.call(this, instance, schema, options, ctx);
      } else if (options.allowUnknownAttributes === false) {
        // This represents an error with the schema itself, not an invalid instance
        throw new SchemaError("Unsupported attribute: " + key, schema);
      }
      if (validatorErr) {
        result.importErrors(validatorErr);
      }
    }
  }

  if (typeof options.rewrite == 'function') {
    var value = options.rewrite.call(this, instance, schema, options, ctx);
    result.instance = value;
  }
  return result;
};

/**
* @private
* @param Object schema
* @param SchemaContext ctx
* @returns Object schema or resolved schema
*/
Validator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {
  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));
};

/**
* @private
* @param Object schema
* @param SchemaContext ctx
* @returns Object schema or resolved schema
*/
Validator.prototype.superResolve = function superResolve (schema, ctx) {
  var ref = shouldResolve(schema);
  if(ref) {
    return this.resolve(schema, ref, ctx).subschema;
  }
  return schema;
};

/**
* @private
* @param Object schema
* @param Object switchSchema
* @param SchemaContext ctx
* @return Object resolved schemas {subschema:String, switchSchema: String}
* @throws SchemaError
*/
Validator.prototype.resolve = function resolve (schema, switchSchema, ctx) {
  switchSchema = ctx.resolve(switchSchema);
  // First see if the schema exists under the provided URI
  if (ctx.schemas[switchSchema]) {
    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};
  }
  // Else try walking the property pointer
  var parsed = urilib.parse(switchSchema);
  var fragment = parsed && parsed.hash;
  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);
  if (!document || !ctx.schemas[document]) {
    throw new SchemaError("no such schema <" + switchSchema + ">", schema);
  }
  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));
  if(subschema===undefined){
    throw new SchemaError("no such schema " + fragment + " located in <" + document + ">", schema);
  }
  return {subschema: subschema, switchSchema: switchSchema};
};

/**
 * Tests whether the instance if of a certain type.
 * @private
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @param type
 * @return {boolean}
 */
Validator.prototype.testType = function validateType (instance, schema, options, ctx, type) {
  if(type===undefined){
    return;
  }else if(type===null){
    throw new SchemaError('Unexpected null in "type" keyword');
  }
  if (typeof this.types[type] == 'function') {
    return this.types[type].call(this, instance);
  }
  if (type && typeof type == 'object') {
    var res = this.validateSchema(instance, type, options, ctx);
    return res === undefined || !(res && res.errors.length);
  }
  // Undefined or properties not on the list are acceptable, same as not being defined
  return true;
};

var types = Validator.prototype.types = {};
types.string = function testString (instance) {
  return typeof instance == 'string';
};
types.number = function testNumber (instance) {
  // isFinite returns false for NaN, Infinity, and -Infinity
  return typeof instance == 'number' && isFinite(instance);
};
types.integer = function testInteger (instance) {
  return (typeof instance == 'number') && instance % 1 === 0;
};
types.boolean = function testBoolean (instance) {
  return typeof instance == 'boolean';
};
types.array = function testArray (instance) {
  return Array.isArray(instance);
};
types['null'] = function testNull (instance) {
  return instance === null;
};
types.date = function testDate (instance) {
  return instance instanceof Date;
};
types.any = function testAny (instance) {
  return true;
};
types.object = function testObject (instance) {
  // TODO: fix this - see #15
  return instance && (typeof instance === 'object') && !(Array.isArray(instance)) && !(instance instanceof Date);
};

module.exports = Validator;


/***/ }),

/***/ 2061:
/***/ ((module, exports, __nccwpck_require__) => {

/* module decorator */ module = __nccwpck_require__.nmd(module);
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, true, true);
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = cloneDeep;


/***/ }),

/***/ 2578:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

/*
 * merge2
 * https://github.com/teambition/merge2
 *
 * Copyright (c) 2014-2020 Teambition
 * Licensed under the MIT license.
 */
const Stream = __nccwpck_require__(2413)
const PassThrough = Stream.PassThrough
const slice = Array.prototype.slice

module.exports = merge2

function merge2 () {
  const streamsQueue = []
  const args = slice.call(arguments)
  let merging = false
  let options = args[args.length - 1]

  if (options && !Array.isArray(options) && options.pipe == null) {
    args.pop()
  } else {
    options = {}
  }

  const doEnd = options.end !== false
  const doPipeError = options.pipeError === true
  if (options.objectMode == null) {
    options.objectMode = true
  }
  if (options.highWaterMark == null) {
    options.highWaterMark = 64 * 1024
  }
  const mergedStream = PassThrough(options)

  function addStream () {
    for (let i = 0, len = arguments.length; i < len; i++) {
      streamsQueue.push(pauseStreams(arguments[i], options))
    }
    mergeStream()
    return this
  }

  function mergeStream () {
    if (merging) {
      return
    }
    merging = true

    let streams = streamsQueue.shift()
    if (!streams) {
      process.nextTick(endStream)
      return
    }
    if (!Array.isArray(streams)) {
      streams = [streams]
    }

    let pipesCount = streams.length + 1

    function next () {
      if (--pipesCount > 0) {
        return
      }
      merging = false
      mergeStream()
    }

    function pipe (stream) {
      function onend () {
        stream.removeListener('merge2UnpipeEnd', onend)
        stream.removeListener('end', onend)
        if (doPipeError) {
          stream.removeListener('error', onerror)
        }
        next()
      }
      function onerror (err) {
        mergedStream.emit('error', err)
      }
      // skip ended stream
      if (stream._readableState.endEmitted) {
        return next()
      }

      stream.on('merge2UnpipeEnd', onend)
      stream.on('end', onend)

      if (doPipeError) {
        stream.on('error', onerror)
      }

      stream.pipe(mergedStream, { end: false })
      // compatible for old stream
      stream.resume()
    }

    for (let i = 0; i < streams.length; i++) {
      pipe(streams[i])
    }

    next()
  }

  function endStream () {
    merging = false
    // emit 'queueDrain' when all streams merged.
    mergedStream.emit('queueDrain')
    if (doEnd) {
      mergedStream.end()
    }
  }

  mergedStream.setMaxListeners(0)
  mergedStream.add = addStream
  mergedStream.on('unpipe', function (stream) {
    stream.emit('merge2UnpipeEnd')
  })

  if (args.length) {
    addStream.apply(null, args)
  }
  return mergedStream
}

// check and pause streams for pipe.
function pauseStreams (streams, options) {
  if (!Array.isArray(streams)) {
    // Backwards-compat with old-style streams
    if (!streams._readableState && streams.pipe) {
      streams = streams.pipe(PassThrough(options))
    }
    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error('Only readable stream can be merged.')
    }
    streams.pause()
  } else {
    for (let i = 0, len = streams.length; i < len; i++) {
      streams[i] = pauseStreams(streams[i], options)
    }
  }
  return streams
}


/***/ }),

/***/ 6228:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const util = __nccwpck_require__(1669);
const braces = __nccwpck_require__(610);
const picomatch = __nccwpck_require__(2864);
const utils = __nccwpck_require__(7426);
const isEmptyString = val => val === '' || val === './';

/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {String|Array<string>} `list` List of strings to match.
 * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

const micromatch = (list, patterns, options) => {
  patterns = [].concat(patterns);
  list = [].concat(list);

  let omit = new Set();
  let keep = new Set();
  let items = new Set();
  let negatives = 0;

  let onResult = state => {
    items.add(state.output);
    if (options && options.onResult) {
      options.onResult(state);
    }
  };

  for (let i = 0; i < patterns.length; i++) {
    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    if (negated) negatives++;

    for (let item of list) {
      let matched = isMatch(item, true);

      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match) continue;

      if (negated) {
        omit.add(matched.output);
      } else {
        omit.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }

  let result = negatives === patterns.length ? [...items] : [...keep];
  let matches = result.filter(item => !omit.has(item));

  if (options && matches.length === 0) {
    if (options.failglob === true) {
      throw new Error(`No matches found for "${patterns.join(', ')}"`);
    }

    if (options.nonull === true || options.nullglob === true) {
      return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
    }
  }

  return matches;
};

/**
 * Backwards compatibility
 */

micromatch.match = micromatch;

/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch.matcher = (pattern, options) => picomatch(pattern, options);

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `[options]` See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Backwards compatibility
 */

micromatch.any = micromatch.isMatch;

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = (list, patterns, options = {}) => {
  patterns = [].concat(patterns).map(String);
  let result = new Set();
  let items = [];

  let onResult = state => {
    if (options.onResult) options.onResult(state);
    items.push(state.output);
  };

  let matches = micromatch(list, patterns, { ...options, onResult });

  for (let item of items) {
    if (!matches.includes(item)) {
      result.add(item);
    }
  }
  return [...result];
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any of the patterns matches any part of `str`.
 * @api public
 */

micromatch.contains = (str, pattern, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  if (Array.isArray(pattern)) {
    return pattern.some(p => micromatch.contains(str, p, options));
  }

  if (typeof pattern === 'string') {
    if (isEmptyString(str) || isEmptyString(pattern)) {
      return false;
    }

    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {
      return true;
    }
  }

  return micromatch.isMatch(str, pattern, { ...options, contains: true });
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = (obj, patterns, options) => {
  if (!utils.isObject(obj)) {
    throw new TypeError('Expected the first argument to be an object');
  }
  let keys = micromatch(Object.keys(obj), patterns, options);
  let res = {};
  for (let key of keys) res[key] = obj[key];
  return res;
};

/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`
 * @api public
 */

micromatch.some = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (items.some(item => isMatch(item))) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`
 * @api public
 */

micromatch.every = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (!items.every(item => isMatch(item))) {
      return false;
    }
  }
  return true;
};

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.all = (str, patterns, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  return [].concat(patterns).every(p => picomatch(p, options)(str));
};

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `glob` Glob pattern to use for matching.
 * @param {String} `input` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch.capture = (glob, input, options) => {
  let posix = utils.isWindows(options);
  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);

  if (match) {
    return match.slice(1).map(v => v === void 0 ? '' : v);
  }
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

micromatch.makeRe = (...args) => picomatch.makeRe(...args);

/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

micromatch.scan = (...args) => picomatch.scan(...args);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm(pattern[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */

micromatch.parse = (patterns, options) => {
  let res = [];
  for (let pattern of [].concat(patterns || [])) {
    for (let str of braces(String(pattern), options)) {
      res.push(picomatch.parse(str, options));
    }
  }
  return res;
};

/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require('micromatch');
 * console.log(braces('foo/{a,b,c}/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch.braces = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  if ((options && options.nobrace === true) || !/\{.*\}/.test(pattern)) {
    return [pattern];
  }
  return braces(pattern, options);
};

/**
 * Expand braces
 */

micromatch.braceExpand = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  return micromatch.braces(pattern, { ...options, expand: true });
};

/**
 * Expose micromatch
 */

module.exports = micromatch;


/***/ }),

/***/ 2864:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


module.exports = __nccwpck_require__(555);


/***/ }),

/***/ 6476:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const path = __nccwpck_require__(5622);
const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

module.exports = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  SEP: path.sep,

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};


/***/ }),

/***/ 5961:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const constants = __nccwpck_require__(6476);
const utils = __nccwpck_require__(7426);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = opts => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index] || '';
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };

  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren') {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');
    let rest;

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        output = token.close = `)${rest})${extglobStar})`;
      }

      if (token.prev.type === 'bos') {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance();
      } else {
        value += advance();
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      increment('braces');

      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: 'text', value, output: value });
        continue;
      }

      let output = ')';

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = output = '\\}';
        state.output = out;
        for (const t of toks) {
          state.output += (t.output || t.value);
        }
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      braces.pop();
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace && stack[stack.length - 1] === 'braces') {
        brace.comma = true;
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({ type: 'text', value, output: DOT_LITERAL });
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if (next === '<' && !utils.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if ((prev && prev.value === '(') || opts.regex === false) {
        push({ type: 'plus', value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', extglob: true, value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) => {
  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants.globChars(win32);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = { negated: false, prefix: '' };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = opts => {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  const output = utils.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

module.exports = parse;


/***/ }),

/***/ 555:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const path = __nccwpck_require__(5622);
const scan = __nccwpck_require__(7751);
const parse = __nccwpck_require__(5961);
const utils = __nccwpck_require__(7426);
const constants = __nccwpck_require__(6476);
const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map(input => picomatch(input, options, returnState));
    const arrayMatcher = str => {
      for (const isMatch of fns) {
        const state = isMatch(str);
        if (state) return state;
      }
      return false;
    };
    return arrayMatcher;
  }

  const isState = isObject(glob) && glob.tokens && glob.input;

  if (glob === '' || (typeof glob !== 'string' && !isState)) {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  const opts = options || {};
  const posix = utils.isWindows(options);
  const regex = isState
    ? picomatch.compileRe(glob, options)
    : picomatch.makeRe(glob, options, false, true);

  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
    const result = { glob, state, regex, posix, input, output, match, isMatch };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return { isMatch: false, output: '' };
  }

  const opts = options || {};
  const format = opts.format || (posix ? utils.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return { isMatch: Boolean(match), match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(path.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch.parse = (pattern, options) => {
  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
  return parse(pattern, { ...options, fastpaths: false });
};

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch.scan = (input, options) => scan(input, options);

/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 */

picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return state.output;
  }

  const opts = options || {};
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';

  let source = `${prepend}(?:${state.output})${append}`;
  if (state && state.negated === true) {
    source = `^(?!${source}).*$`;
  }

  const regex = picomatch.toRegex(source, options);
  if (returnState === true) {
    regex.state = state;
  }

  return regex;
};

/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  let parsed = { negated: false, fastpaths: true };

  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    parsed.output = parse.fastpaths(input, options);
  }

  if (!parsed.output) {
    parsed = parse(input, options);
  }

  return picomatch.compileRe(parsed, options, returnOutput, returnState);
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch.toRegex = (source, options) => {
  try {
    const opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch.constants = constants;

/**
 * Expose "picomatch"
 */

module.exports = picomatch;


/***/ }),

/***/ 7751:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const utils = __nccwpck_require__(7426);
const {
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* { */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* } */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
} = __nccwpck_require__(6476);

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

const depth = token => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

const scan = (input, options) => {
  const opts = options || {};

  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];

  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let negatedExtglob = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = { value: '', depth: 0, isGlob: false };

  const eos = () => index >= length;
  const peek = () => str.charCodeAt(index + 1);
  const advance = () => {
    prev = code;
    return str.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();

      if (code === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (eos() !== true && (code = advance())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (braceEscaped !== true && code === CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (code === CHAR_RIGHT_CURLY_BRACE) {
          braces--;

          if (braces === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index);
      tokens.push(token);
      token = { value: '', depth: 0, isGlob: false };

      if (finished === true) continue;
      if (prev === CHAR_DOT && index === (start + 1)) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (opts.noext !== true) {
      const isExtglobChar = code === CHAR_PLUS
        || code === CHAR_AT
        || code === CHAR_ASTERISK
        || code === CHAR_QUESTION_MARK
        || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;
        if (code === CHAR_EXCLAMATION_MARK && index === start) {
          negatedExtglob = true;
        }

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }

    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;
          break;
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = token.negated = true;
      start++;
      continue;
    }

    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;

      if (scanToEnd === true) {
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code = advance();
            continue;
          }

          if (code === CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }

    if (isGlob === true) {
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }
  }

  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = str;
  } else {
    base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils.removeBackslashes(base);
    }
  }

  const state = {
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated,
    negatedExtglob
  };

  if (opts.tokens === true) {
    state.maxDepth = 0;
    if (!isPathSeparator(code)) {
      tokens.push(token);
    }
    state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;

    for (let idx = 0; idx < slashes.length; idx++) {
      const n = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value = input.slice(n, i);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value;
        }
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }
      if (idx !== 0 || value !== '') {
        parts.push(value);
      }
      prevIndex = i;
    }

    if (prevIndex && prevIndex + 1 < input.length) {
      const value = input.slice(prevIndex + 1);
      parts.push(value);

      if (opts.tokens) {
        tokens[tokens.length - 1].value = value;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }

    state.slashes = slashes;
    state.parts = parts;
  }

  return state;
};

module.exports = scan;


/***/ }),

/***/ 7426:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const path = __nccwpck_require__(5622);
const win32 = process.platform === 'win32';
const {
  REGEX_BACKSLASH,
  REGEX_REMOVE_BACKSLASH,
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL
} = __nccwpck_require__(6476);

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
};

exports.supportsLookbehinds = () => {
  const segs = process.version.slice(1).split('.').map(Number);
  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
    return true;
  }
  return false;
};

exports.isWindows = options => {
  if (options && typeof options.windows === 'boolean') {
    return options.windows;
  }
  return win32 === true || path.sep === '\\';
};

exports.escapeLast = (input, char, lastIdx) => {
  const idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};

exports.removePrefix = (input, state = {}) => {
  let output = input;
  if (output.startsWith('./')) {
    output = output.slice(2);
    state.prefix = './';
  }
  return output;
};

exports.wrapOutput = (input, state = {}, options = {}) => {
  const prepend = options.contains ? '' : '^';
  const append = options.contains ? '' : '$';

  let output = `${prepend}(?:${input})${append}`;
  if (state.negated === true) {
    output = `(?:^(?!${output}).*$)`;
  }
  return output;
};


/***/ }),

/***/ 900:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 8938:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const EventEmitter = __nccwpck_require__(4924);

// Port of lower_bound from http://en.cppreference.com/w/cpp/algorithm/lower_bound
// Used to compute insertion index to keep queue sorted after insertion
function lowerBound(array, value, comp) {
	let first = 0;
	let count = array.length;

	while (count > 0) {
		const step = (count / 2) | 0;
		let it = first + step;

		if (comp(array[it], value) <= 0) {
			first = ++it;
			count -= step + 1;
		} else {
			count = step;
		}
	}

	return first;
}

class PriorityQueue {
	constructor() {
		this._queue = [];
	}

	enqueue(run, options) {
		options = Object.assign({
			priority: 0
		}, options);

		const element = {priority: options.priority, run};

		if (this.size && this._queue[this.size - 1].priority >= options.priority) {
			this._queue.push(element);
			return;
		}

		const index = lowerBound(this._queue, element, (a, b) => b.priority - a.priority);
		this._queue.splice(index, 0, element);
	}

	dequeue() {
		return this._queue.shift().run;
	}

	get size() {
		return this._queue.length;
	}
}

class PQueue extends EventEmitter {
	constructor(options) {
		super();

		options = Object.assign({
			carryoverConcurrencyCount: false,
			intervalCap: Infinity,
			interval: 0,
			concurrency: Infinity,
			autoStart: true,
			queueClass: PriorityQueue
		}, options);

		if (!(typeof options.concurrency === 'number' && options.concurrency >= 1)) {
			throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${options.concurrency}\` (${typeof options.concurrency})`);
		}

		if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {
			throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options.intervalCap}\` (${typeof options.intervalCap})`);
		}

		if (!(Number.isFinite(options.interval) && options.interval >= 0)) {
			throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options.interval}\` (${typeof options.interval})`);
		}

		this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
		this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
		this._intervalCount = 0;
		this._intervalCap = options.intervalCap;
		this._interval = options.interval;
		this._intervalId = null;
		this._intervalEnd = 0;
		this._timeoutId = null;

		this.queue = new options.queueClass(); // eslint-disable-line new-cap
		this._queueClass = options.queueClass;
		this._pendingCount = 0;
		this._concurrency = options.concurrency;
		this._isPaused = options.autoStart === false;
		this._resolveEmpty = () => {};
		this._resolveIdle = () => {};
	}

	get _doesIntervalAllowAnother() {
		return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
	}

	get _doesConcurrentAllowAnother() {
		return this._pendingCount < this._concurrency;
	}

	_next() {
		this._pendingCount--;
		this._tryToStartAnother();
	}

	_resolvePromises() {
		this._resolveEmpty();
		this._resolveEmpty = () => {};

		if (this._pendingCount === 0) {
			this._resolveIdle();
			this._resolveIdle = () => {};
		}
	}

	_onResumeInterval() {
		this._onInterval();
		this._initializeIntervalIfNeeded();
		this._timeoutId = null;
	}

	_intervalPaused() {
		const now = Date.now();

		if (this._intervalId === null) {
			const delay = this._intervalEnd - now;
			if (delay < 0) {
				// Act as the interval was done
				// We don't need to resume it here,
				// because it'll be resumed on line 160
				this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;
			} else {
				// Act as the interval is pending
				if (this._timeoutId === null) {
					this._timeoutId = setTimeout(() => this._onResumeInterval(), delay);
				}

				return true;
			}
		}

		return false;
	}

	_tryToStartAnother() {
		if (this.queue.size === 0) {
			// We can clear the interval ("pause")
			// because we can redo it later ("resume")
			clearInterval(this._intervalId);
			this._intervalId = null;

			this._resolvePromises();

			return false;
		}

		if (!this._isPaused) {
			const canInitializeInterval = !this._intervalPaused();
			if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
				this.emit('active');
				this.queue.dequeue()();
				if (canInitializeInterval) {
					this._initializeIntervalIfNeeded();
				}

				return true;
			}
		}

		return false;
	}

	_initializeIntervalIfNeeded() {
		if (this._isIntervalIgnored || this._intervalId !== null) {
			return;
		}

		this._intervalId = setInterval(() => this._onInterval(), this._interval);
		this._intervalEnd = Date.now() + this._interval;
	}

	_onInterval() {
		if (this._intervalCount === 0 && this._pendingCount === 0) {
			clearInterval(this._intervalId);
			this._intervalId = null;
		}

		this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;
		while (this._tryToStartAnother()) {} // eslint-disable-line no-empty
	}

	add(fn, options) {
		return new Promise((resolve, reject) => {
			const run = () => {
				this._pendingCount++;
				this._intervalCount++;

				try {
					Promise.resolve(fn()).then(
						val => {
							resolve(val);
							this._next();
						},
						err => {
							reject(err);
							this._next();
						}
					);
				} catch (error) {
					reject(error);
					this._next();
				}
			};

			this.queue.enqueue(run, options);
			this._tryToStartAnother();
		});
	}

	addAll(fns, options) {
		return Promise.all(fns.map(fn => this.add(fn, options)));
	}

	start() {
		if (!this._isPaused) {
			return;
		}

		this._isPaused = false;
		while (this._tryToStartAnother()) {} // eslint-disable-line no-empty
	}

	pause() {
		this._isPaused = true;
	}

	clear() {
		this.queue = new this._queueClass();
	}

	onEmpty() {
		// Instantly resolve if the queue is empty
		if (this.queue.size === 0) {
			return Promise.resolve();
		}

		return new Promise(resolve => {
			const existingResolve = this._resolveEmpty;
			this._resolveEmpty = () => {
				existingResolve();
				resolve();
			};
		});
	}

	onIdle() {
		// Instantly resolve if none pending and if nothing else is queued
		if (this._pendingCount === 0 && this.queue.size === 0) {
			return Promise.resolve();
		}

		return new Promise(resolve => {
			const existingResolve = this._resolveIdle;
			this._resolveIdle = () => {
				existingResolve();
				resolve();
			};
		});
	}

	get size() {
		return this.queue.size;
	}

	get pending() {
		return this._pendingCount;
	}

	get isPaused() {
		return this._isPaused;
	}
}

module.exports = PQueue;
module.exports.default = PQueue;


/***/ }),

/***/ 4924:
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ 3433:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

const {promisify} = __nccwpck_require__(1669);
const fs = __nccwpck_require__(5747);

async function isType(fsStatType, statsMethodName, filePath) {
	if (typeof filePath !== 'string') {
		throw new TypeError(`Expected a string, got ${typeof filePath}`);
	}

	try {
		const stats = await promisify(fs[fsStatType])(filePath);
		return stats[statsMethodName]();
	} catch (error) {
		if (error.code === 'ENOENT') {
			return false;
		}

		throw error;
	}
}

function isTypeSync(fsStatType, statsMethodName, filePath) {
	if (typeof filePath !== 'string') {
		throw new TypeError(`Expected a string, got ${typeof filePath}`);
	}

	try {
		return fs[fsStatType](filePath)[statsMethodName]();
	} catch (error) {
		if (error.code === 'ENOENT') {
			return false;
		}

		throw error;
	}
}

exports.isFile = isType.bind(null, 'stat', 'isFile');
exports.isDirectory = isType.bind(null, 'stat', 'isDirectory');
exports.isSymlink = isType.bind(null, 'lstat', 'isSymbolicLink');
exports.isFileSync = isTypeSync.bind(null, 'statSync', 'isFile');
exports.isDirectorySync = isTypeSync.bind(null, 'statSync', 'isDirectory');
exports.isSymlinkSync = isTypeSync.bind(null, 'lstatSync', 'isSymbolicLink');


/***/ }),

/***/ 9795:
/***/ ((module) => {

/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise

module.exports = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0))


/***/ }),

/***/ 2113:
/***/ ((module) => {

"use strict";


function reusify (Constructor) {
  var head = new Constructor()
  var tail = head

  function get () {
    var current = head

    if (current.next) {
      head = current.next
    } else {
      head = new Constructor()
      tail = head
    }

    current.next = null

    return current
  }

  function release (obj) {
    tail.next = obj
    tail = obj
  }

  return {
    get: get,
    release: release
  }
}

module.exports = reusify


/***/ }),

/***/ 5288:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = runParallel

const queueMicrotask = __nccwpck_require__(9795)

function runParallel (tasks, cb) {
  let results, pending, keys
  let isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) queueMicrotask(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (--pending === 0 || err) {
      done(err)
    }
  }

  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) { each(key, err, result) })
    })
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) { each(i, err, result) })
    })
  }

  isSync = false
}


/***/ }),

/***/ 4526:
/***/ ((module) => {

const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
const numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
// const octRegex = /0x[a-z0-9]+/;
// const binRegex = /0x[a-z0-9]+/;


//polyfill
if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
}
if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
}

  
const consider = {
    hex :  true,
    leadingZeros: true,
    decimalPoint: "\.",
    eNotation: true
    //skipLike: /regex/
};

function toNumber(str, options = {}){
    // const options = Object.assign({}, consider);
    // if(opt.leadingZeros === false){
    //     options.leadingZeros = false;
    // }else if(opt.hex === false){
    //     options.hex = false;
    // }

    options = Object.assign({}, consider, options );
    if(!str || typeof str !== "string" ) return str;
    
    let trimmedStr  = str.trim();
    // if(trimmedStr === "0.0") return 0;
    // else if(trimmedStr === "+0.0") return 0;
    // else if(trimmedStr === "-0.0") return -0;

    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
    else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
    // } else if (options.parseOct && octRegex.test(str)) {
    //     return Number.parseInt(val, 8);
    // }else if (options.parseBin && binRegex.test(str)) {
    //     return Number.parseInt(val, 2);
    }else{
        //separate negative sign, leading zeros, and rest number
        const match = numRegex.exec(trimmedStr);
        if(match){
            const sign = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
            //trim ending zeros for floating number
            
            const eNotation = match[4] || match[6];
            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
            else{//no leading zeros or leading zeros are allowed
                const num = Number(trimmedStr);
                const numStr = "" + num;
                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(eNotation){ //given number has enotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(trimmedStr.indexOf(".") !== -1){ //floating number
                    // const decimalPart = match[5].substr(1);
                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

                    
                    // const p = numStr.indexOf(".");
                    // const givenIntPart = numStr.substr(0,p);
                    // const givenDecPart = numStr.substr(p+1);
                    if(numStr === "0" && (numTrimmedByZeros === "") ) return num; //0.0
                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000
                    else if( sign && numStr === "-"+numTrimmedByZeros) return num;
                    else return str;
                }
                
                if(leadingZeros){
                    // if(numTrimmedByZeros === numStr){
                    //     if(options.leadingZeros) return num;
                    //     else return str;
                    // }else return str;
                    if(numTrimmedByZeros === numStr) return num;
                    else if(sign+numTrimmedByZeros === numStr) return num;
                    else return str;
                }

                if(trimmedStr === numStr) return num;
                else if(trimmedStr === sign+numStr) return num;
                // else{
                //     //number with +/- sign
                //     trimmedStr.test(/[-+][0-9]);

                // }
                return str;
            }
            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
            
        }else{ //non-numeric string
            return str;
        }
    }
}

/**
 * 
 * @param {string} numStr without leading zeros
 * @returns 
 */
function trimZeros(numStr){
    if(numStr && numStr.indexOf(".") !== -1){//float
        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
        if(numStr === ".")  numStr = "0";
        else if(numStr[0] === ".")  numStr = "0"+numStr;
        else if(numStr[numStr.length-1] === ".")  numStr = numStr.substr(0,numStr.length-1);
        return numStr;
    }
    return numStr;
}
module.exports = toNumber


/***/ }),

/***/ 9318:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const os = __nccwpck_require__(2087);
const hasFlag = __nccwpck_require__(1621);

const env = process.env;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false')) {
	forceColor = false;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = true;
}
if ('FORCE_COLOR' in env) {
	forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(stream) {
	if (forceColor === false) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (stream && !stream.isTTY && forceColor !== true) {
		return 0;
	}

	const min = forceColor ? 1 : 0;

	if (process.platform === 'win32') {
		// Node.js 7.5.0 is the first version of Node.js to include a patch to
		// libuv that enables 256 color output on Windows. Anything earlier and it
		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
		// release that supports 256 colors. Windows 10 build 14931 is the first release
		// that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(process.versions.node.split('.')[0]) >= 8 &&
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	if (env.TERM === 'dumb') {
		return min;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: getSupportLevel(process.stdout),
	stderr: getSupportLevel(process.stderr)
};


/***/ }),

/***/ 1861:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */



const isNumber = __nccwpck_require__(5680);

const toRegexRange = (min, max, options) => {
  if (isNumber(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if (isNumber(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  let opts = { relaxZeros: true, ...options };
  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange.cache[cacheKey].result;
  }

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    let result = min + '|' + max;
    if (opts.capture) {
      return `(${result})`;
    }
    if (opts.wrap === false) {
      return result;
    }
    return `(?:${result})`;
  }

  let isPadded = hasPadding(min) || hasPadding(max);
  let state = { min, max, a, b };
  let positives = [];
  let negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives, opts);

  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
    state.result = `(?:${state.result})`;
  }

  toRegexRange.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  let nines = 1;
  let zeros = 1;

  let stop = countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops = [...stops];
  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }

  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit, options);

    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return { pattern, count: [count], digits };
}

function splitToPatterns(min, max, tok, options) {
  let ranges = splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) {
    let max = ranges[i];
    let obj = rangeToPattern(String(start), String(max), options);
    let zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(max, tok, options);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  let result = [];

  for (let ele of arr) {
    let { string } = ele;

    // only push if _both_ are negative...
    if (!intersection && !contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }

    // or _both_ are positive
    if (intersection && contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }
  }
  return result;
}

/**
 * Zip strings
 */

function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(ele => ele[key] === val);
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  let [start = 0, stop = ''] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? ',' + stop : '')}}`;
  }
  return '';
}

function toCharacterClass(a, b, options) {
  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';
    case 1:
      return relax ? '0?' : '0';
    case 2:
      return relax ? '0{0,2}' : '00';
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}

/**
 * Cache
 */

toRegexRange.cache = {};
toRegexRange.clearCache = () => (toRegexRange.cache = {});

/**
 * Expose `toRegexRange`
 */

module.exports = toRegexRange;


/***/ }),

/***/ 4351:
/***/ ((module) => {

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if ( true && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
});


/***/ }),

/***/ 4294:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(4219);


/***/ }),

/***/ 4219:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var net = __nccwpck_require__(1631);
var tls = __nccwpck_require__(4016);
var http = __nccwpck_require__(8605);
var https = __nccwpck_require__(7211);
var events = __nccwpck_require__(8614);
var assert = __nccwpck_require__(2357);
var util = __nccwpck_require__(1669);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 2357:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 6417:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 8614:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 5747:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 8605:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 7211:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 1631:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 2004:
/***/ ((module) => {

"use strict";
module.exports = require("node:fs/promises");

/***/ }),

/***/ 2087:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 5622:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 2413:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 4016:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 3867:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 8835:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 1669:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 8761:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__nccwpck_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__nccwpck_require__.o(definition, key) && !__nccwpck_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__nccwpck_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__nccwpck_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__nccwpck_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nccwpck_require__(1156);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=index.js.map